[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "372-374",
    "snippet": "int main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::test::RunAllTests",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "RunAllTests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "36-58",
          "snippet": "int RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nint RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nint main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "354-368",
    "snippet": "TEST(CorruptionTest, UnrelatedKeys) {\n  Build(10);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  Corrupt(kTableFile, 100, 1);\n\n  std::string tmp1, tmp2;\n  ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)));\n  std::string v;\n  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));\n  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);\n  dbi->TEST_CompactMemTable();\n  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));\n  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "Value(1000, &tmp2).ToString()",
            "v"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ClearSavedValue",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "97-104",
          "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Value",
          "args": [
            "1000",
            "&tmp2"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Get(ReadOptions(), Key(1000, &tmp1), &v)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [
            "ReadOptions()",
            "Key(1000, &tmp1)",
            "&v"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Key",
          "args": [
            "1000",
            "&tmp1"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "Key",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "188-193",
          "snippet": "Slice Key(int i, std::string* storage) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"%016d\", i);\n    storage->assign(buf, strlen(buf));\n    return Slice(*storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Key(int i, std::string* storage) {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%016d\", i);\n      storage->assign(buf, strlen(buf));\n      return Slice(*storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "Value(1000, &tmp2).ToString()",
            "v"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Get(ReadOptions(), Key(1000, &tmp1), &v)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2))"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Put",
          "args": [
            "WriteOptions()",
            "Key(1000, &tmp1)",
            "Value(1000, &tmp2)"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kTableFile",
            "100",
            "1"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "10"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, UnrelatedKeys) {\n  Build(10);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  Corrupt(kTableFile, 100, 1);\n\n  std::string tmp1, tmp2;\n  ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)));\n  std::string v;\n  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));\n  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);\n  dbi->TEST_CompactMemTable();\n  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));\n  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "333-352",
    "snippet": "TEST(CorruptionTest, CompactionInputErrorParanoid) {\n  options_.paranoid_checks = true;\n  options_.write_buffer_size = 512 << 10;\n  Reopen();\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n\n  // Make multiple inputs so we need to compact.\n  for (int i = 0; i < 2; i++) {\n    Build(10);\n    dbi->TEST_CompactMemTable();\n    Corrupt(kTableFile, 100, 1);\n    env_.SleepForMicroseconds(100000);\n  }\n  dbi->CompactRange(NULL, NULL);\n\n  // Write must fail because of corrupted table\n  std::string tmp1, tmp2;\n  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));\n  ASSERT_TRUE(!s.ok()) << \"write did not fail in corrupted paranoid db\";\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!s.ok()"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Put",
          "args": [
            "WriteOptions()",
            "Key(5, &tmp1)",
            "Value(5, &tmp2)"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Value",
          "args": [
            "5",
            "&tmp2"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Key",
          "args": [
            "5",
            "&tmp1"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "Key",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "188-193",
          "snippet": "Slice Key(int i, std::string* storage) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"%016d\", i);\n    storage->assign(buf, strlen(buf));\n    return Slice(*storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Key(int i, std::string* storage) {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%016d\", i);\n      storage->assign(buf, strlen(buf));\n      return Slice(*storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->CompactRange",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "536-551",
          "snippet": "void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n  int max_level_with_files = 1;\n  {\n    MutexLock l(&mutex_);\n    Version* base = versions_->current();\n    for (int level = 1; level < config::kNumLevels; level++) {\n      if (base->OverlapInLevel(level, begin, end)) {\n        max_level_with_files = level;\n      }\n    }\n  }\n  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n  for (int level = 0; level < max_level_with_files; level++) {\n    TEST_CompactRange(level, begin, end);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n    int max_level_with_files = 1;\n    {\n      MutexLock l(&mutex_);\n      Version* base = versions_->current();\n      for (int level = 1; level < config::kNumLevels; level++) {\n        if (base->OverlapInLevel(level, begin, end)) {\n          max_level_with_files = level;\n        }\n      }\n    }\n    TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n    for (int level = 0; level < max_level_with_files; level++) {\n      TEST_CompactRange(level, begin, end);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_.SleepForMicroseconds",
          "args": [
            "100000"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "SleepForMicroseconds",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "795-798",
          "snippet": "void Win32Env::SleepForMicroseconds( int micros )\n{\n    ::Sleep((micros + 999) /1000);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  void Win32Env::SleepForMicroseconds( int micros )\n  {\n      ::Sleep((micros + 999) /1000);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kTableFile",
            "100",
            "1"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "10"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, CompactionInputErrorParanoid) {\n  options_.paranoid_checks = true;\n  options_.write_buffer_size = 512 << 10;\n  Reopen();\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n\n  // Make multiple inputs so we need to compact.\n  for (int i = 0; i < 2; i++) {\n    Build(10);\n    dbi->TEST_CompactMemTable();\n    Corrupt(kTableFile, 100, 1);\n    env_.SleepForMicroseconds(100000);\n  }\n  dbi->CompactRange(NULL, NULL);\n\n  // Write must fail because of corrupted table\n  std::string tmp1, tmp2;\n  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));\n  ASSERT_TRUE(!s.ok()) << \"write did not fail in corrupted paranoid db\";\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "318-331",
    "snippet": "TEST(CorruptionTest, CompactionInputError) {\n  Build(10);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  const int last = config::kMaxMemCompactLevel;\n  ASSERT_EQ(1, Property(\"leveldb.num-files-at-level\" + NumberToString(last)));\n\n  Corrupt(kTableFile, 100, 1);\n  Check(5, 9);\n\n  // Force compactions by writing lots of values\n  Build(10000);\n  Check(10000, 10000);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [
            "10000",
            "10000"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "Check",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "88-124",
          "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "10000"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kTableFile",
            "100",
            "1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "1",
            "Property(\"leveldb.num-files-at-level\" + NumberToString(last))"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Property",
          "args": [
            "\"leveldb.num-files-at-level\" + NumberToString(last)"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "Property",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "176-185",
          "snippet": "int Property(const std::string& name) {\n    std::string property;\n    int result;\n    if (db_->GetProperty(name, &property) &&\n        sscanf(property.c_str(), \"%d\", &result) == 1) {\n      return result;\n    } else {\n      return -1;\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  int Property(const std::string& name) {\n      std::string property;\n      int result;\n      if (db_->GetProperty(name, &property) &&\n          sscanf(property.c_str(), \"%d\", &result) == 1) {\n        return result;\n      } else {\n        return -1;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NumberToString",
          "args": [
            "last"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "NumberToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "36-40",
          "snippet": "std::string NumberToString(uint64_t num) {\n  std::string r;\n  AppendNumberTo(&r, num);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string NumberToString(uint64_t num) {\n  std::string r;\n  AppendNumberTo(&r, num);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, CompactionInputError) {\n  Build(10);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  const int last = config::kMaxMemCompactLevel;\n  ASSERT_EQ(1, Property(\"leveldb.num-files-at-level\" + NumberToString(last)));\n\n  Corrupt(kTableFile, 100, 1);\n  Check(5, 9);\n\n  // Force compactions by writing lots of values\n  Build(10000);\n  Check(10000, 10000);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "301-316",
    "snippet": "TEST(CorruptionTest, CorruptedDescriptor) {\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"hello\"));\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  dbi->TEST_CompactRange(0, NULL, NULL);\n\n  Corrupt(kDescriptorFile, 0, 1000);\n  Status s = TryReopen();\n  ASSERT_TRUE(!s.ok());\n\n  RepairDB();\n  Reopen();\n  std::string v;\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"hello\", v);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"hello\"",
            "v"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Get(ReadOptions(), \"foo\", &v)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [
            "ReadOptions()",
            "\"foo\"",
            "&v"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RepairDB",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "RepairDB",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "64-68",
          "snippet": "void RepairDB() {\n    delete db_;\n    db_ = NULL;\n    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void RepairDB() {\n      delete db_;\n      db_ = NULL;\n      ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!s.ok()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TryReopen",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "TryReopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "54-58",
          "snippet": "Status TryReopen() {\n    delete db_;\n    db_ = NULL;\n    return DB::Open(options_, dbname_, &db_);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Status TryReopen() {\n      delete db_;\n      db_ = NULL;\n      return DB::Open(options_, dbname_, &db_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kDescriptorFile",
            "0",
            "1000"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactRange",
          "args": [
            "0",
            "NULL",
            "NULL"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "553-588",
          "snippet": "void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n  assert(level >= 0);\n  assert(level + 1 < config::kNumLevels);\n\n  InternalKey begin_storage, end_storage;\n\n  ManualCompaction manual;\n  manual.level = level;\n  manual.done = false;\n  if (begin == NULL) {\n    manual.begin = NULL;\n  } else {\n    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n    manual.begin = &begin_storage;\n  }\n  if (end == NULL) {\n    manual.end = NULL;\n  } else {\n    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n    manual.end = &end_storage;\n  }\n\n  MutexLock l(&mutex_);\n  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n    if (manual_compaction_ == NULL) {  // Idle\n      manual_compaction_ = &manual;\n      MaybeScheduleCompaction();\n    } else {  // Running either my compaction or another compaction.\n      bg_cv_.Wait();\n    }\n  }\n  if (manual_compaction_ == &manual) {\n    // Cancel my manual compaction since we aborted early for some reason.\n    manual_compaction_ = NULL;\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n    assert(level >= 0);\n    assert(level + 1 < config::kNumLevels);\n  \n    InternalKey begin_storage, end_storage;\n  \n    ManualCompaction manual;\n    manual.level = level;\n    manual.done = false;\n    if (begin == NULL) {\n      manual.begin = NULL;\n    } else {\n      begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n      manual.begin = &begin_storage;\n    }\n    if (end == NULL) {\n      manual.end = NULL;\n    } else {\n      end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n      manual.end = &end_storage;\n    }\n  \n    MutexLock l(&mutex_);\n    while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n      if (manual_compaction_ == NULL) {  // Idle\n        manual_compaction_ = &manual;\n        MaybeScheduleCompaction();\n      } else {  // Running either my compaction or another compaction.\n        bg_cv_.Wait();\n      }\n    }\n    if (manual_compaction_ == &manual) {\n      // Cancel my manual compaction since we aborted early for some reason.\n      manual_compaction_ = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"hello\")"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Put",
          "args": [
            "WriteOptions()",
            "\"foo\"",
            "\"hello\""
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, CorruptedDescriptor) {\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"hello\"));\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  dbi->TEST_CompactRange(0, NULL, NULL);\n\n  Corrupt(kDescriptorFile, 0, 1000);\n  Status s = TryReopen();\n  ASSERT_TRUE(!s.ok());\n\n  RepairDB();\n  Reopen();\n  std::string v;\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"hello\", v);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "280-299",
    "snippet": "TEST(CorruptionTest, SequenceNumberRecovery) {\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v3\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v4\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v5\"));\n  RepairDB();\n  Reopen();\n  std::string v;\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"v5\", v);\n  // Write something.  If sequence number was not recovered properly,\n  // it will be hidden by an earlier write.\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v6\"));\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"v6\", v);\n  Reopen();\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"v6\", v);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"v6\"",
            "v"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Get(ReadOptions(), \"foo\", &v)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [
            "ReadOptions()",
            "\"foo\"",
            "&v"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"v6\"",
            "v"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Get(ReadOptions(), \"foo\", &v)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"v6\")"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Put",
          "args": [
            "WriteOptions()",
            "\"foo\"",
            "\"v6\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"v5\"",
            "v"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Get(ReadOptions(), \"foo\", &v)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RepairDB",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "RepairDB",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "64-68",
          "snippet": "void RepairDB() {\n    delete db_;\n    db_ = NULL;\n    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void RepairDB() {\n      delete db_;\n      db_ = NULL;\n      ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"v5\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"v4\")"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"v3\")"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"v2\")"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), \"foo\", \"v1\")"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, SequenceNumberRecovery) {\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v3\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v4\"));\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v5\"));\n  RepairDB();\n  Reopen();\n  std::string v;\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"v5\", v);\n  // Write something.  If sequence number was not recovered properly,\n  // it will be hidden by an earlier write.\n  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v6\"));\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"v6\", v);\n  Reopen();\n  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n  ASSERT_EQ(\"v6\", v);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "273-278",
    "snippet": "TEST(CorruptionTest, MissingDescriptor) {\n  Build(1000);\n  RepairDB();\n  Reopen();\n  Check(1000, 1000);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [
            "1000",
            "1000"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "Check",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "88-124",
          "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RepairDB",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "RepairDB",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "64-68",
          "snippet": "void RepairDB() {\n    delete db_;\n    db_ = NULL;\n    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void RepairDB() {\n      delete db_;\n      db_ = NULL;\n      ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "1000"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, MissingDescriptor) {\n  Build(1000);\n  RepairDB();\n  Reopen();\n  Check(1000, 1000);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "263-271",
    "snippet": "TEST(CorruptionTest, TableFileIndexData) {\n  Build(10000);  // Enough to build multiple Tables\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n\n  Corrupt(kTableFile, -2000, 500);\n  Reopen();\n  Check(5000, 9999);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [
            "5000",
            "9999"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "Check",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "88-124",
          "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kTableFile",
            "-2000",
            "500"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "10000"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, TableFileIndexData) {\n  Build(10000);  // Enough to build multiple Tables\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n\n  Corrupt(kTableFile, -2000, 500);\n  Reopen();\n  Check(5000, 9999);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "247-261",
    "snippet": "TEST(CorruptionTest, TableFileRepair) {\n  options_.block_size = 2 * kValueSize;  // Limit scope of corruption\n  options_.paranoid_checks = true;\n  Reopen();\n  Build(100);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  dbi->TEST_CompactRange(0, NULL, NULL);\n  dbi->TEST_CompactRange(1, NULL, NULL);\n\n  Corrupt(kTableFile, 100, 1);\n  RepairDB();\n  Reopen();\n  Check(95, 99);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [
            "95",
            "99"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "Check",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "88-124",
          "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RepairDB",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "RepairDB",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "64-68",
          "snippet": "void RepairDB() {\n    delete db_;\n    db_ = NULL;\n    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void RepairDB() {\n      delete db_;\n      db_ = NULL;\n      ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kTableFile",
            "100",
            "1"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactRange",
          "args": [
            "1",
            "NULL",
            "NULL"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "553-588",
          "snippet": "void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n  assert(level >= 0);\n  assert(level + 1 < config::kNumLevels);\n\n  InternalKey begin_storage, end_storage;\n\n  ManualCompaction manual;\n  manual.level = level;\n  manual.done = false;\n  if (begin == NULL) {\n    manual.begin = NULL;\n  } else {\n    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n    manual.begin = &begin_storage;\n  }\n  if (end == NULL) {\n    manual.end = NULL;\n  } else {\n    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n    manual.end = &end_storage;\n  }\n\n  MutexLock l(&mutex_);\n  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n    if (manual_compaction_ == NULL) {  // Idle\n      manual_compaction_ = &manual;\n      MaybeScheduleCompaction();\n    } else {  // Running either my compaction or another compaction.\n      bg_cv_.Wait();\n    }\n  }\n  if (manual_compaction_ == &manual) {\n    // Cancel my manual compaction since we aborted early for some reason.\n    manual_compaction_ = NULL;\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n    assert(level >= 0);\n    assert(level + 1 < config::kNumLevels);\n  \n    InternalKey begin_storage, end_storage;\n  \n    ManualCompaction manual;\n    manual.level = level;\n    manual.done = false;\n    if (begin == NULL) {\n      manual.begin = NULL;\n    } else {\n      begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n      manual.begin = &begin_storage;\n    }\n    if (end == NULL) {\n      manual.end = NULL;\n    } else {\n      end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n      manual.end = &end_storage;\n    }\n  \n    MutexLock l(&mutex_);\n    while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n      if (manual_compaction_ == NULL) {  // Idle\n        manual_compaction_ = &manual;\n        MaybeScheduleCompaction();\n      } else {  // Running either my compaction or another compaction.\n        bg_cv_.Wait();\n      }\n    }\n    if (manual_compaction_ == &manual) {\n      // Cancel my manual compaction since we aborted early for some reason.\n      manual_compaction_ = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "100"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, TableFileRepair) {\n  options_.block_size = 2 * kValueSize;  // Limit scope of corruption\n  options_.paranoid_checks = true;\n  Reopen();\n  Build(100);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  dbi->TEST_CompactRange(0, NULL, NULL);\n  dbi->TEST_CompactRange(1, NULL, NULL);\n\n  Corrupt(kTableFile, 100, 1);\n  RepairDB();\n  Reopen();\n  Check(95, 99);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "236-245",
    "snippet": "TEST(CorruptionTest, TableFile) {\n  Build(100);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  dbi->TEST_CompactRange(0, NULL, NULL);\n  dbi->TEST_CompactRange(1, NULL, NULL);\n\n  Corrupt(kTableFile, 100, 1);\n  Check(90, 99);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [
            "90",
            "99"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "Check",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "88-124",
          "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kTableFile",
            "100",
            "1"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactRange",
          "args": [
            "1",
            "NULL",
            "NULL"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "553-588",
          "snippet": "void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n  assert(level >= 0);\n  assert(level + 1 < config::kNumLevels);\n\n  InternalKey begin_storage, end_storage;\n\n  ManualCompaction manual;\n  manual.level = level;\n  manual.done = false;\n  if (begin == NULL) {\n    manual.begin = NULL;\n  } else {\n    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n    manual.begin = &begin_storage;\n  }\n  if (end == NULL) {\n    manual.end = NULL;\n  } else {\n    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n    manual.end = &end_storage;\n  }\n\n  MutexLock l(&mutex_);\n  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n    if (manual_compaction_ == NULL) {  // Idle\n      manual_compaction_ = &manual;\n      MaybeScheduleCompaction();\n    } else {  // Running either my compaction or another compaction.\n      bg_cv_.Wait();\n    }\n  }\n  if (manual_compaction_ == &manual) {\n    // Cancel my manual compaction since we aborted early for some reason.\n    manual_compaction_ = NULL;\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n    assert(level >= 0);\n    assert(level + 1 < config::kNumLevels);\n  \n    InternalKey begin_storage, end_storage;\n  \n    ManualCompaction manual;\n    manual.level = level;\n    manual.done = false;\n    if (begin == NULL) {\n      manual.begin = NULL;\n    } else {\n      begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n      manual.begin = &begin_storage;\n    }\n    if (end == NULL) {\n      manual.end = NULL;\n    } else {\n      end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n      manual.end = &end_storage;\n    }\n  \n    MutexLock l(&mutex_);\n    while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n      if (manual_compaction_ == NULL) {  // Idle\n        manual_compaction_ = &manual;\n        MaybeScheduleCompaction();\n      } else {  // Running either my compaction or another compaction.\n        bg_cv_.Wait();\n      }\n    }\n    if (manual_compaction_ == &manual) {\n      // Cancel my manual compaction since we aborted early for some reason.\n      manual_compaction_ = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "100"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, TableFile) {\n  Build(100);\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  dbi->TEST_CompactMemTable();\n  dbi->TEST_CompactRange(0, NULL, NULL);\n  dbi->TEST_CompactRange(1, NULL, NULL);\n\n  Corrupt(kTableFile, 100, 1);\n  Check(90, 99);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "219-234",
    "snippet": "TEST(CorruptionTest, NewFileErrorDuringWrite) {\n  // Do enough writing to force minor compaction\n  env_.writable_file_error_ = true;\n  const int num = 3 + (Options().write_buffer_size / kValueSize);\n  std::string value_storage;\n  Status s;\n  for (int i = 0; s.ok() && i < num; i++) {\n    WriteBatch batch;\n    batch.Put(\"a\", Value(100, &value_storage));\n    s = db_->Write(WriteOptions(), &batch);\n  }\n  ASSERT_TRUE(!s.ok());\n  ASSERT_GE(env_.num_writable_file_errors_, 1);\n  env_.writable_file_error_ = false;\n  Reopen();\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_GE",
          "args": [
            "env_.num_writable_file_errors_",
            "1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!s.ok()"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Write",
          "args": [
            "WriteOptions()",
            "&batch"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "\"a\"",
            "Value(100, &value_storage)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Value",
          "args": [
            "100",
            "&value_storage"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentOptions",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "238-251",
          "snippet": "Options CurrentOptions() {\n    Options options;\n    switch (option_config_) {\n      case kFilter:\n        options.filter_policy = filter_policy_;\n        break;\n      case kUncompressed:\n        options.compression = kNoCompression;\n        break;\n      default:\n        break;\n    }\n    return options;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  Options CurrentOptions() {\n      Options options;\n      switch (option_config_) {\n        case kFilter:\n          options.filter_policy = filter_policy_;\n          break;\n        case kUncompressed:\n          options.compression = kNoCompression;\n          break;\n        default:\n          break;\n      }\n      return options;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, NewFileErrorDuringWrite) {\n  // Do enough writing to force minor compaction\n  env_.writable_file_error_ = true;\n  const int num = 3 + (Options().write_buffer_size / kValueSize);\n  std::string value_storage;\n  Status s;\n  for (int i = 0; s.ok() && i < num; i++) {\n    WriteBatch batch;\n    batch.Put(\"a\", Value(100, &value_storage));\n    s = db_->Write(WriteOptions(), &batch);\n  }\n  ASSERT_TRUE(!s.ok());\n  ASSERT_GE(env_.num_writable_file_errors_, 1);\n  env_.writable_file_error_ = false;\n  Reopen();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "213-217",
    "snippet": "TEST(CorruptionTest, RecoverWriteError) {\n  env_.writable_file_error_ = true;\n  Status s = TryReopen();\n  ASSERT_TRUE(!s.ok());\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!s.ok()"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TryReopen",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "TryReopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "54-58",
          "snippet": "Status TryReopen() {\n    delete db_;\n    db_ = NULL;\n    return DB::Open(options_, dbname_, &db_);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Status TryReopen() {\n      delete db_;\n      db_ = NULL;\n      return DB::Open(options_, dbname_, &db_);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, RecoverWriteError) {\n  env_.writable_file_error_ = true;\n  Status s = TryReopen();\n  ASSERT_TRUE(!s.ok());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "202-211",
    "snippet": "TEST(CorruptionTest, Recovery) {\n  Build(100);\n  Check(100, 100);\n  Corrupt(kLogFile, 19, 1);      // WriteBatch tag for first record\n  Corrupt(kLogFile, log::kBlockSize + 1000, 1);  // Somewhere in second block\n  Reopen();\n\n  // The 64 records in the first two log blocks are completely lost.\n  Check(36, 36);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [
            "36",
            "36"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "Check",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "88-124",
          "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Corrupt",
          "args": [
            "kLogFile",
            "log::kBlockSize + 1000",
            "1"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "Corrupt",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "126-174",
          "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Build",
          "args": [
            "100"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "Build",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "70-86",
          "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nTEST(CorruptionTest, Recovery) {\n  Build(100);\n  Check(100, 100);\n  Corrupt(kLogFile, 19, 1);      // WriteBatch tag for first record\n  Corrupt(kLogFile, log::kBlockSize + 1000, 1);  // Somewhere in second block\n  Reopen();\n\n  // The 64 records in the first two log blocks are completely lost.\n  Check(36, 36);\n}"
  },
  {
    "function_name": "Value",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "196-199",
    "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test::RandomString",
          "args": [
            "&r",
            "kValueSize",
            "storage"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "RandomString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testutil.cc",
          "lines": "12-18",
          "snippet": "Slice RandomString(Random* rnd, int len, std::string* dst) {\n  dst->resize(len);\n  for (int i = 0; i < len; i++) {\n    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'\n  }\n  return Slice(*dst);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/testutil.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/testutil.h\"\n\nSlice RandomString(Random* rnd, int len, std::string* dst) {\n  dst->resize(len);\n  for (int i = 0; i < len; i++) {\n    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'\n  }\n  return Slice(*dst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
  },
  {
    "function_name": "Key",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "188-193",
    "snippet": "Slice Key(int i, std::string* storage) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"%016d\", i);\n    storage->assign(buf, strlen(buf));\n    return Slice(*storage);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "*storage"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage->assign",
          "args": [
            "buf",
            "strlen(buf)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%016d\"",
            "i"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Key(int i, std::string* storage) {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%016d\", i);\n      storage->assign(buf, strlen(buf));\n      return Slice(*storage);\n    }\n}"
  },
  {
    "function_name": "Property",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "176-185",
    "snippet": "int Property(const std::string& name) {\n    std::string property;\n    int result;\n    if (db_->GetProperty(name, &property) &&\n        sscanf(property.c_str(), \"%d\", &result) == 1) {\n      return result;\n    } else {\n      return -1;\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "property.c_str()",
            "\"%d\"",
            "&result"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "property.c_str",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->GetProperty",
          "args": [
            "name",
            "&property"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "GetProperty",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1349-1401",
          "snippet": "bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n  value->clear();\n\n  MutexLock l(&mutex_);\n  Slice in = property;\n  Slice prefix(\"leveldb.\");\n  if (!in.starts_with(prefix)) return false;\n  in.remove_prefix(prefix.size());\n\n  if (in.starts_with(\"num-files-at-level\")) {\n    in.remove_prefix(strlen(\"num-files-at-level\"));\n    uint64_t level;\n    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n    if (!ok || level >= config::kNumLevels) {\n      return false;\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%d\",\n               versions_->NumLevelFiles(static_cast<int>(level)));\n      *value = buf;\n      return true;\n    }\n  } else if (in == \"stats\") {\n    char buf[200];\n    snprintf(buf, sizeof(buf),\n             \"                               Compactions\\n\"\n             \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n             \"--------------------------------------------------\\n\"\n             );\n    value->append(buf);\n    for (int level = 0; level < config::kNumLevels; level++) {\n      int files = versions_->NumLevelFiles(level);\n      if (stats_[level].micros > 0 || files > 0) {\n        snprintf(\n            buf, sizeof(buf),\n            \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n            level,\n            files,\n            versions_->NumLevelBytes(level) / 1048576.0,\n            stats_[level].micros / 1e6,\n            stats_[level].bytes_read / 1048576.0,\n            stats_[level].bytes_written / 1048576.0);\n        value->append(buf);\n      }\n    }\n    return true;\n  } else if (in == \"sstables\") {\n    *value = versions_->current()->DebugString();\n    return true;\n  }\n\n  return false;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n    value->clear();\n  \n    MutexLock l(&mutex_);\n    Slice in = property;\n    Slice prefix(\"leveldb.\");\n    if (!in.starts_with(prefix)) return false;\n    in.remove_prefix(prefix.size());\n  \n    if (in.starts_with(\"num-files-at-level\")) {\n      in.remove_prefix(strlen(\"num-files-at-level\"));\n      uint64_t level;\n      bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n      if (!ok || level >= config::kNumLevels) {\n        return false;\n      } else {\n        char buf[100];\n        snprintf(buf, sizeof(buf), \"%d\",\n                 versions_->NumLevelFiles(static_cast<int>(level)));\n        *value = buf;\n        return true;\n      }\n    } else if (in == \"stats\") {\n      char buf[200];\n      snprintf(buf, sizeof(buf),\n               \"                               Compactions\\n\"\n               \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n               \"--------------------------------------------------\\n\"\n               );\n      value->append(buf);\n      for (int level = 0; level < config::kNumLevels; level++) {\n        int files = versions_->NumLevelFiles(level);\n        if (stats_[level].micros > 0 || files > 0) {\n          snprintf(\n              buf, sizeof(buf),\n              \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n              level,\n              files,\n              versions_->NumLevelBytes(level) / 1048576.0,\n              stats_[level].micros / 1e6,\n              stats_[level].bytes_read / 1048576.0,\n              stats_[level].bytes_written / 1048576.0);\n          value->append(buf);\n        }\n      }\n      return true;\n    } else if (in == \"sstables\") {\n      *value = versions_->current()->DebugString();\n      return true;\n    }\n  \n    return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  int Property(const std::string& name) {\n      std::string property;\n      int result;\n      if (db_->GetProperty(name, &property) &&\n          sscanf(property.c_str(), \"%d\", &result) == 1) {\n        return result;\n      } else {\n        return -1;\n      }\n    }\n}"
  },
  {
    "function_name": "Corrupt",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "126-174",
    "snippet": "void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n    // Pick file to corrupt\n    std::vector<std::string> filenames;\n    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n    uint64_t number;\n    FileType type;\n    std::string fname;\n    int picked_number = -1;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type == filetype &&\n          int(number) > picked_number) {  // Pick latest file\n        fname = dbname_ + \"/\" + filenames[i];\n        picked_number = number;\n      }\n    }\n    ASSERT_TRUE(!fname.empty()) << filetype;\n\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      const char* msg = strerror(errno);\n      ASSERT_TRUE(false) << fname << \": \" << msg;\n    }\n\n    if (offset < 0) {\n      // Relative to end of file; make it absolute\n      if (-offset > sbuf.st_size) {\n        offset = 0;\n      } else {\n        offset = sbuf.st_size + offset;\n      }\n    }\n    if (offset > sbuf.st_size) {\n      offset = sbuf.st_size;\n    }\n    if (offset + bytes_to_corrupt > sbuf.st_size) {\n      bytes_to_corrupt = sbuf.st_size - offset;\n    }\n\n    // Do it\n    std::string contents;\n    Status s = ReadFileToString(Env::Default(), fname, &contents);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n    for (int i = 0; i < bytes_to_corrupt; i++) {\n      contents[i + offset] ^= 0x80;\n    }\n    s = WriteStringToFile(Env::Default(), contents, fname);\n    ASSERT_TRUE(s.ok()) << s.ToString();\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "s.ok()"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteStringToFile",
          "args": [
            "Env::Default()",
            "contents",
            "fname"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "WriteStringToFileSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
          "lines": "63-66",
          "snippet": "Status WriteStringToFileSync(Env* env, const Slice& data,\n                             const std::string& fname) {\n  return DoWriteStringToFile(env, data, fname, true);\n}",
          "includes": [
            "#include \"leveldb/env.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n\nStatus WriteStringToFileSync(Env* env, const Slice& data,\n                             const std::string& fname) {\n  return DoWriteStringToFile(env, data, fname, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "s.ok()"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadFileToString",
          "args": [
            "Env::Default()",
            "fname",
            "&contents"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFileToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
          "lines": "68-91",
          "snippet": "Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {\n  data->clear();\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  static const int kBufferSize = 8192;\n  char* space = new char[kBufferSize];\n  while (true) {\n    Slice fragment;\n    s = file->Read(kBufferSize, &fragment, space);\n    if (!s.ok()) {\n      break;\n    }\n    data->append(fragment.data(), fragment.size());\n    if (fragment.empty()) {\n      break;\n    }\n  }\n  delete[] space;\n  delete file;\n  return s;\n}",
          "includes": [
            "#include \"leveldb/env.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n\nStatus ReadFileToString(Env* env, const std::string& fname, std::string* data) {\n  data->clear();\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  static const int kBufferSize = 8192;\n  char* space = new char[kBufferSize];\n  while (true) {\n    Slice fragment;\n    s = file->Read(kBufferSize, &fragment, space);\n    if (!s.ok()) {\n      break;\n    }\n    data->append(fragment.data(), fragment.size());\n    if (fragment.empty()) {\n      break;\n    }\n  }\n  delete[] space;\n  delete file;\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "false"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname.c_str()",
            "&sbuf"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "setstate",
          "container": "CAutoFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "1070-1075",
          "snippet": "void setstate(short bits, const char* psz)\n    {\n        state |= bits;\n        if (state & exceptmask)\n            THROW_WITH_STACKTRACE(std::ios_base::failure(psz));\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCAutoFile {\n  void setstate(short bits, const char* psz)\n      {\n          state |= bits;\n          if (state & exceptmask)\n              THROW_WITH_STACKTRACE(std::ios_base::failure(psz));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!fname.empty()"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.empty",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "number"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "VersionEditPrinter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "110-118",
          "snippet": "static void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseFileName",
          "args": [
            "filenames[i]",
            "&number",
            "&type"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "85-129",
          "snippet": "bool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nbool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filenames.size",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_.GetChildren(dbname_, &filenames)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_.GetChildren",
          "args": [
            "dbname_",
            "&filenames"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "GetChildren",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "767-793",
          "snippet": "Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n{\n    Status sRet;\n    ::WIN32_FIND_DATAW wfd;\n    std::string path = dir;\n    ModifyPath(path);\n    path += \"\\\\*.*\";\n\tstd::wstring wpath;\n\tToWidePath(path, wpath);\n\n\t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n    if(hFind && hFind != INVALID_HANDLE_VALUE){\n        BOOL hasNext = TRUE;\n        std::string child;\n        while(hasNext){\n            ToNarrowPath(wfd.cFileName, child); \n            if(child != \"..\" && child != \".\")  {\n                result->push_back(child);\n            }\n            hasNext = ::FindNextFileW(hFind,&wfd);\n        }\n        ::FindClose(hFind);\n    }\n    else\n        sRet = Status::IOError(dir,\"Could not get children.\");\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n  {\n      Status sRet;\n      ::WIN32_FIND_DATAW wfd;\n      std::string path = dir;\n      ModifyPath(path);\n      path += \"\\\\*.*\";\n  \tstd::wstring wpath;\n  \tToWidePath(path, wpath);\n  \n  \t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n      if(hFind && hFind != INVALID_HANDLE_VALUE){\n          BOOL hasNext = TRUE;\n          std::string child;\n          while(hasNext){\n              ToNarrowPath(wfd.cFileName, child); \n              if(child != \"..\" && child != \".\")  {\n                  result->push_back(child);\n              }\n              hasNext = ::FindNextFileW(hFind,&wfd);\n          }\n          ::FindClose(hFind);\n      }\n      else\n          sRet = Status::IOError(dir,\"Could not get children.\");\n      return sRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n      // Pick file to corrupt\n      std::vector<std::string> filenames;\n      ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n      uint64_t number;\n      FileType type;\n      std::string fname;\n      int picked_number = -1;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type) &&\n            type == filetype &&\n            int(number) > picked_number) {  // Pick latest file\n          fname = dbname_ + \"/\" + filenames[i];\n          picked_number = number;\n        }\n      }\n      ASSERT_TRUE(!fname.empty()) << filetype;\n  \n      struct stat sbuf;\n      if (stat(fname.c_str(), &sbuf) != 0) {\n        const char* msg = strerror(errno);\n        ASSERT_TRUE(false) << fname << \": \" << msg;\n      }\n  \n      if (offset < 0) {\n        // Relative to end of file; make it absolute\n        if (-offset > sbuf.st_size) {\n          offset = 0;\n        } else {\n          offset = sbuf.st_size + offset;\n        }\n      }\n      if (offset > sbuf.st_size) {\n        offset = sbuf.st_size;\n      }\n      if (offset + bytes_to_corrupt > sbuf.st_size) {\n        bytes_to_corrupt = sbuf.st_size - offset;\n      }\n  \n      // Do it\n      std::string contents;\n      Status s = ReadFileToString(Env::Default(), fname, &contents);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n      for (int i = 0; i < bytes_to_corrupt; i++) {\n        contents[i + offset] ^= 0x80;\n      }\n      s = WriteStringToFile(Env::Default(), contents, fname);\n      ASSERT_TRUE(s.ok()) << s.ToString();\n    }\n}"
  },
  {
    "function_name": "Check",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "88-124",
    "snippet": "void Check(int min_expected, int max_expected) {\n    int next_expected = 0;\n    int missed = 0;\n    int bad_keys = 0;\n    int bad_values = 0;\n    int correct = 0;\n    std::string value_space;\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      uint64_t key;\n      Slice in(iter->key());\n      if (in == \"\" || in == \"~\") {\n        // Ignore boundary keys.\n        continue;\n      }\n      if (!ConsumeDecimalNumber(&in, &key) ||\n          !in.empty() ||\n          key < next_expected) {\n        bad_keys++;\n        continue;\n      }\n      missed += (key - next_expected);\n      next_expected = key + 1;\n      if (iter->value() != Value(key, &value_space)) {\n        bad_values++;\n      } else {\n        correct++;\n      }\n    }\n    delete iter;\n\n    fprintf(stderr,\n            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n    ASSERT_LE(min_expected, correct);\n    ASSERT_GE(max_expected, correct);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_GE",
          "args": [
            "max_expected",
            "correct"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_LE",
          "args": [
            "min_expected",
            "correct"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\"",
            "min_expected",
            "max_expected",
            "correct",
            "bad_keys",
            "bad_values",
            "missed"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Value",
          "args": [
            "key",
            "&value_space"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.empty",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConsumeDecimalNumber",
          "args": [
            "&in",
            "&key"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ConsumeDecimalNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "57-79",
          "snippet": "bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {\n  uint64_t v = 0;\n  int digits = 0;\n  while (!in->empty()) {\n    char c = (*in)[0];\n    if (c >= '0' && c <= '9') {\n      ++digits;\n      const int delta = (c - '0');\n      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);\n      if (v > kMaxUint64/10 ||\n          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {\n        // Overflow\n        return false;\n      }\n      v = (v * 10) + delta;\n      in->remove_prefix(1);\n    } else {\n      break;\n    }\n  }\n  *val = v;\n  return (digits > 0);\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nbool ConsumeDecimalNumber(Slice* in, uint64_t* val) {\n  uint64_t v = 0;\n  int digits = 0;\n  while (!in->empty()) {\n    char c = (*in)[0];\n    if (c >= '0' && c <= '9') {\n      ++digits;\n      const int delta = (c - '0');\n      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);\n      if (v > kMaxUint64/10 ||\n          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {\n        // Overflow\n        return false;\n      }\n      v = (v * 10) + delta;\n      in->remove_prefix(1);\n    } else {\n      break;\n    }\n  }\n  *val = v;\n  return (digits > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->NewIterator",
          "args": [
            "ReadOptions()"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Check(int min_expected, int max_expected) {\n      int next_expected = 0;\n      int missed = 0;\n      int bad_keys = 0;\n      int bad_values = 0;\n      int correct = 0;\n      std::string value_space;\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        uint64_t key;\n        Slice in(iter->key());\n        if (in == \"\" || in == \"~\") {\n          // Ignore boundary keys.\n          continue;\n        }\n        if (!ConsumeDecimalNumber(&in, &key) ||\n            !in.empty() ||\n            key < next_expected) {\n          bad_keys++;\n          continue;\n        }\n        missed += (key - next_expected);\n        next_expected = key + 1;\n        if (iter->value() != Value(key, &value_space)) {\n          bad_values++;\n        } else {\n          correct++;\n        }\n      }\n      delete iter;\n  \n      fprintf(stderr,\n              \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n              min_expected, max_expected, correct, bad_keys, bad_values, missed);\n      ASSERT_LE(min_expected, correct);\n      ASSERT_GE(max_expected, correct);\n    }\n}"
  },
  {
    "function_name": "Build",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "70-86",
    "snippet": "void Build(int n) {\n    std::string key_space, value_space;\n    WriteBatch batch;\n    for (int i = 0; i < n; i++) {\n      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n      Slice key = Key(i, &key_space);\n      batch.Clear();\n      batch.Put(key, Value(i, &value_space));\n      WriteOptions options;\n      // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n      // the file size.\n      if (i == n - 1) {\n        options.sync = true;\n      }\n      ASSERT_OK(db_->Write(options, &batch));\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Write(options, &batch)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Write",
          "args": [
            "options",
            "&batch"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "key",
            "Value(i, &value_space)"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Value",
          "args": [
            "i",
            "&value_space"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Clear",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Key",
          "args": [
            "i",
            "&key_space"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "Key",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "188-193",
          "snippet": "Slice Key(int i, std::string* storage) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"%016d\", i);\n    storage->assign(buf, strlen(buf));\n    return Slice(*storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Key(int i, std::string* storage) {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%016d\", i);\n      storage->assign(buf, strlen(buf));\n      return Slice(*storage);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Build(int n) {\n      std::string key_space, value_space;\n      WriteBatch batch;\n      for (int i = 0; i < n; i++) {\n        //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n        Slice key = Key(i, &key_space);\n        batch.Clear();\n        batch.Put(key, Value(i, &value_space));\n        WriteOptions options;\n        // Corrupt() doesn't work without this sync on windows; stat reports 0 for\n        // the file size.\n        if (i == n - 1) {\n          options.sync = true;\n        }\n        ASSERT_OK(db_->Write(options, &batch));\n      }\n    }\n}"
  },
  {
    "function_name": "RepairDB",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "64-68",
    "snippet": "void RepairDB() {\n    delete db_;\n    db_ = NULL;\n    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "::leveldb::RepairDB(dbname_, options_)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::leveldb::RepairDB",
          "args": [
            "dbname_",
            "options_"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "RepairDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "457-460",
          "snippet": "Status RepairDB(const std::string& dbname, const Options& options) {\n  Repairer repairer(dbname, options);\n  return repairer.Run();\n}",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nStatus RepairDB(const std::string& dbname, const Options& options) {\n  Repairer repairer(dbname, options);\n  return repairer.Run();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void RepairDB() {\n      delete db_;\n      db_ = NULL;\n      ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n    }\n}"
  },
  {
    "function_name": "Reopen",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "60-62",
    "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "TryReopen()"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TryReopen",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "TryReopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "54-58",
          "snippet": "Status TryReopen() {\n    delete db_;\n    db_ = NULL;\n    return DB::Open(options_, dbname_, &db_);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Status TryReopen() {\n      delete db_;\n      db_ = NULL;\n      return DB::Open(options_, dbname_, &db_);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
  },
  {
    "function_name": "TryReopen",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "54-58",
    "snippet": "Status TryReopen() {\n    delete db_;\n    db_ = NULL;\n    return DB::Open(options_, dbname_, &db_);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DB::Open",
          "args": [
            "options_",
            "dbname_",
            "&db_"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Status TryReopen() {\n      delete db_;\n      db_ = NULL;\n      return DB::Open(options_, dbname_, &db_);\n    }\n}"
  },
  {
    "function_name": "CorruptionTest",
    "container": "CorruptionTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
    "lines": "35-46",
    "snippet": "CorruptionTest() {\n    tiny_cache_ = NewLRUCache(100);\n    options_.env = &env_;\n    options_.block_cache = tiny_cache_;\n    dbname_ = test::TmpDir() + \"/db_test\";\n    DestroyDB(dbname_, options_);\n\n    db_ = NULL;\n    options_.create_if_missing = true;\n    Reopen();\n    options_.create_if_missing = false;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/log_format.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reopen",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Reopen",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "60-62",
          "snippet": "void Reopen() {\n    ASSERT_OK(TryReopen());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  void Reopen() {\n      ASSERT_OK(TryReopen());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DestroyDB",
          "args": [
            "dbname_",
            "options_"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "DestroyDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1482-1511",
          "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test::TmpDir",
          "args": [],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "TmpDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "60-65",
          "snippet": "std::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nstd::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewLRUCache",
          "args": [
            "100"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  CorruptionTest() {\n      tiny_cache_ = NewLRUCache(100);\n      options_.env = &env_;\n      options_.block_cache = tiny_cache_;\n      dbname_ = test::TmpDir() + \"/db_test\";\n      DestroyDB(dbname_, options_);\n  \n      db_ = NULL;\n      options_.create_if_missing = true;\n      Reopen();\n      options_.create_if_missing = false;\n    }\n}"
  }
]