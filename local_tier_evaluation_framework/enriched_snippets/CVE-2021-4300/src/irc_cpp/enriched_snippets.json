[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "389-402",
    "snippet": "int main(int argc, char *argv[])\n{\n    WSADATA wsadata;\n    if (WSAStartup(MAKEWORD(2,2), &wsadata) != NO_ERROR)\n    {\n        printf(\"Error at WSAStartup()\\n\");\n        return false;\n    }\n\n    ThreadIRCSeed(NULL);\n\n    WSACleanup();\n    return 0;\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSACleanup",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThreadIRCSeed",
          "args": [
            "NULL"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadIRCSeed2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "206-377",
          "snippet": "void ThreadIRCSeed2(void* parg)\n{\n    // Don't connect to IRC if we won't use IPv4 connections.\n    if (IsLimited(NET_IPV4))\n        return;\n\n    // ... or if we won't make outbound connections and won't accept inbound ones.\n    if (mapArgs.count(\"-connect\") && fNoListen)\n        return;\n\n    // ... or if IRC is not enabled.\n    if(!GetBoolArg(\"-irc\", true))\n      return;\n\n    printf(\"ThreadIRCSeed started\\n\");\n    int nErrorWait = 10;\n    int nRetryWait = 10;\n    int nNameRetry = 0;\n\n    while(!fShutdown) {\n\n        SOCKET hSocket;\n        CService addrConnect(\"irc.lfnet.org\", 6667, true);\n\n        if(!ConnectSocket(addrConnect, hSocket)) {\n            addrConnect = CService(\"pelican.heliacal.net\", 6667, true);\n            if(!ConnectSocket(addrConnect, hSocket)) {\n                addrConnect = CService(\"giraffe.heliacal.net\", 6667, true);\n                if(!ConnectSocket(addrConnect, hSocket)) {\n                    printf(\"IRC connect failed!\\n\");\n                    nErrorWait = nErrorWait * 11 / 10;\n                    if(Wait(nErrorWait += 60)) continue;\n                    else return;\n                }\n            }\n        }\n\n        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n\n        CNetAddr addrIPv4(\"1.2.3.4\"); // arbitrary IPv4 address to make GetLocal prefer IPv4 addresses\n        CService addrLocal;\n        string strMyName;\n        // Don't use our IP as our nick if we're not listening\n        // or if it keeps failing because the nick is already in use.\n        if (!fNoListen && GetLocal(addrLocal, &addrIPv4) && nNameRetry<3)\n            strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n        if (strMyName == \"\")\n            strMyName = strprintf(\"x%\"PRIu64\"\", GetRand(1000000000));\n\n        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n\n        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n        if (nRet != 1)\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            if (nRet == 2)\n            {\n                printf(\"IRC name already in use\\n\");\n                nNameRetry++;\n                Wait(10);\n                continue;\n            }\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n        nNameRetry = 0;\n        MilliSleep(500);\n\n        // Get our external IP from the IRC server and re-nick before joining the channel\n        CNetAddr addrFromIRC;\n        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n        {\n            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n            // Don't use our IP as our nick if we're not listening\n            if (!fNoListen && addrFromIRC.IsRoutable())\n            {\n                // IRC lets you to re-nick\n                AddLocal(addrFromIRC, LOCAL_IRC);\n                strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n            }\n        }\n\n        if (fTestNet) {\n            Send(hSocket, \"JOIN #halcyonTEST\\r\");\n            Send(hSocket, \"WHO #halcyonTEST\\r\");\n        } else {\n            // randomly join #halcyon00-#halcyon05\n            //int channel_number = GetRandInt(5);\n            /* Use a single channel currently */\n            int channel_number = 0;\n            Send(hSocket, strprintf(\"JOIN #halcyon%02d\\r\", channel_number).c_str());\n            Send(hSocket, strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str());\n        }\n\n        int64_t nStart = GetTime();\n        string strLine;\n        strLine.reserve(10000);\n        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n        {\n            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n                continue;\n\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() < 2)\n                continue;\n\n            char pszName[10000];\n            pszName[0] = '\\0';\n\n            if (vWords[1] == \"352\" && vWords.size() >= 8)\n            {\n                // index 7 is limited to 16 characters\n                // could get full length name at index 10, but would be different from join messages\n                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n                printf(\"IRC got who\\n\");\n            }\n\n            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n            {\n                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n                if (strchr(pszName, '!'))\n                    *strchr(pszName, '!') = '\\0';\n                printf(\"IRC got join\\n\");\n            }\n\n            if (pszName[0] == 'u')\n            {\n                CAddress addr;\n                if (DecodeAddress(pszName, addr))\n                {\n                    addr.nTime = GetAdjustedTime();\n                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                    nGotIRCAddresses++;\n                }\n                else\n                {\n                    printf(\"IRC decode failed\\n\");\n                }\n            }\n        }\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n\n        if (GetTime() - nStart > 20 * 60)\n        {\n            nErrorWait /= 3;\n            nRetryWait /= 3;\n        }\n\n        nRetryWait = nRetryWait * 11 / 10;\n        if (!Wait(nRetryWait += 60))\n            return;\n    }\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nGotIRCAddresses = 0;",
            "void ThreadIRCSeed2(void* parg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nint nGotIRCAddresses = 0;\nvoid ThreadIRCSeed2(void* parg);\n\nvoid ThreadIRCSeed2(void* parg)\n{\n    // Don't connect to IRC if we won't use IPv4 connections.\n    if (IsLimited(NET_IPV4))\n        return;\n\n    // ... or if we won't make outbound connections and won't accept inbound ones.\n    if (mapArgs.count(\"-connect\") && fNoListen)\n        return;\n\n    // ... or if IRC is not enabled.\n    if(!GetBoolArg(\"-irc\", true))\n      return;\n\n    printf(\"ThreadIRCSeed started\\n\");\n    int nErrorWait = 10;\n    int nRetryWait = 10;\n    int nNameRetry = 0;\n\n    while(!fShutdown) {\n\n        SOCKET hSocket;\n        CService addrConnect(\"irc.lfnet.org\", 6667, true);\n\n        if(!ConnectSocket(addrConnect, hSocket)) {\n            addrConnect = CService(\"pelican.heliacal.net\", 6667, true);\n            if(!ConnectSocket(addrConnect, hSocket)) {\n                addrConnect = CService(\"giraffe.heliacal.net\", 6667, true);\n                if(!ConnectSocket(addrConnect, hSocket)) {\n                    printf(\"IRC connect failed!\\n\");\n                    nErrorWait = nErrorWait * 11 / 10;\n                    if(Wait(nErrorWait += 60)) continue;\n                    else return;\n                }\n            }\n        }\n\n        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n\n        CNetAddr addrIPv4(\"1.2.3.4\"); // arbitrary IPv4 address to make GetLocal prefer IPv4 addresses\n        CService addrLocal;\n        string strMyName;\n        // Don't use our IP as our nick if we're not listening\n        // or if it keeps failing because the nick is already in use.\n        if (!fNoListen && GetLocal(addrLocal, &addrIPv4) && nNameRetry<3)\n            strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n        if (strMyName == \"\")\n            strMyName = strprintf(\"x%\"PRIu64\"\", GetRand(1000000000));\n\n        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n\n        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n        if (nRet != 1)\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            if (nRet == 2)\n            {\n                printf(\"IRC name already in use\\n\");\n                nNameRetry++;\n                Wait(10);\n                continue;\n            }\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n        nNameRetry = 0;\n        MilliSleep(500);\n\n        // Get our external IP from the IRC server and re-nick before joining the channel\n        CNetAddr addrFromIRC;\n        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n        {\n            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n            // Don't use our IP as our nick if we're not listening\n            if (!fNoListen && addrFromIRC.IsRoutable())\n            {\n                // IRC lets you to re-nick\n                AddLocal(addrFromIRC, LOCAL_IRC);\n                strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n            }\n        }\n\n        if (fTestNet) {\n            Send(hSocket, \"JOIN #halcyonTEST\\r\");\n            Send(hSocket, \"WHO #halcyonTEST\\r\");\n        } else {\n            // randomly join #halcyon00-#halcyon05\n            //int channel_number = GetRandInt(5);\n            /* Use a single channel currently */\n            int channel_number = 0;\n            Send(hSocket, strprintf(\"JOIN #halcyon%02d\\r\", channel_number).c_str());\n            Send(hSocket, strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str());\n        }\n\n        int64_t nStart = GetTime();\n        string strLine;\n        strLine.reserve(10000);\n        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n        {\n            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n                continue;\n\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() < 2)\n                continue;\n\n            char pszName[10000];\n            pszName[0] = '\\0';\n\n            if (vWords[1] == \"352\" && vWords.size() >= 8)\n            {\n                // index 7 is limited to 16 characters\n                // could get full length name at index 10, but would be different from join messages\n                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n                printf(\"IRC got who\\n\");\n            }\n\n            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n            {\n                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n                if (strchr(pszName, '!'))\n                    *strchr(pszName, '!') = '\\0';\n                printf(\"IRC got join\\n\");\n            }\n\n            if (pszName[0] == 'u')\n            {\n                CAddress addr;\n                if (DecodeAddress(pszName, addr))\n                {\n                    addr.nTime = GetAdjustedTime();\n                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                    nGotIRCAddresses++;\n                }\n                else\n                {\n                    printf(\"IRC decode failed\\n\");\n                }\n            }\n        }\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n\n        if (GetTime() - nStart > 20 * 60)\n        {\n            nErrorWait /= 3;\n            nRetryWait /= 3;\n        }\n\n        nRetryWait = nRetryWait * 11 / 10;\n        if (!Wait(nRetryWait += 60))\n            return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error at WSAStartup()\\n\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAStartup",
          "args": [
            "MAKEWORD(2,2)",
            "&wsadata"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEWORD",
          "args": [
            "2",
            "2"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nint main(int argc, char *argv[])\n{\n    WSADATA wsadata;\n    if (WSAStartup(MAKEWORD(2,2), &wsadata) != NO_ERROR)\n    {\n        printf(\"Error at WSAStartup()\\n\");\n        return false;\n    }\n\n    ThreadIRCSeed(NULL);\n\n    WSACleanup();\n    return 0;\n}"
  },
  {
    "function_name": "ThreadIRCSeed2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "206-377",
    "snippet": "void ThreadIRCSeed2(void* parg)\n{\n    // Don't connect to IRC if we won't use IPv4 connections.\n    if (IsLimited(NET_IPV4))\n        return;\n\n    // ... or if we won't make outbound connections and won't accept inbound ones.\n    if (mapArgs.count(\"-connect\") && fNoListen)\n        return;\n\n    // ... or if IRC is not enabled.\n    if(!GetBoolArg(\"-irc\", true))\n      return;\n\n    printf(\"ThreadIRCSeed started\\n\");\n    int nErrorWait = 10;\n    int nRetryWait = 10;\n    int nNameRetry = 0;\n\n    while(!fShutdown) {\n\n        SOCKET hSocket;\n        CService addrConnect(\"irc.lfnet.org\", 6667, true);\n\n        if(!ConnectSocket(addrConnect, hSocket)) {\n            addrConnect = CService(\"pelican.heliacal.net\", 6667, true);\n            if(!ConnectSocket(addrConnect, hSocket)) {\n                addrConnect = CService(\"giraffe.heliacal.net\", 6667, true);\n                if(!ConnectSocket(addrConnect, hSocket)) {\n                    printf(\"IRC connect failed!\\n\");\n                    nErrorWait = nErrorWait * 11 / 10;\n                    if(Wait(nErrorWait += 60)) continue;\n                    else return;\n                }\n            }\n        }\n\n        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n\n        CNetAddr addrIPv4(\"1.2.3.4\"); // arbitrary IPv4 address to make GetLocal prefer IPv4 addresses\n        CService addrLocal;\n        string strMyName;\n        // Don't use our IP as our nick if we're not listening\n        // or if it keeps failing because the nick is already in use.\n        if (!fNoListen && GetLocal(addrLocal, &addrIPv4) && nNameRetry<3)\n            strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n        if (strMyName == \"\")\n            strMyName = strprintf(\"x%\"PRIu64\"\", GetRand(1000000000));\n\n        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n\n        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n        if (nRet != 1)\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            if (nRet == 2)\n            {\n                printf(\"IRC name already in use\\n\");\n                nNameRetry++;\n                Wait(10);\n                continue;\n            }\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n        nNameRetry = 0;\n        MilliSleep(500);\n\n        // Get our external IP from the IRC server and re-nick before joining the channel\n        CNetAddr addrFromIRC;\n        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n        {\n            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n            // Don't use our IP as our nick if we're not listening\n            if (!fNoListen && addrFromIRC.IsRoutable())\n            {\n                // IRC lets you to re-nick\n                AddLocal(addrFromIRC, LOCAL_IRC);\n                strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n            }\n        }\n\n        if (fTestNet) {\n            Send(hSocket, \"JOIN #halcyonTEST\\r\");\n            Send(hSocket, \"WHO #halcyonTEST\\r\");\n        } else {\n            // randomly join #halcyon00-#halcyon05\n            //int channel_number = GetRandInt(5);\n            /* Use a single channel currently */\n            int channel_number = 0;\n            Send(hSocket, strprintf(\"JOIN #halcyon%02d\\r\", channel_number).c_str());\n            Send(hSocket, strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str());\n        }\n\n        int64_t nStart = GetTime();\n        string strLine;\n        strLine.reserve(10000);\n        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n        {\n            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n                continue;\n\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() < 2)\n                continue;\n\n            char pszName[10000];\n            pszName[0] = '\\0';\n\n            if (vWords[1] == \"352\" && vWords.size() >= 8)\n            {\n                // index 7 is limited to 16 characters\n                // could get full length name at index 10, but would be different from join messages\n                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n                printf(\"IRC got who\\n\");\n            }\n\n            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n            {\n                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n                if (strchr(pszName, '!'))\n                    *strchr(pszName, '!') = '\\0';\n                printf(\"IRC got join\\n\");\n            }\n\n            if (pszName[0] == 'u')\n            {\n                CAddress addr;\n                if (DecodeAddress(pszName, addr))\n                {\n                    addr.nTime = GetAdjustedTime();\n                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                    nGotIRCAddresses++;\n                }\n                else\n                {\n                    printf(\"IRC decode failed\\n\");\n                }\n            }\n        }\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n\n        if (GetTime() - nStart > 20 * 60)\n        {\n            nErrorWait /= 3;\n            nRetryWait /= 3;\n        }\n\n        nRetryWait = nRetryWait * 11 / 10;\n        if (!Wait(nRetryWait += 60))\n            return;\n    }\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nGotIRCAddresses = 0;",
      "void ThreadIRCSeed2(void* parg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Wait",
          "args": [
            "nRetryWait += 60"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "121-133",
          "snippet": "bool Wait(int nSeconds)\n{\n    if (fShutdown)\n        return false;\n    printf(\"IRC waiting %d seconds to reconnect\\n\", nSeconds);\n    for (int i = 0; i < nSeconds; i++)\n    {\n        if (fShutdown)\n            return false;\n        MilliSleep(1000);\n    }\n    return true;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool Wait(int nSeconds)\n{\n    if (fShutdown)\n        return false;\n    printf(\"IRC waiting %d seconds to reconnect\\n\", nSeconds);\n    for (int i = 0; i < nSeconds; i++)\n    {\n        if (fShutdown)\n            return false;\n        MilliSleep(1000);\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC decode failed\\n\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC got new address: %s\\n\"",
            "addr.ToString().c_str()"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrman.Add",
          "args": [
            "addr",
            "addrConnect",
            "51 * 60"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeAddress",
          "args": [
            "pszName",
            "addr"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "42-55",
          "snippet": "bool DecodeAddress(string str, CService& addr)\n{\n    vector<unsigned char> vch;\n    if (!DecodeBase58Check(str.substr(1), vch))\n        return false;\n\n    struct ircaddr tmp;\n    if (vch.size() != sizeof(tmp))\n        return false;\n    memcpy(&tmp, &vch[0], sizeof(tmp));\n\n    addr = CService(tmp.ip, ntohs(tmp.port));\n    return true;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool DecodeAddress(string str, CService& addr)\n{\n    vector<unsigned char> vch;\n    if (!DecodeBase58Check(str.substr(1), vch))\n        return false;\n\n    struct ircaddr tmp;\n    if (vch.size() != sizeof(tmp))\n        return false;\n    memcpy(&tmp, &vch[0], sizeof(tmp));\n\n    addr = CService(tmp.ip, ntohs(tmp.port));\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC got join\\n\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pszName",
            "'!'"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pszName",
            "'!'"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "pszName",
            "vWords[0].c_str() + 1",
            "sizeof(pszName)"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/strlcpy.h",
          "lines": "27-53",
          "snippet": "inline size_t strlcpy(char *dst, const char *src, size_t siz)\n{\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0)\n    {\n        while (--n != 0)\n        {\n            if ((*d++ = *s++) == '\\0')\n                break;\n        }\n    }\n\n    /* Not enough room in dst, add NUL and traverse rest of src */\n    if (n == 0)\n    {\n        if (siz != 0)\n            *d = '\\0';  /* NUL-terminate dst */\n        while (*s++)\n            ;\n    }\n\n    return(s - src - 1); /* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\ninline size_t strlcpy(char *dst, const char *src, size_t siz)\n{\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0)\n    {\n        while (--n != 0)\n        {\n            if ((*d++ = *s++) == '\\0')\n                break;\n        }\n    }\n\n    /* Not enough room in dst, add NUL and traverse rest of src */\n    if (n == 0)\n    {\n        if (siz != 0)\n            *d = '\\0';  /* NUL-terminate dst */\n        while (*s++)\n            ;\n    }\n\n    return(s - src - 1); /* count does not include NUL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "vWords[0].c_str",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWords[0].size",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC got who\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWords[7].c_str",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseString",
          "args": [
            "strLine",
            "' '",
            "vWords"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "351-368",
          "snippet": "void ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.empty",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecvLineIRC",
          "args": [
            "hSocket",
            "strLine"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "RecvLineIRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "78-99",
          "snippet": "bool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.reserve",
          "args": [
            "10000"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Send",
          "args": [
            "hSocket",
            "strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str()"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "62-76",
          "snippet": "static bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nstatic bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMyName.c_str",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeAddress",
          "args": [
            "GetLocalAddress(&addrConnect)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "29-40",
          "snippet": "string EncodeAddress(const CService& addr)\n{\n    struct ircaddr tmp;\n    if (addr.GetInAddr(&tmp.ip))\n    {\n        tmp.port = htons(addr.GetPort());\n\n        vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n        return string(\"u\") + EncodeBase58Check(vch);\n    }\n    return \"\";\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nstring EncodeAddress(const CService& addr)\n{\n    struct ircaddr tmp;\n    if (addr.GetInAddr(&tmp.ip))\n    {\n        tmp.port = htons(addr.GetPort());\n\n        vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n        return string(\"u\") + EncodeBase58Check(vch);\n    }\n    return \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLocalAddress",
          "args": [
            "&addrConnect"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "131-142",
          "snippet": "CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
            "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\n\nCAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddLocal",
          "args": [
            "addrFromIRC",
            "LOCAL_IRC"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "AddLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "252-255",
          "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrFromIRC.IsRoutable",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetIPFromIRC",
          "args": [
            "hSocket",
            "strMyName",
            "addrFromIRC"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "GetIPFromIRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "158-185",
          "snippet": "bool GetIPFromIRC(SOCKET hSocket, string strMyName, CNetAddr& ipRet)\n{\n    Send(hSocket, strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str());\n\n    string strLine;\n    if (!RecvCodeLine(hSocket, \"302\", strLine))\n        return false;\n\n    vector<string> vWords;\n    ParseString(strLine, ' ', vWords);\n    if (vWords.size() < 4)\n        return false;\n\n    string str = vWords[3];\n    if (str.rfind(\"@\") == string::npos)\n        return false;\n    string strHost = str.substr(str.rfind(\"@\")+1);\n\n    // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n    // but in case another IRC is ever used this should work.\n    printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n    CNetAddr addr(strHost, true);\n    if (!addr.IsValid())\n        return false;\n    ipRet = addr;\n\n    return true;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool GetIPFromIRC(SOCKET hSocket, string strMyName, CNetAddr& ipRet)\n{\n    Send(hSocket, strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str());\n\n    string strLine;\n    if (!RecvCodeLine(hSocket, \"302\", strLine))\n        return false;\n\n    vector<string> vWords;\n    ParseString(strLine, ' ', vWords);\n    if (vWords.size() < 4)\n        return false;\n\n    string str = vWords[3];\n    if (str.rfind(\"@\") == string::npos)\n        return false;\n    string strHost = str.substr(str.rfind(\"@\")+1);\n\n    // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n    // but in case another IRC is ever used this should work.\n    printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n    CNetAddr addr(strHost, true);\n    if (!addr.IsValid())\n        return false;\n    ipRet = addr;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "500"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC name already in use\\n\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RecvUntil",
          "args": [
            "hSocket",
            "\" 004 \"",
            "\" 433 \""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"USER %s 8 * : %s\\r\"",
            "strMyName.c_str()",
            "strMyName.c_str()"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMyName.c_str",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMyName.c_str",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMyName.c_str",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRand",
          "args": [
            "1000000000"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLocal",
          "args": [
            "addrLocal",
            "&addrIPv4"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "106-128",
          "snippet": "bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n{\n    if (fNoListen)\n        return false;\n\n    int nBestScore = -1;\n    int nBestReachability = -1;\n    {\n        LOCK(cs_mapLocalHost);\n        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n        {\n            int nScore = (*it).second.nScore;\n            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n            {\n                addr = CService((*it).first, (*it).second.nPort);\n                nBestReachability = nReachability;\n                nBestScore = nScore;\n            }\n        }\n    }\n    return nBestScore >= 0;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CCriticalSection cs_mapLocalHost;",
            "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n{\n    if (fNoListen)\n        return false;\n\n    int nBestScore = -1;\n    int nBestReachability = -1;\n    {\n        LOCK(cs_mapLocalHost);\n        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n        {\n            int nScore = (*it).second.nScore;\n            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n            {\n                addr = CService((*it).first, (*it).second.nPort);\n                nBestReachability = nReachability;\n                nBestScore = nScore;\n            }\n        }\n    }\n    return nBestScore >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecvUntil",
          "args": [
            "hSocket",
            "\"Found your hostname\"",
            "\"using your IP address instead\"",
            "\"Couldn't look up your hostname\"",
            "\"ignoring hostname\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC connect failed!\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConnectSocket",
          "args": [
            "addrConnect",
            "hSocket"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"giraffe.heliacal.net\"",
            "6667",
            "true"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "CService",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1089-1095",
          "snippet": "CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n        *this = ip;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n          *this = ip;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectSocket",
          "args": [
            "addrConnect",
            "hSocket"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConnectSocket",
          "args": [
            "addrConnect",
            "hSocket"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadIRCSeed started\\n\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-irc\"",
            "true"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "GetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "569-578",
          "snippet": "bool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nbool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapArgs.count",
          "args": [
            "\"-connect\""
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "NET_IPV4"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nint nGotIRCAddresses = 0;\nvoid ThreadIRCSeed2(void* parg);\n\nvoid ThreadIRCSeed2(void* parg)\n{\n    // Don't connect to IRC if we won't use IPv4 connections.\n    if (IsLimited(NET_IPV4))\n        return;\n\n    // ... or if we won't make outbound connections and won't accept inbound ones.\n    if (mapArgs.count(\"-connect\") && fNoListen)\n        return;\n\n    // ... or if IRC is not enabled.\n    if(!GetBoolArg(\"-irc\", true))\n      return;\n\n    printf(\"ThreadIRCSeed started\\n\");\n    int nErrorWait = 10;\n    int nRetryWait = 10;\n    int nNameRetry = 0;\n\n    while(!fShutdown) {\n\n        SOCKET hSocket;\n        CService addrConnect(\"irc.lfnet.org\", 6667, true);\n\n        if(!ConnectSocket(addrConnect, hSocket)) {\n            addrConnect = CService(\"pelican.heliacal.net\", 6667, true);\n            if(!ConnectSocket(addrConnect, hSocket)) {\n                addrConnect = CService(\"giraffe.heliacal.net\", 6667, true);\n                if(!ConnectSocket(addrConnect, hSocket)) {\n                    printf(\"IRC connect failed!\\n\");\n                    nErrorWait = nErrorWait * 11 / 10;\n                    if(Wait(nErrorWait += 60)) continue;\n                    else return;\n                }\n            }\n        }\n\n        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n\n        CNetAddr addrIPv4(\"1.2.3.4\"); // arbitrary IPv4 address to make GetLocal prefer IPv4 addresses\n        CService addrLocal;\n        string strMyName;\n        // Don't use our IP as our nick if we're not listening\n        // or if it keeps failing because the nick is already in use.\n        if (!fNoListen && GetLocal(addrLocal, &addrIPv4) && nNameRetry<3)\n            strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n        if (strMyName == \"\")\n            strMyName = strprintf(\"x%\"PRIu64\"\", GetRand(1000000000));\n\n        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n\n        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n        if (nRet != 1)\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            if (nRet == 2)\n            {\n                printf(\"IRC name already in use\\n\");\n                nNameRetry++;\n                Wait(10);\n                continue;\n            }\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n        nNameRetry = 0;\n        MilliSleep(500);\n\n        // Get our external IP from the IRC server and re-nick before joining the channel\n        CNetAddr addrFromIRC;\n        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n        {\n            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n            // Don't use our IP as our nick if we're not listening\n            if (!fNoListen && addrFromIRC.IsRoutable())\n            {\n                // IRC lets you to re-nick\n                AddLocal(addrFromIRC, LOCAL_IRC);\n                strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n            }\n        }\n\n        if (fTestNet) {\n            Send(hSocket, \"JOIN #halcyonTEST\\r\");\n            Send(hSocket, \"WHO #halcyonTEST\\r\");\n        } else {\n            // randomly join #halcyon00-#halcyon05\n            //int channel_number = GetRandInt(5);\n            /* Use a single channel currently */\n            int channel_number = 0;\n            Send(hSocket, strprintf(\"JOIN #halcyon%02d\\r\", channel_number).c_str());\n            Send(hSocket, strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str());\n        }\n\n        int64_t nStart = GetTime();\n        string strLine;\n        strLine.reserve(10000);\n        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n        {\n            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n                continue;\n\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() < 2)\n                continue;\n\n            char pszName[10000];\n            pszName[0] = '\\0';\n\n            if (vWords[1] == \"352\" && vWords.size() >= 8)\n            {\n                // index 7 is limited to 16 characters\n                // could get full length name at index 10, but would be different from join messages\n                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n                printf(\"IRC got who\\n\");\n            }\n\n            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n            {\n                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n                if (strchr(pszName, '!'))\n                    *strchr(pszName, '!') = '\\0';\n                printf(\"IRC got join\\n\");\n            }\n\n            if (pszName[0] == 'u')\n            {\n                CAddress addr;\n                if (DecodeAddress(pszName, addr))\n                {\n                    addr.nTime = GetAdjustedTime();\n                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                    nGotIRCAddresses++;\n                }\n                else\n                {\n                    printf(\"IRC decode failed\\n\");\n                }\n            }\n        }\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n\n        if (GetTime() - nStart > 20 * 60)\n        {\n            nErrorWait /= 3;\n            nRetryWait /= 3;\n        }\n\n        nRetryWait = nRetryWait * 11 / 10;\n        if (!Wait(nRetryWait += 60))\n            return;\n    }\n}"
  },
  {
    "function_name": "ThreadIRCSeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "189-204",
    "snippet": "void ThreadIRCSeed(void* parg)\n{\n    // Make this thread recognisable as the IRC seeding thread\n    RenameThread(\"hal-ircseed\");\n\n    try\n    {\n        ThreadIRCSeed2(parg);\n    }\n    catch (std::exception& e) {\n        PrintExceptionContinue(&e, \"ThreadIRCSeed()\");\n    } catch (...) {\n        PrintExceptionContinue(NULL, \"ThreadIRCSeed()\");\n    }\n    printf(\"ThreadIRCSeed exited\\n\");\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadIRCSeed2(void* parg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadIRCSeed exited\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintExceptionContinue",
          "args": [
            "NULL",
            "\"ThreadIRCSeed()\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadIRCSeed2",
          "args": [
            "parg"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadIRCSeed2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "206-377",
          "snippet": "void ThreadIRCSeed2(void* parg)\n{\n    // Don't connect to IRC if we won't use IPv4 connections.\n    if (IsLimited(NET_IPV4))\n        return;\n\n    // ... or if we won't make outbound connections and won't accept inbound ones.\n    if (mapArgs.count(\"-connect\") && fNoListen)\n        return;\n\n    // ... or if IRC is not enabled.\n    if(!GetBoolArg(\"-irc\", true))\n      return;\n\n    printf(\"ThreadIRCSeed started\\n\");\n    int nErrorWait = 10;\n    int nRetryWait = 10;\n    int nNameRetry = 0;\n\n    while(!fShutdown) {\n\n        SOCKET hSocket;\n        CService addrConnect(\"irc.lfnet.org\", 6667, true);\n\n        if(!ConnectSocket(addrConnect, hSocket)) {\n            addrConnect = CService(\"pelican.heliacal.net\", 6667, true);\n            if(!ConnectSocket(addrConnect, hSocket)) {\n                addrConnect = CService(\"giraffe.heliacal.net\", 6667, true);\n                if(!ConnectSocket(addrConnect, hSocket)) {\n                    printf(\"IRC connect failed!\\n\");\n                    nErrorWait = nErrorWait * 11 / 10;\n                    if(Wait(nErrorWait += 60)) continue;\n                    else return;\n                }\n            }\n        }\n\n        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n\n        CNetAddr addrIPv4(\"1.2.3.4\"); // arbitrary IPv4 address to make GetLocal prefer IPv4 addresses\n        CService addrLocal;\n        string strMyName;\n        // Don't use our IP as our nick if we're not listening\n        // or if it keeps failing because the nick is already in use.\n        if (!fNoListen && GetLocal(addrLocal, &addrIPv4) && nNameRetry<3)\n            strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n        if (strMyName == \"\")\n            strMyName = strprintf(\"x%\"PRIu64\"\", GetRand(1000000000));\n\n        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n\n        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n        if (nRet != 1)\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            if (nRet == 2)\n            {\n                printf(\"IRC name already in use\\n\");\n                nNameRetry++;\n                Wait(10);\n                continue;\n            }\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n        nNameRetry = 0;\n        MilliSleep(500);\n\n        // Get our external IP from the IRC server and re-nick before joining the channel\n        CNetAddr addrFromIRC;\n        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n        {\n            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n            // Don't use our IP as our nick if we're not listening\n            if (!fNoListen && addrFromIRC.IsRoutable())\n            {\n                // IRC lets you to re-nick\n                AddLocal(addrFromIRC, LOCAL_IRC);\n                strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n            }\n        }\n\n        if (fTestNet) {\n            Send(hSocket, \"JOIN #halcyonTEST\\r\");\n            Send(hSocket, \"WHO #halcyonTEST\\r\");\n        } else {\n            // randomly join #halcyon00-#halcyon05\n            //int channel_number = GetRandInt(5);\n            /* Use a single channel currently */\n            int channel_number = 0;\n            Send(hSocket, strprintf(\"JOIN #halcyon%02d\\r\", channel_number).c_str());\n            Send(hSocket, strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str());\n        }\n\n        int64_t nStart = GetTime();\n        string strLine;\n        strLine.reserve(10000);\n        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n        {\n            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n                continue;\n\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() < 2)\n                continue;\n\n            char pszName[10000];\n            pszName[0] = '\\0';\n\n            if (vWords[1] == \"352\" && vWords.size() >= 8)\n            {\n                // index 7 is limited to 16 characters\n                // could get full length name at index 10, but would be different from join messages\n                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n                printf(\"IRC got who\\n\");\n            }\n\n            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n            {\n                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n                if (strchr(pszName, '!'))\n                    *strchr(pszName, '!') = '\\0';\n                printf(\"IRC got join\\n\");\n            }\n\n            if (pszName[0] == 'u')\n            {\n                CAddress addr;\n                if (DecodeAddress(pszName, addr))\n                {\n                    addr.nTime = GetAdjustedTime();\n                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                    nGotIRCAddresses++;\n                }\n                else\n                {\n                    printf(\"IRC decode failed\\n\");\n                }\n            }\n        }\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n\n        if (GetTime() - nStart > 20 * 60)\n        {\n            nErrorWait /= 3;\n            nRetryWait /= 3;\n        }\n\n        nRetryWait = nRetryWait * 11 / 10;\n        if (!Wait(nRetryWait += 60))\n            return;\n    }\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nGotIRCAddresses = 0;",
            "void ThreadIRCSeed2(void* parg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nint nGotIRCAddresses = 0;\nvoid ThreadIRCSeed2(void* parg);\n\nvoid ThreadIRCSeed2(void* parg)\n{\n    // Don't connect to IRC if we won't use IPv4 connections.\n    if (IsLimited(NET_IPV4))\n        return;\n\n    // ... or if we won't make outbound connections and won't accept inbound ones.\n    if (mapArgs.count(\"-connect\") && fNoListen)\n        return;\n\n    // ... or if IRC is not enabled.\n    if(!GetBoolArg(\"-irc\", true))\n      return;\n\n    printf(\"ThreadIRCSeed started\\n\");\n    int nErrorWait = 10;\n    int nRetryWait = 10;\n    int nNameRetry = 0;\n\n    while(!fShutdown) {\n\n        SOCKET hSocket;\n        CService addrConnect(\"irc.lfnet.org\", 6667, true);\n\n        if(!ConnectSocket(addrConnect, hSocket)) {\n            addrConnect = CService(\"pelican.heliacal.net\", 6667, true);\n            if(!ConnectSocket(addrConnect, hSocket)) {\n                addrConnect = CService(\"giraffe.heliacal.net\", 6667, true);\n                if(!ConnectSocket(addrConnect, hSocket)) {\n                    printf(\"IRC connect failed!\\n\");\n                    nErrorWait = nErrorWait * 11 / 10;\n                    if(Wait(nErrorWait += 60)) continue;\n                    else return;\n                }\n            }\n        }\n\n        if (!RecvUntil(hSocket, \"Found your hostname\", \"using your IP address instead\", \"Couldn't look up your hostname\", \"ignoring hostname\"))\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n\n        CNetAddr addrIPv4(\"1.2.3.4\"); // arbitrary IPv4 address to make GetLocal prefer IPv4 addresses\n        CService addrLocal;\n        string strMyName;\n        // Don't use our IP as our nick if we're not listening\n        // or if it keeps failing because the nick is already in use.\n        if (!fNoListen && GetLocal(addrLocal, &addrIPv4) && nNameRetry<3)\n            strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n        if (strMyName == \"\")\n            strMyName = strprintf(\"x%\"PRIu64\"\", GetRand(1000000000));\n\n        Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n        Send(hSocket, strprintf(\"USER %s 8 * : %s\\r\", strMyName.c_str(), strMyName.c_str()).c_str());\n\n        int nRet = RecvUntil(hSocket, \" 004 \", \" 433 \");\n        if (nRet != 1)\n        {\n            closesocket(hSocket);\n            hSocket = INVALID_SOCKET;\n            if (nRet == 2)\n            {\n                printf(\"IRC name already in use\\n\");\n                nNameRetry++;\n                Wait(10);\n                continue;\n            }\n            nErrorWait = nErrorWait * 11 / 10;\n            if (Wait(nErrorWait += 60))\n                continue;\n            else\n                return;\n        }\n        nNameRetry = 0;\n        MilliSleep(500);\n\n        // Get our external IP from the IRC server and re-nick before joining the channel\n        CNetAddr addrFromIRC;\n        if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n        {\n            printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n            // Don't use our IP as our nick if we're not listening\n            if (!fNoListen && addrFromIRC.IsRoutable())\n            {\n                // IRC lets you to re-nick\n                AddLocal(addrFromIRC, LOCAL_IRC);\n                strMyName = EncodeAddress(GetLocalAddress(&addrConnect));\n                Send(hSocket, strprintf(\"NICK %s\\r\", strMyName.c_str()).c_str());\n            }\n        }\n\n        if (fTestNet) {\n            Send(hSocket, \"JOIN #halcyonTEST\\r\");\n            Send(hSocket, \"WHO #halcyonTEST\\r\");\n        } else {\n            // randomly join #halcyon00-#halcyon05\n            //int channel_number = GetRandInt(5);\n            /* Use a single channel currently */\n            int channel_number = 0;\n            Send(hSocket, strprintf(\"JOIN #halcyon%02d\\r\", channel_number).c_str());\n            Send(hSocket, strprintf(\"WHO #halcyon%02d\\r\", channel_number).c_str());\n        }\n\n        int64_t nStart = GetTime();\n        string strLine;\n        strLine.reserve(10000);\n        while (!fShutdown && RecvLineIRC(hSocket, strLine))\n        {\n            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')\n                continue;\n\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() < 2)\n                continue;\n\n            char pszName[10000];\n            pszName[0] = '\\0';\n\n            if (vWords[1] == \"352\" && vWords.size() >= 8)\n            {\n                // index 7 is limited to 16 characters\n                // could get full length name at index 10, but would be different from join messages\n                strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n                printf(\"IRC got who\\n\");\n            }\n\n            if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)\n            {\n                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname\n                strlcpy(pszName, vWords[0].c_str() + 1, sizeof(pszName));\n                if (strchr(pszName, '!'))\n                    *strchr(pszName, '!') = '\\0';\n                printf(\"IRC got join\\n\");\n            }\n\n            if (pszName[0] == 'u')\n            {\n                CAddress addr;\n                if (DecodeAddress(pszName, addr))\n                {\n                    addr.nTime = GetAdjustedTime();\n                    if (addrman.Add(addr, addrConnect, 51 * 60))\n                        printf(\"IRC got new address: %s\\n\", addr.ToString().c_str());\n                    nGotIRCAddresses++;\n                }\n                else\n                {\n                    printf(\"IRC decode failed\\n\");\n                }\n            }\n        }\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n\n        if (GetTime() - nStart > 20 * 60)\n        {\n            nErrorWait /= 3;\n            nRetryWait /= 3;\n        }\n\n        nRetryWait = nRetryWait * 11 / 10;\n        if (!Wait(nRetryWait += 60))\n            return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-ircseed\""
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nvoid ThreadIRCSeed2(void* parg);\n\nvoid ThreadIRCSeed(void* parg)\n{\n    // Make this thread recognisable as the IRC seeding thread\n    RenameThread(\"hal-ircseed\");\n\n    try\n    {\n        ThreadIRCSeed2(parg);\n    }\n    catch (std::exception& e) {\n        PrintExceptionContinue(&e, \"ThreadIRCSeed()\");\n    } catch (...) {\n        PrintExceptionContinue(NULL, \"ThreadIRCSeed()\");\n    }\n    printf(\"ThreadIRCSeed exited\\n\");\n}"
  },
  {
    "function_name": "GetIPFromIRC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "158-185",
    "snippet": "bool GetIPFromIRC(SOCKET hSocket, string strMyName, CNetAddr& ipRet)\n{\n    Send(hSocket, strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str());\n\n    string strLine;\n    if (!RecvCodeLine(hSocket, \"302\", strLine))\n        return false;\n\n    vector<string> vWords;\n    ParseString(strLine, ' ', vWords);\n    if (vWords.size() < 4)\n        return false;\n\n    string str = vWords[3];\n    if (str.rfind(\"@\") == string::npos)\n        return false;\n    string strHost = str.substr(str.rfind(\"@\")+1);\n\n    // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n    // but in case another IRC is ever used this should work.\n    printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n    CNetAddr addr(strHost, true);\n    if (!addr.IsValid())\n        return false;\n    ipRet = addr;\n\n    return true;\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr.IsValid",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GetIPFromIRC() got userhost %s\\n\"",
            "strHost.c_str()"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strHost.c_str",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.substr",
          "args": [
            "str.rfind(\"@\")+1"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.rfind",
          "args": [
            "\"@\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.rfind",
          "args": [
            "\"@\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWords.size",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseString",
          "args": [
            "strLine",
            "' '",
            "vWords"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "351-368",
          "snippet": "void ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecvCodeLine",
          "args": [
            "hSocket",
            "\"302\"",
            "strLine"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "RecvCodeLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "135-156",
          "snippet": "bool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n{\n    strRet.clear();\n    while (true)\n    {\n        string strLine;\n        if (!RecvLineIRC(hSocket, strLine))\n            return false;\n\n        vector<string> vWords;\n        ParseString(strLine, ' ', vWords);\n        if (vWords.size() < 2)\n            continue;\n\n        if (vWords[1] == psz1)\n        {\n            printf(\"IRC %s\\n\", strLine.c_str());\n            strRet = strLine;\n            return true;\n        }\n    }\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n{\n    strRet.clear();\n    while (true)\n    {\n        string strLine;\n        if (!RecvLineIRC(hSocket, strLine))\n            return false;\n\n        vector<string> vWords;\n        ParseString(strLine, ' ', vWords);\n        if (vWords.size() < 2)\n            continue;\n\n        if (vWords[1] == psz1)\n        {\n            printf(\"IRC %s\\n\", strLine.c_str());\n            strRet = strLine;\n            return true;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Send",
          "args": [
            "hSocket",
            "strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str()"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "62-76",
          "snippet": "static bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nstatic bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMyName.c_str",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool GetIPFromIRC(SOCKET hSocket, string strMyName, CNetAddr& ipRet)\n{\n    Send(hSocket, strprintf(\"USERHOST %s\\r\", strMyName.c_str()).c_str());\n\n    string strLine;\n    if (!RecvCodeLine(hSocket, \"302\", strLine))\n        return false;\n\n    vector<string> vWords;\n    ParseString(strLine, ' ', vWords);\n    if (vWords.size() < 4)\n        return false;\n\n    string str = vWords[3];\n    if (str.rfind(\"@\") == string::npos)\n        return false;\n    string strHost = str.substr(str.rfind(\"@\")+1);\n\n    // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n    // but in case another IRC is ever used this should work.\n    printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n    CNetAddr addr(strHost, true);\n    if (!addr.IsValid())\n        return false;\n    ipRet = addr;\n\n    return true;\n}"
  },
  {
    "function_name": "RecvCodeLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "135-156",
    "snippet": "bool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n{\n    strRet.clear();\n    while (true)\n    {\n        string strLine;\n        if (!RecvLineIRC(hSocket, strLine))\n            return false;\n\n        vector<string> vWords;\n        ParseString(strLine, ' ', vWords);\n        if (vWords.size() < 2)\n            continue;\n\n        if (vWords[1] == psz1)\n        {\n            printf(\"IRC %s\\n\", strLine.c_str());\n            strRet = strLine;\n            return true;\n        }\n    }\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC %s\\n\"",
            "strLine.c_str()"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.c_str",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWords.size",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseString",
          "args": [
            "strLine",
            "' '",
            "vWords"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "351-368",
          "snippet": "void ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecvLineIRC",
          "args": [
            "hSocket",
            "strLine"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "RecvLineIRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "78-99",
          "snippet": "bool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strRet.clear",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool RecvCodeLine(SOCKET hSocket, const char* psz1, string& strRet)\n{\n    strRet.clear();\n    while (true)\n    {\n        string strLine;\n        if (!RecvLineIRC(hSocket, strLine))\n            return false;\n\n        vector<string> vWords;\n        ParseString(strLine, ' ', vWords);\n        if (vWords.size() < 2)\n            continue;\n\n        if (vWords[1] == psz1)\n        {\n            printf(\"IRC %s\\n\", strLine.c_str());\n            strRet = strLine;\n            return true;\n        }\n    }\n}"
  },
  {
    "function_name": "Wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "121-133",
    "snippet": "bool Wait(int nSeconds)\n{\n    if (fShutdown)\n        return false;\n    printf(\"IRC waiting %d seconds to reconnect\\n\", nSeconds);\n    for (int i = 0; i < nSeconds; i++)\n    {\n        if (fShutdown)\n            return false;\n        MilliSleep(1000);\n    }\n    return true;\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "1000"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC waiting %d seconds to reconnect\\n\"",
            "nSeconds"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool Wait(int nSeconds)\n{\n    if (fShutdown)\n        return false;\n    printf(\"IRC waiting %d seconds to reconnect\\n\", nSeconds);\n    for (int i = 0; i < nSeconds; i++)\n    {\n        if (fShutdown)\n            return false;\n        MilliSleep(1000);\n    }\n    return true;\n}"
  },
  {
    "function_name": "RecvUntil",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "101-119",
    "snippet": "int RecvUntil(SOCKET hSocket, const char* psz1, const char* psz2=NULL, const char* psz3=NULL, const char* psz4=NULL)\n{\n    while (true)\n    {\n        string strLine;\n        strLine.reserve(10000);\n        if (!RecvLineIRC(hSocket, strLine))\n            return 0;\n        printf(\"IRC %s\\n\", strLine.c_str());\n        if (psz1 && strLine.find(psz1) != string::npos)\n            return 1;\n        if (psz2 && strLine.find(psz2) != string::npos)\n            return 2;\n        if (psz3 && strLine.find(psz3) != string::npos)\n            return 3;\n        if (psz4 && strLine.find(psz4) != string::npos)\n            return 4;\n    }\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strLine.find",
          "args": [
            "psz4"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC %s\\n\"",
            "strLine.c_str()"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.c_str",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RecvLineIRC",
          "args": [
            "hSocket",
            "strLine"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "RecvLineIRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "78-99",
          "snippet": "bool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.reserve",
          "args": [
            "10000"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nint RecvUntil(SOCKET hSocket, const char* psz1, const char* psz2=NULL, const char* psz3=NULL, const char* psz4=NULL)\n{\n    while (true)\n    {\n        string strLine;\n        strLine.reserve(10000);\n        if (!RecvLineIRC(hSocket, strLine))\n            return 0;\n        printf(\"IRC %s\\n\", strLine.c_str());\n        if (psz1 && strLine.find(psz1) != string::npos)\n            return 1;\n        if (psz2 && strLine.find(psz2) != string::npos)\n            return 2;\n        if (psz3 && strLine.find(psz3) != string::npos)\n            return 3;\n        if (psz4 && strLine.find(psz4) != string::npos)\n            return 4;\n    }\n}"
  },
  {
    "function_name": "RecvLineIRC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "78-99",
    "snippet": "bool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Send",
          "args": [
            "hSocket",
            "strLine.c_str()"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "62-76",
          "snippet": "static bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"strlcpy.h\"",
            "#include \"net.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nstatic bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.c_str",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWords.size",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseString",
          "args": [
            "strLine",
            "' '",
            "vWords"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "351-368",
          "snippet": "void ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid ParseString(const string& str, char c, vector<string>& v)\n{\n    if (str.empty())\n        return;\n    string::size_type i1 = 0;\n    string::size_type i2;\n    while (true)\n    {\n        i2 = str.find(c, i1);\n        if (i2 == str.npos)\n        {\n            v.push_back(str.substr(i1));\n            return;\n        }\n        v.push_back(str.substr(i1, i2-i1));\n        i1 = i2+1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecvLine",
          "args": [
            "hSocket",
            "strLine"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "RecvLineIRC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
          "lines": "78-99",
          "snippet": "bool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool RecvLineIRC(SOCKET hSocket, string& strLine)\n{\n    while (true)\n    {\n        bool fRet = RecvLine(hSocket, strLine);\n        if (fRet)\n        {\n            if (fShutdown)\n                return false;\n            vector<string> vWords;\n            ParseString(strLine, ' ', vWords);\n            if (vWords.size() >= 1 && vWords[0] == \"PING\")\n            {\n                strLine[1] = 'O';\n                strLine += '\\r';\n                Send(hSocket, strLine.c_str());\n                continue;\n            }\n        }\n        return fRet;\n    }\n}"
  },
  {
    "function_name": "Send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "62-76",
    "snippet": "static bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "hSocket",
            "psz",
            "pszEnd - psz",
            "MSG_NOSIGNAL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "psz"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IRC SENDING: %s\\n\"",
            "pszSend"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "pszSend",
            "\"PONG\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nstatic bool Send(SOCKET hSocket, const char* pszSend)\n{\n    if (strstr(pszSend, \"PONG\") != pszSend)\n        printf(\"IRC SENDING: %s\\n\", pszSend);\n    const char* psz = pszSend;\n    const char* pszEnd = psz + strlen(psz);\n    while (psz < pszEnd)\n    {\n        int ret = send(hSocket, psz, pszEnd - psz, MSG_NOSIGNAL);\n        if (ret < 0)\n            return false;\n        psz += ret;\n    }\n    return true;\n}"
  },
  {
    "function_name": "DecodeAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "42-55",
    "snippet": "bool DecodeAddress(string str, CService& addr)\n{\n    vector<unsigned char> vch;\n    if (!DecodeBase58Check(str.substr(1), vch))\n        return false;\n\n    struct ircaddr tmp;\n    if (vch.size() != sizeof(tmp))\n        return false;\n    memcpy(&tmp, &vch[0], sizeof(tmp));\n\n    addr = CService(tmp.ip, ntohs(tmp.port));\n    return true;\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "tmp.ip",
            "ntohs(tmp.port)"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "tmp.port"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp",
            "&vch[0]",
            "sizeof(tmp)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vch.size",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeBase58Check",
          "args": [
            "str.substr(1)",
            "vch"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeBase58Check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "164-167",
          "snippet": "inline bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n{\n    return DecodeBase58Check(str.c_str(), vchRet);\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\ninline bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n{\n    return DecodeBase58Check(str.c_str(), vchRet);\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.substr",
          "args": [
            "1"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nbool DecodeAddress(string str, CService& addr)\n{\n    vector<unsigned char> vch;\n    if (!DecodeBase58Check(str.substr(1), vch))\n        return false;\n\n    struct ircaddr tmp;\n    if (vch.size() != sizeof(tmp))\n        return false;\n    memcpy(&tmp, &vch[0], sizeof(tmp));\n\n    addr = CService(tmp.ip, ntohs(tmp.port));\n    return true;\n}"
  },
  {
    "function_name": "EncodeAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/irc.cpp",
    "lines": "29-40",
    "snippet": "string EncodeAddress(const CService& addr)\n{\n    struct ircaddr tmp;\n    if (addr.GetInAddr(&tmp.ip))\n    {\n        tmp.port = htons(addr.GetPort());\n\n        vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n        return string(\"u\") + EncodeBase58Check(vch);\n    }\n    return \"\";\n}",
    "includes": [
      "#include \"base58.h\"",
      "#include \"strlcpy.h\"",
      "#include \"net.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EncodeBase58Check",
          "args": [
            "vch"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeBase58Check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "132-139",
          "snippet": "inline std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n{\n    // add 4-byte hash check to the end\n    std::vector<unsigned char> vch(vchIn);\n    uint256 hash = Hash(vch.begin(), vch.end());\n    vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);\n    return EncodeBase58(vch);\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\ninline std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n{\n    // add 4-byte hash check to the end\n    std::vector<unsigned char> vch(vchIn);\n    uint256 hash = Hash(vch.begin(), vch.end());\n    vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);\n    return EncodeBase58(vch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"u\""
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "addr.GetPort()"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.GetPort",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "GetPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1097-1100",
          "snippet": "unsigned short CService::GetPort() const\n{\n    return port;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  unsigned short CService::GetPort() const\n  {\n      return port;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.GetInAddr",
          "args": [
            "&tmp.ip"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "GetInAddr",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "831-837",
          "snippet": "bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n{\n    if (!IsIPv4())\n        return false;\n    memcpy(pipv4Addr, ip+12, 4);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n  {\n      if (!IsIPv4())\n          return false;\n      memcpy(pipv4Addr, ip+12, 4);\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"base58.h\"\n#include \"strlcpy.h\"\n#include \"net.h\"\n#include \"irc.h\"\n\nstring EncodeAddress(const CService& addr)\n{\n    struct ircaddr tmp;\n    if (addr.GetInAddr(&tmp.ip))\n    {\n        tmp.port = htons(addr.GetPort());\n\n        vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));\n        return string(\"u\") + EncodeBase58Check(vch);\n    }\n    return \"\";\n}"
  }
]