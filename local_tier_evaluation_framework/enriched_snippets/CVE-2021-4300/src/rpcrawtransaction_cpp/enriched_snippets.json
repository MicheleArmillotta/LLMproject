[
  {
    "function_name": "sendrawtransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "518-564",
    "snippet": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    // parse hex string from parameter\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n\n    // deserialize binary data stream\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n\n    // See if the transaction is already in a block\n    // or in the memory pool:\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"transaction already in block \")+hashBlock.GetHex());\n        // Not in block, but already in the memory pool; will drop\n        // through to re-relay it.\n    }\n    else\n    {\n        // push to local node\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\");\n\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayTransaction(tx, hashTx);\n\n    return hashTx.GetHex();\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashTx.GetHex",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "GetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "402-405",
          "snippet": "std::string GetHex() const\n    {\n        return ToString(16);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::string GetHex() const\n      {\n          return ToString(16);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelayTransaction",
          "args": [
            "tx",
            "hashTx"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "2004-2010",
          "snippet": "void RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SyncWithWallets",
          "args": [
            "tx",
            "NULL",
            "true"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_DESERIALIZATION_ERROR",
            "\"TX rejected\""
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.AcceptToMemoryPool",
          "args": [
            "txdb"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"transaction already in block \""
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "GetTransaction",
          "args": [
            "hashTx",
            "existingTx",
            "hashBlock"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "890-913",
          "snippet": "bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "params[0].get_str()"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "params",
            "list_of(str_type)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "str_type"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    // parse hex string from parameter\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n\n    // deserialize binary data stream\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n\n    // See if the transaction is already in a block\n    // or in the memory pool:\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"transaction already in block \")+hashBlock.GetHex());\n        // Not in block, but already in the memory pool; will drop\n        // through to re-relay it.\n    }\n    else\n    {\n        // push to local node\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\");\n\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayTransaction(tx, hashTx);\n\n    return hashTx.GetHex();\n}"
  },
  {
    "function_name": "signrawtransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "328-516",
    "snippet": "Value signrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 4)\n        throw runtime_error(\n            \"signrawtransaction <hex string> [{\\\"txid\\\":txid,\\\"vout\\\":n,\\\"scriptPubKey\\\":hex},...] [<privatekey1>,...] [sighashtype=\\\"ALL\\\"]\\n\"\n            \"Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n            \"Second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n            \"Third optional argument (may be null) is an array of base58-encoded private\\n\"\n            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n            \"Fourth optional argument is a string that is one of six values; ALL, NONE, SINGLE or\\n\"\n            \"ALL|ANYONECANPAY, NONE|ANYONECANPAY, SINGLE|ANYONECANPAY.\\n\"\n            \"Returns json object with keys:\\n\"\n            \"  hex : raw transaction with signature(s) (hex-encoded string)\\n\"\n            \"  complete : 1 if transaction has a complete set of signature (0 if not)\"\n            + HelpRequiringPassphrase());\n\n    RPCTypeCheck(params, list_of(str_type)(array_type)(array_type)(str_type), true);\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    vector<CTransaction> txVariants;\n    while (!ssData.empty())\n    {\n        try {\n            CTransaction tx;\n            ssData >> tx;\n            txVariants.push_back(tx);\n        }\n        catch (std::exception &e) {\n            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n        }\n    }\n\n    if (txVariants.empty())\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transaction\");\n\n    // mergedTx will end up with all the signatures; it\n    // starts as a clone of the rawtx:\n    CTransaction mergedTx(txVariants[0]);\n    bool fComplete = true;\n\n    // Fetch previous transactions (inputs):\n    map<COutPoint, CScript> mapPrevOut;\n    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n    {\n        CTransaction tempTx;\n        MapPrevTx mapPrevTx;\n        CTxDB txdb(\"r\");\n        map<uint256, CTxIndex> unused;\n        bool fInvalid;\n\n        // FetchInputs aborts on failure, so we go one at a time.\n        tempTx.vin.push_back(mergedTx.vin[i]);\n        tempTx.FetchInputs(txdb, unused, false, false, mapPrevTx, fInvalid);\n\n        // Copy results into mapPrevOut:\n        BOOST_FOREACH(const CTxIn& txin, tempTx.vin)\n        {\n            const uint256& prevHash = txin.prevout.hash;\n            if (mapPrevTx.count(prevHash) && mapPrevTx[prevHash].second.vout.size()>txin.prevout.n)\n                mapPrevOut[txin.prevout] = mapPrevTx[prevHash].second.vout[txin.prevout.n].scriptPubKey;\n        }\n    }\n\n    // Add previous txouts given in the RPC call:\n    if (params.size() > 1 && params[1].type() != null_type)\n    {\n        Array prevTxs = params[1].get_array();\n        BOOST_FOREACH(Value& p, prevTxs)\n        {\n            if (p.type() != obj_type)\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n\n            Object prevOut = p.get_obj();\n\n            RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type));\n\n            string txidHex = find_value(prevOut, \"txid\").get_str();\n            if (!IsHex(txidHex))\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"txid must be hexadecimal\");\n            uint256 txid;\n            txid.SetHex(txidHex);\n\n            int nOut = find_value(prevOut, \"vout\").get_int();\n            if (nOut < 0)\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n\n            string pkHex = find_value(prevOut, \"scriptPubKey\").get_str();\n            if (!IsHex(pkHex))\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"scriptPubKey must be hexadecimal\");\n            vector<unsigned char> pkData(ParseHex(pkHex));\n            CScript scriptPubKey(pkData.begin(), pkData.end());\n\n            COutPoint outpoint(txid, nOut);\n            if (mapPrevOut.count(outpoint))\n            {\n                // Complain if scriptPubKey doesn't match\n                if (mapPrevOut[outpoint] != scriptPubKey)\n                {\n                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n                    err = err + mapPrevOut[outpoint].ToString() + \"\\nvs:\\n\"+\n                        scriptPubKey.ToString();\n                    throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                }\n            }\n            else\n                mapPrevOut[outpoint] = scriptPubKey;\n        }\n    }\n\n    bool fGivenKeys = false;\n    CBasicKeyStore tempKeystore;\n    if (params.size() > 2 && params[2].type() != null_type)\n    {\n        fGivenKeys = true;\n        Array keys = params[2].get_array();\n        BOOST_FOREACH(Value k, keys)\n        {\n            CBitcoinSecret vchSecret;\n            bool fGood = vchSecret.SetString(k.get_str());\n            if (!fGood)\n                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY,\"Invalid private key\");\n            CKey key;\n            bool fCompressed;\n            CSecret secret = vchSecret.GetSecret(fCompressed);\n            key.SetSecret(secret, fCompressed);\n            tempKeystore.AddKey(key);\n        }\n    }\n    else\n        EnsureWalletIsUnlocked();\n\n    const CKeyStore& keystore = (fGivenKeys ? tempKeystore : *pwalletMain);\n\n    int nHashType = SIGHASH_ALL;\n    if (params.size() > 3 && params[3].type() != null_type)\n    {\n        static map<string, int> mapSigHashValues =\n            boost::assign::map_list_of\n            (string(\"ALL\"), int(SIGHASH_ALL))\n            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n            (string(\"NONE\"), int(SIGHASH_NONE))\n            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n            ;\n        string strHashType = params[3].get_str();\n        if (mapSigHashValues.count(strHashType))\n            nHashType = mapSigHashValues[strHashType];\n        else\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n    }\n\n    bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\n\n    // Sign what we can:\n    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n    {\n        CTxIn& txin = mergedTx.vin[i];\n        if (mapPrevOut.count(txin.prevout) == 0)\n        {\n            fComplete = false;\n            continue;\n        }\n        const CScript& prevPubKey = mapPrevOut[txin.prevout];\n\n        txin.scriptSig.clear();\n        // Only sign SIGHASH_SINGLE if there's a corresponding output:\n        if (!fHashSingle || (i < mergedTx.vout.size()))\n            SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n\n        // ... and merge in other signatures:\n        BOOST_FOREACH(const CTransaction& txv, txVariants)\n        {\n            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n        }\n        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, 0))\n            fComplete = false;\n    }\n\n    Object result;\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << mergedTx;\n    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n    result.push_back(Pair(\"complete\", fComplete));\n\n    return result;\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"complete\", fComplete)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"complete\"",
            "fComplete"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end()))"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "ssTx.begin()",
            "ssTx.end()"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssTx.end",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssTx.begin",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VerifyScript",
          "args": [
            "txin.scriptSig",
            "prevPubKey",
            "mergedTx",
            "i",
            "0"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyScript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1682-1717",
          "snippet": "bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CombineSignatures",
          "args": [
            "prevPubKey",
            "mergedTx",
            "i",
            "txin.scriptSig",
            "txv.vin[i].scriptSig"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "CombineSignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1887-1900",
          "snippet": "CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                          const CScript& scriptSig1, const CScript& scriptSig2)\n{\n    txnouttype txType;\n    vector<vector<unsigned char> > vSolutions;\n    Solver(scriptPubKey, txType, vSolutions);\n\n    vector<valtype> stack1;\n    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n    vector<valtype> stack2;\n    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n\n    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                          const CScript& scriptSig1, const CScript& scriptSig2)\n{\n    txnouttype txType;\n    vector<vector<unsigned char> > vSolutions;\n    Solver(scriptPubKey, txType, vSolutions);\n\n    vector<valtype> stack1;\n    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n    vector<valtype> stack2;\n    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n\n    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignSignature",
          "args": [
            "keystore",
            "prevPubKey",
            "mergedTx",
            "i",
            "nHashType"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "SignSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1755-1764",
          "snippet": "bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n    assert(txin.prevout.n < txFrom.vout.size());\n    assert(txin.prevout.hash == txFrom.GetHash());\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n    assert(txin.prevout.n < txFrom.vout.size());\n    assert(txin.prevout.hash == txFrom.GetHash());\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mergedTx.vout.size",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.clear",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapPrevOut.count",
          "args": [
            "txin.prevout"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_INVALID_PARAMETER",
            "\"Invalid sighash param\""
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[3].get_str",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::assign::map_list_of",
          "args": [
            "string(\"SINGLE|ANYONECANPAY\")",
            "int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "SIGHASH_SINGLE|SIGHASH_ANYONECANPAY"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTo",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "143-153",
          "snippet": "bool RelayTo(CNode* pnode) const\n    {\n        // returns true if wasn't already sent\n        if (pnode->hashCheckpointKnown != hashCheckpoint)\n        {\n            pnode->hashCheckpointKnown = hashCheckpoint;\n            pnode->PushMessage(\"checkpoint\", *this);\n            return true;\n        }\n        return false;\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool RelayTo(CNode* pnode) const\n      {\n          // returns true if wasn't already sent\n          if (pnode->hashCheckpointKnown != hashCheckpoint)\n          {\n              pnode->hashCheckpointKnown = hashCheckpoint;\n              pnode->PushMessage(\"checkpoint\", *this);\n              return true;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"SINGLE|ANYONECANPAY\""
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "boost::assign::map_list_of",
          "args": [
            "string(\"SINGLE\")",
            "int(SIGHASH_SINGLE)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::assign::map_list_of",
          "args": [
            "string(\"NONE|ANYONECANPAY\")",
            "int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::assign::map_list_of",
          "args": [
            "string(\"NONE\")",
            "int(SIGHASH_NONE)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::assign::map_list_of",
          "args": [
            "string(\"ALL|ANYONECANPAY\")",
            "int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::assign::map_list_of",
          "args": [
            "string(\"ALL\")",
            "int(SIGHASH_ALL)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[3].type",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "321-324",
          "snippet": "Value_type Value_impl< Config >::type() const\n    {\n        return type_;\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  Value_type Value_impl< Config >::type() const\n      {\n          return type_;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EnsureWalletIsUnlocked",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "EnsureWalletIsUnlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcwallet.cpp",
          "lines": "41-47",
          "snippet": "void EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"ntp.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"ntp.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n\nvoid EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tempKeystore.AddKey",
          "args": [
            "key"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "AddKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "120-140",
          "snippet": "bool CCryptoKeyStore::AddKey(const CKey& key)\n{\n    {\n        LOCK(cs_KeyStore);\n        if (!IsCrypted())\n            return CBasicKeyStore::AddKey(key);\n\n        if (IsLocked())\n            return false;\n\n        std::vector<unsigned char> vchCryptedSecret;\n        CPubKey vchPubKey = key.GetPubKey();\n        bool fCompressed;\n        if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n            return false;\n\n        if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::AddKey(const CKey& key)\n  {\n      {\n          LOCK(cs_KeyStore);\n          if (!IsCrypted())\n              return CBasicKeyStore::AddKey(key);\n  \n          if (IsLocked())\n              return false;\n  \n          std::vector<unsigned char> vchCryptedSecret;\n          CPubKey vchPubKey = key.GetPubKey();\n          bool fCompressed;\n          if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n              return false;\n  \n          if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetSecret",
          "args": [
            "secret",
            "fCompressed"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "SetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "209-230",
          "snippet": "bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n{\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n    if (vchSecret.size() != 32)\n        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n    if (bn == NULL)\n        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n    if (!EC_KEY_regenerate_key(pkey,bn))\n    {\n        BN_clear_free(bn);\n        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n    }\n    BN_clear_free(bn);\n    fSet = true;\n    if (fCompressed || fCompressedPubKey)\n        SetCompressedPubKey();\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n  {\n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n      if (vchSecret.size() != 32)\n          throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n      BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n      if (bn == NULL)\n          throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n      if (!EC_KEY_regenerate_key(pkey,bn))\n      {\n          BN_clear_free(bn);\n          throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n      }\n      BN_clear_free(bn);\n      fSet = true;\n      if (fCompressed || fCompressedPubKey)\n          SetCompressedPubKey();\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSecret.GetSecret",
          "args": [
            "fCompressed"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "GetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "232-245",
          "snippet": "CSecret CKey::GetSecret(bool &fCompressed) const\n{\n    CSecret vchRet;\n    vchRet.resize(32);\n    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n    int nBytes = BN_num_bytes(bn);\n    if (bn == NULL)\n        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n    if (n != nBytes)\n        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n    fCompressed = fCompressedPubKey;\n    return vchRet;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CSecret CKey::GetSecret(bool &fCompressed) const\n  {\n      CSecret vchRet;\n      vchRet.resize(32);\n      const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n      int nBytes = BN_num_bytes(bn);\n      if (bn == NULL)\n          throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n      int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n      if (n != nBytes)\n          throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n      fCompressed = fCompressedPubKey;\n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSecret.SetString",
          "args": [
            "k.get_str()"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "SetString",
          "container": "CBitcoinSecret",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "445-448",
          "snippet": "bool SetString(const std::string& strSecret)\n    {\n        return SetString(strSecret.c_str());\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinSecret {\n  bool SetString(const std::string& strSecret)\n      {\n          return SetString(strSecret.c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "k.get_str",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[2].get_array",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptPubKey.ToString",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsHex",
          "args": [
            "pkHex"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "IsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "459-467",
          "snippet": "bool IsHex(const string& str)\n{\n    BOOST_FOREACH(unsigned char c, str)\n    {\n        if (phexdigit[c] < 0)\n            return false;\n    }\n    return (str.size() > 0) && (str.size()%2 == 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const signed char phexdigit[256] =\n{ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstatic const signed char phexdigit[256] =\n{ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n\nbool IsHex(const string& str)\n{\n    BOOST_FOREACH(unsigned char c, str)\n    {\n        if (phexdigit[c] < 0)\n            return false;\n    }\n    return (str.size() > 0) && (str.size()%2 == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [
            "prevOut",
            "\"scriptPubKey\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [
            "prevOut",
            "\"vout\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txid.SetHex",
          "args": [
            "txidHex"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "SetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "346-374",
          "snippet": "void SetHex(const std::string& str)\n    {\n        // skip 0x\n        const char* psz = str.c_str();\n        while (isspace(*psz))\n            psz++;\n        bool fNegative = false;\n        if (*psz == '-')\n        {\n            fNegative = true;\n            psz++;\n        }\n        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n            psz += 2;\n        while (isspace(*psz))\n            psz++;\n\n        // hex string to bignum\n        static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n        *this = 0;\n        while (isxdigit(*psz))\n        {\n            *this <<= 4;\n            int n = phexdigit[(unsigned char)*psz++];\n            *this += n;\n        }\n        if (fNegative)\n            *this = 0 - *this;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void SetHex(const std::string& str)\n      {\n          // skip 0x\n          const char* psz = str.c_str();\n          while (isspace(*psz))\n              psz++;\n          bool fNegative = false;\n          if (*psz == '-')\n          {\n              fNegative = true;\n              psz++;\n          }\n          if (psz[0] == '0' && tolower(psz[1]) == 'x')\n              psz += 2;\n          while (isspace(*psz))\n              psz++;\n  \n          // hex string to bignum\n          static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n          *this = 0;\n          while (isxdigit(*psz))\n          {\n              *this <<= 4;\n              int n = phexdigit[(unsigned char)*psz++];\n              *this += n;\n          }\n          if (fNegative)\n              *this = 0 - *this;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [
            "prevOut",
            "\"txid\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "prevOut",
            "map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_list_of",
          "args": [
            "\"scriptPubKey\"",
            "str_type"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_list_of",
          "args": [
            "\"vout\"",
            "int_type"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_list_of",
          "args": [
            "\"txid\"",
            "str_type"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.get_obj",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[1].get_array",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tempTx.FetchInputs",
          "args": [
            "txdb",
            "unused",
            "false",
            "false",
            "mapPrevTx",
            "fInvalid"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "FetchInputs",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1310-1523",
          "snippet": "bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nCoinbaseMaturity = 50;",
            "int nBestHeight = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nCoinbaseMaturity = 50;\nint nBestHeight = -1;\n\nCTransaction {\n  bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                                 bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n  {\n      // FetchInputs can return false either because we just haven't seen some inputs\n      // (in which case the transaction should be stored as an orphan)\n      // or because the transaction is malformed (in which case the transaction should\n      // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n      fInvalid = false;\n  \n      if (IsCoinBase())\n          return true; // Coinbase transactions have no inputs to fetch.\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          COutPoint prevout = vin[i].prevout;\n          if (inputsRet.count(prevout.hash))\n              continue; // Got it already\n  \n          // Read txindex\n          CTxIndex& txindex = inputsRet[prevout.hash].first;\n          bool fFound = true;\n          if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n          {\n              // Get txindex from current proposed changes\n              txindex = mapTestPool.find(prevout.hash)->second;\n          }\n          else\n          {\n              // Read txindex from txdb\n              fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n          }\n          if (!fFound && (fBlock || fMiner))\n              return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n  \n          // Read txPrev\n          CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n          {\n              // Get prev tx from single transactions in memory\n              {\n                  LOCK(mempool.cs);\n                  if (!mempool.exists(prevout.hash))\n                      return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                  txPrev = mempool.lookup(prevout.hash);\n              }\n              if (!fFound)\n                  txindex.vSpent.resize(txPrev.vout.size());\n          }\n          else\n          {\n              // Get prev tx from disk\n              if (!txPrev.ReadFromDisk(txindex.pos))\n                  return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Make sure all prevout.n indexes are valid:\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const COutPoint prevout = vin[i].prevout;\n          assert(inputsRet.count(prevout.hash) != 0);\n          const CTxIndex& txindex = inputsRet[prevout.hash].first;\n          const CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n          {\n              // Revisit this if/when transaction replacement is implemented and allows\n              // adding inputs:\n              fInvalid = true;\n              return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n          }\n      }\n  \n      return true;\n  }\n  \n  const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n  {\n      MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n      if (mi == inputs.end())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n  \n      const CTransaction& txPrev = (mi->second).second;\n      if (input.prevout.n >= txPrev.vout.size())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n  \n      return txPrev.vout[input.prevout.n];\n  }\n  \n  int64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      int64_t nResult = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          nResult += GetOutputFor(vin[i], inputs).nValue;\n      }\n      return nResult;\n  \n  }\n  \n  unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      unsigned int nSigOps = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n          if (prevout.scriptPubKey.IsPayToScriptHash())\n              nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n      }\n      return nSigOps;\n  }\n  \n  bool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n      const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n  {\n      // Take over previous transactions' spent pointers\n      // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n      // fMiner is true when called from the internal bitcoin miner\n      // ... both are false when called from CTransaction::AcceptToMemoryPool\n      if (!IsCoinBase())\n      {\n          int64_t nValueIn = 0;\n          int64_t nFees = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                  return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n  \n              // If prev is coinbase or coinstake, check that it's matured\n              if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                  for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                      if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                          return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n  \n              // ppcoin: check transaction timestamp\n              if (txPrev.nTime > nTime)\n                  return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n  \n              // Check for negative or overflow input values\n              nValueIn += txPrev.vout[prevout.n].nValue;\n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n  \n          }\n          // The first loop above does all the inexpensive checks.\n          // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n          // Helps prevent CPU exhaustion attacks.\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              // Check for conflicts (double-spend)\n              // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n              // for an attacker to attempt to split the network.\n              if (!txindex.vSpent[prevout.n].IsNull())\n                  return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n  \n              // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n              // before the last blockchain checkpoint. This is safe because block merkle hashes are\n              // still computed and checked, and any change will be caught at the next checkpoint.\n              if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n              {\n                  // Verify signature\n                  if (!VerifySignature(txPrev, *this, i, 0))\n                  {\n                      return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                  }\n              }\n  \n              // Mark outpoints as spent\n              txindex.vSpent[prevout.n] = posThisTx;\n  \n              // Write back\n              if (fBlock || fMiner)\n              {\n                  mapTestPool[prevout.hash] = txindex;\n              }\n          }\n  \n          if (!IsCoinStake())\n          {\n              if (nValueIn < GetValueOut())\n                  return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // Tally transaction fees\n              int64_t nTxFee = nValueIn - GetValueOut();\n              if (nTxFee < 0)\n                  return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // enforce transaction fees for every block\n              if (nTxFee < GetMinFee())\n                  return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n  \n              nFees += nTxFee;\n              if (!MoneyRange(nFees))\n                  return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n          }\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tempTx.vin.push_back",
          "args": [
            "mergedTx.vin[i]"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txVariants.empty",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txVariants.push_back",
          "args": [
            "tx"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "params[0].get_str()"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "params",
            "list_of(str_type)(array_type)(array_type)(str_type)",
            "true"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "RPCTypeCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "83-100",
          "snippet": "void RPCTypeCheck(const Object& o,\n                  const map<string, Value_type>& typesExpected,\n                  bool fAllowNull)\n{\n    BOOST_FOREACH(const PAIRTYPE(string, Value_type)& t, typesExpected)\n    {\n        const Value& v = find_value(o, t.first);\n        if (!fAllowNull && v.type() == null_type)\n            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first.c_str()));\n\n        if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n        {\n            string err = strprintf(\"Expected type %s for %s, got %s\",\n                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n            throw JSONRPCError(RPC_TYPE_ERROR, err);\n        }\n    }\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nvoid RPCTypeCheck(const Object& o,\n                  const map<string, Value_type>& typesExpected,\n                  bool fAllowNull)\n{\n    BOOST_FOREACH(const PAIRTYPE(string, Value_type)& t, typesExpected)\n    {\n        const Value& v = find_value(o, t.first);\n        if (!fAllowNull && v.type() == null_type)\n            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first.c_str()));\n\n        if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n        {\n            string err = strprintf(\"Expected type %s for %s, got %s\",\n                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n            throw JSONRPCError(RPC_TYPE_ERROR, err);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "str_type"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "array_type"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "array_type"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "str_type"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"signrawtransaction <hex string> [{\\\"txid\\\":txid,\\\"vout\\\":n,\\\"scriptPubKey\\\":hex},...] [<privatekey1>,...] [sighashtype=\\\"ALL\\\"]\\n\"\n            \"Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n            \"Second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n            \"Third optional argument (may be null) is an array of base58-encoded private\\n\"\n            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n            \"Fourth optional argument is a string that is one of six values; ALL, NONE, SINGLE or\\n\"\n            \"ALL|ANYONECANPAY, NONE|ANYONECANPAY, SINGLE|ANYONECANPAY.\\n\"\n            \"Returns json object with keys:\\n\"\n            \"  hex : raw transaction with signature(s) (hex-encoded string)\\n\"\n            \"  complete : 1 if transaction has a complete set of signature (0 if not)\"\n            + HelpRequiringPassphrase()"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HelpRequiringPassphrase",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "HelpRequiringPassphrase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcwallet.cpp",
          "lines": "34-39",
          "snippet": "std::string HelpRequiringPassphrase()\n{\n    return pwalletMain->IsCrypted()\n        ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\"\n        : \"\";\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"ntp.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"ntp.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n\nstd::string HelpRequiringPassphrase()\n{\n    return pwalletMain->IsCrypted()\n        ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\"\n        : \"\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue signrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 4)\n        throw runtime_error(\n            \"signrawtransaction <hex string> [{\\\"txid\\\":txid,\\\"vout\\\":n,\\\"scriptPubKey\\\":hex},...] [<privatekey1>,...] [sighashtype=\\\"ALL\\\"]\\n\"\n            \"Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n            \"Second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n            \"Third optional argument (may be null) is an array of base58-encoded private\\n\"\n            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n            \"Fourth optional argument is a string that is one of six values; ALL, NONE, SINGLE or\\n\"\n            \"ALL|ANYONECANPAY, NONE|ANYONECANPAY, SINGLE|ANYONECANPAY.\\n\"\n            \"Returns json object with keys:\\n\"\n            \"  hex : raw transaction with signature(s) (hex-encoded string)\\n\"\n            \"  complete : 1 if transaction has a complete set of signature (0 if not)\"\n            + HelpRequiringPassphrase());\n\n    RPCTypeCheck(params, list_of(str_type)(array_type)(array_type)(str_type), true);\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    vector<CTransaction> txVariants;\n    while (!ssData.empty())\n    {\n        try {\n            CTransaction tx;\n            ssData >> tx;\n            txVariants.push_back(tx);\n        }\n        catch (std::exception &e) {\n            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n        }\n    }\n\n    if (txVariants.empty())\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transaction\");\n\n    // mergedTx will end up with all the signatures; it\n    // starts as a clone of the rawtx:\n    CTransaction mergedTx(txVariants[0]);\n    bool fComplete = true;\n\n    // Fetch previous transactions (inputs):\n    map<COutPoint, CScript> mapPrevOut;\n    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n    {\n        CTransaction tempTx;\n        MapPrevTx mapPrevTx;\n        CTxDB txdb(\"r\");\n        map<uint256, CTxIndex> unused;\n        bool fInvalid;\n\n        // FetchInputs aborts on failure, so we go one at a time.\n        tempTx.vin.push_back(mergedTx.vin[i]);\n        tempTx.FetchInputs(txdb, unused, false, false, mapPrevTx, fInvalid);\n\n        // Copy results into mapPrevOut:\n        BOOST_FOREACH(const CTxIn& txin, tempTx.vin)\n        {\n            const uint256& prevHash = txin.prevout.hash;\n            if (mapPrevTx.count(prevHash) && mapPrevTx[prevHash].second.vout.size()>txin.prevout.n)\n                mapPrevOut[txin.prevout] = mapPrevTx[prevHash].second.vout[txin.prevout.n].scriptPubKey;\n        }\n    }\n\n    // Add previous txouts given in the RPC call:\n    if (params.size() > 1 && params[1].type() != null_type)\n    {\n        Array prevTxs = params[1].get_array();\n        BOOST_FOREACH(Value& p, prevTxs)\n        {\n            if (p.type() != obj_type)\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n\n            Object prevOut = p.get_obj();\n\n            RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type));\n\n            string txidHex = find_value(prevOut, \"txid\").get_str();\n            if (!IsHex(txidHex))\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"txid must be hexadecimal\");\n            uint256 txid;\n            txid.SetHex(txidHex);\n\n            int nOut = find_value(prevOut, \"vout\").get_int();\n            if (nOut < 0)\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n\n            string pkHex = find_value(prevOut, \"scriptPubKey\").get_str();\n            if (!IsHex(pkHex))\n                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"scriptPubKey must be hexadecimal\");\n            vector<unsigned char> pkData(ParseHex(pkHex));\n            CScript scriptPubKey(pkData.begin(), pkData.end());\n\n            COutPoint outpoint(txid, nOut);\n            if (mapPrevOut.count(outpoint))\n            {\n                // Complain if scriptPubKey doesn't match\n                if (mapPrevOut[outpoint] != scriptPubKey)\n                {\n                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n                    err = err + mapPrevOut[outpoint].ToString() + \"\\nvs:\\n\"+\n                        scriptPubKey.ToString();\n                    throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                }\n            }\n            else\n                mapPrevOut[outpoint] = scriptPubKey;\n        }\n    }\n\n    bool fGivenKeys = false;\n    CBasicKeyStore tempKeystore;\n    if (params.size() > 2 && params[2].type() != null_type)\n    {\n        fGivenKeys = true;\n        Array keys = params[2].get_array();\n        BOOST_FOREACH(Value k, keys)\n        {\n            CBitcoinSecret vchSecret;\n            bool fGood = vchSecret.SetString(k.get_str());\n            if (!fGood)\n                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY,\"Invalid private key\");\n            CKey key;\n            bool fCompressed;\n            CSecret secret = vchSecret.GetSecret(fCompressed);\n            key.SetSecret(secret, fCompressed);\n            tempKeystore.AddKey(key);\n        }\n    }\n    else\n        EnsureWalletIsUnlocked();\n\n    const CKeyStore& keystore = (fGivenKeys ? tempKeystore : *pwalletMain);\n\n    int nHashType = SIGHASH_ALL;\n    if (params.size() > 3 && params[3].type() != null_type)\n    {\n        static map<string, int> mapSigHashValues =\n            boost::assign::map_list_of\n            (string(\"ALL\"), int(SIGHASH_ALL))\n            (string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n            (string(\"NONE\"), int(SIGHASH_NONE))\n            (string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n            (string(\"SINGLE\"), int(SIGHASH_SINGLE))\n            (string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n            ;\n        string strHashType = params[3].get_str();\n        if (mapSigHashValues.count(strHashType))\n            nHashType = mapSigHashValues[strHashType];\n        else\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n    }\n\n    bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\n\n    // Sign what we can:\n    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n    {\n        CTxIn& txin = mergedTx.vin[i];\n        if (mapPrevOut.count(txin.prevout) == 0)\n        {\n            fComplete = false;\n            continue;\n        }\n        const CScript& prevPubKey = mapPrevOut[txin.prevout];\n\n        txin.scriptSig.clear();\n        // Only sign SIGHASH_SINGLE if there's a corresponding output:\n        if (!fHashSingle || (i < mergedTx.vout.size()))\n            SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n\n        // ... and merge in other signatures:\n        BOOST_FOREACH(const CTransaction& txv, txVariants)\n        {\n            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n        }\n        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, 0))\n            fComplete = false;\n    }\n\n    Object result;\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << mergedTx;\n    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n    result.push_back(Pair(\"complete\", fComplete));\n\n    return result;\n}"
  },
  {
    "function_name": "decodescript",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "305-326",
    "snippet": "Value decodescript(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"decodescript <hex string>\\n\"\n            \"Decode a hex-encoded script.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    Object r;\n    CScript script;\n    if (params[0].get_str().size() > 0){\n        vector<unsigned char> scriptData(ParseHexV(params[0], \"argument\"));\n        script = CScript(scriptData.begin(), scriptData.end());\n    } else {\n        // Empty scripts are valid\n    }\n    ScriptPubKeyToJSON(script, r, false);\n\n    r.push_back(Pair(\"p2sh\", CBitcoinAddress(script.GetID()).ToString()));\n    return r;\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r.push_back",
          "args": [
            "Pair(\"p2sh\", CBitcoinAddress(script.GetID()).ToString())"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"p2sh\"",
            "CBitcoinAddress(script.GetID()).ToString()"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "script.GetID()"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "script.GetID",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ScriptPubKeyToJSON",
          "args": [
            "script",
            "r",
            "false"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ScriptPubKeyToJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
          "lines": "21-45",
          "snippet": "void ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n\n    if (fIncludeHex)\n        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}",
          "includes": [
            "#include \"wallet.h\"",
            "#include \"net.h\"",
            "#include \"main.h\"",
            "#include \"init.h\"",
            "#include \"txdb.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nvoid ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n\n    if (fIncludeHex)\n        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [
            "scriptData.begin()",
            "scriptData.end()"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "WriteCScript",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "119-123",
          "snippet": "bool WriteCScript(const uint160& hash, const CScript& redeemScript)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteCScript(const uint160& hash, const CScript& redeemScript)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptData.end",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptData.begin",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseHexV",
          "args": [
            "params[0]",
            "\"argument\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHexV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "150-158",
          "snippet": "vector<unsigned char> ParseHexV(const Value& v, string strName)\n{\n    string strHex;\n    if (v.type() == str_type)\n        strHex = v.get_str();\n    if (!IsHex(strHex))\n        throw JSONRPCError(RPC_INVALID_PARAMETER, strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n    return ParseHex(strHex);\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nvector<unsigned char> ParseHexV(const Value& v, string strName)\n{\n    string strHex;\n    if (v.type() == str_type)\n        strHex = v.get_str();\n    if (!IsHex(strHex))\n        throw JSONRPCError(RPC_INVALID_PARAMETER, strName+\" must be hexadecimal string (not '\"+strHex+\"')\");\n    return ParseHex(strHex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "params",
            "list_of(str_type)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "str_type"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"decodescript <hex string>\\n\"\n            \"Decode a hex-encoded script.\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue decodescript(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"decodescript <hex string>\\n\"\n            \"Decode a hex-encoded script.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    Object r;\n    CScript script;\n    if (params[0].get_str().size() > 0){\n        vector<unsigned char> scriptData(ParseHexV(params[0], \"argument\"));\n        script = CScript(scriptData.begin(), scriptData.end());\n    } else {\n        // Empty scripts are valid\n    }\n    ScriptPubKeyToJSON(script, r, false);\n\n    r.push_back(Pair(\"p2sh\", CBitcoinAddress(script.GetID()).ToString()));\n    return r;\n}"
  },
  {
    "function_name": "decoderawtransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "280-303",
    "snippet": "Value decoderawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"decoderawtransaction <hex string>\\n\"\n            \"Return a JSON object representing the serialized, hex-encoded transaction.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n    }\n\n    Object result;\n    TxToJSON(tx, 0, result);\n\n    return result;\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TxToJSON",
          "args": [
            "tx",
            "0",
            "result"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "TxToJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
          "lines": "47-103",
          "snippet": "void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"time\", (boost::int64_t)tx.nTime));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o, false);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}",
          "includes": [
            "#include \"wallet.h\"",
            "#include \"net.h\"",
            "#include \"main.h\"",
            "#include \"init.h\"",
            "#include \"txdb.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nvoid TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"time\", (boost::int64_t)tx.nTime));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o, false);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_DESERIALIZATION_ERROR",
            "\"TX decode failed\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "params[0].get_str()"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "params",
            "list_of(str_type)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "str_type"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"decoderawtransaction <hex string>\\n\"\n            \"Return a JSON object representing the serialized, hex-encoded transaction.\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue decoderawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"decoderawtransaction <hex string>\\n\"\n            \"Return a JSON object representing the serialized, hex-encoded transaction.\");\n\n    RPCTypeCheck(params, list_of(str_type));\n\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n    }\n\n    Object result;\n    TxToJSON(tx, 0, result);\n\n    return result;\n}"
  },
  {
    "function_name": "createrawtransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "215-278",
    "snippet": "Value createrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 2)\n        throw runtime_error(\n            \"createrawtransaction [{\\\"txid\\\":txid,\\\"vout\\\":n},...] {address:amount,...}\\n\"\n            \"Create a transaction spending given inputs\\n\"\n            \"(array of objects containing transaction id and output number),\\n\"\n            \"sending to given address(es).\\n\"\n            \"Returns hex-encoded raw transaction.\\n\"\n            \"Note that the transaction's inputs are not signed, and\\n\"\n            \"it is not stored in the wallet or transmitted to the network.\");\n\n    RPCTypeCheck(params, list_of(array_type)(obj_type));\n\n    Array inputs = params[0].get_array();\n    Object sendTo = params[1].get_obj();\n\n    CTransaction rawTx;\n\n    BOOST_FOREACH(Value& input, inputs)\n    {\n        const Object& o = input.get_obj();\n\n        const Value& txid_v = find_value(o, \"txid\");\n        if (txid_v.type() != str_type)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, missing txid key\");\n        string txid = txid_v.get_str();\n        if (!IsHex(txid))\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected hex txid\");\n\n        const Value& vout_v = find_value(o, \"vout\");\n        if (vout_v.type() != int_type)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, missing vout key\");\n        int nOutput = vout_v.get_int();\n        if (nOutput < 0)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, vout must be positive\");\n\n        CTxIn in(COutPoint(uint256(txid), nOutput));\n        rawTx.vin.push_back(in);\n    }\n\n    set<CBitcoinAddress> setAddress;\n    BOOST_FOREACH(const Pair& s, sendTo)\n    {\n        CBitcoinAddress address(s.name_);\n        if (!address.IsValid())\n            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Halcyon address: \")+s.name_);\n\n        if (setAddress.count(address))\n            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+s.name_);\n        setAddress.insert(address);\n\n        CScript scriptPubKey;\n        scriptPubKey.SetDestination(address.Get());\n        int64_t nAmount = AmountFromValue(s.value_);\n\n        CTxOut out(nAmount, scriptPubKey);\n        rawTx.vout.push_back(out);\n    }\n\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << rawTx;\n    return HexStr(ss.begin(), ss.end());\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "ss.begin()",
            "ss.end()"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.end",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.begin",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rawTx.vout.push_back",
          "args": [
            "out"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AmountFromValue",
          "args": [
            "s.value_"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "AmountFromValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "102-111",
          "snippet": "int64_t AmountFromValue(const Value& value)\n{\n    double dAmount = value.get_real();\n    if (dAmount <= 0.0 || dAmount > MAX_MONEY)\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    int64_t nAmount = roundint64(dAmount * COIN);\n    if (!MoneyRange(nAmount))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    return nAmount;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nint64_t AmountFromValue(const Value& value)\n{\n    double dAmount = value.get_real();\n    if (dAmount <= 0.0 || dAmount > MAX_MONEY)\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    int64_t nAmount = roundint64(dAmount * COIN);\n    if (!MoneyRange(nAmount))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n    return nAmount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptPubKey.SetDestination",
          "args": [
            "address.Get()"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "SetDestination",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "2011-2014",
          "snippet": "void CScript::SetDestination(const CTxDestination& dest)\n{\n    boost::apply_visitor(CScriptVisitor(this), dest);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetDestination(const CTxDestination& dest)\n  {\n      boost::apply_visitor(CScriptVisitor(this), dest);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "address.Get",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "349-367",
          "snippet": "CTxDestination Get() const {\n        if (!IsValid())\n            return CNoDestination();\n        switch (nVersion) {\n        case PUBKEY_ADDRESS:\n        case PUBKEY_ADDRESS_TEST: {\n            uint160 id;\n            memcpy(&id, &vchData[0], 20);\n            return CKeyID(id);\n        }\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            uint160 id;\n            memcpy(&id, &vchData[0], 20);\n            return CScriptID(id);\n        }\n        }\n        return CNoDestination();\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  CTxDestination Get() const {\n          if (!IsValid())\n              return CNoDestination();\n          switch (nVersion) {\n          case PUBKEY_ADDRESS:\n          case PUBKEY_ADDRESS_TEST: {\n              uint160 id;\n              memcpy(&id, &vchData[0], 20);\n              return CKeyID(id);\n          }\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              uint160 id;\n              memcpy(&id, &vchData[0], 20);\n              return CScriptID(id);\n          }\n          }\n          return CNoDestination();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setAddress.insert",
          "args": [
            "address"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_INVALID_PARAMETER",
            "string(\"Invalid parameter, duplicated address: \")+s.name_"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"Invalid parameter, duplicated address: \""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "setAddress.count",
          "args": [
            "address"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "address.IsValid",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rawTx.vin.push_back",
          "args": [
            "in"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vout_v.get_int",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "get_int",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "385-390",
          "snippet": "int Value_impl< Config >::get_int() const\n    {\n        check_type(  int_type );\n\n        return static_cast< int >( get_int64() );\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  int Value_impl< Config >::get_int() const\n      {\n          check_type(  int_type );\n  \n          return static_cast< int >( get_int64() );\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vout_v.type",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "321-324",
          "snippet": "Value_type Value_impl< Config >::type() const\n    {\n        return type_;\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  Value_type Value_impl< Config >::type() const\n      {\n          return type_;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [
            "o",
            "\"vout\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsHex",
          "args": [
            "txid"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "IsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "459-467",
          "snippet": "bool IsHex(const string& str)\n{\n    BOOST_FOREACH(unsigned char c, str)\n    {\n        if (phexdigit[c] < 0)\n            return false;\n    }\n    return (str.size() > 0) && (str.size()%2 == 0);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const signed char phexdigit[256] =\n{ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstatic const signed char phexdigit[256] =\n{ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,0xa,0xb,0xc,0xd,0xe,0xf,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, };\n\nbool IsHex(const string& str)\n{\n    BOOST_FOREACH(unsigned char c, str)\n    {\n        if (phexdigit[c] < 0)\n            return false;\n    }\n    return (str.size() > 0) && (str.size()%2 == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txid_v.get_str",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [
            "o",
            "\"txid\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.get_obj",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[1].get_obj",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_array",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "params",
            "list_of(array_type)(obj_type)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "obj_type"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "array_type"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"createrawtransaction [{\\\"txid\\\":txid,\\\"vout\\\":n},...] {address:amount,...}\\n\"\n            \"Create a transaction spending given inputs\\n\"\n            \"(array of objects containing transaction id and output number),\\n\"\n            \"sending to given address(es).\\n\"\n            \"Returns hex-encoded raw transaction.\\n\"\n            \"Note that the transaction's inputs are not signed, and\\n\"\n            \"it is not stored in the wallet or transmitted to the network.\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue createrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 2)\n        throw runtime_error(\n            \"createrawtransaction [{\\\"txid\\\":txid,\\\"vout\\\":n},...] {address:amount,...}\\n\"\n            \"Create a transaction spending given inputs\\n\"\n            \"(array of objects containing transaction id and output number),\\n\"\n            \"sending to given address(es).\\n\"\n            \"Returns hex-encoded raw transaction.\\n\"\n            \"Note that the transaction's inputs are not signed, and\\n\"\n            \"it is not stored in the wallet or transmitted to the network.\");\n\n    RPCTypeCheck(params, list_of(array_type)(obj_type));\n\n    Array inputs = params[0].get_array();\n    Object sendTo = params[1].get_obj();\n\n    CTransaction rawTx;\n\n    BOOST_FOREACH(Value& input, inputs)\n    {\n        const Object& o = input.get_obj();\n\n        const Value& txid_v = find_value(o, \"txid\");\n        if (txid_v.type() != str_type)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, missing txid key\");\n        string txid = txid_v.get_str();\n        if (!IsHex(txid))\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected hex txid\");\n\n        const Value& vout_v = find_value(o, \"vout\");\n        if (vout_v.type() != int_type)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, missing vout key\");\n        int nOutput = vout_v.get_int();\n        if (nOutput < 0)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, vout must be positive\");\n\n        CTxIn in(COutPoint(uint256(txid), nOutput));\n        rawTx.vin.push_back(in);\n    }\n\n    set<CBitcoinAddress> setAddress;\n    BOOST_FOREACH(const Pair& s, sendTo)\n    {\n        CBitcoinAddress address(s.name_);\n        if (!address.IsValid())\n            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Halcyon address: \")+s.name_);\n\n        if (setAddress.count(address))\n            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+s.name_);\n        setAddress.insert(address);\n\n        CScript scriptPubKey;\n        scriptPubKey.SetDestination(address.Get());\n        int64_t nAmount = AmountFromValue(s.value_);\n\n        CTxOut out(nAmount, scriptPubKey);\n        rawTx.vout.push_back(out);\n    }\n\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << rawTx;\n    return HexStr(ss.begin(), ss.end());\n}"
  },
  {
    "function_name": "listunspent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "140-213",
    "snippet": "Value listunspent(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 3)\n        throw runtime_error(\n            \"listunspent [minconf=1] [maxconf=9999999]  [\\\"address\\\",...]\\n\"\n            \"Returns array of unspent transaction outputs\\n\"\n            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n            \"Optionally filtered to only include txouts paid to specified addresses.\\n\"\n            \"Results are an array of Objects, each of which has:\\n\"\n            \"{txid, vout, scriptPubKey, amount, confirmations}\");\n\n    RPCTypeCheck(params, list_of(int_type)(int_type)(array_type));\n\n    int nMinDepth = 1;\n    if (params.size() > 0)\n        nMinDepth = params[0].get_int();\n\n    int nMaxDepth = 9999999;\n    if (params.size() > 1)\n        nMaxDepth = params[1].get_int();\n\n    set<CBitcoinAddress> setAddress;\n    if (params.size() > 2)\n    {\n        Array inputs = params[2].get_array();\n        BOOST_FOREACH(Value& input, inputs)\n        {\n            CBitcoinAddress address(input.get_str());\n            if (!address.IsValid())\n                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Halcyon address: \")+input.get_str());\n            if (setAddress.count(address))\n                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+input.get_str());\n           setAddress.insert(address);\n        }\n    }\n\n    Array results;\n    vector<COutput> vecOutputs;\n    pwalletMain->AvailableCoins(vecOutputs, false);\n    BOOST_FOREACH(const COutput& out, vecOutputs)\n    {\n        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n            continue;\n\n        if(setAddress.size())\n        {\n            CTxDestination address;\n            if(!ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n                continue;\n\n            if (!setAddress.count(address))\n                continue;\n        }\n\n        int64_t nValue = out.tx->vout[out.i].nValue;\n        const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n        Object entry;\n        entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n        entry.push_back(Pair(\"vout\", out.i));\n        CTxDestination address;\n        if (ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n        {\n            entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n            if (pwalletMain->mapAddressBook.count(address))\n                entry.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address]));\n        }\n        entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n        entry.push_back(Pair(\"confirmations\",out.nDepth));\n        results.push_back(entry);\n    }\n\n    return results;\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "results.push_back",
          "args": [
            "entry"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"confirmations\",out.nDepth)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"confirmations\"",
            "out.nDepth"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"amount\",ValueFromAmount(nValue))"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValueFromAmount",
          "args": [
            "nValue"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ValueFromAmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "113-116",
          "snippet": "Value ValueFromAmount(int64_t amount)\n{\n    return (double)amount / (double)COIN;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nValue ValueFromAmount(int64_t amount)\n{\n    return (double)amount / (double)COIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end()))"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "pk.begin()",
            "pk.end()"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pk.end",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pk.begin",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"account\", pwalletMain->mapAddressBook[address])"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->mapAddressBook.count",
          "args": [
            "address"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"address\", CBitcoinAddress(address).ToString())"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "address"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractDestination",
          "args": [
            "out.tx->vout[out.i].scriptPubKey",
            "address"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1590-1614",
          "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"vout\", out.i)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"txid\", out.tx->GetHash().GetHex())"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.tx->GetHash",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setAddress.size",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->AvailableCoins",
          "args": [
            "vecOutputs",
            "false"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setAddress.insert",
          "args": [
            "address"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_INVALID_PARAMETER",
            "string(\"Invalid parameter, duplicated address: \")+input.get_str()"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.get_str",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"Invalid parameter, duplicated address: \""
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "input.get_str",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "address.IsValid",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.get_str",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[2].get_array",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[1].get_int",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get_int",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "385-390",
          "snippet": "int Value_impl< Config >::get_int() const\n    {\n        check_type(  int_type );\n\n        return static_cast< int >( get_int64() );\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  int Value_impl< Config >::get_int() const\n      {\n          check_type(  int_type );\n  \n          return static_cast< int >( get_int64() );\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RPCTypeCheck",
          "args": [
            "params",
            "list_of(int_type)(int_type)(array_type)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "array_type"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "int_type"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_of",
          "args": [
            "int_type"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"listunspent [minconf=1] [maxconf=9999999]  [\\\"address\\\",...]\\n\"\n            \"Returns array of unspent transaction outputs\\n\"\n            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n            \"Optionally filtered to only include txouts paid to specified addresses.\\n\"\n            \"Results are an array of Objects, each of which has:\\n\"\n            \"{txid, vout, scriptPubKey, amount, confirmations}\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue listunspent(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 3)\n        throw runtime_error(\n            \"listunspent [minconf=1] [maxconf=9999999]  [\\\"address\\\",...]\\n\"\n            \"Returns array of unspent transaction outputs\\n\"\n            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n            \"Optionally filtered to only include txouts paid to specified addresses.\\n\"\n            \"Results are an array of Objects, each of which has:\\n\"\n            \"{txid, vout, scriptPubKey, amount, confirmations}\");\n\n    RPCTypeCheck(params, list_of(int_type)(int_type)(array_type));\n\n    int nMinDepth = 1;\n    if (params.size() > 0)\n        nMinDepth = params[0].get_int();\n\n    int nMaxDepth = 9999999;\n    if (params.size() > 1)\n        nMaxDepth = params[1].get_int();\n\n    set<CBitcoinAddress> setAddress;\n    if (params.size() > 2)\n    {\n        Array inputs = params[2].get_array();\n        BOOST_FOREACH(Value& input, inputs)\n        {\n            CBitcoinAddress address(input.get_str());\n            if (!address.IsValid())\n                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Halcyon address: \")+input.get_str());\n            if (setAddress.count(address))\n                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+input.get_str());\n           setAddress.insert(address);\n        }\n    }\n\n    Array results;\n    vector<COutput> vecOutputs;\n    pwalletMain->AvailableCoins(vecOutputs, false);\n    BOOST_FOREACH(const COutput& out, vecOutputs)\n    {\n        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n            continue;\n\n        if(setAddress.size())\n        {\n            CTxDestination address;\n            if(!ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n                continue;\n\n            if (!setAddress.count(address))\n                continue;\n        }\n\n        int64_t nValue = out.tx->vout[out.i].nValue;\n        const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n        Object entry;\n        entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n        entry.push_back(Pair(\"vout\", out.i));\n        CTxDestination address;\n        if (ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n        {\n            entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n            if (pwalletMain->mapAddressBook.count(address))\n                entry.push_back(Pair(\"account\", pwalletMain->mapAddressBook[address]));\n        }\n        entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n        entry.push_back(Pair(\"confirmations\",out.nDepth));\n        results.push_back(entry);\n    }\n\n    return results;\n}"
  },
  {
    "function_name": "getrawtransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "105-138",
    "snippet": "Value getrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 2)\n        throw runtime_error(\n            \"getrawtransaction <txid> [verbose=0]\\n\"\n            \"If verbose=0, returns a string that is\\n\"\n            \"serialized, hex-encoded data for <txid>.\\n\"\n            \"If verbose is non-zero, returns an Object\\n\"\n            \"with information about <txid>.\");\n\n    uint256 hash;\n    hash.SetHex(params[0].get_str());\n\n    bool fVerbose = false;\n    if (params.size() > 1)\n        fVerbose = (params[1].get_int() != 0);\n\n    CTransaction tx;\n    uint256 hashBlock = 0;\n    if (!GetTransaction(hash, tx, hashBlock))\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << tx;\n    string strHex = HexStr(ssTx.begin(), ssTx.end());\n\n    if (!fVerbose)\n        return strHex;\n\n    Object result;\n    result.push_back(Pair(\"hex\", strHex));\n    TxToJSON(tx, hashBlock, result);\n    return result;\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TxToJSON",
          "args": [
            "tx",
            "hashBlock",
            "result"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "TxToJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
          "lines": "47-103",
          "snippet": "void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"time\", (boost::int64_t)tx.nTime));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o, false);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}",
          "includes": [
            "#include \"wallet.h\"",
            "#include \"net.h\"",
            "#include \"main.h\"",
            "#include \"init.h\"",
            "#include \"txdb.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nvoid TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"time\", (boost::int64_t)tx.nTime));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o, false);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"hex\", strHex)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"hex\"",
            "strHex"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "ssTx.begin()",
            "ssTx.end()"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssTx.end",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssTx.begin",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_INVALID_ADDRESS_OR_KEY",
            "\"No information available about transaction\""
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTransaction",
          "args": [
            "hash",
            "tx",
            "hashBlock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "890-913",
          "snippet": "bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[1].get_int",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "get_int",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "385-390",
          "snippet": "int Value_impl< Config >::get_int() const\n    {\n        check_type(  int_type );\n\n        return static_cast< int >( get_int64() );\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  int Value_impl< Config >::get_int() const\n      {\n          check_type(  int_type );\n  \n          return static_cast< int >( get_int64() );\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.SetHex",
          "args": [
            "params[0].get_str()"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "SetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "346-374",
          "snippet": "void SetHex(const std::string& str)\n    {\n        // skip 0x\n        const char* psz = str.c_str();\n        while (isspace(*psz))\n            psz++;\n        bool fNegative = false;\n        if (*psz == '-')\n        {\n            fNegative = true;\n            psz++;\n        }\n        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n            psz += 2;\n        while (isspace(*psz))\n            psz++;\n\n        // hex string to bignum\n        static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n        *this = 0;\n        while (isxdigit(*psz))\n        {\n            *this <<= 4;\n            int n = phexdigit[(unsigned char)*psz++];\n            *this += n;\n        }\n        if (fNegative)\n            *this = 0 - *this;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void SetHex(const std::string& str)\n      {\n          // skip 0x\n          const char* psz = str.c_str();\n          while (isspace(*psz))\n              psz++;\n          bool fNegative = false;\n          if (*psz == '-')\n          {\n              fNegative = true;\n              psz++;\n          }\n          if (psz[0] == '0' && tolower(psz[1]) == 'x')\n              psz += 2;\n          while (isspace(*psz))\n              psz++;\n  \n          // hex string to bignum\n          static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n          *this = 0;\n          while (isxdigit(*psz))\n          {\n              *this <<= 4;\n              int n = phexdigit[(unsigned char)*psz++];\n              *this += n;\n          }\n          if (fNegative)\n              *this = 0 - *this;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"getrawtransaction <txid> [verbose=0]\\n\"\n            \"If verbose=0, returns a string that is\\n\"\n            \"serialized, hex-encoded data for <txid>.\\n\"\n            \"If verbose is non-zero, returns an Object\\n\"\n            \"with information about <txid>.\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nValue getrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 2)\n        throw runtime_error(\n            \"getrawtransaction <txid> [verbose=0]\\n\"\n            \"If verbose=0, returns a string that is\\n\"\n            \"serialized, hex-encoded data for <txid>.\\n\"\n            \"If verbose is non-zero, returns an Object\\n\"\n            \"with information about <txid>.\");\n\n    uint256 hash;\n    hash.SetHex(params[0].get_str());\n\n    bool fVerbose = false;\n    if (params.size() > 1)\n        fVerbose = (params[1].get_int() != 0);\n\n    CTransaction tx;\n    uint256 hashBlock = 0;\n    if (!GetTransaction(hash, tx, hashBlock))\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n\n    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n    ssTx << tx;\n    string strHex = HexStr(ssTx.begin(), ssTx.end());\n\n    if (!fVerbose)\n        return strHex;\n\n    Object result;\n    result.push_back(Pair(\"hex\", strHex));\n    TxToJSON(tx, hashBlock, result);\n    return result;\n}"
  },
  {
    "function_name": "TxToJSON",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "47-103",
    "snippet": "void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"time\", (boost::int64_t)tx.nTime));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o, false);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"confirmations\", 0)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"confirmations\"",
            "0"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"blocktime\", (boost::int64_t)pindex->nTime)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"time\", (boost::int64_t)pindex->nTime)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->IsInMainChain",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "hashBlock"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"blockhash\", hashBlock.GetHex())"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashBlock.GetHex",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "GetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "402-405",
          "snippet": "std::string GetHex() const\n    {\n        return ToString(16);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::string GetHex() const\n      {\n          return ToString(16);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"vout\", vout)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vout.push_back",
          "args": [
            "out"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"scriptPubKey\", o)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScriptPubKeyToJSON",
          "args": [
            "txout.scriptPubKey",
            "o",
            "false"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ScriptPubKeyToJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
          "lines": "21-45",
          "snippet": "void ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n\n    if (fIncludeHex)\n        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}",
          "includes": [
            "#include \"wallet.h\"",
            "#include \"net.h\"",
            "#include \"main.h\"",
            "#include \"init.h\"",
            "#include \"txdb.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nvoid ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n\n    if (fIncludeHex)\n        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"n\", (boost::int64_t)i)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"value\", ValueFromAmount(txout.nValue))"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValueFromAmount",
          "args": [
            "txout.nValue"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ValueFromAmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "113-116",
          "snippet": "Value ValueFromAmount(int64_t amount)\n{\n    return (double)amount / (double)COIN;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nValue ValueFromAmount(int64_t amount)\n{\n    return (double)amount / (double)COIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.vout.size",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"vin\", vin)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vin.push_back",
          "args": [
            "in"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.push_back",
          "args": [
            "Pair(\"sequence\", (boost::int64_t)txin.nSequence)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.push_back",
          "args": [
            "Pair(\"scriptSig\", o)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o.push_back",
          "args": [
            "Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()))"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "txin.scriptSig.begin()",
            "txin.scriptSig.end()"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.begin",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "o.push_back",
          "args": [
            "Pair(\"asm\", txin.scriptSig.ToString())"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.ToString",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.push_back",
          "args": [
            "Pair(\"vout\", (boost::int64_t)txin.prevout.n)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.push_back",
          "args": [
            "Pair(\"txid\", txin.prevout.hash.GetHex())"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.push_back",
          "args": [
            "Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"locktime\", (boost::int64_t)tx.nLockTime)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"time\", (boost::int64_t)tx.nTime)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"version\", tx.nVersion)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"txid\", tx.GetHash().GetHex())"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nvoid TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n{\n    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n    entry.push_back(Pair(\"version\", tx.nVersion));\n    entry.push_back(Pair(\"time\", (boost::int64_t)tx.nTime));\n    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n    Array vin;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        Object in;\n        if (tx.IsCoinBase())\n            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n        else\n        {\n            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n            Object o;\n            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n            in.push_back(Pair(\"scriptSig\", o));\n        }\n        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n        vin.push_back(in);\n    }\n    entry.push_back(Pair(\"vin\", vin));\n    Array vout;\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        Object out;\n        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n        out.push_back(Pair(\"n\", (boost::int64_t)i));\n        Object o;\n        ScriptPubKeyToJSON(txout.scriptPubKey, o, false);\n        out.push_back(Pair(\"scriptPubKey\", o));\n        vout.push_back(out);\n    }\n    entry.push_back(Pair(\"vout\", vout));\n\n    if (hashBlock != 0)\n    {\n        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n        if (mi != mapBlockIndex.end() && (*mi).second)\n        {\n            CBlockIndex* pindex = (*mi).second;\n            if (pindex->IsInMainChain())\n            {\n                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n            }\n            else\n                entry.push_back(Pair(\"confirmations\", 0));\n        }\n    }\n}"
  },
  {
    "function_name": "ScriptPubKeyToJSON",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcrawtransaction.cpp",
    "lines": "21-45",
    "snippet": "void ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n\n    if (fIncludeHex)\n        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}",
    "includes": [
      "#include \"wallet.h\"",
      "#include \"net.h\"",
      "#include \"main.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"base58.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"addresses\", a)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"addresses\"",
            "a"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "a.push_back",
          "args": [
            "CBitcoinAddress(addr).ToString()"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "addr"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"type\", GetTxnOutputType(type))"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTxnOutputType",
          "args": [
            "type"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"reqSigs\", nRequired)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD))"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTxnOutputType",
          "args": [
            "TX_NONSTANDARD"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExtractDestinations",
          "args": [
            "scriptPubKey",
            "type",
            "addresses",
            "nRequired"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestinations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1653-1680",
          "snippet": "bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n{\n    addressRet.clear();\n    typeRet = TX_NONSTANDARD;\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, typeRet, vSolutions))\n        return false;\n\n    if (typeRet == TX_MULTISIG)\n    {\n        nRequiredRet = vSolutions.front()[0];\n        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n        {\n            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n            addressRet.push_back(address);\n        }\n    }\n    else\n    {\n        nRequiredRet = 1;\n        CTxDestination address;\n        if (!ExtractDestination(scriptPubKey, address))\n           return false;\n        addressRet.push_back(address);\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n{\n    addressRet.clear();\n    typeRet = TX_NONSTANDARD;\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, typeRet, vSolutions))\n        return false;\n\n    if (typeRet == TX_MULTISIG)\n    {\n        nRequiredRet = vSolutions.front()[0];\n        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n        {\n            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n            addressRet.push_back(address);\n        }\n    }\n    else\n    {\n        nRequiredRet = 1;\n        CTxDestination address;\n        if (!ExtractDestination(scriptPubKey, address))\n           return false;\n        addressRet.push_back(address);\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end()))"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "scriptPubKey.begin()",
            "scriptPubKey.end()"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptPubKey.end",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptPubKey.begin",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.push_back",
          "args": [
            "Pair(\"asm\", scriptPubKey.ToString())"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptPubKey.ToString",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wallet.h\"\n#include \"net.h\"\n#include \"main.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include <boost/assign/list_of.hpp>\n\nvoid ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex)\n{\n    txnouttype type;\n    vector<CTxDestination> addresses;\n    int nRequired;\n\n    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n\n    if (fIncludeHex)\n        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n\n    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n    {\n        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n        return;\n    }\n\n    out.push_back(Pair(\"reqSigs\", nRequired));\n    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n\n    Array a;\n    BOOST_FOREACH(const CTxDestination& addr, addresses)\n        a.push_back(CBitcoinAddress(addr).ToString());\n    out.push_back(Pair(\"addresses\", a));\n}"
  }
]