[
  {
    "function_name": "DestroyDB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1482-1511",
    "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env->DeleteDir",
          "args": [
            "dbname"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteDir",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "939-949",
          "snippet": "Status Win32Env::DeleteDir( const std::string& dirname )\n{\n    Status sRet;\n    std::wstring path;\n\tToWidePath(dirname, path);\n    ModifyPath(path);\n    if(!::RemoveDirectoryW( path.c_str() ) ){\n        sRet = Status::IOError(dirname, \"Could not delete directory.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteDir( const std::string& dirname )\n  {\n      Status sRet;\n      std::wstring path;\n  \tToWidePath(dirname, path);\n      ModifyPath(path);\n      if(!::RemoveDirectoryW( path.c_str() ) ){\n          sRet = Status::IOError(dirname, \"Could not delete directory.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->DeleteFile",
          "args": [
            "lockname"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->UnlockFile",
          "args": [
            "lock"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "UnlockFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "871-876",
          "snippet": "Status Win32Env::UnlockFile( FileLock* lock )\n{\n    Status sRet;\n    delete lock;\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::UnlockFile( FileLock* lock )\n  {\n      Status sRet;\n      delete lock;\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "del.ok",
          "args": [],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseFileName",
          "args": [
            "filenames[i]",
            "&number",
            "&type"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "85-129",
          "snippet": "bool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nbool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filenames.size",
          "args": [],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->LockFile",
          "args": [
            "lockname",
            "&lock"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "LockFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "855-869",
          "snippet": "Status Win32Env::LockFile( const std::string& fname, FileLock** lock )\n{\n    Status sRet;\n    std::string path = fname;\n    ModifyPath(path);\n    Win32FileLock* _lock = new Win32FileLock(path);\n    if(!_lock->isEnable()){\n        delete _lock;\n        *lock = NULL;\n        sRet = Status::IOError(path, \"Could not lock file.\");\n    }\n    else\n        *lock = _lock;\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::LockFile( const std::string& fname, FileLock** lock )\n  {\n      Status sRet;\n      std::string path = fname;\n      ModifyPath(path);\n      Win32FileLock* _lock = new Win32FileLock(path);\n      if(!_lock->isEnable()){\n          delete _lock;\n          *lock = NULL;\n          sRet = Status::IOError(path, \"Could not lock file.\");\n      }\n      else\n          *lock = _lock;\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LockFileName",
          "args": [
            "dbname"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "LockFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "59-61",
          "snippet": "std::string LockFileName(const std::string& dbname) {\n  return dbname + \"/LOCK\";\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LockFileName(const std::string& dbname) {\n  return dbname + \"/LOCK\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filenames.empty",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->GetChildren",
          "args": [
            "dbname",
            "&filenames"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "GetChildren",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "767-793",
          "snippet": "Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n{\n    Status sRet;\n    ::WIN32_FIND_DATAW wfd;\n    std::string path = dir;\n    ModifyPath(path);\n    path += \"\\\\*.*\";\n\tstd::wstring wpath;\n\tToWidePath(path, wpath);\n\n\t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n    if(hFind && hFind != INVALID_HANDLE_VALUE){\n        BOOL hasNext = TRUE;\n        std::string child;\n        while(hasNext){\n            ToNarrowPath(wfd.cFileName, child); \n            if(child != \"..\" && child != \".\")  {\n                result->push_back(child);\n            }\n            hasNext = ::FindNextFileW(hFind,&wfd);\n        }\n        ::FindClose(hFind);\n    }\n    else\n        sRet = Status::IOError(dir,\"Could not get children.\");\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n  {\n      Status sRet;\n      ::WIN32_FIND_DATAW wfd;\n      std::string path = dir;\n      ModifyPath(path);\n      path += \"\\\\*.*\";\n  \tstd::wstring wpath;\n  \tToWidePath(path, wpath);\n  \n  \t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n      if(hFind && hFind != INVALID_HANDLE_VALUE){\n          BOOL hasNext = TRUE;\n          std::string child;\n          while(hasNext){\n              ToNarrowPath(wfd.cFileName, child); \n              if(child != \"..\" && child != \".\")  {\n                  result->push_back(child);\n              }\n              hasNext = ::FindNextFileW(hFind,&wfd);\n          }\n          ::FindClose(hFind);\n      }\n      else\n          sRet = Status::IOError(dir,\"Could not get children.\");\n      return sRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
  },
  {
    "function_name": "~Snapshot",
    "container": "Snapshot",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1479-1480",
    "snippet": "Snapshot::~Snapshot() {\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nSnapshot {\n  Snapshot::~Snapshot() {\n  }\n}"
  },
  {
    "function_name": "Open",
    "container": "DB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1445-1477",
    "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->mutex_.Unlock",
          "args": [],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->MaybeScheduleCompaction",
          "args": [],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeScheduleCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "614-630",
          "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->DeleteObsoleteFiles",
          "args": [],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteObsoleteFiles",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "218-272",
          "snippet": "void DBImpl::DeleteObsoleteFiles() {\n  if (!bg_error_.ok()) {\n    // After a background error, we don't know whether a new version may\n    // or may not have been committed, so we cannot safely garbage collect.\n    return;\n  }\n\n  // Make a set of all of the live files\n  std::set<uint64_t> live = pending_outputs_;\n  versions_->AddLiveFiles(&live);\n\n  std::vector<std::string> filenames;\n  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n  uint64_t number;\n  FileType type;\n  for (size_t i = 0; i < filenames.size(); i++) {\n    if (ParseFileName(filenames[i], &number, &type)) {\n      bool keep = true;\n      switch (type) {\n        case kLogFile:\n          keep = ((number >= versions_->LogNumber()) ||\n                  (number == versions_->PrevLogNumber()));\n          break;\n        case kDescriptorFile:\n          // Keep my manifest file, and any newer incarnations'\n          // (in case there is a race that allows other incarnations)\n          keep = (number >= versions_->ManifestFileNumber());\n          break;\n        case kTableFile:\n          keep = (live.find(number) != live.end());\n          break;\n        case kTempFile:\n          // Any temp files that are currently being written to must\n          // be recorded in pending_outputs_, which is inserted into \"live\"\n          keep = (live.find(number) != live.end());\n          break;\n        case kCurrentFile:\n        case kDBLockFile:\n        case kInfoLogFile:\n          keep = true;\n          break;\n      }\n\n      if (!keep) {\n        if (type == kTableFile) {\n          table_cache_->Evict(number);\n        }\n        Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n            int(type),\n            static_cast<unsigned long long>(number));\n        env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::DeleteObsoleteFiles() {\n    if (!bg_error_.ok()) {\n      // After a background error, we don't know whether a new version may\n      // or may not have been committed, so we cannot safely garbage collect.\n      return;\n    }\n  \n    // Make a set of all of the live files\n    std::set<uint64_t> live = pending_outputs_;\n    versions_->AddLiveFiles(&live);\n  \n    std::vector<std::string> filenames;\n    env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        bool keep = true;\n        switch (type) {\n          case kLogFile:\n            keep = ((number >= versions_->LogNumber()) ||\n                    (number == versions_->PrevLogNumber()));\n            break;\n          case kDescriptorFile:\n            // Keep my manifest file, and any newer incarnations'\n            // (in case there is a race that allows other incarnations)\n            keep = (number >= versions_->ManifestFileNumber());\n            break;\n          case kTableFile:\n            keep = (live.find(number) != live.end());\n            break;\n          case kTempFile:\n            // Any temp files that are currently being written to must\n            // be recorded in pending_outputs_, which is inserted into \"live\"\n            keep = (live.find(number) != live.end());\n            break;\n          case kCurrentFile:\n          case kDBLockFile:\n          case kInfoLogFile:\n            keep = true;\n            break;\n        }\n  \n        if (!keep) {\n          if (type == kTableFile) {\n            table_cache_->Evict(number);\n          }\n          Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n              int(type),\n              static_cast<unsigned long long>(number));\n          env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->versions_->LogAndApply",
          "args": [
            "&edit",
            "&impl->mutex_"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "LogAndApply",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "825-908",
          "snippet": "Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n  if (edit->has_log_number_) {\n    assert(edit->log_number_ >= log_number_);\n    assert(edit->log_number_ < next_file_number_);\n  } else {\n    edit->SetLogNumber(log_number_);\n  }\n\n  if (!edit->has_prev_log_number_) {\n    edit->SetPrevLogNumber(prev_log_number_);\n  }\n\n  edit->SetNextFile(next_file_number_);\n  edit->SetLastSequence(last_sequence_);\n\n  Version* v = new Version(this);\n  {\n    Builder builder(this, current_);\n    builder.Apply(edit);\n    builder.SaveTo(v);\n  }\n  Finalize(v);\n\n  // Initialize new descriptor log file if necessary by creating\n  // a temporary file that contains a snapshot of the current version.\n  std::string new_manifest_file;\n  Status s;\n  if (descriptor_log_ == NULL) {\n    // No reason to unlock *mu here since we only hit this path in the\n    // first call to LogAndApply (when opening the database).\n    assert(descriptor_file_ == NULL);\n    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n    edit->SetNextFile(next_file_number_);\n    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n    if (s.ok()) {\n      descriptor_log_ = new log::Writer(descriptor_file_);\n      s = WriteSnapshot(descriptor_log_);\n    }\n  }\n\n  // Unlock during expensive MANIFEST log write\n  {\n    mu->Unlock();\n\n    // Write new record to MANIFEST log\n    if (s.ok()) {\n      std::string record;\n      edit->EncodeTo(&record);\n      s = descriptor_log_->AddRecord(record);\n      if (s.ok()) {\n        s = descriptor_file_->Sync();\n      }\n      if (!s.ok()) {\n        Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n      }\n    }\n\n    // If we just created a new descriptor file, install it by writing a\n    // new CURRENT file that points to it.\n    if (s.ok() && !new_manifest_file.empty()) {\n      s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n    }\n\n    mu->Lock();\n  }\n\n  // Install the new version\n  if (s.ok()) {\n    AppendVersion(v);\n    log_number_ = edit->log_number_;\n    prev_log_number_ = edit->prev_log_number_;\n  } else {\n    delete v;\n    if (!new_manifest_file.empty()) {\n      delete descriptor_log_;\n      delete descriptor_file_;\n      descriptor_log_ = NULL;\n      descriptor_file_ = NULL;\n      env_->DeleteFile(new_manifest_file);\n    }\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n    if (edit->has_log_number_) {\n      assert(edit->log_number_ >= log_number_);\n      assert(edit->log_number_ < next_file_number_);\n    } else {\n      edit->SetLogNumber(log_number_);\n    }\n  \n    if (!edit->has_prev_log_number_) {\n      edit->SetPrevLogNumber(prev_log_number_);\n    }\n  \n    edit->SetNextFile(next_file_number_);\n    edit->SetLastSequence(last_sequence_);\n  \n    Version* v = new Version(this);\n    {\n      Builder builder(this, current_);\n      builder.Apply(edit);\n      builder.SaveTo(v);\n    }\n    Finalize(v);\n  \n    // Initialize new descriptor log file if necessary by creating\n    // a temporary file that contains a snapshot of the current version.\n    std::string new_manifest_file;\n    Status s;\n    if (descriptor_log_ == NULL) {\n      // No reason to unlock *mu here since we only hit this path in the\n      // first call to LogAndApply (when opening the database).\n      assert(descriptor_file_ == NULL);\n      new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n      edit->SetNextFile(next_file_number_);\n      s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n      if (s.ok()) {\n        descriptor_log_ = new log::Writer(descriptor_file_);\n        s = WriteSnapshot(descriptor_log_);\n      }\n    }\n  \n    // Unlock during expensive MANIFEST log write\n    {\n      mu->Unlock();\n  \n      // Write new record to MANIFEST log\n      if (s.ok()) {\n        std::string record;\n        edit->EncodeTo(&record);\n        s = descriptor_log_->AddRecord(record);\n        if (s.ok()) {\n          s = descriptor_file_->Sync();\n        }\n        if (!s.ok()) {\n          Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n        }\n      }\n  \n      // If we just created a new descriptor file, install it by writing a\n      // new CURRENT file that points to it.\n      if (s.ok() && !new_manifest_file.empty()) {\n        s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n      }\n  \n      mu->Lock();\n    }\n  \n    // Install the new version\n    if (s.ok()) {\n      AppendVersion(v);\n      log_number_ = edit->log_number_;\n      prev_log_number_ = edit->prev_log_number_;\n    } else {\n      delete v;\n      if (!new_manifest_file.empty()) {\n        delete descriptor_log_;\n        delete descriptor_file_;\n        descriptor_log_ = NULL;\n        descriptor_file_ = NULL;\n        env_->DeleteFile(new_manifest_file);\n      }\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.SetLogNumber",
          "args": [
            "new_log_number"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "SetLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "39-42",
          "snippet": "void SetLogNumber(uint64_t num) {\n    has_log_number_ = true;\n    log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetLogNumber(uint64_t num) {\n      has_log_number_ = true;\n      log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "options.env->NewWritableFile",
          "args": [
            "LogFileName(dbname, new_log_number)",
            "&lfile"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogFileName",
          "args": [
            "dbname",
            "new_log_number"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "LogFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "27-30",
          "snippet": "std::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->versions_->NewFileNumber",
          "args": [],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "NewFileNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "191-191",
          "snippet": "uint64_t NewFileNumber() { return next_file_number_++; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t NewFileNumber() { return next_file_number_++; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->Recover",
          "args": [
            "&edit"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "Recover",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "274-360",
          "snippet": "Status DBImpl::Recover(VersionEdit* edit) {\n  mutex_.AssertHeld();\n\n  // Ignore error from CreateDir since the creation of the DB is\n  // committed only when the descriptor is created, and this directory\n  // may already exist from a previous failed creation attempt.\n  env_->CreateDir(dbname_);\n  assert(db_lock_ == NULL);\n  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);\n  if (!s.ok()) {\n    return s;\n  }\n\n  if (!env_->FileExists(CurrentFileName(dbname_))) {\n    if (options_.create_if_missing) {\n      s = NewDB();\n      if (!s.ok()) {\n        return s;\n      }\n    } else {\n      return Status::InvalidArgument(\n          dbname_, \"does not exist (create_if_missing is false)\");\n    }\n  } else {\n    if (options_.error_if_exists) {\n      return Status::InvalidArgument(\n          dbname_, \"exists (error_if_exists is true)\");\n    }\n  }\n\n  s = versions_->Recover();\n  if (s.ok()) {\n    SequenceNumber max_sequence(0);\n\n    // Recover from all newer log files than the ones named in the\n    // descriptor (new log files may have been added by the previous\n    // incarnation without registering them in the descriptor).\n    //\n    // Note that PrevLogNumber() is no longer used, but we pay\n    // attention to it in case we are recovering a database\n    // produced by an older version of leveldb.\n    const uint64_t min_log = versions_->LogNumber();\n    const uint64_t prev_log = versions_->PrevLogNumber();\n    std::vector<std::string> filenames;\n    s = env_->GetChildren(dbname_, &filenames);\n    if (!s.ok()) {\n      return s;\n    }\n    std::set<uint64_t> expected;\n    versions_->AddLiveFiles(&expected);\n    uint64_t number;\n    FileType type;\n    std::vector<uint64_t> logs;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        expected.erase(number);\n        if (type == kLogFile && ((number >= min_log) || (number == prev_log)))\n          logs.push_back(number);\n      }\n    }\n    if (!expected.empty()) {\n      char buf[50];\n      snprintf(buf, sizeof(buf), \"%d missing files; e.g.\",\n               static_cast<int>(expected.size()));\n      return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));\n    }\n\n    // Recover in the order in which the logs were generated\n    std::sort(logs.begin(), logs.end());\n    for (size_t i = 0; i < logs.size(); i++) {\n      s = RecoverLogFile(logs[i], edit, &max_sequence);\n\n      // The previous incarnation may not have written any MANIFEST\n      // records after allocating this log number.  So we manually\n      // update the file number allocation counter in VersionSet.\n      versions_->MarkFileNumberUsed(logs[i]);\n    }\n\n    if (s.ok()) {\n      if (versions_->LastSequence() < max_sequence) {\n        versions_->SetLastSequence(max_sequence);\n      }\n    }\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Recover(VersionEdit* edit) {\n    mutex_.AssertHeld();\n  \n    // Ignore error from CreateDir since the creation of the DB is\n    // committed only when the descriptor is created, and this directory\n    // may already exist from a previous failed creation attempt.\n    env_->CreateDir(dbname_);\n    assert(db_lock_ == NULL);\n    Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);\n    if (!s.ok()) {\n      return s;\n    }\n  \n    if (!env_->FileExists(CurrentFileName(dbname_))) {\n      if (options_.create_if_missing) {\n        s = NewDB();\n        if (!s.ok()) {\n          return s;\n        }\n      } else {\n        return Status::InvalidArgument(\n            dbname_, \"does not exist (create_if_missing is false)\");\n      }\n    } else {\n      if (options_.error_if_exists) {\n        return Status::InvalidArgument(\n            dbname_, \"exists (error_if_exists is true)\");\n      }\n    }\n  \n    s = versions_->Recover();\n    if (s.ok()) {\n      SequenceNumber max_sequence(0);\n  \n      // Recover from all newer log files than the ones named in the\n      // descriptor (new log files may have been added by the previous\n      // incarnation without registering them in the descriptor).\n      //\n      // Note that PrevLogNumber() is no longer used, but we pay\n      // attention to it in case we are recovering a database\n      // produced by an older version of leveldb.\n      const uint64_t min_log = versions_->LogNumber();\n      const uint64_t prev_log = versions_->PrevLogNumber();\n      std::vector<std::string> filenames;\n      s = env_->GetChildren(dbname_, &filenames);\n      if (!s.ok()) {\n        return s;\n      }\n      std::set<uint64_t> expected;\n      versions_->AddLiveFiles(&expected);\n      uint64_t number;\n      FileType type;\n      std::vector<uint64_t> logs;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type)) {\n          expected.erase(number);\n          if (type == kLogFile && ((number >= min_log) || (number == prev_log)))\n            logs.push_back(number);\n        }\n      }\n      if (!expected.empty()) {\n        char buf[50];\n        snprintf(buf, sizeof(buf), \"%d missing files; e.g.\",\n                 static_cast<int>(expected.size()));\n        return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));\n      }\n  \n      // Recover in the order in which the logs were generated\n      std::sort(logs.begin(), logs.end());\n      for (size_t i = 0; i < logs.size(); i++) {\n        s = RecoverLogFile(logs[i], edit, &max_sequence);\n  \n        // The previous incarnation may not have written any MANIFEST\n        // records after allocating this log number.  So we manually\n        // update the file number allocation counter in VersionSet.\n        versions_->MarkFileNumberUsed(logs[i]);\n      }\n  \n      if (s.ok()) {\n        if (versions_->LastSequence() < max_sequence) {\n          versions_->SetLastSequence(max_sequence);\n        }\n      }\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "impl->mutex_.Lock",
          "args": [],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "~DB",
    "container": "DB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1443-1443",
    "snippet": "DB::~DB() { }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  DB::~DB() { }\n}"
  },
  {
    "function_name": "Delete",
    "container": "DB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1437-1441",
    "snippet": "Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n  WriteBatch batch;\n  batch.Delete(key);\n  return Write(opt, &batch);\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "opt",
            "&batch"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Delete",
          "args": [
            "key"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "78-81",
          "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n    WriteBatch batch;\n    batch.Delete(key);\n    return Write(opt, &batch);\n  }\n}"
  },
  {
    "function_name": "Put",
    "container": "DB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1431-1435",
    "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "opt",
            "&batch"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "key",
            "value"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
  },
  {
    "function_name": "GetApproximateSizes",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1403-1427",
    "snippet": "void DBImpl::GetApproximateSizes(\n    const Range* range, int n,\n    uint64_t* sizes) {\n  // TODO(opt): better implementation\n  Version* v;\n  {\n    MutexLock l(&mutex_);\n    versions_->current()->Ref();\n    v = versions_->current();\n  }\n\n  for (int i = 0; i < n; i++) {\n    // Convert user_key into a corresponding internal key.\n    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);\n    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);\n    uint64_t start = versions_->ApproximateOffsetOf(v, k1);\n    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);\n    sizes[i] = (limit >= start ? limit - start : 0);\n  }\n\n  {\n    MutexLock l(&mutex_);\n    v->Unref();\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->Unref",
          "args": [],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->ApproximateOffsetOf",
          "args": [
            "v",
            "k2"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ApproximateOffsetOf",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1119-1149",
          "snippet": "uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {\n  uint64_t result = 0;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    const std::vector<FileMetaData*>& files = v->files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {\n        // Entire file is before \"ikey\", so just add the file size\n        result += files[i]->file_size;\n      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {\n        // Entire file is after \"ikey\", so ignore\n        if (level > 0) {\n          // Files other than level 0 are sorted by meta->smallest, so\n          // no further files in this level will contain data for\n          // \"ikey\".\n          break;\n        }\n      } else {\n        // \"ikey\" falls in the range for this table.  Add the\n        // approximate offset of \"ikey\" within the table.\n        Table* tableptr;\n        Iterator* iter = table_cache_->NewIterator(\n            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);\n        if (tableptr != NULL) {\n          result += tableptr->ApproximateOffsetOf(ikey.Encode());\n        }\n        delete iter;\n      }\n    }\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {\n    uint64_t result = 0;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = v->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        if (icmp_.Compare(files[i]->largest, ikey) <= 0) {\n          // Entire file is before \"ikey\", so just add the file size\n          result += files[i]->file_size;\n        } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {\n          // Entire file is after \"ikey\", so ignore\n          if (level > 0) {\n            // Files other than level 0 are sorted by meta->smallest, so\n            // no further files in this level will contain data for\n            // \"ikey\".\n            break;\n          }\n        } else {\n          // \"ikey\" falls in the range for this table.  Add the\n          // approximate offset of \"ikey\" within the table.\n          Table* tableptr;\n          Iterator* iter = table_cache_->NewIterator(\n              ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);\n          if (tableptr != NULL) {\n            result += tableptr->ApproximateOffsetOf(ikey.Encode());\n          }\n          delete iter;\n        }\n      }\n    }\n    return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::GetApproximateSizes(\n      const Range* range, int n,\n      uint64_t* sizes) {\n    // TODO(opt): better implementation\n    Version* v;\n    {\n      MutexLock l(&mutex_);\n      versions_->current()->Ref();\n      v = versions_->current();\n    }\n  \n    for (int i = 0; i < n; i++) {\n      // Convert user_key into a corresponding internal key.\n      InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);\n      InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);\n      uint64_t start = versions_->ApproximateOffsetOf(v, k1);\n      uint64_t limit = versions_->ApproximateOffsetOf(v, k2);\n      sizes[i] = (limit >= start ? limit - start : 0);\n    }\n  \n    {\n      MutexLock l(&mutex_);\n      v->Unref();\n    }\n  }\n}"
  },
  {
    "function_name": "GetProperty",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1349-1401",
    "snippet": "bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n  value->clear();\n\n  MutexLock l(&mutex_);\n  Slice in = property;\n  Slice prefix(\"leveldb.\");\n  if (!in.starts_with(prefix)) return false;\n  in.remove_prefix(prefix.size());\n\n  if (in.starts_with(\"num-files-at-level\")) {\n    in.remove_prefix(strlen(\"num-files-at-level\"));\n    uint64_t level;\n    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n    if (!ok || level >= config::kNumLevels) {\n      return false;\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%d\",\n               versions_->NumLevelFiles(static_cast<int>(level)));\n      *value = buf;\n      return true;\n    }\n  } else if (in == \"stats\") {\n    char buf[200];\n    snprintf(buf, sizeof(buf),\n             \"                               Compactions\\n\"\n             \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n             \"--------------------------------------------------\\n\"\n             );\n    value->append(buf);\n    for (int level = 0; level < config::kNumLevels; level++) {\n      int files = versions_->NumLevelFiles(level);\n      if (stats_[level].micros > 0 || files > 0) {\n        snprintf(\n            buf, sizeof(buf),\n            \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n            level,\n            files,\n            versions_->NumLevelBytes(level) / 1048576.0,\n            stats_[level].micros / 1e6,\n            stats_[level].bytes_read / 1048576.0,\n            stats_[level].bytes_written / 1048576.0);\n        value->append(buf);\n      }\n    }\n    return true;\n  } else if (in == \"sstables\") {\n    *value = versions_->current()->DebugString();\n    return true;\n  }\n\n  return false;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->append",
          "args": [
            "buf"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\"",
            "level",
            "files",
            "versions_->NumLevelBytes(level) / 1048576.0",
            "stats_[level].micros / 1e6",
            "stats_[level].bytes_read / 1048576.0",
            "stats_[level].bytes_written / 1048576.0"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->NumLevelBytes",
          "args": [
            "level"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "NumLevelBytes",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1164-1168",
          "snippet": "int64_t VersionSet::NumLevelBytes(int level) const {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  return TotalFileSize(current_->files_[level]);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int64_t VersionSet::NumLevelBytes(int level) const {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    return TotalFileSize(current_->files_[level]);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->NumLevelFiles",
          "args": [
            "level"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "NumLevelFiles",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1098-1102",
          "snippet": "int VersionSet::NumLevelFiles(int level) const {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  return current_->files_[level].size();\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int VersionSet::NumLevelFiles(int level) const {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    return current_->files_[level].size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->append",
          "args": [
            "buf"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"                               Compactions\\n\"\n             \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n             \"--------------------------------------------------\\n\""
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%d\"",
            "versions_->NumLevelFiles(static_cast<int>(level))"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "level"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.empty",
          "args": [],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConsumeDecimalNumber",
          "args": [
            "&in",
            "&level"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "ConsumeDecimalNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "57-79",
          "snippet": "bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {\n  uint64_t v = 0;\n  int digits = 0;\n  while (!in->empty()) {\n    char c = (*in)[0];\n    if (c >= '0' && c <= '9') {\n      ++digits;\n      const int delta = (c - '0');\n      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);\n      if (v > kMaxUint64/10 ||\n          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {\n        // Overflow\n        return false;\n      }\n      v = (v * 10) + delta;\n      in->remove_prefix(1);\n    } else {\n      break;\n    }\n  }\n  *val = v;\n  return (digits > 0);\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nbool ConsumeDecimalNumber(Slice* in, uint64_t* val) {\n  uint64_t v = 0;\n  int digits = 0;\n  while (!in->empty()) {\n    char c = (*in)[0];\n    if (c >= '0' && c <= '9') {\n      ++digits;\n      const int delta = (c - '0');\n      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);\n      if (v > kMaxUint64/10 ||\n          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {\n        // Overflow\n        return false;\n      }\n      v = (v * 10) + delta;\n      in->remove_prefix(1);\n    } else {\n      break;\n    }\n  }\n  *val = v;\n  return (digits > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.remove_prefix",
          "args": [
            "strlen(\"num-files-at-level\")"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "remove_prefix",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "59-63",
          "snippet": "void remove_prefix(size_t n) {\n    assert(n <= size());\n    data_ += n;\n    size_ -= n;\n  }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  void remove_prefix(size_t n) {\n      assert(n <= size());\n      data_ += n;\n      size_ -= n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"num-files-at-level\""
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.starts_with",
          "args": [
            "\"num-files-at-level\""
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "starts_with",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "75-78",
          "snippet": "bool starts_with(const Slice& x) const {\n    return ((size_ >= x.size_) &&\n            (memcmp(data_, x.data_, x.size_) == 0));\n  }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  bool starts_with(const Slice& x) const {\n      return ((size_ >= x.size_) &&\n              (memcmp(data_, x.data_, x.size_) == 0));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix.size",
          "args": [],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->clear",
          "args": [],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n    value->clear();\n  \n    MutexLock l(&mutex_);\n    Slice in = property;\n    Slice prefix(\"leveldb.\");\n    if (!in.starts_with(prefix)) return false;\n    in.remove_prefix(prefix.size());\n  \n    if (in.starts_with(\"num-files-at-level\")) {\n      in.remove_prefix(strlen(\"num-files-at-level\"));\n      uint64_t level;\n      bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n      if (!ok || level >= config::kNumLevels) {\n        return false;\n      } else {\n        char buf[100];\n        snprintf(buf, sizeof(buf), \"%d\",\n                 versions_->NumLevelFiles(static_cast<int>(level)));\n        *value = buf;\n        return true;\n      }\n    } else if (in == \"stats\") {\n      char buf[200];\n      snprintf(buf, sizeof(buf),\n               \"                               Compactions\\n\"\n               \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n               \"--------------------------------------------------\\n\"\n               );\n      value->append(buf);\n      for (int level = 0; level < config::kNumLevels; level++) {\n        int files = versions_->NumLevelFiles(level);\n        if (stats_[level].micros > 0 || files > 0) {\n          snprintf(\n              buf, sizeof(buf),\n              \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n              level,\n              files,\n              versions_->NumLevelBytes(level) / 1048576.0,\n              stats_[level].micros / 1e6,\n              stats_[level].bytes_read / 1048576.0,\n              stats_[level].bytes_written / 1048576.0);\n          value->append(buf);\n        }\n      }\n      return true;\n    } else if (in == \"sstables\") {\n      *value = versions_->current()->DebugString();\n      return true;\n    }\n  \n    return false;\n  }\n}"
  },
  {
    "function_name": "MakeRoomForWrite",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1286-1347",
    "snippet": "Status DBImpl::MakeRoomForWrite(bool force) {\n  mutex_.AssertHeld();\n  assert(!writers_.empty());\n  bool allow_delay = !force;\n  Status s;\n  while (true) {\n    if (!bg_error_.ok()) {\n      // Yield previous error\n      s = bg_error_;\n      break;\n    } else if (\n        allow_delay &&\n        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {\n      // We are getting close to hitting a hard limit on the number of\n      // L0 files.  Rather than delaying a single write by several\n      // seconds when we hit the hard limit, start delaying each\n      // individual write by 1ms to reduce latency variance.  Also,\n      // this delay hands over some CPU to the compaction thread in\n      // case it is sharing the same core as the writer.\n      mutex_.Unlock();\n      env_->SleepForMicroseconds(1000);\n      allow_delay = false;  // Do not delay a single write more than once\n      mutex_.Lock();\n    } else if (!force &&\n               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {\n      // There is room in current memtable\n      break;\n    } else if (imm_ != NULL) {\n      // We have filled up the current memtable, but the previous\n      // one is still being compacted, so we wait.\n      Log(options_.info_log, \"Current memtable full; waiting...\\n\");\n      bg_cv_.Wait();\n    } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {\n      // There are too many level-0 files.\n      Log(options_.info_log, \"Too many L0 files; waiting...\\n\");\n      bg_cv_.Wait();\n    } else {\n      // Attempt to switch to a new memtable and trigger compaction of old\n      assert(versions_->PrevLogNumber() == 0);\n      uint64_t new_log_number = versions_->NewFileNumber();\n      WritableFile* lfile = NULL;\n      s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);\n      if (!s.ok()) {\n        // Avoid chewing through file number space in a tight loop.\n        versions_->ReuseFileNumber(new_log_number);\n        break;\n      }\n      delete log_;\n      delete logfile_;\n      logfile_ = lfile;\n      logfile_number_ = new_log_number;\n      log_ = new log::Writer(lfile);\n      imm_ = mem_;\n      has_imm_.Release_Store(imm_);\n      mem_ = new MemTable(internal_comparator_);\n      mem_->Ref();\n      force = false;   // Do not force another compaction if have room\n      MaybeScheduleCompaction();\n    }\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MaybeScheduleCompaction",
          "args": [],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeScheduleCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "614-630",
          "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_->Ref",
          "args": [],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_imm_.Release_Store",
          "args": [
            "imm_"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "Release_Store",
          "container": "AtomicPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/atomic_pointer.h",
          "lines": "198-205",
          "snippet": "inline void Release_Store(void* v) {\n    __asm__ __volatile__ (\n        \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n        :\n        : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n        : \"memory\"\n        );\n  }",
          "includes": [
            "#include <libkern/OSAtomic.h>",
            "#include <windows.h>",
            "#include <cstdatomic>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libkern/OSAtomic.h>\n#include <windows.h>\n#include <cstdatomic>\n#include <stdint.h>\n\nAtomicPointer {\n  inline void Release_Store(void* v) {\n      __asm__ __volatile__ (\n          \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n          :\n          : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n          : \"memory\"\n          );\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->ReuseFileNumber",
          "args": [
            "new_log_number"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "ReuseFileNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "196-200",
          "snippet": "void ReuseFileNumber(uint64_t file_number) {\n    if (next_file_number_ == file_number + 1) {\n      next_file_number_ = file_number;\n    }\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  void ReuseFileNumber(uint64_t file_number) {\n      if (next_file_number_ == file_number + 1) {\n        next_file_number_ = file_number;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "LogFileName(dbname_, new_log_number)",
            "&lfile"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogFileName",
          "args": [
            "dbname_",
            "new_log_number"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "LogFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "27-30",
          "snippet": "std::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->NewFileNumber",
          "args": [],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "NewFileNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "191-191",
          "snippet": "uint64_t NewFileNumber() { return next_file_number_++; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t NewFileNumber() { return next_file_number_++; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "versions_->PrevLogNumber() == 0"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->PrevLogNumber",
          "args": [],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "PrevLogNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "225-225",
          "snippet": "uint64_t PrevLogNumber() const { return prev_log_number_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t PrevLogNumber() const { return prev_log_number_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_cv_.Wait",
          "args": [],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Too many L0 files; waiting...\\n\""
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "104-106",
          "snippet": "bool DumpLog(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, WriteBatchPrinter);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpLog(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, WriteBatchPrinter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->NumLevelFiles",
          "args": [
            "0"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "NumLevelFiles",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1098-1102",
          "snippet": "int VersionSet::NumLevelFiles(int level) const {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  return current_->files_[level].size();\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int VersionSet::NumLevelFiles(int level) const {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    return current_->files_[level].size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_->ApproximateMemoryUsage",
          "args": [],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "ApproximateMemoryUsage",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "31-31",
          "snippet": "size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->SleepForMicroseconds",
          "args": [
            "1000"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "SleepForMicroseconds",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "795-798",
          "snippet": "void Win32Env::SleepForMicroseconds( int micros )\n{\n    ::Sleep((micros + 999) /1000);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  void Win32Env::SleepForMicroseconds( int micros )\n  {\n      ::Sleep((micros + 999) /1000);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!writers_.empty()"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writers_.empty",
          "args": [],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::MakeRoomForWrite(bool force) {\n    mutex_.AssertHeld();\n    assert(!writers_.empty());\n    bool allow_delay = !force;\n    Status s;\n    while (true) {\n      if (!bg_error_.ok()) {\n        // Yield previous error\n        s = bg_error_;\n        break;\n      } else if (\n          allow_delay &&\n          versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {\n        // We are getting close to hitting a hard limit on the number of\n        // L0 files.  Rather than delaying a single write by several\n        // seconds when we hit the hard limit, start delaying each\n        // individual write by 1ms to reduce latency variance.  Also,\n        // this delay hands over some CPU to the compaction thread in\n        // case it is sharing the same core as the writer.\n        mutex_.Unlock();\n        env_->SleepForMicroseconds(1000);\n        allow_delay = false;  // Do not delay a single write more than once\n        mutex_.Lock();\n      } else if (!force &&\n                 (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {\n        // There is room in current memtable\n        break;\n      } else if (imm_ != NULL) {\n        // We have filled up the current memtable, but the previous\n        // one is still being compacted, so we wait.\n        Log(options_.info_log, \"Current memtable full; waiting...\\n\");\n        bg_cv_.Wait();\n      } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {\n        // There are too many level-0 files.\n        Log(options_.info_log, \"Too many L0 files; waiting...\\n\");\n        bg_cv_.Wait();\n      } else {\n        // Attempt to switch to a new memtable and trigger compaction of old\n        assert(versions_->PrevLogNumber() == 0);\n        uint64_t new_log_number = versions_->NewFileNumber();\n        WritableFile* lfile = NULL;\n        s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);\n        if (!s.ok()) {\n          // Avoid chewing through file number space in a tight loop.\n          versions_->ReuseFileNumber(new_log_number);\n          break;\n        }\n        delete log_;\n        delete logfile_;\n        logfile_ = lfile;\n        logfile_number_ = new_log_number;\n        log_ = new log::Writer(lfile);\n        imm_ = mem_;\n        has_imm_.Release_Store(imm_);\n        mem_ = new MemTable(internal_comparator_);\n        mem_->Ref();\n        force = false;   // Do not force another compaction if have room\n        MaybeScheduleCompaction();\n      }\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "Write",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1162-1233",
    "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writers_.front",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writers_.front",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writers_.empty",
          "args": [],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ready->cv.Signal",
          "args": [],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "Signal",
          "container": "CondVar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "98-108",
          "snippet": "void CondVar::Signal() {\n  wait_mtx_.Lock();\n  if (waiting_ > 0) {\n    --waiting_;\n\n    // finalize handshake\n    ::ReleaseSemaphore(sem1_, 1, NULL);\n    ::WaitForSingleObject(sem2_, INFINITE);\n  }\n  wait_mtx_.Unlock();\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nCondVar {\n  void CondVar::Signal() {\n    wait_mtx_.Lock();\n    if (waiting_ > 0) {\n      --waiting_;\n  \n      // finalize handshake\n      ::ReleaseSemaphore(sem1_, 1, NULL);\n      ::WaitForSingleObject(sem2_, INFINITE);\n    }\n    wait_mtx_.Unlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writers_.pop_front",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writers_.front",
          "args": [],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->SetLastSequence",
          "args": [
            "last_sequence"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "SetLastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "212-215",
          "snippet": "void SetLastSequence(uint64_t s) {\n    assert(s >= last_sequence_);\n    last_sequence_ = s;\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  void SetLastSequence(uint64_t s) {\n      assert(s >= last_sequence_);\n      last_sequence_ = s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp_batch_->Clear",
          "args": [],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecordBackgroundError",
          "args": [
            "status"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "RecordBackgroundError",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "606-612",
          "snippet": "void DBImpl::RecordBackgroundError(const Status& s) {\n  mutex_.AssertHeld();\n  if (bg_error_.ok()) {\n    bg_error_ = s;\n    bg_cv_.SignalAll();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordBackgroundError(const Status& s) {\n    mutex_.AssertHeld();\n    if (bg_error_.ok()) {\n      bg_error_ = s;\n      bg_cv_.SignalAll();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::InsertInto",
          "args": [
            "updates",
            "mem_"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "InsertInto",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "128-134",
          "snippet": "Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                      MemTable* memtable) {\n  MemTableInserter inserter;\n  inserter.sequence_ = WriteBatchInternal::Sequence(b);\n  inserter.mem_ = memtable;\n  return b->Iterate(&inserter);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                        MemTable* memtable) {\n    MemTableInserter inserter;\n    inserter.sequence_ = WriteBatchInternal::Sequence(b);\n    inserter.mem_ = memtable;\n    return b->Iterate(&inserter);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfile_->Sync",
          "args": [],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "Sync",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "47-47",
          "snippet": "virtual Status Sync() { return Status::OK(); }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Sync() { return Status::OK(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_->AddRecord",
          "args": [
            "WriteBatchInternal::Contents(updates)"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "AddRecord",
          "container": "Writer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
          "lines": "27-73",
          "snippet": "Status Writer::AddRecord(const Slice& slice) {\n  const char* ptr = slice.data();\n  size_t left = slice.size();\n\n  // Fragment the record if necessary and emit it.  Note that if slice\n  // is empty, we still want to iterate once to emit a single\n  // zero-length record\n  Status s;\n  bool begin = true;\n  do {\n    const int leftover = kBlockSize - block_offset_;\n    assert(leftover >= 0);\n    if (leftover < kHeaderSize) {\n      // Switch to a new block\n      if (leftover > 0) {\n        // Fill the trailer (literal below relies on kHeaderSize being 7)\n        assert(kHeaderSize == 7);\n        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n      }\n      block_offset_ = 0;\n    }\n\n    // Invariant: we never leave < kHeaderSize bytes in a block.\n    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n\n    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n    const size_t fragment_length = (left < avail) ? left : avail;\n\n    RecordType type;\n    const bool end = (left == fragment_length);\n    if (begin && end) {\n      type = kFullType;\n    } else if (begin) {\n      type = kFirstType;\n    } else if (end) {\n      type = kLastType;\n    } else {\n      type = kMiddleType;\n    }\n\n    s = EmitPhysicalRecord(type, ptr, fragment_length);\n    ptr += fragment_length;\n    left -= fragment_length;\n    begin = false;\n  } while (s.ok() && left > 0);\n  return s;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdint.h>",
            "#include \"db/log_writer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::AddRecord(const Slice& slice) {\n    const char* ptr = slice.data();\n    size_t left = slice.size();\n  \n    // Fragment the record if necessary and emit it.  Note that if slice\n    // is empty, we still want to iterate once to emit a single\n    // zero-length record\n    Status s;\n    bool begin = true;\n    do {\n      const int leftover = kBlockSize - block_offset_;\n      assert(leftover >= 0);\n      if (leftover < kHeaderSize) {\n        // Switch to a new block\n        if (leftover > 0) {\n          // Fill the trailer (literal below relies on kHeaderSize being 7)\n          assert(kHeaderSize == 7);\n          dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n        }\n        block_offset_ = 0;\n      }\n  \n      // Invariant: we never leave < kHeaderSize bytes in a block.\n      assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n  \n      const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n      const size_t fragment_length = (left < avail) ? left : avail;\n  \n      RecordType type;\n      const bool end = (left == fragment_length);\n      if (begin && end) {\n        type = kFullType;\n      } else if (begin) {\n        type = kFirstType;\n      } else if (end) {\n        type = kLastType;\n      } else {\n        type = kMiddleType;\n      }\n  \n      s = EmitPhysicalRecord(type, ptr, fragment_length);\n      ptr += fragment_length;\n      left -= fragment_length;\n      begin = false;\n    } while (s.ok() && left > 0);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Contents",
          "args": [
            "updates"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "Contents",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_internal.h",
          "lines": "31-33",
          "snippet": "static Slice Contents(const WriteBatch* batch) {\n    return Slice(batch->rep_);\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  static Slice Contents(const WriteBatch* batch) {\n      return Slice(batch->rep_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Count",
          "args": [
            "updates"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "Count",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "82-84",
          "snippet": "int WriteBatchInternal::Count(const WriteBatch* b) {\n  return DecodeFixed32(b->rep_.data() + 8);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  int WriteBatchInternal::Count(const WriteBatch* b) {\n    return DecodeFixed32(b->rep_.data() + 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetSequence",
          "args": [
            "updates",
            "last_sequence + 1"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "SetSequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "94-96",
          "snippet": "void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n  EncodeFixed64(&b->rep_[0], seq);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n    EncodeFixed64(&b->rep_[0], seq);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildBatchGroup",
          "args": [
            "&last_writer"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->LastSequence",
          "args": [],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "LastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "209-209",
          "snippet": "uint64_t LastSequence() const { return last_sequence_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t LastSequence() const { return last_sequence_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeRoomForWrite",
          "args": [
            "my_batch == NULL"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "MakeRoomForWrite",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1286-1347",
          "snippet": "Status DBImpl::MakeRoomForWrite(bool force) {\n  mutex_.AssertHeld();\n  assert(!writers_.empty());\n  bool allow_delay = !force;\n  Status s;\n  while (true) {\n    if (!bg_error_.ok()) {\n      // Yield previous error\n      s = bg_error_;\n      break;\n    } else if (\n        allow_delay &&\n        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {\n      // We are getting close to hitting a hard limit on the number of\n      // L0 files.  Rather than delaying a single write by several\n      // seconds when we hit the hard limit, start delaying each\n      // individual write by 1ms to reduce latency variance.  Also,\n      // this delay hands over some CPU to the compaction thread in\n      // case it is sharing the same core as the writer.\n      mutex_.Unlock();\n      env_->SleepForMicroseconds(1000);\n      allow_delay = false;  // Do not delay a single write more than once\n      mutex_.Lock();\n    } else if (!force &&\n               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {\n      // There is room in current memtable\n      break;\n    } else if (imm_ != NULL) {\n      // We have filled up the current memtable, but the previous\n      // one is still being compacted, so we wait.\n      Log(options_.info_log, \"Current memtable full; waiting...\\n\");\n      bg_cv_.Wait();\n    } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {\n      // There are too many level-0 files.\n      Log(options_.info_log, \"Too many L0 files; waiting...\\n\");\n      bg_cv_.Wait();\n    } else {\n      // Attempt to switch to a new memtable and trigger compaction of old\n      assert(versions_->PrevLogNumber() == 0);\n      uint64_t new_log_number = versions_->NewFileNumber();\n      WritableFile* lfile = NULL;\n      s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);\n      if (!s.ok()) {\n        // Avoid chewing through file number space in a tight loop.\n        versions_->ReuseFileNumber(new_log_number);\n        break;\n      }\n      delete log_;\n      delete logfile_;\n      logfile_ = lfile;\n      logfile_number_ = new_log_number;\n      log_ = new log::Writer(lfile);\n      imm_ = mem_;\n      has_imm_.Release_Store(imm_);\n      mem_ = new MemTable(internal_comparator_);\n      mem_->Ref();\n      force = false;   // Do not force another compaction if have room\n      MaybeScheduleCompaction();\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::MakeRoomForWrite(bool force) {\n    mutex_.AssertHeld();\n    assert(!writers_.empty());\n    bool allow_delay = !force;\n    Status s;\n    while (true) {\n      if (!bg_error_.ok()) {\n        // Yield previous error\n        s = bg_error_;\n        break;\n      } else if (\n          allow_delay &&\n          versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {\n        // We are getting close to hitting a hard limit on the number of\n        // L0 files.  Rather than delaying a single write by several\n        // seconds when we hit the hard limit, start delaying each\n        // individual write by 1ms to reduce latency variance.  Also,\n        // this delay hands over some CPU to the compaction thread in\n        // case it is sharing the same core as the writer.\n        mutex_.Unlock();\n        env_->SleepForMicroseconds(1000);\n        allow_delay = false;  // Do not delay a single write more than once\n        mutex_.Lock();\n      } else if (!force &&\n                 (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {\n        // There is room in current memtable\n        break;\n      } else if (imm_ != NULL) {\n        // We have filled up the current memtable, but the previous\n        // one is still being compacted, so we wait.\n        Log(options_.info_log, \"Current memtable full; waiting...\\n\");\n        bg_cv_.Wait();\n      } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {\n        // There are too many level-0 files.\n        Log(options_.info_log, \"Too many L0 files; waiting...\\n\");\n        bg_cv_.Wait();\n      } else {\n        // Attempt to switch to a new memtable and trigger compaction of old\n        assert(versions_->PrevLogNumber() == 0);\n        uint64_t new_log_number = versions_->NewFileNumber();\n        WritableFile* lfile = NULL;\n        s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);\n        if (!s.ok()) {\n          // Avoid chewing through file number space in a tight loop.\n          versions_->ReuseFileNumber(new_log_number);\n          break;\n        }\n        delete log_;\n        delete logfile_;\n        logfile_ = lfile;\n        logfile_number_ = new_log_number;\n        log_ = new log::Writer(lfile);\n        imm_ = mem_;\n        has_imm_.Release_Store(imm_);\n        mem_ = new MemTable(internal_comparator_);\n        mem_->Ref();\n        force = false;   // Do not force another compaction if have room\n        MaybeScheduleCompaction();\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "w.cv.Wait",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writers_.front",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writers_.push_back",
          "args": [
            "&w"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
  },
  {
    "function_name": "Delete",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1158-1160",
    "snippet": "Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {\n  return DB::Delete(options, key);\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DB::Delete",
          "args": [
            "options",
            "key"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1437-1441",
          "snippet": "Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n  WriteBatch batch;\n  batch.Delete(key);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n    WriteBatch batch;\n    batch.Delete(key);\n    return Write(opt, &batch);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {\n    return DB::Delete(options, key);\n  }\n}"
  },
  {
    "function_name": "Put",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1154-1156",
    "snippet": "Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {\n  return DB::Put(o, key, val);\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DB::Put",
          "args": [
            "o",
            "key",
            "val"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {\n    return DB::Put(o, key, val);\n  }\n}"
  },
  {
    "function_name": "ReleaseSnapshot",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1148-1151",
    "snippet": "void DBImpl::ReleaseSnapshot(const Snapshot* s) {\n  MutexLock l(&mutex_);\n  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snapshots_.Delete",
          "args": [
            "reinterpret_cast<const SnapshotImpl*>(s)"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "78-81",
          "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const SnapshotImpl*>",
          "args": [
            "s"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::ReleaseSnapshot(const Snapshot* s) {\n    MutexLock l(&mutex_);\n    snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));\n  }\n}"
  },
  {
    "function_name": "RecordReadSample",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1136-1141",
    "snippet": "void DBImpl::RecordReadSample(Slice key) {\n  MutexLock l(&mutex_);\n  if (versions_->current()->RecordReadSample(key)) {\n    MaybeScheduleCompaction();\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MaybeScheduleCompaction",
          "args": [],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeScheduleCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "614-630",
          "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [
            "key"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordReadSample(Slice key) {\n    MutexLock l(&mutex_);\n    if (versions_->current()->RecordReadSample(key)) {\n      MaybeScheduleCompaction();\n    }\n  }\n}"
  },
  {
    "function_name": "Get",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1077-1122",
    "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current->Unref",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaybeScheduleCompaction",
          "args": [],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeScheduleCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "614-630",
          "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->UpdateStats",
          "args": [
            "stats"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateStats",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "436-447",
          "snippet": "bool Version::UpdateStats(const GetStats& stats) {\n  FileMetaData* f = stats.seek_file;\n  if (f != NULL) {\n    f->allowed_seeks--;\n    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n      file_to_compact_ = f;\n      file_to_compact_level_ = stats.seek_file_level;\n      return true;\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::UpdateStats(const GetStats& stats) {\n    FileMetaData* f = stats.seek_file;\n    if (f != NULL) {\n      f->allowed_seeks--;\n      if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n        file_to_compact_ = f;\n        file_to_compact_level_ = stats.seek_file_level;\n        return true;\n      }\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->Get",
          "args": [
            "options",
            "lkey",
            "value",
            "&stats"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "337-434",
          "snippet": "Status Version::Get(const ReadOptions& options,\n                    const LookupKey& k,\n                    std::string* value,\n                    GetStats* stats) {\n  Slice ikey = k.internal_key();\n  Slice user_key = k.user_key();\n  const Comparator* ucmp = vset_->icmp_.user_comparator();\n  Status s;\n\n  stats->seek_file = NULL;\n  stats->seek_file_level = -1;\n  FileMetaData* last_file_read = NULL;\n  int last_file_read_level = -1;\n\n  // We can search level-by-level since entries never hop across\n  // levels.  Therefore we are guaranteed that if we find data\n  // in an smaller level, later levels are irrelevant.\n  std::vector<FileMetaData*> tmp;\n  FileMetaData* tmp2;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    size_t num_files = files_[level].size();\n    if (num_files == 0) continue;\n\n    // Get the list of files to search in this level\n    FileMetaData* const* files = &files_[level][0];\n    if (level == 0) {\n      // Level-0 files may overlap each other.  Find all files that\n      // overlap user_key and process them in order from newest to oldest.\n      tmp.reserve(num_files);\n      for (uint32_t i = 0; i < num_files; i++) {\n        FileMetaData* f = files[i];\n        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n          tmp.push_back(f);\n        }\n      }\n      if (tmp.empty()) continue;\n\n      std::sort(tmp.begin(), tmp.end(), NewestFirst);\n      files = &tmp[0];\n      num_files = tmp.size();\n    } else {\n      // Binary search to find earliest index whose largest key >= ikey.\n      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);\n      if (index >= num_files) {\n        files = NULL;\n        num_files = 0;\n      } else {\n        tmp2 = files[index];\n        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {\n          // All of \"tmp2\" is past any data for user_key\n          files = NULL;\n          num_files = 0;\n        } else {\n          files = &tmp2;\n          num_files = 1;\n        }\n      }\n    }\n\n    for (uint32_t i = 0; i < num_files; ++i) {\n      if (last_file_read != NULL && stats->seek_file == NULL) {\n        // We have had more than one seek for this read.  Charge the 1st file.\n        stats->seek_file = last_file_read;\n        stats->seek_file_level = last_file_read_level;\n      }\n\n      FileMetaData* f = files[i];\n      last_file_read = f;\n      last_file_read_level = level;\n\n      Saver saver;\n      saver.state = kNotFound;\n      saver.ucmp = ucmp;\n      saver.user_key = user_key;\n      saver.value = value;\n      s = vset_->table_cache_->Get(options, f->number, f->file_size,\n                                   ikey, &saver, SaveValue);\n      if (!s.ok()) {\n        return s;\n      }\n      switch (saver.state) {\n        case kNotFound:\n          break;      // Keep searching in other files\n        case kFound:\n          return s;\n        case kDeleted:\n          s = Status::NotFound(Slice());  // Use empty error message for speed\n          return s;\n        case kCorrupt:\n          s = Status::Corruption(\"corrupted key for \", user_key);\n          return s;\n      }\n    }\n  }\n\n  return Status::NotFound(Slice());  // Use an empty error message for speed\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  Status Version::Get(const ReadOptions& options,\n                      const LookupKey& k,\n                      std::string* value,\n                      GetStats* stats) {\n    Slice ikey = k.internal_key();\n    Slice user_key = k.user_key();\n    const Comparator* ucmp = vset_->icmp_.user_comparator();\n    Status s;\n  \n    stats->seek_file = NULL;\n    stats->seek_file_level = -1;\n    FileMetaData* last_file_read = NULL;\n    int last_file_read_level = -1;\n  \n    // We can search level-by-level since entries never hop across\n    // levels.  Therefore we are guaranteed that if we find data\n    // in an smaller level, later levels are irrelevant.\n    std::vector<FileMetaData*> tmp;\n    FileMetaData* tmp2;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      size_t num_files = files_[level].size();\n      if (num_files == 0) continue;\n  \n      // Get the list of files to search in this level\n      FileMetaData* const* files = &files_[level][0];\n      if (level == 0) {\n        // Level-0 files may overlap each other.  Find all files that\n        // overlap user_key and process them in order from newest to oldest.\n        tmp.reserve(num_files);\n        for (uint32_t i = 0; i < num_files; i++) {\n          FileMetaData* f = files[i];\n          if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n              ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n            tmp.push_back(f);\n          }\n        }\n        if (tmp.empty()) continue;\n  \n        std::sort(tmp.begin(), tmp.end(), NewestFirst);\n        files = &tmp[0];\n        num_files = tmp.size();\n      } else {\n        // Binary search to find earliest index whose largest key >= ikey.\n        uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);\n        if (index >= num_files) {\n          files = NULL;\n          num_files = 0;\n        } else {\n          tmp2 = files[index];\n          if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {\n            // All of \"tmp2\" is past any data for user_key\n            files = NULL;\n            num_files = 0;\n          } else {\n            files = &tmp2;\n            num_files = 1;\n          }\n        }\n      }\n  \n      for (uint32_t i = 0; i < num_files; ++i) {\n        if (last_file_read != NULL && stats->seek_file == NULL) {\n          // We have had more than one seek for this read.  Charge the 1st file.\n          stats->seek_file = last_file_read;\n          stats->seek_file_level = last_file_read_level;\n        }\n  \n        FileMetaData* f = files[i];\n        last_file_read = f;\n        last_file_read_level = level;\n  \n        Saver saver;\n        saver.state = kNotFound;\n        saver.ucmp = ucmp;\n        saver.user_key = user_key;\n        saver.value = value;\n        s = vset_->table_cache_->Get(options, f->number, f->file_size,\n                                     ikey, &saver, SaveValue);\n        if (!s.ok()) {\n          return s;\n        }\n        switch (saver.state) {\n          case kNotFound:\n            break;      // Keep searching in other files\n          case kFound:\n            return s;\n          case kDeleted:\n            s = Status::NotFound(Slice());  // Use empty error message for speed\n            return s;\n          case kCorrupt:\n            s = Status::Corruption(\"corrupted key for \", user_key);\n            return s;\n        }\n      }\n    }\n  \n    return Status::NotFound(Slice());  // Use an empty error message for speed\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "imm->Get",
          "args": [
            "lkey",
            "value",
            "&s"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current->Ref",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->LastSequence",
          "args": [],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "LastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "209-209",
          "snippet": "uint64_t LastSequence() const { return last_sequence_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t LastSequence() const { return last_sequence_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const SnapshotImpl*>",
          "args": [
            "options.snapshot"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
  },
  {
    "function_name": "TEST_MaxNextLevelOverlappingBytes",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1072-1075",
    "snippet": "int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {\n  MutexLock l(&mutex_);\n  return versions_->MaxNextLevelOverlappingBytes();\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "versions_->MaxNextLevelOverlappingBytes",
          "args": [],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "MaxNextLevelOverlappingBytes",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1170-1185",
          "snippet": "int64_t VersionSet::MaxNextLevelOverlappingBytes() {\n  int64_t result = 0;\n  std::vector<FileMetaData*> overlaps;\n  for (int level = 1; level < config::kNumLevels - 1; level++) {\n    for (size_t i = 0; i < current_->files_[level].size(); i++) {\n      const FileMetaData* f = current_->files_[level][i];\n      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,\n                                     &overlaps);\n      const int64_t sum = TotalFileSize(overlaps);\n      if (sum > result) {\n        result = sum;\n      }\n    }\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int64_t VersionSet::MaxNextLevelOverlappingBytes() {\n    int64_t result = 0;\n    std::vector<FileMetaData*> overlaps;\n    for (int level = 1; level < config::kNumLevels - 1; level++) {\n      for (size_t i = 0; i < current_->files_[level].size(); i++) {\n        const FileMetaData* f = current_->files_[level][i];\n        current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,\n                                       &overlaps);\n        const int64_t sum = TotalFileSize(overlaps);\n        if (sum > result) {\n          result = sum;\n        }\n      }\n    }\n    return result;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {\n    MutexLock l(&mutex_);\n    return versions_->MaxNextLevelOverlappingBytes();\n  }\n}"
  },
  {
    "function_name": "CleanupIteratorState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "1024-1032",
    "snippet": "static void CleanupIteratorState(void* arg1, void* arg2) {\n  IterState* state = reinterpret_cast<IterState*>(arg1);\n  state->mu->Lock();\n  state->mem->Unref();\n  if (state->imm != NULL) state->imm->Unref();\n  state->version->Unref();\n  state->mu->Unlock();\n  delete state;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "state->mu->Unlock",
          "args": [],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state->version->Unref",
          "args": [],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state->mu->Lock",
          "args": [],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<IterState*>",
          "args": [
            "arg1"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nstatic void CleanupIteratorState(void* arg1, void* arg2) {\n  IterState* state = reinterpret_cast<IterState*>(arg1);\n  state->mu->Lock();\n  state->mem->Unref();\n  if (state->imm != NULL) state->imm->Unref();\n  state->version->Unref();\n  state->mu->Unlock();\n  delete state;\n}"
  },
  {
    "function_name": "DoCompactionWork",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "855-1014",
    "snippet": "Status DBImpl::DoCompactionWork(CompactionState* compact) {\n  const uint64_t start_micros = env_->NowMicros();\n  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions\n\n  Log(options_.info_log,  \"Compacting %d@%d + %d@%d files\",\n      compact->compaction->num_input_files(0),\n      compact->compaction->level(),\n      compact->compaction->num_input_files(1),\n      compact->compaction->level() + 1);\n\n  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);\n  assert(compact->builder == NULL);\n  assert(compact->outfile == NULL);\n  if (snapshots_.empty()) {\n    compact->smallest_snapshot = versions_->LastSequence();\n  } else {\n    compact->smallest_snapshot = snapshots_.oldest()->number_;\n  }\n\n  // Release mutex while we're actually doing the compaction work\n  mutex_.Unlock();\n\n  Iterator* input = versions_->MakeInputIterator(compact->compaction);\n  input->SeekToFirst();\n  Status status;\n  ParsedInternalKey ikey;\n  std::string current_user_key;\n  bool has_current_user_key = false;\n  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;\n  for (; input->Valid() && !shutting_down_.Acquire_Load(); ) {\n    // Prioritize immutable compaction work\n    if (has_imm_.NoBarrier_Load() != NULL) {\n      const uint64_t imm_start = env_->NowMicros();\n      mutex_.Lock();\n      if (imm_ != NULL) {\n        CompactMemTable();\n        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary\n      }\n      mutex_.Unlock();\n      imm_micros += (env_->NowMicros() - imm_start);\n    }\n\n    Slice key = input->key();\n    if (compact->compaction->ShouldStopBefore(key) &&\n        compact->builder != NULL) {\n      status = FinishCompactionOutputFile(compact, input);\n      if (!status.ok()) {\n        break;\n      }\n    }\n\n    // Handle key/value, add to state, etc.\n    bool drop = false;\n    if (!ParseInternalKey(key, &ikey)) {\n      // Do not hide error keys\n      current_user_key.clear();\n      has_current_user_key = false;\n      last_sequence_for_key = kMaxSequenceNumber;\n    } else {\n      if (!has_current_user_key ||\n          user_comparator()->Compare(ikey.user_key,\n                                     Slice(current_user_key)) != 0) {\n        // First occurrence of this user key\n        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());\n        has_current_user_key = true;\n        last_sequence_for_key = kMaxSequenceNumber;\n      }\n\n      if (last_sequence_for_key <= compact->smallest_snapshot) {\n        // Hidden by an newer entry for same user key\n        drop = true;    // (A)\n      } else if (ikey.type == kTypeDeletion &&\n                 ikey.sequence <= compact->smallest_snapshot &&\n                 compact->compaction->IsBaseLevelForKey(ikey.user_key)) {\n        // For this user key:\n        // (1) there is no data in higher levels\n        // (2) data in lower levels will have larger sequence numbers\n        // (3) data in layers that are being compacted here and have\n        //     smaller sequence numbers will be dropped in the next\n        //     few iterations of this loop (by rule (A) above).\n        // Therefore this deletion marker is obsolete and can be dropped.\n        drop = true;\n      }\n\n      last_sequence_for_key = ikey.sequence;\n    }\n#if 0\n    Log(options_.info_log,\n        \"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, \"\n        \"%d smallest_snapshot: %d\",\n        ikey.user_key.ToString().c_str(),\n        (int)ikey.sequence, ikey.type, kTypeValue, drop,\n        compact->compaction->IsBaseLevelForKey(ikey.user_key),\n        (int)last_sequence_for_key, (int)compact->smallest_snapshot);\n#endif\n\n    if (!drop) {\n      // Open output file if necessary\n      if (compact->builder == NULL) {\n        status = OpenCompactionOutputFile(compact);\n        if (!status.ok()) {\n          break;\n        }\n      }\n      if (compact->builder->NumEntries() == 0) {\n        compact->current_output()->smallest.DecodeFrom(key);\n      }\n      compact->current_output()->largest.DecodeFrom(key);\n      compact->builder->Add(key, input->value());\n\n      // Close output file if it is big enough\n      if (compact->builder->FileSize() >=\n          compact->compaction->MaxOutputFileSize()) {\n        status = FinishCompactionOutputFile(compact, input);\n        if (!status.ok()) {\n          break;\n        }\n      }\n    }\n\n    input->Next();\n  }\n\n  if (status.ok() && shutting_down_.Acquire_Load()) {\n    status = Status::IOError(\"Deleting DB during compaction\");\n  }\n  if (status.ok() && compact->builder != NULL) {\n    status = FinishCompactionOutputFile(compact, input);\n  }\n  if (status.ok()) {\n    status = input->status();\n  }\n  delete input;\n  input = NULL;\n\n  CompactionStats stats;\n  stats.micros = env_->NowMicros() - start_micros - imm_micros;\n  for (int which = 0; which < 2; which++) {\n    for (int i = 0; i < compact->compaction->num_input_files(which); i++) {\n      stats.bytes_read += compact->compaction->input(which, i)->file_size;\n    }\n  }\n  for (size_t i = 0; i < compact->outputs.size(); i++) {\n    stats.bytes_written += compact->outputs[i].file_size;\n  }\n\n  mutex_.Lock();\n  stats_[compact->compaction->level() + 1].Add(stats);\n\n  if (status.ok()) {\n    status = InstallCompactionResults(compact);\n  }\n  if (!status.ok()) {\n    RecordBackgroundError(status);\n  }\n  VersionSet::LevelSummaryStorage tmp;\n  Log(options_.info_log,\n      \"compacted to: %s\", versions_->LevelSummary(&tmp));\n  return status;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"compacted to: %s\"",
            "versions_->LevelSummary(&tmp)"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverLogFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "362-455",
          "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::RecoverLogFile(uint64_t log_number,\n                                VersionEdit* edit,\n                                SequenceNumber* max_sequence) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      const char* fname;\n      Status* status;  // NULL if options_.paranoid_checks==false\n      virtual void Corruption(size_t bytes, const Status& s) {\n        Log(info_log, \"%s%s: dropping %d bytes; %s\",\n            (this->status == NULL ? \"(ignoring error) \" : \"\"),\n            fname, static_cast<int>(bytes), s.ToString().c_str());\n        if (this->status != NULL && this->status->ok()) *this->status = s;\n      }\n    };\n  \n    mutex_.AssertHeld();\n  \n    // Open the log file\n    std::string fname = LogFileName(dbname_, log_number);\n    SequentialFile* file;\n    Status status = env_->NewSequentialFile(fname, &file);\n    if (!status.ok()) {\n      MaybeIgnoreError(&status);\n      return status;\n    }\n  \n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.fname = fname.c_str();\n    reporter.status = (options_.paranoid_checks ? &status : NULL);\n    // We intentially make log::Reader do checksumming even if\n    // paranoid_checks==false so that corruptions cause entire commits\n    // to be skipped instead of propagating bad information (like overly\n    // large sequence numbers).\n    log::Reader reader(file, &reporter, true/*checksum*/,\n                       0/*initial_offset*/);\n    Log(options_.info_log, \"Recovering log #%llu\",\n        (unsigned long long) log_number);\n  \n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = NULL;\n    while (reader.ReadRecord(&record, &scratch) &&\n           status.ok()) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n  \n      if (mem == NULL) {\n        mem = new MemTable(internal_comparator_);\n        mem->Ref();\n      }\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      MaybeIgnoreError(&status);\n      if (!status.ok()) {\n        break;\n      }\n      const SequenceNumber last_seq =\n          WriteBatchInternal::Sequence(&batch) +\n          WriteBatchInternal::Count(&batch) - 1;\n      if (last_seq > *max_sequence) {\n        *max_sequence = last_seq;\n      }\n  \n      if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n        status = WriteLevel0Table(mem, edit, NULL);\n        if (!status.ok()) {\n          // Reflect errors immediately so that conditions like full\n          // file-systems cause the DB::Open() to fail.\n          break;\n        }\n        mem->Unref();\n        mem = NULL;\n      }\n    }\n  \n    if (status.ok() && mem != NULL) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      // Reflect errors immediately so that conditions like full\n      // file-systems cause the DB::Open() to fail.\n    }\n  \n    if (mem != NULL) mem->Unref();\n    delete file;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->LevelSummary",
          "args": [
            "&tmp"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RecordBackgroundError",
          "args": [
            "status"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "RecordBackgroundError",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "606-612",
          "snippet": "void DBImpl::RecordBackgroundError(const Status& s) {\n  mutex_.AssertHeld();\n  if (bg_error_.ok()) {\n    bg_error_ = s;\n    bg_cv_.SignalAll();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordBackgroundError(const Status& s) {\n    mutex_.AssertHeld();\n    if (bg_error_.ok()) {\n      bg_error_ = s;\n      bg_cv_.SignalAll();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InstallCompactionResults",
          "args": [
            "compact"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "InstallCompactionResults",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "834-853",
          "snippet": "Status DBImpl::InstallCompactionResults(CompactionState* compact) {\n  mutex_.AssertHeld();\n  Log(options_.info_log,  \"Compacted %d@%d + %d@%d files => %lld bytes\",\n      compact->compaction->num_input_files(0),\n      compact->compaction->level(),\n      compact->compaction->num_input_files(1),\n      compact->compaction->level() + 1,\n      static_cast<long long>(compact->total_bytes));\n\n  // Add compaction outputs\n  compact->compaction->AddInputDeletions(compact->compaction->edit());\n  const int level = compact->compaction->level();\n  for (size_t i = 0; i < compact->outputs.size(); i++) {\n    const CompactionState::Output& out = compact->outputs[i];\n    compact->compaction->edit()->AddFile(\n        level + 1,\n        out.number, out.file_size, out.smallest, out.largest);\n  }\n  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::InstallCompactionResults(CompactionState* compact) {\n    mutex_.AssertHeld();\n    Log(options_.info_log,  \"Compacted %d@%d + %d@%d files => %lld bytes\",\n        compact->compaction->num_input_files(0),\n        compact->compaction->level(),\n        compact->compaction->num_input_files(1),\n        compact->compaction->level() + 1,\n        static_cast<long long>(compact->total_bytes));\n  \n    // Add compaction outputs\n    compact->compaction->AddInputDeletions(compact->compaction->edit());\n    const int level = compact->compaction->level();\n    for (size_t i = 0; i < compact->outputs.size(); i++) {\n      const CompactionState::Output& out = compact->outputs[i];\n      compact->compaction->edit()->AddFile(\n          level + 1,\n          out.number, out.file_size, out.smallest, out.largest);\n    }\n    return versions_->LogAndApply(compact->compaction->edit(), &mutex_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stats_[compact->compaction->level",
          "args": [
            "stats"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->compaction->level",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "level",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "328-328",
          "snippet": "int level() const { return level_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int level() const { return level_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->outputs.size",
          "args": [],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->input",
          "args": [
            "which",
            "i"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->compaction->num_input_files",
          "args": [
            "which"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "num_input_files",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "335-335",
          "snippet": "int num_input_files(int which) const { return inputs_[which].size(); }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int num_input_files(int which) const { return inputs_[which].size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NowMicros",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "NowMicros",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "901-907",
          "snippet": "uint64_t Win32Env::NowMicros()\n{\n#ifndef USE_VISTA_API\n#define GetTickCount64 GetTickCount\n#endif\n    return (uint64_t)(GetTickCount64()*1000);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [
            "#define GetTickCount64 GetTickCount"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\n#define GetTickCount64 GetTickCount\n\nWin32Env {\n  uint64_t Win32Env::NowMicros()\n  {\n  #ifndef USE_VISTA_API\n  #define GetTickCount64 GetTickCount\n  #endif\n      return (uint64_t)(GetTickCount64()*1000);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->status",
          "args": [],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "74-80",
          "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Status status() const {\n      if (status_.ok()) {\n        return iter_->status();\n      } else {\n        return status_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FinishCompactionOutputFile",
          "args": [
            "compact",
            "input"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "FinishCompactionOutputFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "782-831",
          "snippet": "Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,\n                                          Iterator* input) {\n  assert(compact != NULL);\n  assert(compact->outfile != NULL);\n  assert(compact->builder != NULL);\n\n  const uint64_t output_number = compact->current_output()->number;\n  assert(output_number != 0);\n\n  // Check for iterator errors\n  Status s = input->status();\n  const uint64_t current_entries = compact->builder->NumEntries();\n  if (s.ok()) {\n    s = compact->builder->Finish();\n  } else {\n    compact->builder->Abandon();\n  }\n  const uint64_t current_bytes = compact->builder->FileSize();\n  compact->current_output()->file_size = current_bytes;\n  compact->total_bytes += current_bytes;\n  delete compact->builder;\n  compact->builder = NULL;\n\n  // Finish and check for file errors\n  if (s.ok()) {\n    s = compact->outfile->Sync();\n  }\n  if (s.ok()) {\n    s = compact->outfile->Close();\n  }\n  delete compact->outfile;\n  compact->outfile = NULL;\n\n  if (s.ok() && current_entries > 0) {\n    // Verify that the table is usable\n    Iterator* iter = table_cache_->NewIterator(ReadOptions(),\n                                               output_number,\n                                               current_bytes);\n    s = iter->status();\n    delete iter;\n    if (s.ok()) {\n      Log(options_.info_log,\n          \"Generated table #%llu: %lld keys, %lld bytes\",\n          (unsigned long long) output_number,\n          (unsigned long long) current_entries,\n          (unsigned long long) current_bytes);\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,\n                                            Iterator* input) {\n    assert(compact != NULL);\n    assert(compact->outfile != NULL);\n    assert(compact->builder != NULL);\n  \n    const uint64_t output_number = compact->current_output()->number;\n    assert(output_number != 0);\n  \n    // Check for iterator errors\n    Status s = input->status();\n    const uint64_t current_entries = compact->builder->NumEntries();\n    if (s.ok()) {\n      s = compact->builder->Finish();\n    } else {\n      compact->builder->Abandon();\n    }\n    const uint64_t current_bytes = compact->builder->FileSize();\n    compact->current_output()->file_size = current_bytes;\n    compact->total_bytes += current_bytes;\n    delete compact->builder;\n    compact->builder = NULL;\n  \n    // Finish and check for file errors\n    if (s.ok()) {\n      s = compact->outfile->Sync();\n    }\n    if (s.ok()) {\n      s = compact->outfile->Close();\n    }\n    delete compact->outfile;\n    compact->outfile = NULL;\n  \n    if (s.ok() && current_entries > 0) {\n      // Verify that the table is usable\n      Iterator* iter = table_cache_->NewIterator(ReadOptions(),\n                                                 output_number,\n                                                 current_bytes);\n      s = iter->status();\n      delete iter;\n      if (s.ok()) {\n        Log(options_.info_log,\n            \"Generated table #%llu: %lld keys, %lld bytes\",\n            (unsigned long long) output_number,\n            (unsigned long long) current_entries,\n            (unsigned long long) current_bytes);\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::IOError",
          "args": [
            "\"Deleting DB during compaction\""
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "IOError",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "47-49",
          "snippet": "static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kIOError, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kIOError, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input->Next",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->MaxOutputFileSize",
          "args": [],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "MaxOutputFileSize",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "341-341",
          "snippet": "uint64_t MaxOutputFileSize() const { return max_output_file_size_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->builder->FileSize",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "FileSize",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "266-268",
          "snippet": "uint64_t TableBuilder::FileSize() const {\n  return rep_->offset;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  uint64_t TableBuilder::FileSize() const {\n    return rep_->offset;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->builder->Add",
          "args": [
            "key",
            "input->value()"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "FindFileTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set_test.cc",
          "lines": "25-33",
          "snippet": "void Add(const char* smallest, const char* largest,\n           SequenceNumber smallest_seq = 100,\n           SequenceNumber largest_seq = 100) {\n    FileMetaData* f = new FileMetaData;\n    f->number = files_.size() + 1;\n    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n    f->largest = InternalKey(largest, largest_seq, kTypeValue);\n    files_.push_back(f);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n\nFindFileTest {\n  void Add(const char* smallest, const char* largest,\n             SequenceNumber smallest_seq = 100,\n             SequenceNumber largest_seq = 100) {\n      FileMetaData* f = new FileMetaData;\n      f->number = files_.size() + 1;\n      f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n      f->largest = InternalKey(largest, largest_seq, kTypeValue);\n      files_.push_back(f);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->value",
          "args": [],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->current_output",
          "args": [
            "key"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->current_output",
          "args": [],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->current_output",
          "args": [
            "key"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->current_output",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->builder->NumEntries",
          "args": [],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "NumEntries",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "262-264",
          "snippet": "uint64_t TableBuilder::NumEntries() const {\n  return rep_->num_entries;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  uint64_t TableBuilder::NumEntries() const {\n    return rep_->num_entries;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenCompactionOutputFile",
          "args": [
            "compact"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "OpenCompactionOutputFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "757-780",
          "snippet": "Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {\n  assert(compact != NULL);\n  assert(compact->builder == NULL);\n  uint64_t file_number;\n  {\n    mutex_.Lock();\n    file_number = versions_->NewFileNumber();\n    pending_outputs_.insert(file_number);\n    CompactionState::Output out;\n    out.number = file_number;\n    out.smallest.Clear();\n    out.largest.Clear();\n    compact->outputs.push_back(out);\n    mutex_.Unlock();\n  }\n\n  // Make the output file\n  std::string fname = TableFileName(dbname_, file_number);\n  Status s = env_->NewWritableFile(fname, &compact->outfile);\n  if (s.ok()) {\n    compact->builder = new TableBuilder(options_, compact->outfile);\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {\n    assert(compact != NULL);\n    assert(compact->builder == NULL);\n    uint64_t file_number;\n    {\n      mutex_.Lock();\n      file_number = versions_->NewFileNumber();\n      pending_outputs_.insert(file_number);\n      CompactionState::Output out;\n      out.number = file_number;\n      out.smallest.Clear();\n      out.largest.Clear();\n      compact->outputs.push_back(out);\n      mutex_.Unlock();\n    }\n  \n    // Make the output file\n    std::string fname = TableFileName(dbname_, file_number);\n    Status s = env_->NewWritableFile(fname, &compact->outfile);\n    if (s.ok()) {\n      compact->builder = new TableBuilder(options_, compact->outfile);\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, \"\n        \"%d smallest_snapshot: %d\"",
            "ikey.user_key.ToString().c_str()",
            "(int)ikey.sequence",
            "ikey.type",
            "kTypeValue",
            "drop",
            "compact->compaction->IsBaseLevelForKey(ikey.user_key)",
            "(int)last_sequence_for_key",
            "(int)compact->smallest_snapshot"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->compaction->IsBaseLevelForKey",
          "args": [
            "ikey.user_key"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "IsBaseLevelForKey",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1448-1467",
          "snippet": "bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n  // Maybe use binary search to find right entry instead of linear search?\n  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();\n  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {\n    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];\n    for (; level_ptrs_[lvl] < files.size(); ) {\n      FileMetaData* f = files[level_ptrs_[lvl]];\n      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {\n        // We've advanced far enough\n        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {\n          // Key falls in this file's range, so definitely not base level\n          return false;\n        }\n        break;\n      }\n      level_ptrs_[lvl]++;\n    }\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n    // Maybe use binary search to find right entry instead of linear search?\n    const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();\n    for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {\n      const std::vector<FileMetaData*>& files = input_version_->files_[lvl];\n      for (; level_ptrs_[lvl] < files.size(); ) {\n        FileMetaData* f = files[level_ptrs_[lvl]];\n        if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {\n          // We've advanced far enough\n          if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {\n            // Key falls in this file's range, so definitely not base level\n            return false;\n          }\n          break;\n        }\n        level_ptrs_[lvl]++;\n      }\n    }\n    return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ikey.user_key.ToString",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_key.assign",
          "args": [
            "ikey.user_key.data()",
            "ikey.user_key.size()"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikey.user_key.data",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_comparator",
          "args": [
            "ikey.user_key",
            "Slice(current_user_key)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "current_user_key"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_comparator",
          "args": [],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_key.clear",
          "args": [],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "key",
            "&ikey"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->ShouldStopBefore",
          "args": [
            "key"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ShouldStopBefore",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1469-1489",
          "snippet": "bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n  // Scan to find earliest grandparent file that contains key.\n  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n  while (grandparent_index_ < grandparents_.size() &&\n      icmp->Compare(internal_key,\n                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n    if (seen_key_) {\n      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;\n    }\n    grandparent_index_++;\n  }\n  seen_key_ = true;\n\n  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n    // Too much overlap for current output; start new output\n    overlapped_bytes_ = 0;\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n    // Scan to find earliest grandparent file that contains key.\n    const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n    while (grandparent_index_ < grandparents_.size() &&\n        icmp->Compare(internal_key,\n                      grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n      if (seen_key_) {\n        overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;\n      }\n      grandparent_index_++;\n    }\n    seen_key_ = true;\n  \n    if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n      // Too much overlap for current output; start new output\n      overlapped_bytes_ = 0;\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->key",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_cv_.SignalAll",
          "args": [],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "SignalAll",
          "container": "CondVar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "110-118",
          "snippet": "void CondVar::SignalAll() {\n  wait_mtx_.Lock();\n  ::ReleaseSemaphore(sem1_, waiting_, NULL);\n  while(waiting_ > 0) {\n    --waiting_;\n    ::WaitForSingleObject(sem2_, INFINITE);\n  }\n  wait_mtx_.Unlock();\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nCondVar {\n  void CondVar::SignalAll() {\n    wait_mtx_.Lock();\n    ::ReleaseSemaphore(sem1_, waiting_, NULL);\n    while(waiting_ > 0) {\n      --waiting_;\n      ::WaitForSingleObject(sem2_, INFINITE);\n    }\n    wait_mtx_.Unlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CompactMemTable",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_imm_.NoBarrier_Load",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input->Valid",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->SeekToFirst",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->MakeInputIterator",
          "args": [
            "compact->compaction"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshots_.oldest",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->LastSequence",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "LastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "209-209",
          "snippet": "uint64_t LastSequence() const { return last_sequence_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t LastSequence() const { return last_sequence_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshots_.empty",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact->outfile == NULL"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact->builder == NULL"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "versions_->NumLevelFiles(compact->compaction->level()) > 0"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->NumLevelFiles",
          "args": [
            "compact->compaction->level()"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "NumLevelFiles",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1098-1102",
          "snippet": "int VersionSet::NumLevelFiles(int level) const {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  return current_->files_[level].size();\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int VersionSet::NumLevelFiles(int level) const {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    return current_->files_[level].size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Compacting %d@%d + %d@%d files\"",
            "compact->compaction->num_input_files(0)",
            "compact->compaction->level()",
            "compact->compaction->num_input_files(1)",
            "compact->compaction->level() + 1"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::DoCompactionWork(CompactionState* compact) {\n    const uint64_t start_micros = env_->NowMicros();\n    int64_t imm_micros = 0;  // Micros spent doing imm_ compactions\n  \n    Log(options_.info_log,  \"Compacting %d@%d + %d@%d files\",\n        compact->compaction->num_input_files(0),\n        compact->compaction->level(),\n        compact->compaction->num_input_files(1),\n        compact->compaction->level() + 1);\n  \n    assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);\n    assert(compact->builder == NULL);\n    assert(compact->outfile == NULL);\n    if (snapshots_.empty()) {\n      compact->smallest_snapshot = versions_->LastSequence();\n    } else {\n      compact->smallest_snapshot = snapshots_.oldest()->number_;\n    }\n  \n    // Release mutex while we're actually doing the compaction work\n    mutex_.Unlock();\n  \n    Iterator* input = versions_->MakeInputIterator(compact->compaction);\n    input->SeekToFirst();\n    Status status;\n    ParsedInternalKey ikey;\n    std::string current_user_key;\n    bool has_current_user_key = false;\n    SequenceNumber last_sequence_for_key = kMaxSequenceNumber;\n    for (; input->Valid() && !shutting_down_.Acquire_Load(); ) {\n      // Prioritize immutable compaction work\n      if (has_imm_.NoBarrier_Load() != NULL) {\n        const uint64_t imm_start = env_->NowMicros();\n        mutex_.Lock();\n        if (imm_ != NULL) {\n          CompactMemTable();\n          bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary\n        }\n        mutex_.Unlock();\n        imm_micros += (env_->NowMicros() - imm_start);\n      }\n  \n      Slice key = input->key();\n      if (compact->compaction->ShouldStopBefore(key) &&\n          compact->builder != NULL) {\n        status = FinishCompactionOutputFile(compact, input);\n        if (!status.ok()) {\n          break;\n        }\n      }\n  \n      // Handle key/value, add to state, etc.\n      bool drop = false;\n      if (!ParseInternalKey(key, &ikey)) {\n        // Do not hide error keys\n        current_user_key.clear();\n        has_current_user_key = false;\n        last_sequence_for_key = kMaxSequenceNumber;\n      } else {\n        if (!has_current_user_key ||\n            user_comparator()->Compare(ikey.user_key,\n                                       Slice(current_user_key)) != 0) {\n          // First occurrence of this user key\n          current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());\n          has_current_user_key = true;\n          last_sequence_for_key = kMaxSequenceNumber;\n        }\n  \n        if (last_sequence_for_key <= compact->smallest_snapshot) {\n          // Hidden by an newer entry for same user key\n          drop = true;    // (A)\n        } else if (ikey.type == kTypeDeletion &&\n                   ikey.sequence <= compact->smallest_snapshot &&\n                   compact->compaction->IsBaseLevelForKey(ikey.user_key)) {\n          // For this user key:\n          // (1) there is no data in higher levels\n          // (2) data in lower levels will have larger sequence numbers\n          // (3) data in layers that are being compacted here and have\n          //     smaller sequence numbers will be dropped in the next\n          //     few iterations of this loop (by rule (A) above).\n          // Therefore this deletion marker is obsolete and can be dropped.\n          drop = true;\n        }\n  \n        last_sequence_for_key = ikey.sequence;\n      }\n  #if 0\n      Log(options_.info_log,\n          \"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, \"\n          \"%d smallest_snapshot: %d\",\n          ikey.user_key.ToString().c_str(),\n          (int)ikey.sequence, ikey.type, kTypeValue, drop,\n          compact->compaction->IsBaseLevelForKey(ikey.user_key),\n          (int)last_sequence_for_key, (int)compact->smallest_snapshot);\n  #endif\n  \n      if (!drop) {\n        // Open output file if necessary\n        if (compact->builder == NULL) {\n          status = OpenCompactionOutputFile(compact);\n          if (!status.ok()) {\n            break;\n          }\n        }\n        if (compact->builder->NumEntries() == 0) {\n          compact->current_output()->smallest.DecodeFrom(key);\n        }\n        compact->current_output()->largest.DecodeFrom(key);\n        compact->builder->Add(key, input->value());\n  \n        // Close output file if it is big enough\n        if (compact->builder->FileSize() >=\n            compact->compaction->MaxOutputFileSize()) {\n          status = FinishCompactionOutputFile(compact, input);\n          if (!status.ok()) {\n            break;\n          }\n        }\n      }\n  \n      input->Next();\n    }\n  \n    if (status.ok() && shutting_down_.Acquire_Load()) {\n      status = Status::IOError(\"Deleting DB during compaction\");\n    }\n    if (status.ok() && compact->builder != NULL) {\n      status = FinishCompactionOutputFile(compact, input);\n    }\n    if (status.ok()) {\n      status = input->status();\n    }\n    delete input;\n    input = NULL;\n  \n    CompactionStats stats;\n    stats.micros = env_->NowMicros() - start_micros - imm_micros;\n    for (int which = 0; which < 2; which++) {\n      for (int i = 0; i < compact->compaction->num_input_files(which); i++) {\n        stats.bytes_read += compact->compaction->input(which, i)->file_size;\n      }\n    }\n    for (size_t i = 0; i < compact->outputs.size(); i++) {\n      stats.bytes_written += compact->outputs[i].file_size;\n    }\n  \n    mutex_.Lock();\n    stats_[compact->compaction->level() + 1].Add(stats);\n  \n    if (status.ok()) {\n      status = InstallCompactionResults(compact);\n    }\n    if (!status.ok()) {\n      RecordBackgroundError(status);\n    }\n    VersionSet::LevelSummaryStorage tmp;\n    Log(options_.info_log,\n        \"compacted to: %s\", versions_->LevelSummary(&tmp));\n    return status;\n  }\n}"
  },
  {
    "function_name": "InstallCompactionResults",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "834-853",
    "snippet": "Status DBImpl::InstallCompactionResults(CompactionState* compact) {\n  mutex_.AssertHeld();\n  Log(options_.info_log,  \"Compacted %d@%d + %d@%d files => %lld bytes\",\n      compact->compaction->num_input_files(0),\n      compact->compaction->level(),\n      compact->compaction->num_input_files(1),\n      compact->compaction->level() + 1,\n      static_cast<long long>(compact->total_bytes));\n\n  // Add compaction outputs\n  compact->compaction->AddInputDeletions(compact->compaction->edit());\n  const int level = compact->compaction->level();\n  for (size_t i = 0; i < compact->outputs.size(); i++) {\n    const CompactionState::Output& out = compact->outputs[i];\n    compact->compaction->edit()->AddFile(\n        level + 1,\n        out.number, out.file_size, out.smallest, out.largest);\n  }\n  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "versions_->LogAndApply",
          "args": [
            "compact->compaction->edit()",
            "&mutex_"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "LogAndApply",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "825-908",
          "snippet": "Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n  if (edit->has_log_number_) {\n    assert(edit->log_number_ >= log_number_);\n    assert(edit->log_number_ < next_file_number_);\n  } else {\n    edit->SetLogNumber(log_number_);\n  }\n\n  if (!edit->has_prev_log_number_) {\n    edit->SetPrevLogNumber(prev_log_number_);\n  }\n\n  edit->SetNextFile(next_file_number_);\n  edit->SetLastSequence(last_sequence_);\n\n  Version* v = new Version(this);\n  {\n    Builder builder(this, current_);\n    builder.Apply(edit);\n    builder.SaveTo(v);\n  }\n  Finalize(v);\n\n  // Initialize new descriptor log file if necessary by creating\n  // a temporary file that contains a snapshot of the current version.\n  std::string new_manifest_file;\n  Status s;\n  if (descriptor_log_ == NULL) {\n    // No reason to unlock *mu here since we only hit this path in the\n    // first call to LogAndApply (when opening the database).\n    assert(descriptor_file_ == NULL);\n    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n    edit->SetNextFile(next_file_number_);\n    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n    if (s.ok()) {\n      descriptor_log_ = new log::Writer(descriptor_file_);\n      s = WriteSnapshot(descriptor_log_);\n    }\n  }\n\n  // Unlock during expensive MANIFEST log write\n  {\n    mu->Unlock();\n\n    // Write new record to MANIFEST log\n    if (s.ok()) {\n      std::string record;\n      edit->EncodeTo(&record);\n      s = descriptor_log_->AddRecord(record);\n      if (s.ok()) {\n        s = descriptor_file_->Sync();\n      }\n      if (!s.ok()) {\n        Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n      }\n    }\n\n    // If we just created a new descriptor file, install it by writing a\n    // new CURRENT file that points to it.\n    if (s.ok() && !new_manifest_file.empty()) {\n      s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n    }\n\n    mu->Lock();\n  }\n\n  // Install the new version\n  if (s.ok()) {\n    AppendVersion(v);\n    log_number_ = edit->log_number_;\n    prev_log_number_ = edit->prev_log_number_;\n  } else {\n    delete v;\n    if (!new_manifest_file.empty()) {\n      delete descriptor_log_;\n      delete descriptor_file_;\n      descriptor_log_ = NULL;\n      descriptor_file_ = NULL;\n      env_->DeleteFile(new_manifest_file);\n    }\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n    if (edit->has_log_number_) {\n      assert(edit->log_number_ >= log_number_);\n      assert(edit->log_number_ < next_file_number_);\n    } else {\n      edit->SetLogNumber(log_number_);\n    }\n  \n    if (!edit->has_prev_log_number_) {\n      edit->SetPrevLogNumber(prev_log_number_);\n    }\n  \n    edit->SetNextFile(next_file_number_);\n    edit->SetLastSequence(last_sequence_);\n  \n    Version* v = new Version(this);\n    {\n      Builder builder(this, current_);\n      builder.Apply(edit);\n      builder.SaveTo(v);\n    }\n    Finalize(v);\n  \n    // Initialize new descriptor log file if necessary by creating\n    // a temporary file that contains a snapshot of the current version.\n    std::string new_manifest_file;\n    Status s;\n    if (descriptor_log_ == NULL) {\n      // No reason to unlock *mu here since we only hit this path in the\n      // first call to LogAndApply (when opening the database).\n      assert(descriptor_file_ == NULL);\n      new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n      edit->SetNextFile(next_file_number_);\n      s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n      if (s.ok()) {\n        descriptor_log_ = new log::Writer(descriptor_file_);\n        s = WriteSnapshot(descriptor_log_);\n      }\n    }\n  \n    // Unlock during expensive MANIFEST log write\n    {\n      mu->Unlock();\n  \n      // Write new record to MANIFEST log\n      if (s.ok()) {\n        std::string record;\n        edit->EncodeTo(&record);\n        s = descriptor_log_->AddRecord(record);\n        if (s.ok()) {\n          s = descriptor_file_->Sync();\n        }\n        if (!s.ok()) {\n          Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n        }\n      }\n  \n      // If we just created a new descriptor file, install it by writing a\n      // new CURRENT file that points to it.\n      if (s.ok() && !new_manifest_file.empty()) {\n        s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n      }\n  \n      mu->Lock();\n    }\n  \n    // Install the new version\n    if (s.ok()) {\n      AppendVersion(v);\n      log_number_ = edit->log_number_;\n      prev_log_number_ = edit->prev_log_number_;\n    } else {\n      delete v;\n      if (!new_manifest_file.empty()) {\n        delete descriptor_log_;\n        delete descriptor_file_;\n        descriptor_log_ = NULL;\n        descriptor_file_ = NULL;\n        env_->DeleteFile(new_manifest_file);\n      }\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->edit",
          "args": [],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->compaction->edit",
          "args": [
            "level + 1",
            "out.number",
            "out.file_size",
            "out.smallest",
            "out.largest"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->compaction->edit",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->outputs.size",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->level",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "level",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "328-328",
          "snippet": "int level() const { return level_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int level() const { return level_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->AddInputDeletions",
          "args": [
            "compact->compaction->edit()"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "AddInputDeletions",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1440-1446",
          "snippet": "void Compaction::AddInputDeletions(VersionEdit* edit) {\n  for (int which = 0; which < 2; which++) {\n    for (size_t i = 0; i < inputs_[which].size(); i++) {\n      edit->DeleteFile(level_ + which, inputs_[which][i]->number);\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  void Compaction::AddInputDeletions(VersionEdit* edit) {\n    for (int which = 0; which < 2; which++) {\n      for (size_t i = 0; i < inputs_[which].size(); i++) {\n        edit->DeleteFile(level_ + which, inputs_[which][i]->number);\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->compaction->edit",
          "args": [],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Compacted %d@%d + %d@%d files => %lld bytes\"",
            "compact->compaction->num_input_files(0)",
            "compact->compaction->level()",
            "compact->compaction->num_input_files(1)",
            "compact->compaction->level() + 1",
            "static_cast<long long>(compact->total_bytes)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<long long>",
          "args": [
            "compact->total_bytes"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->compaction->num_input_files",
          "args": [
            "1"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "num_input_files",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "335-335",
          "snippet": "int num_input_files(int which) const { return inputs_[which].size(); }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int num_input_files(int which) const { return inputs_[which].size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::InstallCompactionResults(CompactionState* compact) {\n    mutex_.AssertHeld();\n    Log(options_.info_log,  \"Compacted %d@%d + %d@%d files => %lld bytes\",\n        compact->compaction->num_input_files(0),\n        compact->compaction->level(),\n        compact->compaction->num_input_files(1),\n        compact->compaction->level() + 1,\n        static_cast<long long>(compact->total_bytes));\n  \n    // Add compaction outputs\n    compact->compaction->AddInputDeletions(compact->compaction->edit());\n    const int level = compact->compaction->level();\n    for (size_t i = 0; i < compact->outputs.size(); i++) {\n      const CompactionState::Output& out = compact->outputs[i];\n      compact->compaction->edit()->AddFile(\n          level + 1,\n          out.number, out.file_size, out.smallest, out.largest);\n    }\n    return versions_->LogAndApply(compact->compaction->edit(), &mutex_);\n  }\n}"
  },
  {
    "function_name": "FinishCompactionOutputFile",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "782-831",
    "snippet": "Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,\n                                          Iterator* input) {\n  assert(compact != NULL);\n  assert(compact->outfile != NULL);\n  assert(compact->builder != NULL);\n\n  const uint64_t output_number = compact->current_output()->number;\n  assert(output_number != 0);\n\n  // Check for iterator errors\n  Status s = input->status();\n  const uint64_t current_entries = compact->builder->NumEntries();\n  if (s.ok()) {\n    s = compact->builder->Finish();\n  } else {\n    compact->builder->Abandon();\n  }\n  const uint64_t current_bytes = compact->builder->FileSize();\n  compact->current_output()->file_size = current_bytes;\n  compact->total_bytes += current_bytes;\n  delete compact->builder;\n  compact->builder = NULL;\n\n  // Finish and check for file errors\n  if (s.ok()) {\n    s = compact->outfile->Sync();\n  }\n  if (s.ok()) {\n    s = compact->outfile->Close();\n  }\n  delete compact->outfile;\n  compact->outfile = NULL;\n\n  if (s.ok() && current_entries > 0) {\n    // Verify that the table is usable\n    Iterator* iter = table_cache_->NewIterator(ReadOptions(),\n                                               output_number,\n                                               current_bytes);\n    s = iter->status();\n    delete iter;\n    if (s.ok()) {\n      Log(options_.info_log,\n          \"Generated table #%llu: %lld keys, %lld bytes\",\n          (unsigned long long) output_number,\n          (unsigned long long) current_entries,\n          (unsigned long long) current_bytes);\n    }\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Generated table #%llu: %lld keys, %lld bytes\"",
            "(unsigned long long) output_number",
            "(unsigned long long) current_entries",
            "(unsigned long long) current_bytes"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->status",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "74-80",
          "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Status status() const {\n      if (status_.ok()) {\n        return iter_->status();\n      } else {\n        return status_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_cache_->NewIterator",
          "args": [
            "ReadOptions()",
            "output_number",
            "current_bytes"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->outfile->Close",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "261-264",
          "snippet": "void Close() {\n    delete db_;\n    db_ = NULL;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  void Close() {\n      delete db_;\n      db_ = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->outfile->Sync",
          "args": [],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "Sync",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "47-47",
          "snippet": "virtual Status Sync() { return Status::OK(); }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Sync() { return Status::OK(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->current_output",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->builder->FileSize",
          "args": [],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "FileSize",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "266-268",
          "snippet": "uint64_t TableBuilder::FileSize() const {\n  return rep_->offset;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  uint64_t TableBuilder::FileSize() const {\n    return rep_->offset;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->builder->Abandon",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "Abandon",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "256-260",
          "snippet": "void TableBuilder::Abandon() {\n  Rep* r = rep_;\n  assert(!r->closed);\n  r->closed = true;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  void TableBuilder::Abandon() {\n    Rep* r = rep_;\n    assert(!r->closed);\n    r->closed = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->builder->Finish",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "Finish",
          "container": "FilterBlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
          "lines": "36-50",
          "snippet": "Slice FilterBlockBuilder::Finish() {\n  if (!start_.empty()) {\n    GenerateFilter();\n  }\n\n  // Append array of per-filter offsets\n  const uint32_t array_offset = result_.size();\n  for (size_t i = 0; i < filter_offsets_.size(); i++) {\n    PutFixed32(&result_, filter_offsets_[i]);\n  }\n\n  PutFixed32(&result_, array_offset);\n  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n  return Slice(result_);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"table/filter_block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  Slice FilterBlockBuilder::Finish() {\n    if (!start_.empty()) {\n      GenerateFilter();\n    }\n  \n    // Append array of per-filter offsets\n    const uint32_t array_offset = result_.size();\n    for (size_t i = 0; i < filter_offsets_.size(); i++) {\n      PutFixed32(&result_, filter_offsets_[i]);\n    }\n  \n    PutFixed32(&result_, array_offset);\n    result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n    return Slice(result_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->builder->NumEntries",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "NumEntries",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "262-264",
          "snippet": "uint64_t TableBuilder::NumEntries() const {\n  return rep_->num_entries;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  uint64_t TableBuilder::NumEntries() const {\n    return rep_->num_entries;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "output_number != 0"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->current_output",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact->builder != NULL"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact->outfile != NULL"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact != NULL"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,\n                                            Iterator* input) {\n    assert(compact != NULL);\n    assert(compact->outfile != NULL);\n    assert(compact->builder != NULL);\n  \n    const uint64_t output_number = compact->current_output()->number;\n    assert(output_number != 0);\n  \n    // Check for iterator errors\n    Status s = input->status();\n    const uint64_t current_entries = compact->builder->NumEntries();\n    if (s.ok()) {\n      s = compact->builder->Finish();\n    } else {\n      compact->builder->Abandon();\n    }\n    const uint64_t current_bytes = compact->builder->FileSize();\n    compact->current_output()->file_size = current_bytes;\n    compact->total_bytes += current_bytes;\n    delete compact->builder;\n    compact->builder = NULL;\n  \n    // Finish and check for file errors\n    if (s.ok()) {\n      s = compact->outfile->Sync();\n    }\n    if (s.ok()) {\n      s = compact->outfile->Close();\n    }\n    delete compact->outfile;\n    compact->outfile = NULL;\n  \n    if (s.ok() && current_entries > 0) {\n      // Verify that the table is usable\n      Iterator* iter = table_cache_->NewIterator(ReadOptions(),\n                                                 output_number,\n                                                 current_bytes);\n      s = iter->status();\n      delete iter;\n      if (s.ok()) {\n        Log(options_.info_log,\n            \"Generated table #%llu: %lld keys, %lld bytes\",\n            (unsigned long long) output_number,\n            (unsigned long long) current_entries,\n            (unsigned long long) current_bytes);\n      }\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "OpenCompactionOutputFile",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "757-780",
    "snippet": "Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {\n  assert(compact != NULL);\n  assert(compact->builder == NULL);\n  uint64_t file_number;\n  {\n    mutex_.Lock();\n    file_number = versions_->NewFileNumber();\n    pending_outputs_.insert(file_number);\n    CompactionState::Output out;\n    out.number = file_number;\n    out.smallest.Clear();\n    out.largest.Clear();\n    compact->outputs.push_back(out);\n    mutex_.Unlock();\n  }\n\n  // Make the output file\n  std::string fname = TableFileName(dbname_, file_number);\n  Status s = env_->NewWritableFile(fname, &compact->outfile);\n  if (s.ok()) {\n    compact->builder = new TableBuilder(options_, compact->outfile);\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "fname",
            "&compact->outfile"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TableFileName",
          "args": [
            "dbname_",
            "file_number"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "SSTTableFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "42-45",
          "snippet": "std::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->outputs.push_back",
          "args": [
            "out"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out.largest.Clear",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pending_outputs_.insert",
          "args": [
            "file_number"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->NewFileNumber",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "NewFileNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "191-191",
          "snippet": "uint64_t NewFileNumber() { return next_file_number_++; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t NewFileNumber() { return next_file_number_++; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact->builder == NULL"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact != NULL"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {\n    assert(compact != NULL);\n    assert(compact->builder == NULL);\n    uint64_t file_number;\n    {\n      mutex_.Lock();\n      file_number = versions_->NewFileNumber();\n      pending_outputs_.insert(file_number);\n      CompactionState::Output out;\n      out.number = file_number;\n      out.smallest.Clear();\n      out.largest.Clear();\n      compact->outputs.push_back(out);\n      mutex_.Unlock();\n    }\n  \n    // Make the output file\n    std::string fname = TableFileName(dbname_, file_number);\n    Status s = env_->NewWritableFile(fname, &compact->outfile);\n    if (s.ok()) {\n      compact->builder = new TableBuilder(options_, compact->outfile);\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "CleanupCompaction",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "740-755",
    "snippet": "void DBImpl::CleanupCompaction(CompactionState* compact) {\n  mutex_.AssertHeld();\n  if (compact->builder != NULL) {\n    // May happen if we get a shutdown call in the middle of compaction\n    compact->builder->Abandon();\n    delete compact->builder;\n  } else {\n    assert(compact->outfile == NULL);\n  }\n  delete compact->outfile;\n  for (size_t i = 0; i < compact->outputs.size(); i++) {\n    const CompactionState::Output& out = compact->outputs[i];\n    pending_outputs_.erase(out.number);\n  }\n  delete compact;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pending_outputs_.erase",
          "args": [
            "out.number"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact->outputs.size",
          "args": [],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "compact->outfile == NULL"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compact->builder->Abandon",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "Abandon",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "256-260",
          "snippet": "void TableBuilder::Abandon() {\n  Rep* r = rep_;\n  assert(!r->closed);\n  r->closed = true;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  void TableBuilder::Abandon() {\n    Rep* r = rep_;\n    assert(!r->closed);\n    r->closed = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CleanupCompaction(CompactionState* compact) {\n    mutex_.AssertHeld();\n    if (compact->builder != NULL) {\n      // May happen if we get a shutdown call in the middle of compaction\n      compact->builder->Abandon();\n      delete compact->builder;\n    } else {\n      assert(compact->outfile == NULL);\n    }\n    delete compact->outfile;\n    for (size_t i = 0; i < compact->outputs.size(); i++) {\n      const CompactionState::Output& out = compact->outputs[i];\n      pending_outputs_.erase(out.number);\n    }\n    delete compact;\n  }\n}"
  },
  {
    "function_name": "BackgroundCompaction",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "655-738",
    "snippet": "void DBImpl::BackgroundCompaction() {\n  mutex_.AssertHeld();\n\n  if (imm_ != NULL) {\n    CompactMemTable();\n    return;\n  }\n\n  Compaction* c;\n  bool is_manual = (manual_compaction_ != NULL);\n  InternalKey manual_end;\n  if (is_manual) {\n    ManualCompaction* m = manual_compaction_;\n    c = versions_->CompactRange(m->level, m->begin, m->end);\n    m->done = (c == NULL);\n    if (c != NULL) {\n      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;\n    }\n    Log(options_.info_log,\n        \"Manual compaction at level-%d from %s .. %s; will stop at %s\\n\",\n        m->level,\n        (m->begin ? m->begin->DebugString().c_str() : \"(begin)\"),\n        (m->end ? m->end->DebugString().c_str() : \"(end)\"),\n        (m->done ? \"(end)\" : manual_end.DebugString().c_str()));\n  } else {\n    c = versions_->PickCompaction();\n  }\n\n  Status status;\n  if (c == NULL) {\n    // Nothing to do\n  } else if (!is_manual && c->IsTrivialMove()) {\n    // Move file to next level\n    assert(c->num_input_files(0) == 1);\n    FileMetaData* f = c->input(0, 0);\n    c->edit()->DeleteFile(c->level(), f->number);\n    c->edit()->AddFile(c->level() + 1, f->number, f->file_size,\n                       f->smallest, f->largest);\n    status = versions_->LogAndApply(c->edit(), &mutex_);\n    if (!status.ok()) {\n      RecordBackgroundError(status);\n    }\n    VersionSet::LevelSummaryStorage tmp;\n    Log(options_.info_log, \"Moved #%lld to level-%d %lld bytes %s: %s\\n\",\n        static_cast<unsigned long long>(f->number),\n        c->level() + 1,\n        static_cast<unsigned long long>(f->file_size),\n        status.ToString().c_str(),\n        versions_->LevelSummary(&tmp));\n  } else {\n    CompactionState* compact = new CompactionState(c);\n    status = DoCompactionWork(compact);\n    if (!status.ok()) {\n      RecordBackgroundError(status);\n    }\n    CleanupCompaction(compact);\n    c->ReleaseInputs();\n    DeleteObsoleteFiles();\n  }\n  delete c;\n\n  if (status.ok()) {\n    // Done\n  } else if (shutting_down_.Acquire_Load()) {\n    // Ignore compaction errors found during shutting down\n  } else {\n    Log(options_.info_log,\n        \"Compaction error: %s\", status.ToString().c_str());\n  }\n\n  if (is_manual) {\n    ManualCompaction* m = manual_compaction_;\n    if (!status.ok()) {\n      m->done = true;\n    }\n    if (!m->done) {\n      // We only compacted part of the requested range.  Update *m\n      // to the range that is left to be compacted.\n      m->tmp_storage = manual_end;\n      m->begin = &m->tmp_storage;\n    }\n    manual_compaction_ = NULL;\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Compaction error: %s\"",
            "status.ToString().c_str()"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverLogFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "362-455",
          "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::RecoverLogFile(uint64_t log_number,\n                                VersionEdit* edit,\n                                SequenceNumber* max_sequence) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      const char* fname;\n      Status* status;  // NULL if options_.paranoid_checks==false\n      virtual void Corruption(size_t bytes, const Status& s) {\n        Log(info_log, \"%s%s: dropping %d bytes; %s\",\n            (this->status == NULL ? \"(ignoring error) \" : \"\"),\n            fname, static_cast<int>(bytes), s.ToString().c_str());\n        if (this->status != NULL && this->status->ok()) *this->status = s;\n      }\n    };\n  \n    mutex_.AssertHeld();\n  \n    // Open the log file\n    std::string fname = LogFileName(dbname_, log_number);\n    SequentialFile* file;\n    Status status = env_->NewSequentialFile(fname, &file);\n    if (!status.ok()) {\n      MaybeIgnoreError(&status);\n      return status;\n    }\n  \n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.fname = fname.c_str();\n    reporter.status = (options_.paranoid_checks ? &status : NULL);\n    // We intentially make log::Reader do checksumming even if\n    // paranoid_checks==false so that corruptions cause entire commits\n    // to be skipped instead of propagating bad information (like overly\n    // large sequence numbers).\n    log::Reader reader(file, &reporter, true/*checksum*/,\n                       0/*initial_offset*/);\n    Log(options_.info_log, \"Recovering log #%llu\",\n        (unsigned long long) log_number);\n  \n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = NULL;\n    while (reader.ReadRecord(&record, &scratch) &&\n           status.ok()) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n  \n      if (mem == NULL) {\n        mem = new MemTable(internal_comparator_);\n        mem->Ref();\n      }\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      MaybeIgnoreError(&status);\n      if (!status.ok()) {\n        break;\n      }\n      const SequenceNumber last_seq =\n          WriteBatchInternal::Sequence(&batch) +\n          WriteBatchInternal::Count(&batch) - 1;\n      if (last_seq > *max_sequence) {\n        *max_sequence = last_seq;\n      }\n  \n      if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n        status = WriteLevel0Table(mem, edit, NULL);\n        if (!status.ok()) {\n          // Reflect errors immediately so that conditions like full\n          // file-systems cause the DB::Open() to fail.\n          break;\n        }\n        mem->Unref();\n        mem = NULL;\n      }\n    }\n  \n    if (status.ok() && mem != NULL) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      // Reflect errors immediately so that conditions like full\n      // file-systems cause the DB::Open() to fail.\n    }\n  \n    if (mem != NULL) mem->Unref();\n    delete file;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteObsoleteFiles",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteObsoleteFiles",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "218-272",
          "snippet": "void DBImpl::DeleteObsoleteFiles() {\n  if (!bg_error_.ok()) {\n    // After a background error, we don't know whether a new version may\n    // or may not have been committed, so we cannot safely garbage collect.\n    return;\n  }\n\n  // Make a set of all of the live files\n  std::set<uint64_t> live = pending_outputs_;\n  versions_->AddLiveFiles(&live);\n\n  std::vector<std::string> filenames;\n  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n  uint64_t number;\n  FileType type;\n  for (size_t i = 0; i < filenames.size(); i++) {\n    if (ParseFileName(filenames[i], &number, &type)) {\n      bool keep = true;\n      switch (type) {\n        case kLogFile:\n          keep = ((number >= versions_->LogNumber()) ||\n                  (number == versions_->PrevLogNumber()));\n          break;\n        case kDescriptorFile:\n          // Keep my manifest file, and any newer incarnations'\n          // (in case there is a race that allows other incarnations)\n          keep = (number >= versions_->ManifestFileNumber());\n          break;\n        case kTableFile:\n          keep = (live.find(number) != live.end());\n          break;\n        case kTempFile:\n          // Any temp files that are currently being written to must\n          // be recorded in pending_outputs_, which is inserted into \"live\"\n          keep = (live.find(number) != live.end());\n          break;\n        case kCurrentFile:\n        case kDBLockFile:\n        case kInfoLogFile:\n          keep = true;\n          break;\n      }\n\n      if (!keep) {\n        if (type == kTableFile) {\n          table_cache_->Evict(number);\n        }\n        Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n            int(type),\n            static_cast<unsigned long long>(number));\n        env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::DeleteObsoleteFiles() {\n    if (!bg_error_.ok()) {\n      // After a background error, we don't know whether a new version may\n      // or may not have been committed, so we cannot safely garbage collect.\n      return;\n    }\n  \n    // Make a set of all of the live files\n    std::set<uint64_t> live = pending_outputs_;\n    versions_->AddLiveFiles(&live);\n  \n    std::vector<std::string> filenames;\n    env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        bool keep = true;\n        switch (type) {\n          case kLogFile:\n            keep = ((number >= versions_->LogNumber()) ||\n                    (number == versions_->PrevLogNumber()));\n            break;\n          case kDescriptorFile:\n            // Keep my manifest file, and any newer incarnations'\n            // (in case there is a race that allows other incarnations)\n            keep = (number >= versions_->ManifestFileNumber());\n            break;\n          case kTableFile:\n            keep = (live.find(number) != live.end());\n            break;\n          case kTempFile:\n            // Any temp files that are currently being written to must\n            // be recorded in pending_outputs_, which is inserted into \"live\"\n            keep = (live.find(number) != live.end());\n            break;\n          case kCurrentFile:\n          case kDBLockFile:\n          case kInfoLogFile:\n            keep = true;\n            break;\n        }\n  \n        if (!keep) {\n          if (type == kTableFile) {\n            table_cache_->Evict(number);\n          }\n          Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n              int(type),\n              static_cast<unsigned long long>(number));\n          env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->ReleaseInputs",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseInputs",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1491-1496",
          "snippet": "void Compaction::ReleaseInputs() {\n  if (input_version_ != NULL) {\n    input_version_->Unref();\n    input_version_ = NULL;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  void Compaction::ReleaseInputs() {\n    if (input_version_ != NULL) {\n      input_version_->Unref();\n      input_version_ = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CleanupCompaction",
          "args": [
            "compact"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "CleanupCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "740-755",
          "snippet": "void DBImpl::CleanupCompaction(CompactionState* compact) {\n  mutex_.AssertHeld();\n  if (compact->builder != NULL) {\n    // May happen if we get a shutdown call in the middle of compaction\n    compact->builder->Abandon();\n    delete compact->builder;\n  } else {\n    assert(compact->outfile == NULL);\n  }\n  delete compact->outfile;\n  for (size_t i = 0; i < compact->outputs.size(); i++) {\n    const CompactionState::Output& out = compact->outputs[i];\n    pending_outputs_.erase(out.number);\n  }\n  delete compact;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CleanupCompaction(CompactionState* compact) {\n    mutex_.AssertHeld();\n    if (compact->builder != NULL) {\n      // May happen if we get a shutdown call in the middle of compaction\n      compact->builder->Abandon();\n      delete compact->builder;\n    } else {\n      assert(compact->outfile == NULL);\n    }\n    delete compact->outfile;\n    for (size_t i = 0; i < compact->outputs.size(); i++) {\n      const CompactionState::Output& out = compact->outputs[i];\n      pending_outputs_.erase(out.number);\n    }\n    delete compact;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecordBackgroundError",
          "args": [
            "status"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "RecordBackgroundError",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "606-612",
          "snippet": "void DBImpl::RecordBackgroundError(const Status& s) {\n  mutex_.AssertHeld();\n  if (bg_error_.ok()) {\n    bg_error_ = s;\n    bg_cv_.SignalAll();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordBackgroundError(const Status& s) {\n    mutex_.AssertHeld();\n    if (bg_error_.ok()) {\n      bg_error_ = s;\n      bg_cv_.SignalAll();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoCompactionWork",
          "args": [
            "compact"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "DoCompactionWork",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "855-1014",
          "snippet": "Status DBImpl::DoCompactionWork(CompactionState* compact) {\n  const uint64_t start_micros = env_->NowMicros();\n  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions\n\n  Log(options_.info_log,  \"Compacting %d@%d + %d@%d files\",\n      compact->compaction->num_input_files(0),\n      compact->compaction->level(),\n      compact->compaction->num_input_files(1),\n      compact->compaction->level() + 1);\n\n  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);\n  assert(compact->builder == NULL);\n  assert(compact->outfile == NULL);\n  if (snapshots_.empty()) {\n    compact->smallest_snapshot = versions_->LastSequence();\n  } else {\n    compact->smallest_snapshot = snapshots_.oldest()->number_;\n  }\n\n  // Release mutex while we're actually doing the compaction work\n  mutex_.Unlock();\n\n  Iterator* input = versions_->MakeInputIterator(compact->compaction);\n  input->SeekToFirst();\n  Status status;\n  ParsedInternalKey ikey;\n  std::string current_user_key;\n  bool has_current_user_key = false;\n  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;\n  for (; input->Valid() && !shutting_down_.Acquire_Load(); ) {\n    // Prioritize immutable compaction work\n    if (has_imm_.NoBarrier_Load() != NULL) {\n      const uint64_t imm_start = env_->NowMicros();\n      mutex_.Lock();\n      if (imm_ != NULL) {\n        CompactMemTable();\n        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary\n      }\n      mutex_.Unlock();\n      imm_micros += (env_->NowMicros() - imm_start);\n    }\n\n    Slice key = input->key();\n    if (compact->compaction->ShouldStopBefore(key) &&\n        compact->builder != NULL) {\n      status = FinishCompactionOutputFile(compact, input);\n      if (!status.ok()) {\n        break;\n      }\n    }\n\n    // Handle key/value, add to state, etc.\n    bool drop = false;\n    if (!ParseInternalKey(key, &ikey)) {\n      // Do not hide error keys\n      current_user_key.clear();\n      has_current_user_key = false;\n      last_sequence_for_key = kMaxSequenceNumber;\n    } else {\n      if (!has_current_user_key ||\n          user_comparator()->Compare(ikey.user_key,\n                                     Slice(current_user_key)) != 0) {\n        // First occurrence of this user key\n        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());\n        has_current_user_key = true;\n        last_sequence_for_key = kMaxSequenceNumber;\n      }\n\n      if (last_sequence_for_key <= compact->smallest_snapshot) {\n        // Hidden by an newer entry for same user key\n        drop = true;    // (A)\n      } else if (ikey.type == kTypeDeletion &&\n                 ikey.sequence <= compact->smallest_snapshot &&\n                 compact->compaction->IsBaseLevelForKey(ikey.user_key)) {\n        // For this user key:\n        // (1) there is no data in higher levels\n        // (2) data in lower levels will have larger sequence numbers\n        // (3) data in layers that are being compacted here and have\n        //     smaller sequence numbers will be dropped in the next\n        //     few iterations of this loop (by rule (A) above).\n        // Therefore this deletion marker is obsolete and can be dropped.\n        drop = true;\n      }\n\n      last_sequence_for_key = ikey.sequence;\n    }\n#if 0\n    Log(options_.info_log,\n        \"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, \"\n        \"%d smallest_snapshot: %d\",\n        ikey.user_key.ToString().c_str(),\n        (int)ikey.sequence, ikey.type, kTypeValue, drop,\n        compact->compaction->IsBaseLevelForKey(ikey.user_key),\n        (int)last_sequence_for_key, (int)compact->smallest_snapshot);\n#endif\n\n    if (!drop) {\n      // Open output file if necessary\n      if (compact->builder == NULL) {\n        status = OpenCompactionOutputFile(compact);\n        if (!status.ok()) {\n          break;\n        }\n      }\n      if (compact->builder->NumEntries() == 0) {\n        compact->current_output()->smallest.DecodeFrom(key);\n      }\n      compact->current_output()->largest.DecodeFrom(key);\n      compact->builder->Add(key, input->value());\n\n      // Close output file if it is big enough\n      if (compact->builder->FileSize() >=\n          compact->compaction->MaxOutputFileSize()) {\n        status = FinishCompactionOutputFile(compact, input);\n        if (!status.ok()) {\n          break;\n        }\n      }\n    }\n\n    input->Next();\n  }\n\n  if (status.ok() && shutting_down_.Acquire_Load()) {\n    status = Status::IOError(\"Deleting DB during compaction\");\n  }\n  if (status.ok() && compact->builder != NULL) {\n    status = FinishCompactionOutputFile(compact, input);\n  }\n  if (status.ok()) {\n    status = input->status();\n  }\n  delete input;\n  input = NULL;\n\n  CompactionStats stats;\n  stats.micros = env_->NowMicros() - start_micros - imm_micros;\n  for (int which = 0; which < 2; which++) {\n    for (int i = 0; i < compact->compaction->num_input_files(which); i++) {\n      stats.bytes_read += compact->compaction->input(which, i)->file_size;\n    }\n  }\n  for (size_t i = 0; i < compact->outputs.size(); i++) {\n    stats.bytes_written += compact->outputs[i].file_size;\n  }\n\n  mutex_.Lock();\n  stats_[compact->compaction->level() + 1].Add(stats);\n\n  if (status.ok()) {\n    status = InstallCompactionResults(compact);\n  }\n  if (!status.ok()) {\n    RecordBackgroundError(status);\n  }\n  VersionSet::LevelSummaryStorage tmp;\n  Log(options_.info_log,\n      \"compacted to: %s\", versions_->LevelSummary(&tmp));\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::DoCompactionWork(CompactionState* compact) {\n    const uint64_t start_micros = env_->NowMicros();\n    int64_t imm_micros = 0;  // Micros spent doing imm_ compactions\n  \n    Log(options_.info_log,  \"Compacting %d@%d + %d@%d files\",\n        compact->compaction->num_input_files(0),\n        compact->compaction->level(),\n        compact->compaction->num_input_files(1),\n        compact->compaction->level() + 1);\n  \n    assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);\n    assert(compact->builder == NULL);\n    assert(compact->outfile == NULL);\n    if (snapshots_.empty()) {\n      compact->smallest_snapshot = versions_->LastSequence();\n    } else {\n      compact->smallest_snapshot = snapshots_.oldest()->number_;\n    }\n  \n    // Release mutex while we're actually doing the compaction work\n    mutex_.Unlock();\n  \n    Iterator* input = versions_->MakeInputIterator(compact->compaction);\n    input->SeekToFirst();\n    Status status;\n    ParsedInternalKey ikey;\n    std::string current_user_key;\n    bool has_current_user_key = false;\n    SequenceNumber last_sequence_for_key = kMaxSequenceNumber;\n    for (; input->Valid() && !shutting_down_.Acquire_Load(); ) {\n      // Prioritize immutable compaction work\n      if (has_imm_.NoBarrier_Load() != NULL) {\n        const uint64_t imm_start = env_->NowMicros();\n        mutex_.Lock();\n        if (imm_ != NULL) {\n          CompactMemTable();\n          bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary\n        }\n        mutex_.Unlock();\n        imm_micros += (env_->NowMicros() - imm_start);\n      }\n  \n      Slice key = input->key();\n      if (compact->compaction->ShouldStopBefore(key) &&\n          compact->builder != NULL) {\n        status = FinishCompactionOutputFile(compact, input);\n        if (!status.ok()) {\n          break;\n        }\n      }\n  \n      // Handle key/value, add to state, etc.\n      bool drop = false;\n      if (!ParseInternalKey(key, &ikey)) {\n        // Do not hide error keys\n        current_user_key.clear();\n        has_current_user_key = false;\n        last_sequence_for_key = kMaxSequenceNumber;\n      } else {\n        if (!has_current_user_key ||\n            user_comparator()->Compare(ikey.user_key,\n                                       Slice(current_user_key)) != 0) {\n          // First occurrence of this user key\n          current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());\n          has_current_user_key = true;\n          last_sequence_for_key = kMaxSequenceNumber;\n        }\n  \n        if (last_sequence_for_key <= compact->smallest_snapshot) {\n          // Hidden by an newer entry for same user key\n          drop = true;    // (A)\n        } else if (ikey.type == kTypeDeletion &&\n                   ikey.sequence <= compact->smallest_snapshot &&\n                   compact->compaction->IsBaseLevelForKey(ikey.user_key)) {\n          // For this user key:\n          // (1) there is no data in higher levels\n          // (2) data in lower levels will have larger sequence numbers\n          // (3) data in layers that are being compacted here and have\n          //     smaller sequence numbers will be dropped in the next\n          //     few iterations of this loop (by rule (A) above).\n          // Therefore this deletion marker is obsolete and can be dropped.\n          drop = true;\n        }\n  \n        last_sequence_for_key = ikey.sequence;\n      }\n  #if 0\n      Log(options_.info_log,\n          \"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, \"\n          \"%d smallest_snapshot: %d\",\n          ikey.user_key.ToString().c_str(),\n          (int)ikey.sequence, ikey.type, kTypeValue, drop,\n          compact->compaction->IsBaseLevelForKey(ikey.user_key),\n          (int)last_sequence_for_key, (int)compact->smallest_snapshot);\n  #endif\n  \n      if (!drop) {\n        // Open output file if necessary\n        if (compact->builder == NULL) {\n          status = OpenCompactionOutputFile(compact);\n          if (!status.ok()) {\n            break;\n          }\n        }\n        if (compact->builder->NumEntries() == 0) {\n          compact->current_output()->smallest.DecodeFrom(key);\n        }\n        compact->current_output()->largest.DecodeFrom(key);\n        compact->builder->Add(key, input->value());\n  \n        // Close output file if it is big enough\n        if (compact->builder->FileSize() >=\n            compact->compaction->MaxOutputFileSize()) {\n          status = FinishCompactionOutputFile(compact, input);\n          if (!status.ok()) {\n            break;\n          }\n        }\n      }\n  \n      input->Next();\n    }\n  \n    if (status.ok() && shutting_down_.Acquire_Load()) {\n      status = Status::IOError(\"Deleting DB during compaction\");\n    }\n    if (status.ok() && compact->builder != NULL) {\n      status = FinishCompactionOutputFile(compact, input);\n    }\n    if (status.ok()) {\n      status = input->status();\n    }\n    delete input;\n    input = NULL;\n  \n    CompactionStats stats;\n    stats.micros = env_->NowMicros() - start_micros - imm_micros;\n    for (int which = 0; which < 2; which++) {\n      for (int i = 0; i < compact->compaction->num_input_files(which); i++) {\n        stats.bytes_read += compact->compaction->input(which, i)->file_size;\n      }\n    }\n    for (size_t i = 0; i < compact->outputs.size(); i++) {\n      stats.bytes_written += compact->outputs[i].file_size;\n    }\n  \n    mutex_.Lock();\n    stats_[compact->compaction->level() + 1].Add(stats);\n  \n    if (status.ok()) {\n      status = InstallCompactionResults(compact);\n    }\n    if (!status.ok()) {\n      RecordBackgroundError(status);\n    }\n    VersionSet::LevelSummaryStorage tmp;\n    Log(options_.info_log,\n        \"compacted to: %s\", versions_->LevelSummary(&tmp));\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Moved #%lld to level-%d %lld bytes %s: %s\\n\"",
            "static_cast<unsigned long long>(f->number)",
            "c->level() + 1",
            "static_cast<unsigned long long>(f->file_size)",
            "status.ToString().c_str()",
            "versions_->LevelSummary(&tmp)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->LevelSummary",
          "args": [
            "&tmp"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long long>",
          "args": [
            "f->file_size"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->level",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "level",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "328-328",
          "snippet": "int level() const { return level_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int level() const { return level_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long long>",
          "args": [
            "f->number"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->LogAndApply",
          "args": [
            "c->edit()",
            "&mutex_"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "LogAndApply",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "825-908",
          "snippet": "Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n  if (edit->has_log_number_) {\n    assert(edit->log_number_ >= log_number_);\n    assert(edit->log_number_ < next_file_number_);\n  } else {\n    edit->SetLogNumber(log_number_);\n  }\n\n  if (!edit->has_prev_log_number_) {\n    edit->SetPrevLogNumber(prev_log_number_);\n  }\n\n  edit->SetNextFile(next_file_number_);\n  edit->SetLastSequence(last_sequence_);\n\n  Version* v = new Version(this);\n  {\n    Builder builder(this, current_);\n    builder.Apply(edit);\n    builder.SaveTo(v);\n  }\n  Finalize(v);\n\n  // Initialize new descriptor log file if necessary by creating\n  // a temporary file that contains a snapshot of the current version.\n  std::string new_manifest_file;\n  Status s;\n  if (descriptor_log_ == NULL) {\n    // No reason to unlock *mu here since we only hit this path in the\n    // first call to LogAndApply (when opening the database).\n    assert(descriptor_file_ == NULL);\n    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n    edit->SetNextFile(next_file_number_);\n    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n    if (s.ok()) {\n      descriptor_log_ = new log::Writer(descriptor_file_);\n      s = WriteSnapshot(descriptor_log_);\n    }\n  }\n\n  // Unlock during expensive MANIFEST log write\n  {\n    mu->Unlock();\n\n    // Write new record to MANIFEST log\n    if (s.ok()) {\n      std::string record;\n      edit->EncodeTo(&record);\n      s = descriptor_log_->AddRecord(record);\n      if (s.ok()) {\n        s = descriptor_file_->Sync();\n      }\n      if (!s.ok()) {\n        Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n      }\n    }\n\n    // If we just created a new descriptor file, install it by writing a\n    // new CURRENT file that points to it.\n    if (s.ok() && !new_manifest_file.empty()) {\n      s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n    }\n\n    mu->Lock();\n  }\n\n  // Install the new version\n  if (s.ok()) {\n    AppendVersion(v);\n    log_number_ = edit->log_number_;\n    prev_log_number_ = edit->prev_log_number_;\n  } else {\n    delete v;\n    if (!new_manifest_file.empty()) {\n      delete descriptor_log_;\n      delete descriptor_file_;\n      descriptor_log_ = NULL;\n      descriptor_file_ = NULL;\n      env_->DeleteFile(new_manifest_file);\n    }\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n    if (edit->has_log_number_) {\n      assert(edit->log_number_ >= log_number_);\n      assert(edit->log_number_ < next_file_number_);\n    } else {\n      edit->SetLogNumber(log_number_);\n    }\n  \n    if (!edit->has_prev_log_number_) {\n      edit->SetPrevLogNumber(prev_log_number_);\n    }\n  \n    edit->SetNextFile(next_file_number_);\n    edit->SetLastSequence(last_sequence_);\n  \n    Version* v = new Version(this);\n    {\n      Builder builder(this, current_);\n      builder.Apply(edit);\n      builder.SaveTo(v);\n    }\n    Finalize(v);\n  \n    // Initialize new descriptor log file if necessary by creating\n    // a temporary file that contains a snapshot of the current version.\n    std::string new_manifest_file;\n    Status s;\n    if (descriptor_log_ == NULL) {\n      // No reason to unlock *mu here since we only hit this path in the\n      // first call to LogAndApply (when opening the database).\n      assert(descriptor_file_ == NULL);\n      new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n      edit->SetNextFile(next_file_number_);\n      s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n      if (s.ok()) {\n        descriptor_log_ = new log::Writer(descriptor_file_);\n        s = WriteSnapshot(descriptor_log_);\n      }\n    }\n  \n    // Unlock during expensive MANIFEST log write\n    {\n      mu->Unlock();\n  \n      // Write new record to MANIFEST log\n      if (s.ok()) {\n        std::string record;\n        edit->EncodeTo(&record);\n        s = descriptor_log_->AddRecord(record);\n        if (s.ok()) {\n          s = descriptor_file_->Sync();\n        }\n        if (!s.ok()) {\n          Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n        }\n      }\n  \n      // If we just created a new descriptor file, install it by writing a\n      // new CURRENT file that points to it.\n      if (s.ok() && !new_manifest_file.empty()) {\n        s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n      }\n  \n      mu->Lock();\n    }\n  \n    // Install the new version\n    if (s.ok()) {\n      AppendVersion(v);\n      log_number_ = edit->log_number_;\n      prev_log_number_ = edit->prev_log_number_;\n    } else {\n      delete v;\n      if (!new_manifest_file.empty()) {\n        delete descriptor_log_;\n        delete descriptor_file_;\n        descriptor_log_ = NULL;\n        descriptor_file_ = NULL;\n        env_->DeleteFile(new_manifest_file);\n      }\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->edit",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->edit",
          "args": [
            "c->level() + 1",
            "f->number",
            "f->file_size",
            "f->smallest",
            "f->largest"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->edit",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->edit",
          "args": [
            "c->level()",
            "f->number"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->edit",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->input",
          "args": [
            "0",
            "0"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "c->num_input_files(0) == 1"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->num_input_files",
          "args": [
            "0"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "num_input_files",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "335-335",
          "snippet": "int num_input_files(int which) const { return inputs_[which].size(); }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int num_input_files(int which) const { return inputs_[which].size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->IsTrivialMove",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "IsTrivialMove",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1431-1438",
          "snippet": "bool Compaction::IsTrivialMove() const {\n  // Avoid a move if there is lots of overlapping grandparent data.\n  // Otherwise, the move could create a parent file that will require\n  // a very expensive merge later on.\n  return (num_input_files(0) == 1 &&\n          num_input_files(1) == 0 &&\n          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  bool Compaction::IsTrivialMove() const {\n    // Avoid a move if there is lots of overlapping grandparent data.\n    // Otherwise, the move could create a parent file that will require\n    // a very expensive merge later on.\n    return (num_input_files(0) == 1 &&\n            num_input_files(1) == 0 &&\n            TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->PickCompaction",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Manual compaction at level-%d from %s .. %s; will stop at %s\\n\"",
            "m->level",
            "(m->begin ? m->begin->DebugString().c_str() : \"(begin)\")",
            "(m->end ? m->end->DebugString().c_str() : \"(end)\")",
            "(m->done ? \"(end)\" : manual_end.DebugString().c_str())"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manual_end.DebugString",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "DebugString",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "212-264",
          "snippet": "std::string VersionEdit::DebugString() const {\n  std::string r;\n  r.append(\"VersionEdit {\");\n  if (has_comparator_) {\n    r.append(\"\\n  Comparator: \");\n    r.append(comparator_);\n  }\n  if (has_log_number_) {\n    r.append(\"\\n  LogNumber: \");\n    AppendNumberTo(&r, log_number_);\n  }\n  if (has_prev_log_number_) {\n    r.append(\"\\n  PrevLogNumber: \");\n    AppendNumberTo(&r, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    r.append(\"\\n  NextFile: \");\n    AppendNumberTo(&r, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    r.append(\"\\n  LastSeq: \");\n    AppendNumberTo(&r, last_sequence_);\n  }\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    r.append(\"\\n  CompactPointer: \");\n    AppendNumberTo(&r, compact_pointers_[i].first);\n    r.append(\" \");\n    r.append(compact_pointers_[i].second.DebugString());\n  }\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    r.append(\"\\n  DeleteFile: \");\n    AppendNumberTo(&r, iter->first);\n    r.append(\" \");\n    AppendNumberTo(&r, iter->second);\n  }\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    r.append(\"\\n  AddFile: \");\n    AppendNumberTo(&r, new_files_[i].first);\n    r.append(\" \");\n    AppendNumberTo(&r, f.number);\n    r.append(\" \");\n    AppendNumberTo(&r, f.file_size);\n    r.append(\" \");\n    r.append(f.smallest.DebugString());\n    r.append(\" .. \");\n    r.append(f.largest.DebugString());\n  }\n  r.append(\"\\n}\\n\");\n  return r;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  std::string VersionEdit::DebugString() const {\n    std::string r;\n    r.append(\"VersionEdit {\");\n    if (has_comparator_) {\n      r.append(\"\\n  Comparator: \");\n      r.append(comparator_);\n    }\n    if (has_log_number_) {\n      r.append(\"\\n  LogNumber: \");\n      AppendNumberTo(&r, log_number_);\n    }\n    if (has_prev_log_number_) {\n      r.append(\"\\n  PrevLogNumber: \");\n      AppendNumberTo(&r, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      r.append(\"\\n  NextFile: \");\n      AppendNumberTo(&r, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      r.append(\"\\n  LastSeq: \");\n      AppendNumberTo(&r, last_sequence_);\n    }\n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      r.append(\"\\n  CompactPointer: \");\n      AppendNumberTo(&r, compact_pointers_[i].first);\n      r.append(\" \");\n      r.append(compact_pointers_[i].second.DebugString());\n    }\n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      r.append(\"\\n  DeleteFile: \");\n      AppendNumberTo(&r, iter->first);\n      r.append(\" \");\n      AppendNumberTo(&r, iter->second);\n    }\n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      r.append(\"\\n  AddFile: \");\n      AppendNumberTo(&r, new_files_[i].first);\n      r.append(\" \");\n      AppendNumberTo(&r, f.number);\n      r.append(\" \");\n      AppendNumberTo(&r, f.file_size);\n      r.append(\" \");\n      r.append(f.smallest.DebugString());\n      r.append(\" .. \");\n      r.append(f.largest.DebugString());\n    }\n    r.append(\"\\n}\\n\");\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->input",
          "args": [
            "0",
            "c->num_input_files(0) - 1"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "versions_->CompactRange",
          "args": [
            "m->level",
            "m->begin",
            "m->end"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CompactMemTable",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::BackgroundCompaction() {\n    mutex_.AssertHeld();\n  \n    if (imm_ != NULL) {\n      CompactMemTable();\n      return;\n    }\n  \n    Compaction* c;\n    bool is_manual = (manual_compaction_ != NULL);\n    InternalKey manual_end;\n    if (is_manual) {\n      ManualCompaction* m = manual_compaction_;\n      c = versions_->CompactRange(m->level, m->begin, m->end);\n      m->done = (c == NULL);\n      if (c != NULL) {\n        manual_end = c->input(0, c->num_input_files(0) - 1)->largest;\n      }\n      Log(options_.info_log,\n          \"Manual compaction at level-%d from %s .. %s; will stop at %s\\n\",\n          m->level,\n          (m->begin ? m->begin->DebugString().c_str() : \"(begin)\"),\n          (m->end ? m->end->DebugString().c_str() : \"(end)\"),\n          (m->done ? \"(end)\" : manual_end.DebugString().c_str()));\n    } else {\n      c = versions_->PickCompaction();\n    }\n  \n    Status status;\n    if (c == NULL) {\n      // Nothing to do\n    } else if (!is_manual && c->IsTrivialMove()) {\n      // Move file to next level\n      assert(c->num_input_files(0) == 1);\n      FileMetaData* f = c->input(0, 0);\n      c->edit()->DeleteFile(c->level(), f->number);\n      c->edit()->AddFile(c->level() + 1, f->number, f->file_size,\n                         f->smallest, f->largest);\n      status = versions_->LogAndApply(c->edit(), &mutex_);\n      if (!status.ok()) {\n        RecordBackgroundError(status);\n      }\n      VersionSet::LevelSummaryStorage tmp;\n      Log(options_.info_log, \"Moved #%lld to level-%d %lld bytes %s: %s\\n\",\n          static_cast<unsigned long long>(f->number),\n          c->level() + 1,\n          static_cast<unsigned long long>(f->file_size),\n          status.ToString().c_str(),\n          versions_->LevelSummary(&tmp));\n    } else {\n      CompactionState* compact = new CompactionState(c);\n      status = DoCompactionWork(compact);\n      if (!status.ok()) {\n        RecordBackgroundError(status);\n      }\n      CleanupCompaction(compact);\n      c->ReleaseInputs();\n      DeleteObsoleteFiles();\n    }\n    delete c;\n  \n    if (status.ok()) {\n      // Done\n    } else if (shutting_down_.Acquire_Load()) {\n      // Ignore compaction errors found during shutting down\n    } else {\n      Log(options_.info_log,\n          \"Compaction error: %s\", status.ToString().c_str());\n    }\n  \n    if (is_manual) {\n      ManualCompaction* m = manual_compaction_;\n      if (!status.ok()) {\n        m->done = true;\n      }\n      if (!m->done) {\n        // We only compacted part of the requested range.  Update *m\n        // to the range that is left to be compacted.\n        m->tmp_storage = manual_end;\n        m->begin = &m->tmp_storage;\n      }\n      manual_compaction_ = NULL;\n    }\n  }\n}"
  },
  {
    "function_name": "BackgroundCall",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "636-653",
    "snippet": "void DBImpl::BackgroundCall() {\n  MutexLock l(&mutex_);\n  assert(bg_compaction_scheduled_);\n  if (shutting_down_.Acquire_Load()) {\n    // No more background work when shutting down.\n  } else if (!bg_error_.ok()) {\n    // No more background work after a background error.\n  } else {\n    BackgroundCompaction();\n  }\n\n  bg_compaction_scheduled_ = false;\n\n  // Previous compaction may have produced too many files in a level,\n  // so reschedule another compaction if needed.\n  MaybeScheduleCompaction();\n  bg_cv_.SignalAll();\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_cv_.SignalAll",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "SignalAll",
          "container": "CondVar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "110-118",
          "snippet": "void CondVar::SignalAll() {\n  wait_mtx_.Lock();\n  ::ReleaseSemaphore(sem1_, waiting_, NULL);\n  while(waiting_ > 0) {\n    --waiting_;\n    ::WaitForSingleObject(sem2_, INFINITE);\n  }\n  wait_mtx_.Unlock();\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nCondVar {\n  void CondVar::SignalAll() {\n    wait_mtx_.Lock();\n    ::ReleaseSemaphore(sem1_, waiting_, NULL);\n    while(waiting_ > 0) {\n      --waiting_;\n      ::WaitForSingleObject(sem2_, INFINITE);\n    }\n    wait_mtx_.Unlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaybeScheduleCompaction",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeScheduleCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "614-630",
          "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BackgroundCompaction",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "BackgroundCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "655-738",
          "snippet": "void DBImpl::BackgroundCompaction() {\n  mutex_.AssertHeld();\n\n  if (imm_ != NULL) {\n    CompactMemTable();\n    return;\n  }\n\n  Compaction* c;\n  bool is_manual = (manual_compaction_ != NULL);\n  InternalKey manual_end;\n  if (is_manual) {\n    ManualCompaction* m = manual_compaction_;\n    c = versions_->CompactRange(m->level, m->begin, m->end);\n    m->done = (c == NULL);\n    if (c != NULL) {\n      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;\n    }\n    Log(options_.info_log,\n        \"Manual compaction at level-%d from %s .. %s; will stop at %s\\n\",\n        m->level,\n        (m->begin ? m->begin->DebugString().c_str() : \"(begin)\"),\n        (m->end ? m->end->DebugString().c_str() : \"(end)\"),\n        (m->done ? \"(end)\" : manual_end.DebugString().c_str()));\n  } else {\n    c = versions_->PickCompaction();\n  }\n\n  Status status;\n  if (c == NULL) {\n    // Nothing to do\n  } else if (!is_manual && c->IsTrivialMove()) {\n    // Move file to next level\n    assert(c->num_input_files(0) == 1);\n    FileMetaData* f = c->input(0, 0);\n    c->edit()->DeleteFile(c->level(), f->number);\n    c->edit()->AddFile(c->level() + 1, f->number, f->file_size,\n                       f->smallest, f->largest);\n    status = versions_->LogAndApply(c->edit(), &mutex_);\n    if (!status.ok()) {\n      RecordBackgroundError(status);\n    }\n    VersionSet::LevelSummaryStorage tmp;\n    Log(options_.info_log, \"Moved #%lld to level-%d %lld bytes %s: %s\\n\",\n        static_cast<unsigned long long>(f->number),\n        c->level() + 1,\n        static_cast<unsigned long long>(f->file_size),\n        status.ToString().c_str(),\n        versions_->LevelSummary(&tmp));\n  } else {\n    CompactionState* compact = new CompactionState(c);\n    status = DoCompactionWork(compact);\n    if (!status.ok()) {\n      RecordBackgroundError(status);\n    }\n    CleanupCompaction(compact);\n    c->ReleaseInputs();\n    DeleteObsoleteFiles();\n  }\n  delete c;\n\n  if (status.ok()) {\n    // Done\n  } else if (shutting_down_.Acquire_Load()) {\n    // Ignore compaction errors found during shutting down\n  } else {\n    Log(options_.info_log,\n        \"Compaction error: %s\", status.ToString().c_str());\n  }\n\n  if (is_manual) {\n    ManualCompaction* m = manual_compaction_;\n    if (!status.ok()) {\n      m->done = true;\n    }\n    if (!m->done) {\n      // We only compacted part of the requested range.  Update *m\n      // to the range that is left to be compacted.\n      m->tmp_storage = manual_end;\n      m->begin = &m->tmp_storage;\n    }\n    manual_compaction_ = NULL;\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::BackgroundCompaction() {\n    mutex_.AssertHeld();\n  \n    if (imm_ != NULL) {\n      CompactMemTable();\n      return;\n    }\n  \n    Compaction* c;\n    bool is_manual = (manual_compaction_ != NULL);\n    InternalKey manual_end;\n    if (is_manual) {\n      ManualCompaction* m = manual_compaction_;\n      c = versions_->CompactRange(m->level, m->begin, m->end);\n      m->done = (c == NULL);\n      if (c != NULL) {\n        manual_end = c->input(0, c->num_input_files(0) - 1)->largest;\n      }\n      Log(options_.info_log,\n          \"Manual compaction at level-%d from %s .. %s; will stop at %s\\n\",\n          m->level,\n          (m->begin ? m->begin->DebugString().c_str() : \"(begin)\"),\n          (m->end ? m->end->DebugString().c_str() : \"(end)\"),\n          (m->done ? \"(end)\" : manual_end.DebugString().c_str()));\n    } else {\n      c = versions_->PickCompaction();\n    }\n  \n    Status status;\n    if (c == NULL) {\n      // Nothing to do\n    } else if (!is_manual && c->IsTrivialMove()) {\n      // Move file to next level\n      assert(c->num_input_files(0) == 1);\n      FileMetaData* f = c->input(0, 0);\n      c->edit()->DeleteFile(c->level(), f->number);\n      c->edit()->AddFile(c->level() + 1, f->number, f->file_size,\n                         f->smallest, f->largest);\n      status = versions_->LogAndApply(c->edit(), &mutex_);\n      if (!status.ok()) {\n        RecordBackgroundError(status);\n      }\n      VersionSet::LevelSummaryStorage tmp;\n      Log(options_.info_log, \"Moved #%lld to level-%d %lld bytes %s: %s\\n\",\n          static_cast<unsigned long long>(f->number),\n          c->level() + 1,\n          static_cast<unsigned long long>(f->file_size),\n          status.ToString().c_str(),\n          versions_->LevelSummary(&tmp));\n    } else {\n      CompactionState* compact = new CompactionState(c);\n      status = DoCompactionWork(compact);\n      if (!status.ok()) {\n        RecordBackgroundError(status);\n      }\n      CleanupCompaction(compact);\n      c->ReleaseInputs();\n      DeleteObsoleteFiles();\n    }\n    delete c;\n  \n    if (status.ok()) {\n      // Done\n    } else if (shutting_down_.Acquire_Load()) {\n      // Ignore compaction errors found during shutting down\n    } else {\n      Log(options_.info_log,\n          \"Compaction error: %s\", status.ToString().c_str());\n    }\n  \n    if (is_manual) {\n      ManualCompaction* m = manual_compaction_;\n      if (!status.ok()) {\n        m->done = true;\n      }\n      if (!m->done) {\n        // We only compacted part of the requested range.  Update *m\n        // to the range that is left to be compacted.\n        m->tmp_storage = manual_end;\n        m->begin = &m->tmp_storage;\n      }\n      manual_compaction_ = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bg_compaction_scheduled_"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::BackgroundCall() {\n    MutexLock l(&mutex_);\n    assert(bg_compaction_scheduled_);\n    if (shutting_down_.Acquire_Load()) {\n      // No more background work when shutting down.\n    } else if (!bg_error_.ok()) {\n      // No more background work after a background error.\n    } else {\n      BackgroundCompaction();\n    }\n  \n    bg_compaction_scheduled_ = false;\n  \n    // Previous compaction may have produced too many files in a level,\n    // so reschedule another compaction if needed.\n    MaybeScheduleCompaction();\n    bg_cv_.SignalAll();\n  }\n}"
  },
  {
    "function_name": "BGWork",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "632-634",
    "snippet": "void DBImpl::BGWork(void* db) {\n  reinterpret_cast<DBImpl*>(db)->BackgroundCall();\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::BGWork(void* db) {\n    reinterpret_cast<DBImpl*>(db)->BackgroundCall();\n  }\n}"
  },
  {
    "function_name": "MaybeScheduleCompaction",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "614-630",
    "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_->Schedule",
          "args": [
            "&DBImpl::BGWork",
            "this"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "Schedule",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "878-883",
          "snippet": "void Win32Env::Schedule( void (*function)(void* arg), void* arg )\n{\n    QueueUserWorkItem(Win32::WorkItemWrapperProc,\n                      new Win32::WorkItemWrapper(function,arg),\n                      WT_EXECUTEDEFAULT);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  void Win32Env::Schedule( void (*function)(void* arg), void* arg )\n  {\n      QueueUserWorkItem(Win32::WorkItemWrapperProc,\n                        new Win32::WorkItemWrapper(function,arg),\n                        WT_EXECUTEDEFAULT);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->NeedsCompaction",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "NeedsCompaction",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "251-254",
          "snippet": "bool NeedsCompaction() const {\n    Version* v = current_;\n    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  bool NeedsCompaction() const {\n      Version* v = current_;\n      return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
  },
  {
    "function_name": "RecordBackgroundError",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "606-612",
    "snippet": "void DBImpl::RecordBackgroundError(const Status& s) {\n  mutex_.AssertHeld();\n  if (bg_error_.ok()) {\n    bg_error_ = s;\n    bg_cv_.SignalAll();\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_cv_.SignalAll",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "SignalAll",
          "container": "CondVar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "110-118",
          "snippet": "void CondVar::SignalAll() {\n  wait_mtx_.Lock();\n  ::ReleaseSemaphore(sem1_, waiting_, NULL);\n  while(waiting_ > 0) {\n    --waiting_;\n    ::WaitForSingleObject(sem2_, INFINITE);\n  }\n  wait_mtx_.Unlock();\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nCondVar {\n  void CondVar::SignalAll() {\n    wait_mtx_.Lock();\n    ::ReleaseSemaphore(sem1_, waiting_, NULL);\n    while(waiting_ > 0) {\n      --waiting_;\n      ::WaitForSingleObject(sem2_, INFINITE);\n    }\n    wait_mtx_.Unlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordBackgroundError(const Status& s) {\n    mutex_.AssertHeld();\n    if (bg_error_.ok()) {\n      bg_error_ = s;\n      bg_cv_.SignalAll();\n    }\n  }\n}"
  },
  {
    "function_name": "TEST_CompactMemTable",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "590-604",
    "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_cv_.Wait",
          "args": [],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "WriteOptions()",
            "NULL"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "TEST_CompactRange",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "553-588",
    "snippet": "void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n  assert(level >= 0);\n  assert(level + 1 < config::kNumLevels);\n\n  InternalKey begin_storage, end_storage;\n\n  ManualCompaction manual;\n  manual.level = level;\n  manual.done = false;\n  if (begin == NULL) {\n    manual.begin = NULL;\n  } else {\n    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n    manual.begin = &begin_storage;\n  }\n  if (end == NULL) {\n    manual.end = NULL;\n  } else {\n    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n    manual.end = &end_storage;\n  }\n\n  MutexLock l(&mutex_);\n  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n    if (manual_compaction_ == NULL) {  // Idle\n      manual_compaction_ = &manual;\n      MaybeScheduleCompaction();\n    } else {  // Running either my compaction or another compaction.\n      bg_cv_.Wait();\n    }\n  }\n  if (manual_compaction_ == &manual) {\n    // Cancel my manual compaction since we aborted early for some reason.\n    manual_compaction_ = NULL;\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_cv_.Wait",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaybeScheduleCompaction",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeScheduleCompaction",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "614-630",
          "snippet": "void DBImpl::MaybeScheduleCompaction() {\n  mutex_.AssertHeld();\n  if (bg_compaction_scheduled_) {\n    // Already scheduled\n  } else if (shutting_down_.Acquire_Load()) {\n    // DB is being deleted; no more background compactions\n  } else if (!bg_error_.ok()) {\n    // Already got an error; no more changes\n  } else if (imm_ == NULL &&\n             manual_compaction_ == NULL &&\n             !versions_->NeedsCompaction()) {\n    // No work to be done\n  } else {\n    bg_compaction_scheduled_ = true;\n    env_->Schedule(&DBImpl::BGWork, this);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeScheduleCompaction() {\n    mutex_.AssertHeld();\n    if (bg_compaction_scheduled_) {\n      // Already scheduled\n    } else if (shutting_down_.Acquire_Load()) {\n      // DB is being deleted; no more background compactions\n    } else if (!bg_error_.ok()) {\n      // Already got an error; no more changes\n    } else if (imm_ == NULL &&\n               manual_compaction_ == NULL &&\n               !versions_->NeedsCompaction()) {\n      // No work to be done\n    } else {\n      bg_compaction_scheduled_ = true;\n      env_->Schedule(&DBImpl::BGWork, this);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InternalKey",
          "args": [
            "*end",
            "0",
            "static_cast<ValueType>(0)"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "InternalKey",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "149-151",
          "snippet": "InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {\n    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {\n      AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<ValueType>",
          "args": [
            "0"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level + 1 < config::kNumLevels"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level >= 0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n    assert(level >= 0);\n    assert(level + 1 < config::kNumLevels);\n  \n    InternalKey begin_storage, end_storage;\n  \n    ManualCompaction manual;\n    manual.level = level;\n    manual.done = false;\n    if (begin == NULL) {\n      manual.begin = NULL;\n    } else {\n      begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n      manual.begin = &begin_storage;\n    }\n    if (end == NULL) {\n      manual.end = NULL;\n    } else {\n      end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n      manual.end = &end_storage;\n    }\n  \n    MutexLock l(&mutex_);\n    while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n      if (manual_compaction_ == NULL) {  // Idle\n        manual_compaction_ = &manual;\n        MaybeScheduleCompaction();\n      } else {  // Running either my compaction or another compaction.\n        bg_cv_.Wait();\n      }\n    }\n    if (manual_compaction_ == &manual) {\n      // Cancel my manual compaction since we aborted early for some reason.\n      manual_compaction_ = NULL;\n    }\n  }\n}"
  },
  {
    "function_name": "CompactRange",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "536-551",
    "snippet": "void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n  int max_level_with_files = 1;\n  {\n    MutexLock l(&mutex_);\n    Version* base = versions_->current();\n    for (int level = 1; level < config::kNumLevels; level++) {\n      if (base->OverlapInLevel(level, begin, end)) {\n        max_level_with_files = level;\n      }\n    }\n  }\n  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n  for (int level = 0; level < max_level_with_files; level++) {\n    TEST_CompactRange(level, begin, end);\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEST_CompactRange",
          "args": [
            "level",
            "begin",
            "end"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "553-588",
          "snippet": "void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n  assert(level >= 0);\n  assert(level + 1 < config::kNumLevels);\n\n  InternalKey begin_storage, end_storage;\n\n  ManualCompaction manual;\n  manual.level = level;\n  manual.done = false;\n  if (begin == NULL) {\n    manual.begin = NULL;\n  } else {\n    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n    manual.begin = &begin_storage;\n  }\n  if (end == NULL) {\n    manual.end = NULL;\n  } else {\n    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n    manual.end = &end_storage;\n  }\n\n  MutexLock l(&mutex_);\n  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n    if (manual_compaction_ == NULL) {  // Idle\n      manual_compaction_ = &manual;\n      MaybeScheduleCompaction();\n    } else {  // Running either my compaction or another compaction.\n      bg_cv_.Wait();\n    }\n  }\n  if (manual_compaction_ == &manual) {\n    // Cancel my manual compaction since we aborted early for some reason.\n    manual_compaction_ = NULL;\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n    assert(level >= 0);\n    assert(level + 1 < config::kNumLevels);\n  \n    InternalKey begin_storage, end_storage;\n  \n    ManualCompaction manual;\n    manual.level = level;\n    manual.done = false;\n    if (begin == NULL) {\n      manual.begin = NULL;\n    } else {\n      begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n      manual.begin = &begin_storage;\n    }\n    if (end == NULL) {\n      manual.end = NULL;\n    } else {\n      end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n      manual.end = &end_storage;\n    }\n  \n    MutexLock l(&mutex_);\n    while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {\n      if (manual_compaction_ == NULL) {  // Idle\n        manual_compaction_ = &manual;\n        MaybeScheduleCompaction();\n      } else {  // Running either my compaction or another compaction.\n        bg_cv_.Wait();\n      }\n    }\n    if (manual_compaction_ == &manual) {\n      // Cancel my manual compaction since we aborted early for some reason.\n      manual_compaction_ = NULL;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_CompactMemTable",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->OverlapInLevel",
          "args": [
            "level",
            "begin",
            "end"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "OverlapInLevel",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "500-505",
          "snippet": "bool Version::OverlapInLevel(int level,\n                             const Slice* smallest_user_key,\n                             const Slice* largest_user_key) {\n  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n                               smallest_user_key, largest_user_key);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::OverlapInLevel(int level,\n                               const Slice* smallest_user_key,\n                               const Slice* largest_user_key) {\n    return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n                                 smallest_user_key, largest_user_key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n    int max_level_with_files = 1;\n    {\n      MutexLock l(&mutex_);\n      Version* base = versions_->current();\n      for (int level = 1; level < config::kNumLevels; level++) {\n        if (base->OverlapInLevel(level, begin, end)) {\n          max_level_with_files = level;\n        }\n      }\n    }\n    TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n    for (int level = 0; level < max_level_with_files; level++) {\n      TEST_CompactRange(level, begin, end);\n    }\n  }\n}"
  },
  {
    "function_name": "CompactMemTable",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "503-534",
    "snippet": "void DBImpl::CompactMemTable() {\n  mutex_.AssertHeld();\n  assert(imm_ != NULL);\n\n  // Save the contents of the memtable as a new Table\n  VersionEdit edit;\n  Version* base = versions_->current();\n  base->Ref();\n  Status s = WriteLevel0Table(imm_, &edit, base);\n  base->Unref();\n\n  if (s.ok() && shutting_down_.Acquire_Load()) {\n    s = Status::IOError(\"Deleting DB during memtable compaction\");\n  }\n\n  // Replace immutable memtable with the generated Table\n  if (s.ok()) {\n    edit.SetPrevLogNumber(0);\n    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed\n    s = versions_->LogAndApply(&edit, &mutex_);\n  }\n\n  if (s.ok()) {\n    // Commit to the new state\n    imm_->Unref();\n    imm_ = NULL;\n    has_imm_.Release_Store(NULL);\n    DeleteObsoleteFiles();\n  } else {\n    RecordBackgroundError(s);\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RecordBackgroundError",
          "args": [
            "s"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "RecordBackgroundError",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "606-612",
          "snippet": "void DBImpl::RecordBackgroundError(const Status& s) {\n  mutex_.AssertHeld();\n  if (bg_error_.ok()) {\n    bg_error_ = s;\n    bg_cv_.SignalAll();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordBackgroundError(const Status& s) {\n    mutex_.AssertHeld();\n    if (bg_error_.ok()) {\n      bg_error_ = s;\n      bg_cv_.SignalAll();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteObsoleteFiles",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteObsoleteFiles",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "218-272",
          "snippet": "void DBImpl::DeleteObsoleteFiles() {\n  if (!bg_error_.ok()) {\n    // After a background error, we don't know whether a new version may\n    // or may not have been committed, so we cannot safely garbage collect.\n    return;\n  }\n\n  // Make a set of all of the live files\n  std::set<uint64_t> live = pending_outputs_;\n  versions_->AddLiveFiles(&live);\n\n  std::vector<std::string> filenames;\n  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n  uint64_t number;\n  FileType type;\n  for (size_t i = 0; i < filenames.size(); i++) {\n    if (ParseFileName(filenames[i], &number, &type)) {\n      bool keep = true;\n      switch (type) {\n        case kLogFile:\n          keep = ((number >= versions_->LogNumber()) ||\n                  (number == versions_->PrevLogNumber()));\n          break;\n        case kDescriptorFile:\n          // Keep my manifest file, and any newer incarnations'\n          // (in case there is a race that allows other incarnations)\n          keep = (number >= versions_->ManifestFileNumber());\n          break;\n        case kTableFile:\n          keep = (live.find(number) != live.end());\n          break;\n        case kTempFile:\n          // Any temp files that are currently being written to must\n          // be recorded in pending_outputs_, which is inserted into \"live\"\n          keep = (live.find(number) != live.end());\n          break;\n        case kCurrentFile:\n        case kDBLockFile:\n        case kInfoLogFile:\n          keep = true;\n          break;\n      }\n\n      if (!keep) {\n        if (type == kTableFile) {\n          table_cache_->Evict(number);\n        }\n        Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n            int(type),\n            static_cast<unsigned long long>(number));\n        env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::DeleteObsoleteFiles() {\n    if (!bg_error_.ok()) {\n      // After a background error, we don't know whether a new version may\n      // or may not have been committed, so we cannot safely garbage collect.\n      return;\n    }\n  \n    // Make a set of all of the live files\n    std::set<uint64_t> live = pending_outputs_;\n    versions_->AddLiveFiles(&live);\n  \n    std::vector<std::string> filenames;\n    env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        bool keep = true;\n        switch (type) {\n          case kLogFile:\n            keep = ((number >= versions_->LogNumber()) ||\n                    (number == versions_->PrevLogNumber()));\n            break;\n          case kDescriptorFile:\n            // Keep my manifest file, and any newer incarnations'\n            // (in case there is a race that allows other incarnations)\n            keep = (number >= versions_->ManifestFileNumber());\n            break;\n          case kTableFile:\n            keep = (live.find(number) != live.end());\n            break;\n          case kTempFile:\n            // Any temp files that are currently being written to must\n            // be recorded in pending_outputs_, which is inserted into \"live\"\n            keep = (live.find(number) != live.end());\n            break;\n          case kCurrentFile:\n          case kDBLockFile:\n          case kInfoLogFile:\n            keep = true;\n            break;\n        }\n  \n        if (!keep) {\n          if (type == kTableFile) {\n            table_cache_->Evict(number);\n          }\n          Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n              int(type),\n              static_cast<unsigned long long>(number));\n          env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_imm_.Release_Store",
          "args": [
            "NULL"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "Release_Store",
          "container": "AtomicPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/atomic_pointer.h",
          "lines": "198-205",
          "snippet": "inline void Release_Store(void* v) {\n    __asm__ __volatile__ (\n        \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n        :\n        : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n        : \"memory\"\n        );\n  }",
          "includes": [
            "#include <libkern/OSAtomic.h>",
            "#include <windows.h>",
            "#include <cstdatomic>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libkern/OSAtomic.h>\n#include <windows.h>\n#include <cstdatomic>\n#include <stdint.h>\n\nAtomicPointer {\n  inline void Release_Store(void* v) {\n      __asm__ __volatile__ (\n          \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n          :\n          : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n          : \"memory\"\n          );\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "imm_->Unref",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->LogAndApply",
          "args": [
            "&edit",
            "&mutex_"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "LogAndApply",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "825-908",
          "snippet": "Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n  if (edit->has_log_number_) {\n    assert(edit->log_number_ >= log_number_);\n    assert(edit->log_number_ < next_file_number_);\n  } else {\n    edit->SetLogNumber(log_number_);\n  }\n\n  if (!edit->has_prev_log_number_) {\n    edit->SetPrevLogNumber(prev_log_number_);\n  }\n\n  edit->SetNextFile(next_file_number_);\n  edit->SetLastSequence(last_sequence_);\n\n  Version* v = new Version(this);\n  {\n    Builder builder(this, current_);\n    builder.Apply(edit);\n    builder.SaveTo(v);\n  }\n  Finalize(v);\n\n  // Initialize new descriptor log file if necessary by creating\n  // a temporary file that contains a snapshot of the current version.\n  std::string new_manifest_file;\n  Status s;\n  if (descriptor_log_ == NULL) {\n    // No reason to unlock *mu here since we only hit this path in the\n    // first call to LogAndApply (when opening the database).\n    assert(descriptor_file_ == NULL);\n    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n    edit->SetNextFile(next_file_number_);\n    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n    if (s.ok()) {\n      descriptor_log_ = new log::Writer(descriptor_file_);\n      s = WriteSnapshot(descriptor_log_);\n    }\n  }\n\n  // Unlock during expensive MANIFEST log write\n  {\n    mu->Unlock();\n\n    // Write new record to MANIFEST log\n    if (s.ok()) {\n      std::string record;\n      edit->EncodeTo(&record);\n      s = descriptor_log_->AddRecord(record);\n      if (s.ok()) {\n        s = descriptor_file_->Sync();\n      }\n      if (!s.ok()) {\n        Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n      }\n    }\n\n    // If we just created a new descriptor file, install it by writing a\n    // new CURRENT file that points to it.\n    if (s.ok() && !new_manifest_file.empty()) {\n      s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n    }\n\n    mu->Lock();\n  }\n\n  // Install the new version\n  if (s.ok()) {\n    AppendVersion(v);\n    log_number_ = edit->log_number_;\n    prev_log_number_ = edit->prev_log_number_;\n  } else {\n    delete v;\n    if (!new_manifest_file.empty()) {\n      delete descriptor_log_;\n      delete descriptor_file_;\n      descriptor_log_ = NULL;\n      descriptor_file_ = NULL;\n      env_->DeleteFile(new_manifest_file);\n    }\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n    if (edit->has_log_number_) {\n      assert(edit->log_number_ >= log_number_);\n      assert(edit->log_number_ < next_file_number_);\n    } else {\n      edit->SetLogNumber(log_number_);\n    }\n  \n    if (!edit->has_prev_log_number_) {\n      edit->SetPrevLogNumber(prev_log_number_);\n    }\n  \n    edit->SetNextFile(next_file_number_);\n    edit->SetLastSequence(last_sequence_);\n  \n    Version* v = new Version(this);\n    {\n      Builder builder(this, current_);\n      builder.Apply(edit);\n      builder.SaveTo(v);\n    }\n    Finalize(v);\n  \n    // Initialize new descriptor log file if necessary by creating\n    // a temporary file that contains a snapshot of the current version.\n    std::string new_manifest_file;\n    Status s;\n    if (descriptor_log_ == NULL) {\n      // No reason to unlock *mu here since we only hit this path in the\n      // first call to LogAndApply (when opening the database).\n      assert(descriptor_file_ == NULL);\n      new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n      edit->SetNextFile(next_file_number_);\n      s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n      if (s.ok()) {\n        descriptor_log_ = new log::Writer(descriptor_file_);\n        s = WriteSnapshot(descriptor_log_);\n      }\n    }\n  \n    // Unlock during expensive MANIFEST log write\n    {\n      mu->Unlock();\n  \n      // Write new record to MANIFEST log\n      if (s.ok()) {\n        std::string record;\n        edit->EncodeTo(&record);\n        s = descriptor_log_->AddRecord(record);\n        if (s.ok()) {\n          s = descriptor_file_->Sync();\n        }\n        if (!s.ok()) {\n          Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n        }\n      }\n  \n      // If we just created a new descriptor file, install it by writing a\n      // new CURRENT file that points to it.\n      if (s.ok() && !new_manifest_file.empty()) {\n        s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n      }\n  \n      mu->Lock();\n    }\n  \n    // Install the new version\n    if (s.ok()) {\n      AppendVersion(v);\n      log_number_ = edit->log_number_;\n      prev_log_number_ = edit->prev_log_number_;\n    } else {\n      delete v;\n      if (!new_manifest_file.empty()) {\n        delete descriptor_log_;\n        delete descriptor_file_;\n        descriptor_log_ = NULL;\n        descriptor_file_ = NULL;\n        env_->DeleteFile(new_manifest_file);\n      }\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.SetLogNumber",
          "args": [
            "logfile_number_"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "SetLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "39-42",
          "snippet": "void SetLogNumber(uint64_t num) {\n    has_log_number_ = true;\n    log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetLogNumber(uint64_t num) {\n      has_log_number_ = true;\n      log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.SetPrevLogNumber",
          "args": [
            "0"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "SetPrevLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "43-46",
          "snippet": "void SetPrevLogNumber(uint64_t num) {\n    has_prev_log_number_ = true;\n    prev_log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetPrevLogNumber(uint64_t num) {\n      has_prev_log_number_ = true;\n      prev_log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::IOError",
          "args": [
            "\"Deleting DB during memtable compaction\""
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "IOError",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "47-49",
          "snippet": "static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kIOError, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kIOError, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Acquire_Load",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteLevel0Table",
          "args": [
            "imm_",
            "&edit",
            "base"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "WriteLevel0Table",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "457-501",
          "snippet": "Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n                                Version* base) {\n  mutex_.AssertHeld();\n  const uint64_t start_micros = env_->NowMicros();\n  FileMetaData meta;\n  meta.number = versions_->NewFileNumber();\n  pending_outputs_.insert(meta.number);\n  Iterator* iter = mem->NewIterator();\n  Log(options_.info_log, \"Level-0 table #%llu: started\",\n      (unsigned long long) meta.number);\n\n  Status s;\n  {\n    mutex_.Unlock();\n    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n    mutex_.Lock();\n  }\n\n  Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n      (unsigned long long) meta.number,\n      (unsigned long long) meta.file_size,\n      s.ToString().c_str());\n  delete iter;\n  pending_outputs_.erase(meta.number);\n\n\n  // Note that if file_size is zero, the file has been deleted and\n  // should not be added to the manifest.\n  int level = 0;\n  if (s.ok() && meta.file_size > 0) {\n    const Slice min_user_key = meta.smallest.user_key();\n    const Slice max_user_key = meta.largest.user_key();\n    if (base != NULL) {\n      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n    }\n    edit->AddFile(level, meta.number, meta.file_size,\n                  meta.smallest, meta.largest);\n  }\n\n  CompactionStats stats;\n  stats.micros = env_->NowMicros() - start_micros;\n  stats.bytes_written = meta.file_size;\n  stats_[level].Add(stats);\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n                                  Version* base) {\n    mutex_.AssertHeld();\n    const uint64_t start_micros = env_->NowMicros();\n    FileMetaData meta;\n    meta.number = versions_->NewFileNumber();\n    pending_outputs_.insert(meta.number);\n    Iterator* iter = mem->NewIterator();\n    Log(options_.info_log, \"Level-0 table #%llu: started\",\n        (unsigned long long) meta.number);\n  \n    Status s;\n    {\n      mutex_.Unlock();\n      s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n      mutex_.Lock();\n    }\n  \n    Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n        (unsigned long long) meta.number,\n        (unsigned long long) meta.file_size,\n        s.ToString().c_str());\n    delete iter;\n    pending_outputs_.erase(meta.number);\n  \n  \n    // Note that if file_size is zero, the file has been deleted and\n    // should not be added to the manifest.\n    int level = 0;\n    if (s.ok() && meta.file_size > 0) {\n      const Slice min_user_key = meta.smallest.user_key();\n      const Slice max_user_key = meta.largest.user_key();\n      if (base != NULL) {\n        level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n      }\n      edit->AddFile(level, meta.number, meta.file_size,\n                    meta.smallest, meta.largest);\n    }\n  \n    CompactionStats stats;\n    stats.micros = env_->NowMicros() - start_micros;\n    stats.bytes_written = meta.file_size;\n    stats_[level].Add(stats);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->Ref",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->current",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "imm_ != NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CompactMemTable() {\n    mutex_.AssertHeld();\n    assert(imm_ != NULL);\n  \n    // Save the contents of the memtable as a new Table\n    VersionEdit edit;\n    Version* base = versions_->current();\n    base->Ref();\n    Status s = WriteLevel0Table(imm_, &edit, base);\n    base->Unref();\n  \n    if (s.ok() && shutting_down_.Acquire_Load()) {\n      s = Status::IOError(\"Deleting DB during memtable compaction\");\n    }\n  \n    // Replace immutable memtable with the generated Table\n    if (s.ok()) {\n      edit.SetPrevLogNumber(0);\n      edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed\n      s = versions_->LogAndApply(&edit, &mutex_);\n    }\n  \n    if (s.ok()) {\n      // Commit to the new state\n      imm_->Unref();\n      imm_ = NULL;\n      has_imm_.Release_Store(NULL);\n      DeleteObsoleteFiles();\n    } else {\n      RecordBackgroundError(s);\n    }\n  }\n}"
  },
  {
    "function_name": "WriteLevel0Table",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "457-501",
    "snippet": "Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n                                Version* base) {\n  mutex_.AssertHeld();\n  const uint64_t start_micros = env_->NowMicros();\n  FileMetaData meta;\n  meta.number = versions_->NewFileNumber();\n  pending_outputs_.insert(meta.number);\n  Iterator* iter = mem->NewIterator();\n  Log(options_.info_log, \"Level-0 table #%llu: started\",\n      (unsigned long long) meta.number);\n\n  Status s;\n  {\n    mutex_.Unlock();\n    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n    mutex_.Lock();\n  }\n\n  Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n      (unsigned long long) meta.number,\n      (unsigned long long) meta.file_size,\n      s.ToString().c_str());\n  delete iter;\n  pending_outputs_.erase(meta.number);\n\n\n  // Note that if file_size is zero, the file has been deleted and\n  // should not be added to the manifest.\n  int level = 0;\n  if (s.ok() && meta.file_size > 0) {\n    const Slice min_user_key = meta.smallest.user_key();\n    const Slice max_user_key = meta.largest.user_key();\n    if (base != NULL) {\n      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n    }\n    edit->AddFile(level, meta.number, meta.file_size,\n                  meta.smallest, meta.largest);\n  }\n\n  CompactionStats stats;\n  stats.micros = env_->NowMicros() - start_micros;\n  stats.bytes_written = meta.file_size;\n  stats_[level].Add(stats);\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stats_[level].Add",
          "args": [
            "stats"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "DBImpl::CompactionStats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.h",
          "lines": "185-189",
          "snippet": "void Add(const CompactionStats& c) {\n      this->micros += c.micros;\n      this->bytes_read += c.bytes_read;\n      this->bytes_written += c.bytes_written;\n    }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/snapshot.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/dbformat.h\"",
            "#include <set>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/snapshot.h\"\n#include \"db/log_writer.h\"\n#include \"db/dbformat.h\"\n#include <set>\n#include <deque>\n\nDBImpl {\n  CompactionStats {\n    void Add(const CompactionStats& c) {\n          this->micros += c.micros;\n          this->bytes_read += c.bytes_read;\n          this->bytes_written += c.bytes_written;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NowMicros",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "NowMicros",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "901-907",
          "snippet": "uint64_t Win32Env::NowMicros()\n{\n#ifndef USE_VISTA_API\n#define GetTickCount64 GetTickCount\n#endif\n    return (uint64_t)(GetTickCount64()*1000);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [
            "#define GetTickCount64 GetTickCount"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\n#define GetTickCount64 GetTickCount\n\nWin32Env {\n  uint64_t Win32Env::NowMicros()\n  {\n  #ifndef USE_VISTA_API\n  #define GetTickCount64 GetTickCount\n  #endif\n      return (uint64_t)(GetTickCount64()*1000);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->AddFile",
          "args": [
            "level",
            "meta.number",
            "meta.file_size",
            "meta.smallest",
            "meta.largest"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "AddFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "62-72",
          "snippet": "void AddFile(int level, uint64_t file,\n               uint64_t file_size,\n               const InternalKey& smallest,\n               const InternalKey& largest) {\n    FileMetaData f;\n    f.number = file;\n    f.file_size = file_size;\n    f.smallest = smallest;\n    f.largest = largest;\n    new_files_.push_back(std::make_pair(level, f));\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void AddFile(int level, uint64_t file,\n                 uint64_t file_size,\n                 const InternalKey& smallest,\n                 const InternalKey& largest) {\n      FileMetaData f;\n      f.number = file;\n      f.file_size = file_size;\n      f.smallest = smallest;\n      f.largest = largest;\n      new_files_.push_back(std::make_pair(level, f));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->PickLevelForMemTableOutput",
          "args": [
            "min_user_key",
            "max_user_key"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "PickLevelForMemTableOutput",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "507-533",
          "snippet": "int Version::PickLevelForMemTableOutput(\n    const Slice& smallest_user_key,\n    const Slice& largest_user_key) {\n  int level = 0;\n  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {\n    // Push to next level if there is no overlap in next level,\n    // and the #bytes overlapping in the level after that are limited.\n    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);\n    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));\n    std::vector<FileMetaData*> overlaps;\n    while (level < config::kMaxMemCompactLevel) {\n      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n        break;\n      }\n      if (level + 2 < config::kNumLevels) {\n        // Check that file does not overlap too many grandparent bytes.\n        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n        const int64_t sum = TotalFileSize(overlaps);\n        if (sum > kMaxGrandParentOverlapBytes) {\n          break;\n        }\n      }\n      level++;\n    }\n  }\n  return level;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  int Version::PickLevelForMemTableOutput(\n      const Slice& smallest_user_key,\n      const Slice& largest_user_key) {\n    int level = 0;\n    if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {\n      // Push to next level if there is no overlap in next level,\n      // and the #bytes overlapping in the level after that are limited.\n      InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);\n      InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));\n      std::vector<FileMetaData*> overlaps;\n      while (level < config::kMaxMemCompactLevel) {\n        if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n          break;\n        }\n        if (level + 2 < config::kNumLevels) {\n          // Check that file does not overlap too many grandparent bytes.\n          GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n          const int64_t sum = TotalFileSize(overlaps);\n          if (sum > kMaxGrandParentOverlapBytes) {\n            break;\n          }\n        }\n        level++;\n      }\n    }\n    return level;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "meta.largest.user_key",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pending_outputs_.erase",
          "args": [
            "meta.number"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Level-0 table #%llu: %lld bytes %s\"",
            "(unsigned long long) meta.number",
            "(unsigned long long) meta.file_size",
            "s.ToString().c_str()"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildTable",
          "args": [
            "dbname_",
            "env_",
            "options_",
            "table_cache_",
            "iter",
            "&meta"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "BuildTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/builder.cc",
          "lines": "17-86",
          "snippet": "Status BuildTable(const std::string& dbname,\n                  Env* env,\n                  const Options& options,\n                  TableCache* table_cache,\n                  Iterator* iter,\n                  FileMetaData* meta) {\n  Status s;\n  meta->file_size = 0;\n  iter->SeekToFirst();\n\n  std::string fname = TableFileName(dbname, meta->number);\n  if (iter->Valid()) {\n    WritableFile* file;\n    s = env->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n\n    TableBuilder* builder = new TableBuilder(options, file);\n    meta->smallest.DecodeFrom(iter->key());\n    for (; iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      meta->largest.DecodeFrom(key);\n      builder->Add(key, iter->value());\n    }\n\n    // Finish and check for builder errors\n    if (s.ok()) {\n      s = builder->Finish();\n      if (s.ok()) {\n        meta->file_size = builder->FileSize();\n        assert(meta->file_size > 0);\n      }\n    } else {\n      builder->Abandon();\n    }\n    delete builder;\n\n    // Finish and check for file errors\n    if (s.ok()) {\n      s = file->Sync();\n    }\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (s.ok()) {\n      // Verify that the table is usable\n      Iterator* it = table_cache->NewIterator(ReadOptions(),\n                                              meta->number,\n                                              meta->file_size);\n      s = it->status();\n      delete it;\n    }\n  }\n\n  // Check for input iterator errors\n  if (!iter->status().ok()) {\n    s = iter->status();\n  }\n\n  if (s.ok() && meta->file_size > 0) {\n    // Keep it\n  } else {\n    env->DeleteFile(fname);\n  }\n  return s;\n}",
          "includes": [
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include \"db/builder.h\"\n\nStatus BuildTable(const std::string& dbname,\n                  Env* env,\n                  const Options& options,\n                  TableCache* table_cache,\n                  Iterator* iter,\n                  FileMetaData* meta) {\n  Status s;\n  meta->file_size = 0;\n  iter->SeekToFirst();\n\n  std::string fname = TableFileName(dbname, meta->number);\n  if (iter->Valid()) {\n    WritableFile* file;\n    s = env->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n\n    TableBuilder* builder = new TableBuilder(options, file);\n    meta->smallest.DecodeFrom(iter->key());\n    for (; iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      meta->largest.DecodeFrom(key);\n      builder->Add(key, iter->value());\n    }\n\n    // Finish and check for builder errors\n    if (s.ok()) {\n      s = builder->Finish();\n      if (s.ok()) {\n        meta->file_size = builder->FileSize();\n        assert(meta->file_size > 0);\n      }\n    } else {\n      builder->Abandon();\n    }\n    delete builder;\n\n    // Finish and check for file errors\n    if (s.ok()) {\n      s = file->Sync();\n    }\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (s.ok()) {\n      // Verify that the table is usable\n      Iterator* it = table_cache->NewIterator(ReadOptions(),\n                                              meta->number,\n                                              meta->file_size);\n      s = it->status();\n      delete it;\n    }\n  }\n\n  // Check for input iterator errors\n  if (!iter->status().ok()) {\n    s = iter->status();\n  }\n\n  if (s.ok() && meta->file_size > 0) {\n    // Keep it\n  } else {\n    env->DeleteFile(fname);\n  }\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Level-0 table #%llu: started\"",
            "(unsigned long long) meta.number"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverLogFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "362-455",
          "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::RecoverLogFile(uint64_t log_number,\n                                VersionEdit* edit,\n                                SequenceNumber* max_sequence) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      const char* fname;\n      Status* status;  // NULL if options_.paranoid_checks==false\n      virtual void Corruption(size_t bytes, const Status& s) {\n        Log(info_log, \"%s%s: dropping %d bytes; %s\",\n            (this->status == NULL ? \"(ignoring error) \" : \"\"),\n            fname, static_cast<int>(bytes), s.ToString().c_str());\n        if (this->status != NULL && this->status->ok()) *this->status = s;\n      }\n    };\n  \n    mutex_.AssertHeld();\n  \n    // Open the log file\n    std::string fname = LogFileName(dbname_, log_number);\n    SequentialFile* file;\n    Status status = env_->NewSequentialFile(fname, &file);\n    if (!status.ok()) {\n      MaybeIgnoreError(&status);\n      return status;\n    }\n  \n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.fname = fname.c_str();\n    reporter.status = (options_.paranoid_checks ? &status : NULL);\n    // We intentially make log::Reader do checksumming even if\n    // paranoid_checks==false so that corruptions cause entire commits\n    // to be skipped instead of propagating bad information (like overly\n    // large sequence numbers).\n    log::Reader reader(file, &reporter, true/*checksum*/,\n                       0/*initial_offset*/);\n    Log(options_.info_log, \"Recovering log #%llu\",\n        (unsigned long long) log_number);\n  \n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = NULL;\n    while (reader.ReadRecord(&record, &scratch) &&\n           status.ok()) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n  \n      if (mem == NULL) {\n        mem = new MemTable(internal_comparator_);\n        mem->Ref();\n      }\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      MaybeIgnoreError(&status);\n      if (!status.ok()) {\n        break;\n      }\n      const SequenceNumber last_seq =\n          WriteBatchInternal::Sequence(&batch) +\n          WriteBatchInternal::Count(&batch) - 1;\n      if (last_seq > *max_sequence) {\n        *max_sequence = last_seq;\n      }\n  \n      if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n        status = WriteLevel0Table(mem, edit, NULL);\n        if (!status.ok()) {\n          // Reflect errors immediately so that conditions like full\n          // file-systems cause the DB::Open() to fail.\n          break;\n        }\n        mem->Unref();\n        mem = NULL;\n      }\n    }\n  \n    if (status.ok() && mem != NULL) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      // Reflect errors immediately so that conditions like full\n      // file-systems cause the DB::Open() to fail.\n    }\n  \n    if (mem != NULL) mem->Unref();\n    delete file;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->NewIterator",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pending_outputs_.insert",
          "args": [
            "meta.number"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->NewFileNumber",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "NewFileNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "191-191",
          "snippet": "uint64_t NewFileNumber() { return next_file_number_++; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t NewFileNumber() { return next_file_number_++; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n                                  Version* base) {\n    mutex_.AssertHeld();\n    const uint64_t start_micros = env_->NowMicros();\n    FileMetaData meta;\n    meta.number = versions_->NewFileNumber();\n    pending_outputs_.insert(meta.number);\n    Iterator* iter = mem->NewIterator();\n    Log(options_.info_log, \"Level-0 table #%llu: started\",\n        (unsigned long long) meta.number);\n  \n    Status s;\n    {\n      mutex_.Unlock();\n      s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n      mutex_.Lock();\n    }\n  \n    Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n        (unsigned long long) meta.number,\n        (unsigned long long) meta.file_size,\n        s.ToString().c_str());\n    delete iter;\n    pending_outputs_.erase(meta.number);\n  \n  \n    // Note that if file_size is zero, the file has been deleted and\n    // should not be added to the manifest.\n    int level = 0;\n    if (s.ok() && meta.file_size > 0) {\n      const Slice min_user_key = meta.smallest.user_key();\n      const Slice max_user_key = meta.largest.user_key();\n      if (base != NULL) {\n        level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n      }\n      edit->AddFile(level, meta.number, meta.file_size,\n                    meta.smallest, meta.largest);\n    }\n  \n    CompactionStats stats;\n    stats.micros = env_->NowMicros() - start_micros;\n    stats.bytes_written = meta.file_size;\n    stats_[level].Add(stats);\n    return s;\n  }\n}"
  },
  {
    "function_name": "RecoverLogFile",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "362-455",
    "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem->Unref",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteLevel0Table",
          "args": [
            "mem",
            "edit",
            "NULL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "WriteLevel0Table",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "457-501",
          "snippet": "Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n                                Version* base) {\n  mutex_.AssertHeld();\n  const uint64_t start_micros = env_->NowMicros();\n  FileMetaData meta;\n  meta.number = versions_->NewFileNumber();\n  pending_outputs_.insert(meta.number);\n  Iterator* iter = mem->NewIterator();\n  Log(options_.info_log, \"Level-0 table #%llu: started\",\n      (unsigned long long) meta.number);\n\n  Status s;\n  {\n    mutex_.Unlock();\n    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n    mutex_.Lock();\n  }\n\n  Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n      (unsigned long long) meta.number,\n      (unsigned long long) meta.file_size,\n      s.ToString().c_str());\n  delete iter;\n  pending_outputs_.erase(meta.number);\n\n\n  // Note that if file_size is zero, the file has been deleted and\n  // should not be added to the manifest.\n  int level = 0;\n  if (s.ok() && meta.file_size > 0) {\n    const Slice min_user_key = meta.smallest.user_key();\n    const Slice max_user_key = meta.largest.user_key();\n    if (base != NULL) {\n      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n    }\n    edit->AddFile(level, meta.number, meta.file_size,\n                  meta.smallest, meta.largest);\n  }\n\n  CompactionStats stats;\n  stats.micros = env_->NowMicros() - start_micros;\n  stats.bytes_written = meta.file_size;\n  stats_[level].Add(stats);\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n                                  Version* base) {\n    mutex_.AssertHeld();\n    const uint64_t start_micros = env_->NowMicros();\n    FileMetaData meta;\n    meta.number = versions_->NewFileNumber();\n    pending_outputs_.insert(meta.number);\n    Iterator* iter = mem->NewIterator();\n    Log(options_.info_log, \"Level-0 table #%llu: started\",\n        (unsigned long long) meta.number);\n  \n    Status s;\n    {\n      mutex_.Unlock();\n      s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n      mutex_.Lock();\n    }\n  \n    Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n        (unsigned long long) meta.number,\n        (unsigned long long) meta.file_size,\n        s.ToString().c_str());\n    delete iter;\n    pending_outputs_.erase(meta.number);\n  \n  \n    // Note that if file_size is zero, the file has been deleted and\n    // should not be added to the manifest.\n    int level = 0;\n    if (s.ok() && meta.file_size > 0) {\n      const Slice min_user_key = meta.smallest.user_key();\n      const Slice max_user_key = meta.largest.user_key();\n      if (base != NULL) {\n        level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n      }\n      edit->AddFile(level, meta.number, meta.file_size,\n                    meta.smallest, meta.largest);\n    }\n  \n    CompactionStats stats;\n    stats.micros = env_->NowMicros() - start_micros;\n    stats.bytes_written = meta.file_size;\n    stats_[level].Add(stats);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->ApproximateMemoryUsage",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ApproximateMemoryUsage",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "31-31",
          "snippet": "size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Count",
          "args": [
            "&batch"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "Count",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "82-84",
          "snippet": "int WriteBatchInternal::Count(const WriteBatch* b) {\n  return DecodeFixed32(b->rep_.data() + 8);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  int WriteBatchInternal::Count(const WriteBatch* b) {\n    return DecodeFixed32(b->rep_.data() + 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Sequence",
          "args": [
            "&batch"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "Sequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "90-92",
          "snippet": "SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n  return SequenceNumber(DecodeFixed64(b->rep_.data()));\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n    return SequenceNumber(DecodeFixed64(b->rep_.data()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaybeIgnoreError",
          "args": [
            "&status"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeIgnoreError",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "209-216",
          "snippet": "void DBImpl::MaybeIgnoreError(Status* s) const {\n  if (s->ok() || options_.paranoid_checks) {\n    // No change needed\n  } else {\n    Log(options_.info_log, \"Ignoring error %s\", s->ToString().c_str());\n    *s = Status::OK();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeIgnoreError(Status* s) const {\n    if (s->ok() || options_.paranoid_checks) {\n      // No change needed\n    } else {\n      Log(options_.info_log, \"Ignoring error %s\", s->ToString().c_str());\n      *s = Status::OK();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::InsertInto",
          "args": [
            "&batch",
            "mem"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "InsertInto",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "128-134",
          "snippet": "Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                      MemTable* memtable) {\n  MemTableInserter inserter;\n  inserter.sequence_ = WriteBatchInternal::Sequence(b);\n  inserter.mem_ = memtable;\n  return b->Iterate(&inserter);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                        MemTable* memtable) {\n    MemTableInserter inserter;\n    inserter.sequence_ = WriteBatchInternal::Sequence(b);\n    inserter.mem_ = memtable;\n    return b->Iterate(&inserter);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->Ref",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetContents",
          "args": [
            "&batch",
            "record"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "SetContents",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "136-139",
          "snippet": "void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n  assert(contents.size() >= kHeader);\n  b->rep_.assign(contents.data(), contents.size());\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n    assert(contents.size() >= kHeader);\n    b->rep_.assign(contents.data(), contents.size());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reporter.Corruption",
          "args": [
            "record.size()",
            "Status::Corruption(\"log record too small\")"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "CorruptionReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "38-42",
          "snippet": "virtual void Corruption(size_t bytes, const Status& status) {\n    printf(\"corruption: %d bytes; %s\\n\",\n            static_cast<int>(bytes),\n            status.ToString().c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nCorruptionReporter {\n  virtual void Corruption(size_t bytes, const Status& status) {\n      printf(\"corruption: %d bytes; %s\\n\",\n              static_cast<int>(bytes),\n              status.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"log record too small\""
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "record.size",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.ReadRecord",
          "args": [
            "&record",
            "&scratch"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ReadRecord",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "59-162",
          "snippet": "bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n  if (last_record_offset_ < initial_offset_) {\n    if (!SkipToInitialBlock()) {\n      return false;\n    }\n  }\n\n  scratch->clear();\n  record->clear();\n  bool in_fragmented_record = false;\n  // Record offset of the logical record that we're reading\n  // 0 is a dummy value to make compilers happy\n  uint64_t prospective_record_offset = 0;\n\n  Slice fragment;\n  while (true) {\n    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n    const unsigned int record_type = ReadPhysicalRecord(&fragment);\n    switch (record_type) {\n      case kFullType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(1)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->clear();\n        *record = fragment;\n        last_record_offset_ = prospective_record_offset;\n        return true;\n\n      case kFirstType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(2)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->assign(fragment.data(), fragment.size());\n        in_fragmented_record = true;\n        break;\n\n      case kMiddleType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(1)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n        }\n        break;\n\n      case kLastType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(2)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n          *record = Slice(*scratch);\n          last_record_offset_ = prospective_record_offset;\n          return true;\n        }\n        break;\n\n      case kEof:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"partial record without end(3)\");\n          scratch->clear();\n        }\n        return false;\n\n      case kBadRecord:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"error in middle of record\");\n          in_fragmented_record = false;\n          scratch->clear();\n        }\n        break;\n\n      default: {\n        char buf[40];\n        snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n        ReportCorruption(\n            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n            buf);\n        in_fragmented_record = false;\n        scratch->clear();\n        break;\n      }\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n    if (last_record_offset_ < initial_offset_) {\n      if (!SkipToInitialBlock()) {\n        return false;\n      }\n    }\n  \n    scratch->clear();\n    record->clear();\n    bool in_fragmented_record = false;\n    // Record offset of the logical record that we're reading\n    // 0 is a dummy value to make compilers happy\n    uint64_t prospective_record_offset = 0;\n  \n    Slice fragment;\n    while (true) {\n      uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n      const unsigned int record_type = ReadPhysicalRecord(&fragment);\n      switch (record_type) {\n        case kFullType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(1)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->clear();\n          *record = fragment;\n          last_record_offset_ = prospective_record_offset;\n          return true;\n  \n        case kFirstType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(2)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->assign(fragment.data(), fragment.size());\n          in_fragmented_record = true;\n          break;\n  \n        case kMiddleType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(1)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n          }\n          break;\n  \n        case kLastType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(2)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n            *record = Slice(*scratch);\n            last_record_offset_ = prospective_record_offset;\n            return true;\n          }\n          break;\n  \n        case kEof:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"partial record without end(3)\");\n            scratch->clear();\n          }\n          return false;\n  \n        case kBadRecord:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"error in middle of record\");\n            in_fragmented_record = false;\n            scratch->clear();\n          }\n          break;\n  \n        default: {\n          char buf[40];\n          snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n          ReportCorruption(\n              (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n              buf);\n          in_fragmented_record = false;\n          scratch->clear();\n          break;\n        }\n      }\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Recovering log #%llu\"",
            "(unsigned long long) log_number"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverLogFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "362-455",
          "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [
            "fname",
            "&file"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "951-964",
          "snippet": "Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n{\n    Status sRet;\n    std::string path = fname;\n    ModifyPath(path);\n    Win32SequentialFile* pFile = new Win32SequentialFile(path);\n    if(pFile->isEnable()){\n        *result = pFile;\n    }else {\n        delete pFile;\n        sRet = Status::IOError(path, Win32::GetLastErrSz());\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n  {\n      Status sRet;\n      std::string path = fname;\n      ModifyPath(path);\n      Win32SequentialFile* pFile = new Win32SequentialFile(path);\n      if(pFile->isEnable()){\n          *result = pFile;\n      }else {\n          delete pFile;\n          sRet = Status::IOError(path, Win32::GetLastErrSz());\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogFileName",
          "args": [
            "dbname_",
            "log_number"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "LogFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "27-30",
          "snippet": "std::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "info_log",
            "\"%s%s: dropping %d bytes; %s\"",
            "(this->status == NULL ? \"(ignoring error) \" : \"\")",
            "fname",
            "static_cast<int>(bytes)",
            "s.ToString().c_str()"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "bytes"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::RecoverLogFile(uint64_t log_number,\n                                VersionEdit* edit,\n                                SequenceNumber* max_sequence) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      const char* fname;\n      Status* status;  // NULL if options_.paranoid_checks==false\n      virtual void Corruption(size_t bytes, const Status& s) {\n        Log(info_log, \"%s%s: dropping %d bytes; %s\",\n            (this->status == NULL ? \"(ignoring error) \" : \"\"),\n            fname, static_cast<int>(bytes), s.ToString().c_str());\n        if (this->status != NULL && this->status->ok()) *this->status = s;\n      }\n    };\n  \n    mutex_.AssertHeld();\n  \n    // Open the log file\n    std::string fname = LogFileName(dbname_, log_number);\n    SequentialFile* file;\n    Status status = env_->NewSequentialFile(fname, &file);\n    if (!status.ok()) {\n      MaybeIgnoreError(&status);\n      return status;\n    }\n  \n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.fname = fname.c_str();\n    reporter.status = (options_.paranoid_checks ? &status : NULL);\n    // We intentially make log::Reader do checksumming even if\n    // paranoid_checks==false so that corruptions cause entire commits\n    // to be skipped instead of propagating bad information (like overly\n    // large sequence numbers).\n    log::Reader reader(file, &reporter, true/*checksum*/,\n                       0/*initial_offset*/);\n    Log(options_.info_log, \"Recovering log #%llu\",\n        (unsigned long long) log_number);\n  \n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = NULL;\n    while (reader.ReadRecord(&record, &scratch) &&\n           status.ok()) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n  \n      if (mem == NULL) {\n        mem = new MemTable(internal_comparator_);\n        mem->Ref();\n      }\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      MaybeIgnoreError(&status);\n      if (!status.ok()) {\n        break;\n      }\n      const SequenceNumber last_seq =\n          WriteBatchInternal::Sequence(&batch) +\n          WriteBatchInternal::Count(&batch) - 1;\n      if (last_seq > *max_sequence) {\n        *max_sequence = last_seq;\n      }\n  \n      if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n        status = WriteLevel0Table(mem, edit, NULL);\n        if (!status.ok()) {\n          // Reflect errors immediately so that conditions like full\n          // file-systems cause the DB::Open() to fail.\n          break;\n        }\n        mem->Unref();\n        mem = NULL;\n      }\n    }\n  \n    if (status.ok() && mem != NULL) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      // Reflect errors immediately so that conditions like full\n      // file-systems cause the DB::Open() to fail.\n    }\n  \n    if (mem != NULL) mem->Unref();\n    delete file;\n    return status;\n  }\n}"
  },
  {
    "function_name": "Recover",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "274-360",
    "snippet": "Status DBImpl::Recover(VersionEdit* edit) {\n  mutex_.AssertHeld();\n\n  // Ignore error from CreateDir since the creation of the DB is\n  // committed only when the descriptor is created, and this directory\n  // may already exist from a previous failed creation attempt.\n  env_->CreateDir(dbname_);\n  assert(db_lock_ == NULL);\n  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);\n  if (!s.ok()) {\n    return s;\n  }\n\n  if (!env_->FileExists(CurrentFileName(dbname_))) {\n    if (options_.create_if_missing) {\n      s = NewDB();\n      if (!s.ok()) {\n        return s;\n      }\n    } else {\n      return Status::InvalidArgument(\n          dbname_, \"does not exist (create_if_missing is false)\");\n    }\n  } else {\n    if (options_.error_if_exists) {\n      return Status::InvalidArgument(\n          dbname_, \"exists (error_if_exists is true)\");\n    }\n  }\n\n  s = versions_->Recover();\n  if (s.ok()) {\n    SequenceNumber max_sequence(0);\n\n    // Recover from all newer log files than the ones named in the\n    // descriptor (new log files may have been added by the previous\n    // incarnation without registering them in the descriptor).\n    //\n    // Note that PrevLogNumber() is no longer used, but we pay\n    // attention to it in case we are recovering a database\n    // produced by an older version of leveldb.\n    const uint64_t min_log = versions_->LogNumber();\n    const uint64_t prev_log = versions_->PrevLogNumber();\n    std::vector<std::string> filenames;\n    s = env_->GetChildren(dbname_, &filenames);\n    if (!s.ok()) {\n      return s;\n    }\n    std::set<uint64_t> expected;\n    versions_->AddLiveFiles(&expected);\n    uint64_t number;\n    FileType type;\n    std::vector<uint64_t> logs;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        expected.erase(number);\n        if (type == kLogFile && ((number >= min_log) || (number == prev_log)))\n          logs.push_back(number);\n      }\n    }\n    if (!expected.empty()) {\n      char buf[50];\n      snprintf(buf, sizeof(buf), \"%d missing files; e.g.\",\n               static_cast<int>(expected.size()));\n      return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));\n    }\n\n    // Recover in the order in which the logs were generated\n    std::sort(logs.begin(), logs.end());\n    for (size_t i = 0; i < logs.size(); i++) {\n      s = RecoverLogFile(logs[i], edit, &max_sequence);\n\n      // The previous incarnation may not have written any MANIFEST\n      // records after allocating this log number.  So we manually\n      // update the file number allocation counter in VersionSet.\n      versions_->MarkFileNumberUsed(logs[i]);\n    }\n\n    if (s.ok()) {\n      if (versions_->LastSequence() < max_sequence) {\n        versions_->SetLastSequence(max_sequence);\n      }\n    }\n  }\n\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "versions_->SetLastSequence",
          "args": [
            "max_sequence"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "SetLastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "212-215",
          "snippet": "void SetLastSequence(uint64_t s) {\n    assert(s >= last_sequence_);\n    last_sequence_ = s;\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  void SetLastSequence(uint64_t s) {\n      assert(s >= last_sequence_);\n      last_sequence_ = s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->LastSequence",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "LastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "209-209",
          "snippet": "uint64_t LastSequence() const { return last_sequence_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t LastSequence() const { return last_sequence_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->MarkFileNumberUsed",
          "args": [
            "logs[i]"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "MarkFileNumberUsed",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1025-1029",
          "snippet": "void VersionSet::MarkFileNumberUsed(uint64_t number) {\n  if (next_file_number_ <= number) {\n    next_file_number_ = number + 1;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::MarkFileNumberUsed(uint64_t number) {\n    if (next_file_number_ <= number) {\n      next_file_number_ = number + 1;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RecoverLogFile",
          "args": [
            "logs[i]",
            "edit",
            "&max_sequence"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverLogFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "362-455",
          "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::RecoverLogFile(uint64_t log_number,\n                                VersionEdit* edit,\n                                SequenceNumber* max_sequence) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      const char* fname;\n      Status* status;  // NULL if options_.paranoid_checks==false\n      virtual void Corruption(size_t bytes, const Status& s) {\n        Log(info_log, \"%s%s: dropping %d bytes; %s\",\n            (this->status == NULL ? \"(ignoring error) \" : \"\"),\n            fname, static_cast<int>(bytes), s.ToString().c_str());\n        if (this->status != NULL && this->status->ok()) *this->status = s;\n      }\n    };\n  \n    mutex_.AssertHeld();\n  \n    // Open the log file\n    std::string fname = LogFileName(dbname_, log_number);\n    SequentialFile* file;\n    Status status = env_->NewSequentialFile(fname, &file);\n    if (!status.ok()) {\n      MaybeIgnoreError(&status);\n      return status;\n    }\n  \n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.fname = fname.c_str();\n    reporter.status = (options_.paranoid_checks ? &status : NULL);\n    // We intentially make log::Reader do checksumming even if\n    // paranoid_checks==false so that corruptions cause entire commits\n    // to be skipped instead of propagating bad information (like overly\n    // large sequence numbers).\n    log::Reader reader(file, &reporter, true/*checksum*/,\n                       0/*initial_offset*/);\n    Log(options_.info_log, \"Recovering log #%llu\",\n        (unsigned long long) log_number);\n  \n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = NULL;\n    while (reader.ReadRecord(&record, &scratch) &&\n           status.ok()) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n  \n      if (mem == NULL) {\n        mem = new MemTable(internal_comparator_);\n        mem->Ref();\n      }\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      MaybeIgnoreError(&status);\n      if (!status.ok()) {\n        break;\n      }\n      const SequenceNumber last_seq =\n          WriteBatchInternal::Sequence(&batch) +\n          WriteBatchInternal::Count(&batch) - 1;\n      if (last_seq > *max_sequence) {\n        *max_sequence = last_seq;\n      }\n  \n      if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n        status = WriteLevel0Table(mem, edit, NULL);\n        if (!status.ok()) {\n          // Reflect errors immediately so that conditions like full\n          // file-systems cause the DB::Open() to fail.\n          break;\n        }\n        mem->Unref();\n        mem = NULL;\n      }\n    }\n  \n    if (status.ok() && mem != NULL) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      // Reflect errors immediately so that conditions like full\n      // file-systems cause the DB::Open() to fail.\n    }\n  \n    if (mem != NULL) mem->Unref();\n    delete file;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "logs.size",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "logs.begin()",
            "logs.end()"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logs.end",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "logs.begin",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "buf",
            "TableFileName(dbname_, *(expected.begin()))"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "CorruptionReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "38-42",
          "snippet": "virtual void Corruption(size_t bytes, const Status& status) {\n    printf(\"corruption: %d bytes; %s\\n\",\n            static_cast<int>(bytes),\n            status.ToString().c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nCorruptionReporter {\n  virtual void Corruption(size_t bytes, const Status& status) {\n      printf(\"corruption: %d bytes; %s\\n\",\n              static_cast<int>(bytes),\n              status.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TableFileName",
          "args": [
            "dbname_",
            "*(expected.begin())"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "SSTTableFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "42-45",
          "snippet": "std::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%d missing files; e.g.\"",
            "static_cast<int>(expected.size())"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "expected.size()"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected.empty",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "logs.push_back",
          "args": [
            "number"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected.erase",
          "args": [
            "number"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseFileName",
          "args": [
            "filenames[i]",
            "&number",
            "&type"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "85-129",
          "snippet": "bool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nbool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->AddLiveFiles",
          "args": [
            "&expected"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "AddLiveFiles",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1151-1162",
          "snippet": "void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n  for (Version* v = dummy_versions_.next_;\n       v != &dummy_versions_;\n       v = v->next_) {\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = v->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        live->insert(files[i]->number);\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n    for (Version* v = dummy_versions_.next_;\n         v != &dummy_versions_;\n         v = v->next_) {\n      for (int level = 0; level < config::kNumLevels; level++) {\n        const std::vector<FileMetaData*>& files = v->files_[level];\n        for (size_t i = 0; i < files.size(); i++) {\n          live->insert(files[i]->number);\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->GetChildren",
          "args": [
            "dbname_",
            "&filenames"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "GetChildren",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "767-793",
          "snippet": "Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n{\n    Status sRet;\n    ::WIN32_FIND_DATAW wfd;\n    std::string path = dir;\n    ModifyPath(path);\n    path += \"\\\\*.*\";\n\tstd::wstring wpath;\n\tToWidePath(path, wpath);\n\n\t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n    if(hFind && hFind != INVALID_HANDLE_VALUE){\n        BOOL hasNext = TRUE;\n        std::string child;\n        while(hasNext){\n            ToNarrowPath(wfd.cFileName, child); \n            if(child != \"..\" && child != \".\")  {\n                result->push_back(child);\n            }\n            hasNext = ::FindNextFileW(hFind,&wfd);\n        }\n        ::FindClose(hFind);\n    }\n    else\n        sRet = Status::IOError(dir,\"Could not get children.\");\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n  {\n      Status sRet;\n      ::WIN32_FIND_DATAW wfd;\n      std::string path = dir;\n      ModifyPath(path);\n      path += \"\\\\*.*\";\n  \tstd::wstring wpath;\n  \tToWidePath(path, wpath);\n  \n  \t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n      if(hFind && hFind != INVALID_HANDLE_VALUE){\n          BOOL hasNext = TRUE;\n          std::string child;\n          while(hasNext){\n              ToNarrowPath(wfd.cFileName, child); \n              if(child != \"..\" && child != \".\")  {\n                  result->push_back(child);\n              }\n              hasNext = ::FindNextFileW(hFind,&wfd);\n          }\n          ::FindClose(hFind);\n      }\n      else\n          sRet = Status::IOError(dir,\"Could not get children.\");\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->PrevLogNumber",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "PrevLogNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "225-225",
          "snippet": "uint64_t PrevLogNumber() const { return prev_log_number_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t PrevLogNumber() const { return prev_log_number_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->LogNumber",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "LogNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "221-221",
          "snippet": "uint64_t LogNumber() const { return log_number_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t LogNumber() const { return log_number_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->Recover",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "Recover",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "910-1023",
          "snippet": "Status VersionSet::Recover() {\n  struct LogReporter : public log::Reader::Reporter {\n    Status* status;\n    virtual void Corruption(size_t bytes, const Status& s) {\n      if (this->status->ok()) *this->status = s;\n    }\n  };\n\n  // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n  std::string current;\n  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);\n  if (!s.ok()) {\n    return s;\n  }\n  if (current.empty() || current[current.size()-1] != '\\n') {\n    return Status::Corruption(\"CURRENT file does not end with newline\");\n  }\n  current.resize(current.size() - 1);\n\n  std::string dscname = dbname_ + \"/\" + current;\n  SequentialFile* file;\n  s = env_->NewSequentialFile(dscname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n\n  bool have_log_number = false;\n  bool have_prev_log_number = false;\n  bool have_next_file = false;\n  bool have_last_sequence = false;\n  uint64_t next_file = 0;\n  uint64_t last_sequence = 0;\n  uint64_t log_number = 0;\n  uint64_t prev_log_number = 0;\n  Builder builder(this, current_);\n\n  {\n    LogReporter reporter;\n    reporter.status = &s;\n    log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);\n    Slice record;\n    std::string scratch;\n    while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n      VersionEdit edit;\n      s = edit.DecodeFrom(record);\n      if (s.ok()) {\n        if (edit.has_comparator_ &&\n            edit.comparator_ != icmp_.user_comparator()->Name()) {\n          s = Status::InvalidArgument(\n              edit.comparator_ + \" does not match existing comparator \",\n              icmp_.user_comparator()->Name());\n        }\n      }\n\n      if (s.ok()) {\n        builder.Apply(&edit);\n      }\n\n      if (edit.has_log_number_) {\n        log_number = edit.log_number_;\n        have_log_number = true;\n      }\n\n      if (edit.has_prev_log_number_) {\n        prev_log_number = edit.prev_log_number_;\n        have_prev_log_number = true;\n      }\n\n      if (edit.has_next_file_number_) {\n        next_file = edit.next_file_number_;\n        have_next_file = true;\n      }\n\n      if (edit.has_last_sequence_) {\n        last_sequence = edit.last_sequence_;\n        have_last_sequence = true;\n      }\n    }\n  }\n  delete file;\n  file = NULL;\n\n  if (s.ok()) {\n    if (!have_next_file) {\n      s = Status::Corruption(\"no meta-nextfile entry in descriptor\");\n    } else if (!have_log_number) {\n      s = Status::Corruption(\"no meta-lognumber entry in descriptor\");\n    } else if (!have_last_sequence) {\n      s = Status::Corruption(\"no last-sequence-number entry in descriptor\");\n    }\n\n    if (!have_prev_log_number) {\n      prev_log_number = 0;\n    }\n\n    MarkFileNumberUsed(prev_log_number);\n    MarkFileNumberUsed(log_number);\n  }\n\n  if (s.ok()) {\n    Version* v = new Version(this);\n    builder.SaveTo(v);\n    // Install recovered version\n    Finalize(v);\n    AppendVersion(v);\n    manifest_file_number_ = next_file;\n    next_file_number_ = next_file + 1;\n    last_sequence_ = last_sequence;\n    log_number_ = log_number;\n    prev_log_number_ = prev_log_number;\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::Recover() {\n    struct LogReporter : public log::Reader::Reporter {\n      Status* status;\n      virtual void Corruption(size_t bytes, const Status& s) {\n        if (this->status->ok()) *this->status = s;\n      }\n    };\n  \n    // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n    std::string current;\n    Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);\n    if (!s.ok()) {\n      return s;\n    }\n    if (current.empty() || current[current.size()-1] != '\\n') {\n      return Status::Corruption(\"CURRENT file does not end with newline\");\n    }\n    current.resize(current.size() - 1);\n  \n    std::string dscname = dbname_ + \"/\" + current;\n    SequentialFile* file;\n    s = env_->NewSequentialFile(dscname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n  \n    bool have_log_number = false;\n    bool have_prev_log_number = false;\n    bool have_next_file = false;\n    bool have_last_sequence = false;\n    uint64_t next_file = 0;\n    uint64_t last_sequence = 0;\n    uint64_t log_number = 0;\n    uint64_t prev_log_number = 0;\n    Builder builder(this, current_);\n  \n    {\n      LogReporter reporter;\n      reporter.status = &s;\n      log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);\n      Slice record;\n      std::string scratch;\n      while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n        VersionEdit edit;\n        s = edit.DecodeFrom(record);\n        if (s.ok()) {\n          if (edit.has_comparator_ &&\n              edit.comparator_ != icmp_.user_comparator()->Name()) {\n            s = Status::InvalidArgument(\n                edit.comparator_ + \" does not match existing comparator \",\n                icmp_.user_comparator()->Name());\n          }\n        }\n  \n        if (s.ok()) {\n          builder.Apply(&edit);\n        }\n  \n        if (edit.has_log_number_) {\n          log_number = edit.log_number_;\n          have_log_number = true;\n        }\n  \n        if (edit.has_prev_log_number_) {\n          prev_log_number = edit.prev_log_number_;\n          have_prev_log_number = true;\n        }\n  \n        if (edit.has_next_file_number_) {\n          next_file = edit.next_file_number_;\n          have_next_file = true;\n        }\n  \n        if (edit.has_last_sequence_) {\n          last_sequence = edit.last_sequence_;\n          have_last_sequence = true;\n        }\n      }\n    }\n    delete file;\n    file = NULL;\n  \n    if (s.ok()) {\n      if (!have_next_file) {\n        s = Status::Corruption(\"no meta-nextfile entry in descriptor\");\n      } else if (!have_log_number) {\n        s = Status::Corruption(\"no meta-lognumber entry in descriptor\");\n      } else if (!have_last_sequence) {\n        s = Status::Corruption(\"no last-sequence-number entry in descriptor\");\n      }\n  \n      if (!have_prev_log_number) {\n        prev_log_number = 0;\n      }\n  \n      MarkFileNumberUsed(prev_log_number);\n      MarkFileNumberUsed(log_number);\n    }\n  \n    if (s.ok()) {\n      Version* v = new Version(this);\n      builder.SaveTo(v);\n      // Install recovered version\n      Finalize(v);\n      AppendVersion(v);\n      manifest_file_number_ = next_file;\n      next_file_number_ = next_file + 1;\n      last_sequence_ = last_sequence;\n      log_number_ = log_number;\n      prev_log_number_ = prev_log_number;\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::InvalidArgument",
          "args": [
            "dbname_",
            "\"exists (error_if_exists is true)\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Status::InvalidArgument",
          "args": [
            "dbname_",
            "\"does not exist (create_if_missing is false)\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewDB",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "NewDB",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "177-207",
          "snippet": "Status DBImpl::NewDB() {\n  VersionEdit new_db;\n  new_db.SetComparatorName(user_comparator()->Name());\n  new_db.SetLogNumber(0);\n  new_db.SetNextFile(2);\n  new_db.SetLastSequence(0);\n\n  const std::string manifest = DescriptorFileName(dbname_, 1);\n  WritableFile* file;\n  Status s = env_->NewWritableFile(manifest, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  {\n    log::Writer log(file);\n    std::string record;\n    new_db.EncodeTo(&record);\n    s = log.AddRecord(record);\n    if (s.ok()) {\n      s = file->Close();\n    }\n  }\n  delete file;\n  if (s.ok()) {\n    // Make \"CURRENT\" file that points to the new manifest file.\n    s = SetCurrentFile(env_, dbname_, 1);\n  } else {\n    env_->DeleteFile(manifest);\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::NewDB() {\n    VersionEdit new_db;\n    new_db.SetComparatorName(user_comparator()->Name());\n    new_db.SetLogNumber(0);\n    new_db.SetNextFile(2);\n    new_db.SetLastSequence(0);\n  \n    const std::string manifest = DescriptorFileName(dbname_, 1);\n    WritableFile* file;\n    Status s = env_->NewWritableFile(manifest, &file);\n    if (!s.ok()) {\n      return s;\n    }\n    {\n      log::Writer log(file);\n      std::string record;\n      new_db.EncodeTo(&record);\n      s = log.AddRecord(record);\n      if (s.ok()) {\n        s = file->Close();\n      }\n    }\n    delete file;\n    if (s.ok()) {\n      // Make \"CURRENT\" file that points to the new manifest file.\n      s = SetCurrentFile(env_, dbname_, 1);\n    } else {\n      env_->DeleteFile(manifest);\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->FileExists",
          "args": [
            "CurrentFileName(dbname_)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "FileExists",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "759-765",
          "snippet": "bool Win32Env::FileExists(const std::string& fname)\n{\n\tstd::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n    return ::PathFileExistsW(wpath.c_str()) ? true : false;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  bool Win32Env::FileExists(const std::string& fname)\n  {\n  \tstd::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n      return ::PathFileExistsW(wpath.c_str()) ? true : false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CurrentFileName",
          "args": [
            "dbname_"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "55-57",
          "snippet": "std::string CurrentFileName(const std::string& dbname) {\n  return dbname + \"/CURRENT\";\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string CurrentFileName(const std::string& dbname) {\n  return dbname + \"/CURRENT\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->LockFile",
          "args": [
            "LockFileName(dbname_)",
            "&db_lock_"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "LockFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "855-869",
          "snippet": "Status Win32Env::LockFile( const std::string& fname, FileLock** lock )\n{\n    Status sRet;\n    std::string path = fname;\n    ModifyPath(path);\n    Win32FileLock* _lock = new Win32FileLock(path);\n    if(!_lock->isEnable()){\n        delete _lock;\n        *lock = NULL;\n        sRet = Status::IOError(path, \"Could not lock file.\");\n    }\n    else\n        *lock = _lock;\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::LockFile( const std::string& fname, FileLock** lock )\n  {\n      Status sRet;\n      std::string path = fname;\n      ModifyPath(path);\n      Win32FileLock* _lock = new Win32FileLock(path);\n      if(!_lock->isEnable()){\n          delete _lock;\n          *lock = NULL;\n          sRet = Status::IOError(path, \"Could not lock file.\");\n      }\n      else\n          *lock = _lock;\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LockFileName",
          "args": [
            "dbname_"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "LockFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "59-61",
          "snippet": "std::string LockFileName(const std::string& dbname) {\n  return dbname + \"/LOCK\";\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LockFileName(const std::string& dbname) {\n  return dbname + \"/LOCK\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "db_lock_ == NULL"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->CreateDir",
          "args": [
            "dbname_"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "CreateDir",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "928-937",
          "snippet": "Status Win32Env::CreateDir( const std::string& dirname )\n{\n    std::string path = dirname;\n    if(path[path.length() - 1] != '\\\\'){\n        path += '\\\\';\n    }\n    ModifyPath(path);\n\n    return CreateDirInner(path);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::CreateDir( const std::string& dirname )\n  {\n      std::string path = dirname;\n      if(path[path.length() - 1] != '\\\\'){\n          path += '\\\\';\n      }\n      ModifyPath(path);\n  \n      return CreateDirInner(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.AssertHeld",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "AssertHeld",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_posix.h",
          "lines": "96-96",
          "snippet": "void AssertHeld() { }",
          "includes": [
            "#include \"port/atomic_pointer.h\"",
            "#include <string>",
            "#include <stdint.h>",
            "#include <snappy.h>",
            "#include <pthread.h>",
            "#include <endian.h>",
            "#include <endian.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/endian.h>",
            "#include <sys/types.h>",
            "#include <sys/isa_defs.h>",
            "#include <machine/endian.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/atomic_pointer.h\"\n#include <string>\n#include <stdint.h>\n#include <snappy.h>\n#include <pthread.h>\n#include <endian.h>\n#include <endian.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/endian.h>\n#include <sys/types.h>\n#include <sys/isa_defs.h>\n#include <machine/endian.h>\n\nMutex {\n  void AssertHeld() { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Recover(VersionEdit* edit) {\n    mutex_.AssertHeld();\n  \n    // Ignore error from CreateDir since the creation of the DB is\n    // committed only when the descriptor is created, and this directory\n    // may already exist from a previous failed creation attempt.\n    env_->CreateDir(dbname_);\n    assert(db_lock_ == NULL);\n    Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);\n    if (!s.ok()) {\n      return s;\n    }\n  \n    if (!env_->FileExists(CurrentFileName(dbname_))) {\n      if (options_.create_if_missing) {\n        s = NewDB();\n        if (!s.ok()) {\n          return s;\n        }\n      } else {\n        return Status::InvalidArgument(\n            dbname_, \"does not exist (create_if_missing is false)\");\n      }\n    } else {\n      if (options_.error_if_exists) {\n        return Status::InvalidArgument(\n            dbname_, \"exists (error_if_exists is true)\");\n      }\n    }\n  \n    s = versions_->Recover();\n    if (s.ok()) {\n      SequenceNumber max_sequence(0);\n  \n      // Recover from all newer log files than the ones named in the\n      // descriptor (new log files may have been added by the previous\n      // incarnation without registering them in the descriptor).\n      //\n      // Note that PrevLogNumber() is no longer used, but we pay\n      // attention to it in case we are recovering a database\n      // produced by an older version of leveldb.\n      const uint64_t min_log = versions_->LogNumber();\n      const uint64_t prev_log = versions_->PrevLogNumber();\n      std::vector<std::string> filenames;\n      s = env_->GetChildren(dbname_, &filenames);\n      if (!s.ok()) {\n        return s;\n      }\n      std::set<uint64_t> expected;\n      versions_->AddLiveFiles(&expected);\n      uint64_t number;\n      FileType type;\n      std::vector<uint64_t> logs;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type)) {\n          expected.erase(number);\n          if (type == kLogFile && ((number >= min_log) || (number == prev_log)))\n            logs.push_back(number);\n        }\n      }\n      if (!expected.empty()) {\n        char buf[50];\n        snprintf(buf, sizeof(buf), \"%d missing files; e.g.\",\n                 static_cast<int>(expected.size()));\n        return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));\n      }\n  \n      // Recover in the order in which the logs were generated\n      std::sort(logs.begin(), logs.end());\n      for (size_t i = 0; i < logs.size(); i++) {\n        s = RecoverLogFile(logs[i], edit, &max_sequence);\n  \n        // The previous incarnation may not have written any MANIFEST\n        // records after allocating this log number.  So we manually\n        // update the file number allocation counter in VersionSet.\n        versions_->MarkFileNumberUsed(logs[i]);\n      }\n  \n      if (s.ok()) {\n        if (versions_->LastSequence() < max_sequence) {\n          versions_->SetLastSequence(max_sequence);\n        }\n      }\n    }\n  \n    return s;\n  }\n}"
  },
  {
    "function_name": "DeleteObsoleteFiles",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "218-272",
    "snippet": "void DBImpl::DeleteObsoleteFiles() {\n  if (!bg_error_.ok()) {\n    // After a background error, we don't know whether a new version may\n    // or may not have been committed, so we cannot safely garbage collect.\n    return;\n  }\n\n  // Make a set of all of the live files\n  std::set<uint64_t> live = pending_outputs_;\n  versions_->AddLiveFiles(&live);\n\n  std::vector<std::string> filenames;\n  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n  uint64_t number;\n  FileType type;\n  for (size_t i = 0; i < filenames.size(); i++) {\n    if (ParseFileName(filenames[i], &number, &type)) {\n      bool keep = true;\n      switch (type) {\n        case kLogFile:\n          keep = ((number >= versions_->LogNumber()) ||\n                  (number == versions_->PrevLogNumber()));\n          break;\n        case kDescriptorFile:\n          // Keep my manifest file, and any newer incarnations'\n          // (in case there is a race that allows other incarnations)\n          keep = (number >= versions_->ManifestFileNumber());\n          break;\n        case kTableFile:\n          keep = (live.find(number) != live.end());\n          break;\n        case kTempFile:\n          // Any temp files that are currently being written to must\n          // be recorded in pending_outputs_, which is inserted into \"live\"\n          keep = (live.find(number) != live.end());\n          break;\n        case kCurrentFile:\n        case kDBLockFile:\n        case kInfoLogFile:\n          keep = true;\n          break;\n      }\n\n      if (!keep) {\n        if (type == kTableFile) {\n          table_cache_->Evict(number);\n        }\n        Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n            int(type),\n            static_cast<unsigned long long>(number));\n        env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [
            "dbname_ + \"/\" + filenames[i]"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Delete type=%d #%lld\\n\"",
            "int(type)",
            "static_cast<unsigned long long>(number)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long long>",
          "args": [
            "number"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "type"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "VersionEditPrinter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "110-118",
          "snippet": "static void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_cache_->Evict",
          "args": [
            "number"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "Evict",
          "container": "TableCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
          "lines": "121-125",
          "snippet": "void TableCache::Evict(uint64_t file_number) {\n  char buf[sizeof(file_number)];\n  EncodeFixed64(buf, file_number);\n  cache_->Erase(Slice(buf, sizeof(buf)));\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/table_cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  void TableCache::Evict(uint64_t file_number) {\n    char buf[sizeof(file_number)];\n    EncodeFixed64(buf, file_number);\n    cache_->Erase(Slice(buf, sizeof(buf)));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "live.end",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "live.find",
          "args": [
            "number"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->ManifestFileNumber",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ManifestFileNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "188-188",
          "snippet": "uint64_t ManifestFileNumber() const { return manifest_file_number_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t ManifestFileNumber() const { return manifest_file_number_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->PrevLogNumber",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "PrevLogNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "225-225",
          "snippet": "uint64_t PrevLogNumber() const { return prev_log_number_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t PrevLogNumber() const { return prev_log_number_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->LogNumber",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "LogNumber",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "221-221",
          "snippet": "uint64_t LogNumber() const { return log_number_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  uint64_t LogNumber() const { return log_number_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseFileName",
          "args": [
            "filenames[i]",
            "&number",
            "&type"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "85-129",
          "snippet": "bool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nbool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filenames.size",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->GetChildren",
          "args": [
            "dbname_",
            "&filenames"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "GetChildren",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "767-793",
          "snippet": "Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n{\n    Status sRet;\n    ::WIN32_FIND_DATAW wfd;\n    std::string path = dir;\n    ModifyPath(path);\n    path += \"\\\\*.*\";\n\tstd::wstring wpath;\n\tToWidePath(path, wpath);\n\n\t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n    if(hFind && hFind != INVALID_HANDLE_VALUE){\n        BOOL hasNext = TRUE;\n        std::string child;\n        while(hasNext){\n            ToNarrowPath(wfd.cFileName, child); \n            if(child != \"..\" && child != \".\")  {\n                result->push_back(child);\n            }\n            hasNext = ::FindNextFileW(hFind,&wfd);\n        }\n        ::FindClose(hFind);\n    }\n    else\n        sRet = Status::IOError(dir,\"Could not get children.\");\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n  {\n      Status sRet;\n      ::WIN32_FIND_DATAW wfd;\n      std::string path = dir;\n      ModifyPath(path);\n      path += \"\\\\*.*\";\n  \tstd::wstring wpath;\n  \tToWidePath(path, wpath);\n  \n  \t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n      if(hFind && hFind != INVALID_HANDLE_VALUE){\n          BOOL hasNext = TRUE;\n          std::string child;\n          while(hasNext){\n              ToNarrowPath(wfd.cFileName, child); \n              if(child != \"..\" && child != \".\")  {\n                  result->push_back(child);\n              }\n              hasNext = ::FindNextFileW(hFind,&wfd);\n          }\n          ::FindClose(hFind);\n      }\n      else\n          sRet = Status::IOError(dir,\"Could not get children.\");\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "versions_->AddLiveFiles",
          "args": [
            "&live"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "AddLiveFiles",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1151-1162",
          "snippet": "void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n  for (Version* v = dummy_versions_.next_;\n       v != &dummy_versions_;\n       v = v->next_) {\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = v->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        live->insert(files[i]->number);\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n    for (Version* v = dummy_versions_.next_;\n         v != &dummy_versions_;\n         v = v->next_) {\n      for (int level = 0; level < config::kNumLevels; level++) {\n        const std::vector<FileMetaData*>& files = v->files_[level];\n        for (size_t i = 0; i < files.size(); i++) {\n          live->insert(files[i]->number);\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_error_.ok",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::DeleteObsoleteFiles() {\n    if (!bg_error_.ok()) {\n      // After a background error, we don't know whether a new version may\n      // or may not have been committed, so we cannot safely garbage collect.\n      return;\n    }\n  \n    // Make a set of all of the live files\n    std::set<uint64_t> live = pending_outputs_;\n    versions_->AddLiveFiles(&live);\n  \n    std::vector<std::string> filenames;\n    env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        bool keep = true;\n        switch (type) {\n          case kLogFile:\n            keep = ((number >= versions_->LogNumber()) ||\n                    (number == versions_->PrevLogNumber()));\n            break;\n          case kDescriptorFile:\n            // Keep my manifest file, and any newer incarnations'\n            // (in case there is a race that allows other incarnations)\n            keep = (number >= versions_->ManifestFileNumber());\n            break;\n          case kTableFile:\n            keep = (live.find(number) != live.end());\n            break;\n          case kTempFile:\n            // Any temp files that are currently being written to must\n            // be recorded in pending_outputs_, which is inserted into \"live\"\n            keep = (live.find(number) != live.end());\n            break;\n          case kCurrentFile:\n          case kDBLockFile:\n          case kInfoLogFile:\n            keep = true;\n            break;\n        }\n  \n        if (!keep) {\n          if (type == kTableFile) {\n            table_cache_->Evict(number);\n          }\n          Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n              int(type),\n              static_cast<unsigned long long>(number));\n          env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "MaybeIgnoreError",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "209-216",
    "snippet": "void DBImpl::MaybeIgnoreError(Status* s) const {\n  if (s->ok() || options_.paranoid_checks) {\n    // No change needed\n  } else {\n    Log(options_.info_log, \"Ignoring error %s\", s->ToString().c_str());\n    *s = Status::OK();\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Ignoring error %s\"",
            "s->ToString().c_str()"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverLogFile",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "362-455",
          "snippet": "Status DBImpl::RecoverLogFile(uint64_t log_number,\n                              VersionEdit* edit,\n                              SequenceNumber* max_sequence) {\n  struct LogReporter : public log::Reader::Reporter {\n    Env* env;\n    Logger* info_log;\n    const char* fname;\n    Status* status;  // NULL if options_.paranoid_checks==false\n    virtual void Corruption(size_t bytes, const Status& s) {\n      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n          fname, static_cast<int>(bytes), s.ToString().c_str());\n      if (this->status != NULL && this->status->ok()) *this->status = s;\n    }\n  };\n\n  mutex_.AssertHeld();\n\n  // Open the log file\n  std::string fname = LogFileName(dbname_, log_number);\n  SequentialFile* file;\n  Status status = env_->NewSequentialFile(fname, &file);\n  if (!status.ok()) {\n    MaybeIgnoreError(&status);\n    return status;\n  }\n\n  // Create the log reader.\n  LogReporter reporter;\n  reporter.env = env_;\n  reporter.info_log = options_.info_log;\n  reporter.fname = fname.c_str();\n  reporter.status = (options_.paranoid_checks ? &status : NULL);\n  // We intentially make log::Reader do checksumming even if\n  // paranoid_checks==false so that corruptions cause entire commits\n  // to be skipped instead of propagating bad information (like overly\n  // large sequence numbers).\n  log::Reader reader(file, &reporter, true/*checksum*/,\n                     0/*initial_offset*/);\n  Log(options_.info_log, \"Recovering log #%llu\",\n      (unsigned long long) log_number);\n\n  // Read all the records and add to a memtable\n  std::string scratch;\n  Slice record;\n  WriteBatch batch;\n  MemTable* mem = NULL;\n  while (reader.ReadRecord(&record, &scratch) &&\n         status.ok()) {\n    if (record.size() < 12) {\n      reporter.Corruption(\n          record.size(), Status::Corruption(\"log record too small\"));\n      continue;\n    }\n    WriteBatchInternal::SetContents(&batch, record);\n\n    if (mem == NULL) {\n      mem = new MemTable(internal_comparator_);\n      mem->Ref();\n    }\n    status = WriteBatchInternal::InsertInto(&batch, mem);\n    MaybeIgnoreError(&status);\n    if (!status.ok()) {\n      break;\n    }\n    const SequenceNumber last_seq =\n        WriteBatchInternal::Sequence(&batch) +\n        WriteBatchInternal::Count(&batch) - 1;\n    if (last_seq > *max_sequence) {\n      *max_sequence = last_seq;\n    }\n\n    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      if (!status.ok()) {\n        // Reflect errors immediately so that conditions like full\n        // file-systems cause the DB::Open() to fail.\n        break;\n      }\n      mem->Unref();\n      mem = NULL;\n    }\n  }\n\n  if (status.ok() && mem != NULL) {\n    status = WriteLevel0Table(mem, edit, NULL);\n    // Reflect errors immediately so that conditions like full\n    // file-systems cause the DB::Open() to fail.\n  }\n\n  if (mem != NULL) mem->Unref();\n  delete file;\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::RecoverLogFile(uint64_t log_number,\n                                VersionEdit* edit,\n                                SequenceNumber* max_sequence) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      const char* fname;\n      Status* status;  // NULL if options_.paranoid_checks==false\n      virtual void Corruption(size_t bytes, const Status& s) {\n        Log(info_log, \"%s%s: dropping %d bytes; %s\",\n            (this->status == NULL ? \"(ignoring error) \" : \"\"),\n            fname, static_cast<int>(bytes), s.ToString().c_str());\n        if (this->status != NULL && this->status->ok()) *this->status = s;\n      }\n    };\n  \n    mutex_.AssertHeld();\n  \n    // Open the log file\n    std::string fname = LogFileName(dbname_, log_number);\n    SequentialFile* file;\n    Status status = env_->NewSequentialFile(fname, &file);\n    if (!status.ok()) {\n      MaybeIgnoreError(&status);\n      return status;\n    }\n  \n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.fname = fname.c_str();\n    reporter.status = (options_.paranoid_checks ? &status : NULL);\n    // We intentially make log::Reader do checksumming even if\n    // paranoid_checks==false so that corruptions cause entire commits\n    // to be skipped instead of propagating bad information (like overly\n    // large sequence numbers).\n    log::Reader reader(file, &reporter, true/*checksum*/,\n                       0/*initial_offset*/);\n    Log(options_.info_log, \"Recovering log #%llu\",\n        (unsigned long long) log_number);\n  \n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = NULL;\n    while (reader.ReadRecord(&record, &scratch) &&\n           status.ok()) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n  \n      if (mem == NULL) {\n        mem = new MemTable(internal_comparator_);\n        mem->Ref();\n      }\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      MaybeIgnoreError(&status);\n      if (!status.ok()) {\n        break;\n      }\n      const SequenceNumber last_seq =\n          WriteBatchInternal::Sequence(&batch) +\n          WriteBatchInternal::Count(&batch) - 1;\n      if (last_seq > *max_sequence) {\n        *max_sequence = last_seq;\n      }\n  \n      if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n        status = WriteLevel0Table(mem, edit, NULL);\n        if (!status.ok()) {\n          // Reflect errors immediately so that conditions like full\n          // file-systems cause the DB::Open() to fail.\n          break;\n        }\n        mem->Unref();\n        mem = NULL;\n      }\n    }\n  \n    if (status.ok() && mem != NULL) {\n      status = WriteLevel0Table(mem, edit, NULL);\n      // Reflect errors immediately so that conditions like full\n      // file-systems cause the DB::Open() to fail.\n    }\n  \n    if (mem != NULL) mem->Unref();\n    delete file;\n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->ToString",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->ok",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::MaybeIgnoreError(Status* s) const {\n    if (s->ok() || options_.paranoid_checks) {\n      // No change needed\n    } else {\n      Log(options_.info_log, \"Ignoring error %s\", s->ToString().c_str());\n      *s = Status::OK();\n    }\n  }\n}"
  },
  {
    "function_name": "NewDB",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "177-207",
    "snippet": "Status DBImpl::NewDB() {\n  VersionEdit new_db;\n  new_db.SetComparatorName(user_comparator()->Name());\n  new_db.SetLogNumber(0);\n  new_db.SetNextFile(2);\n  new_db.SetLastSequence(0);\n\n  const std::string manifest = DescriptorFileName(dbname_, 1);\n  WritableFile* file;\n  Status s = env_->NewWritableFile(manifest, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  {\n    log::Writer log(file);\n    std::string record;\n    new_db.EncodeTo(&record);\n    s = log.AddRecord(record);\n    if (s.ok()) {\n      s = file->Close();\n    }\n  }\n  delete file;\n  if (s.ok()) {\n    // Make \"CURRENT\" file that points to the new manifest file.\n    s = SetCurrentFile(env_, dbname_, 1);\n  } else {\n    env_->DeleteFile(manifest);\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [
            "manifest"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetCurrentFile",
          "args": [
            "env_",
            "dbname_",
            "1"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "SetCurrentFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "131-147",
          "snippet": "Status SetCurrentFile(Env* env, const std::string& dbname,\n                      uint64_t descriptor_number) {\n  // Remove leading \"dbname/\" and add newline to manifest file name\n  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n  Slice contents = manifest;\n  assert(contents.starts_with(dbname + \"/\"));\n  contents.remove_prefix(dbname.size() + 1);\n  std::string tmp = TempFileName(dbname, descriptor_number);\n  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n  if (s.ok()) {\n    s = env->RenameFile(tmp, CurrentFileName(dbname));\n  }\n  if (!s.ok()) {\n    env->DeleteFile(tmp);\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nStatus SetCurrentFile(Env* env, const std::string& dbname,\n                      uint64_t descriptor_number) {\n  // Remove leading \"dbname/\" and add newline to manifest file name\n  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n  Slice contents = manifest;\n  assert(contents.starts_with(dbname + \"/\"));\n  contents.remove_prefix(dbname.size() + 1);\n  std::string tmp = TempFileName(dbname, descriptor_number);\n  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n  if (s.ok()) {\n    s = env->RenameFile(tmp, CurrentFileName(dbname));\n  }\n  if (!s.ok()) {\n    env->DeleteFile(tmp);\n  }\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Close",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "261-264",
          "snippet": "void Close() {\n    delete db_;\n    db_ = NULL;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  void Close() {\n      delete db_;\n      db_ = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "log.AddRecord",
          "args": [
            "record"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "AddRecord",
          "container": "Writer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
          "lines": "27-73",
          "snippet": "Status Writer::AddRecord(const Slice& slice) {\n  const char* ptr = slice.data();\n  size_t left = slice.size();\n\n  // Fragment the record if necessary and emit it.  Note that if slice\n  // is empty, we still want to iterate once to emit a single\n  // zero-length record\n  Status s;\n  bool begin = true;\n  do {\n    const int leftover = kBlockSize - block_offset_;\n    assert(leftover >= 0);\n    if (leftover < kHeaderSize) {\n      // Switch to a new block\n      if (leftover > 0) {\n        // Fill the trailer (literal below relies on kHeaderSize being 7)\n        assert(kHeaderSize == 7);\n        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n      }\n      block_offset_ = 0;\n    }\n\n    // Invariant: we never leave < kHeaderSize bytes in a block.\n    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n\n    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n    const size_t fragment_length = (left < avail) ? left : avail;\n\n    RecordType type;\n    const bool end = (left == fragment_length);\n    if (begin && end) {\n      type = kFullType;\n    } else if (begin) {\n      type = kFirstType;\n    } else if (end) {\n      type = kLastType;\n    } else {\n      type = kMiddleType;\n    }\n\n    s = EmitPhysicalRecord(type, ptr, fragment_length);\n    ptr += fragment_length;\n    left -= fragment_length;\n    begin = false;\n  } while (s.ok() && left > 0);\n  return s;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdint.h>",
            "#include \"db/log_writer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::AddRecord(const Slice& slice) {\n    const char* ptr = slice.data();\n    size_t left = slice.size();\n  \n    // Fragment the record if necessary and emit it.  Note that if slice\n    // is empty, we still want to iterate once to emit a single\n    // zero-length record\n    Status s;\n    bool begin = true;\n    do {\n      const int leftover = kBlockSize - block_offset_;\n      assert(leftover >= 0);\n      if (leftover < kHeaderSize) {\n        // Switch to a new block\n        if (leftover > 0) {\n          // Fill the trailer (literal below relies on kHeaderSize being 7)\n          assert(kHeaderSize == 7);\n          dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n        }\n        block_offset_ = 0;\n      }\n  \n      // Invariant: we never leave < kHeaderSize bytes in a block.\n      assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n  \n      const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n      const size_t fragment_length = (left < avail) ? left : avail;\n  \n      RecordType type;\n      const bool end = (left == fragment_length);\n      if (begin && end) {\n        type = kFullType;\n      } else if (begin) {\n        type = kFirstType;\n      } else if (end) {\n        type = kLastType;\n      } else {\n        type = kMiddleType;\n      }\n  \n      s = EmitPhysicalRecord(type, ptr, fragment_length);\n      ptr += fragment_length;\n      left -= fragment_length;\n      begin = false;\n    } while (s.ok() && left > 0);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_db.EncodeTo",
          "args": [
            "&record"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTo",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "41-86",
          "snippet": "void VersionEdit::EncodeTo(std::string* dst) const {\n  if (has_comparator_) {\n    PutVarint32(dst, kComparator);\n    PutLengthPrefixedSlice(dst, comparator_);\n  }\n  if (has_log_number_) {\n    PutVarint32(dst, kLogNumber);\n    PutVarint64(dst, log_number_);\n  }\n  if (has_prev_log_number_) {\n    PutVarint32(dst, kPrevLogNumber);\n    PutVarint64(dst, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    PutVarint32(dst, kNextFileNumber);\n    PutVarint64(dst, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    PutVarint32(dst, kLastSequence);\n    PutVarint64(dst, last_sequence_);\n  }\n\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    PutVarint32(dst, kCompactPointer);\n    PutVarint32(dst, compact_pointers_[i].first);  // level\n    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n  }\n\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    PutVarint32(dst, kDeletedFile);\n    PutVarint32(dst, iter->first);   // level\n    PutVarint64(dst, iter->second);  // file number\n  }\n\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    PutVarint32(dst, kNewFile);\n    PutVarint32(dst, new_files_[i].first);  // level\n    PutVarint64(dst, f.number);\n    PutVarint64(dst, f.file_size);\n    PutLengthPrefixedSlice(dst, f.smallest.Encode());\n    PutLengthPrefixedSlice(dst, f.largest.Encode());\n  }\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  void VersionEdit::EncodeTo(std::string* dst) const {\n    if (has_comparator_) {\n      PutVarint32(dst, kComparator);\n      PutLengthPrefixedSlice(dst, comparator_);\n    }\n    if (has_log_number_) {\n      PutVarint32(dst, kLogNumber);\n      PutVarint64(dst, log_number_);\n    }\n    if (has_prev_log_number_) {\n      PutVarint32(dst, kPrevLogNumber);\n      PutVarint64(dst, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      PutVarint32(dst, kNextFileNumber);\n      PutVarint64(dst, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      PutVarint32(dst, kLastSequence);\n      PutVarint64(dst, last_sequence_);\n    }\n  \n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      PutVarint32(dst, kCompactPointer);\n      PutVarint32(dst, compact_pointers_[i].first);  // level\n      PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n    }\n  \n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      PutVarint32(dst, kDeletedFile);\n      PutVarint32(dst, iter->first);   // level\n      PutVarint64(dst, iter->second);  // file number\n    }\n  \n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      PutVarint32(dst, kNewFile);\n      PutVarint32(dst, new_files_[i].first);  // level\n      PutVarint64(dst, f.number);\n      PutVarint64(dst, f.file_size);\n      PutLengthPrefixedSlice(dst, f.smallest.Encode());\n      PutLengthPrefixedSlice(dst, f.largest.Encode());\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "manifest",
            "&file"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DescriptorFileName",
          "args": [
            "dbname_",
            "1"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "DescriptorFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "47-53",
          "snippet": "std::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n           static_cast<unsigned long long>(number));\n  return dbname + buf;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n           static_cast<unsigned long long>(number));\n  return dbname + buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_db.SetLastSequence",
          "args": [
            "0"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "SetLastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "212-215",
          "snippet": "void SetLastSequence(uint64_t s) {\n    assert(s >= last_sequence_);\n    last_sequence_ = s;\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  void SetLastSequence(uint64_t s) {\n      assert(s >= last_sequence_);\n      last_sequence_ = s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_db.SetNextFile",
          "args": [
            "2"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "SetNextFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "47-50",
          "snippet": "void SetNextFile(uint64_t num) {\n    has_next_file_number_ = true;\n    next_file_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetNextFile(uint64_t num) {\n      has_next_file_number_ = true;\n      next_file_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_db.SetLogNumber",
          "args": [
            "0"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "SetLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "39-42",
          "snippet": "void SetLogNumber(uint64_t num) {\n    has_log_number_ = true;\n    log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetLogNumber(uint64_t num) {\n      has_log_number_ = true;\n      log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_db.SetComparatorName",
          "args": [
            "user_comparator()->Name()"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "SetComparatorName",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "35-38",
          "snippet": "void SetComparatorName(const Slice& name) {\n    has_comparator_ = true;\n    comparator_ = name.ToString();\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetComparatorName(const Slice& name) {\n      has_comparator_ = true;\n      comparator_ = name.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_comparator",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_comparator",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::NewDB() {\n    VersionEdit new_db;\n    new_db.SetComparatorName(user_comparator()->Name());\n    new_db.SetLogNumber(0);\n    new_db.SetNextFile(2);\n    new_db.SetLastSequence(0);\n  \n    const std::string manifest = DescriptorFileName(dbname_, 1);\n    WritableFile* file;\n    Status s = env_->NewWritableFile(manifest, &file);\n    if (!s.ok()) {\n      return s;\n    }\n    {\n      log::Writer log(file);\n      std::string record;\n      new_db.EncodeTo(&record);\n      s = log.AddRecord(record);\n      if (s.ok()) {\n        s = file->Close();\n      }\n    }\n    delete file;\n    if (s.ok()) {\n      // Make \"CURRENT\" file that points to the new manifest file.\n      s = SetCurrentFile(env_, dbname_, 1);\n    } else {\n      env_->DeleteFile(manifest);\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "~DBImpl",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "148-175",
    "snippet": "DBImpl::~DBImpl() {\n  // Wait for background work to finish\n  mutex_.Lock();\n  shutting_down_.Release_Store(this);  // Any non-NULL value is ok\n  while (bg_compaction_scheduled_) {\n    bg_cv_.Wait();\n  }\n  mutex_.Unlock();\n\n  if (db_lock_ != NULL) {\n    env_->UnlockFile(db_lock_);\n  }\n\n  delete versions_;\n  if (mem_ != NULL) mem_->Unref();\n  if (imm_ != NULL) imm_->Unref();\n  delete tmp_batch_;\n  delete log_;\n  delete logfile_;\n  delete table_cache_;\n\n  if (owns_info_log_) {\n    delete options_.info_log;\n  }\n  if (owns_cache_) {\n    delete options_.block_cache;\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "imm_->Unref",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->UnlockFile",
          "args": [
            "db_lock_"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "UnlockFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "871-876",
          "snippet": "Status Win32Env::UnlockFile( FileLock* lock )\n{\n    Status sRet;\n    delete lock;\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::UnlockFile( FileLock* lock )\n  {\n      Status sRet;\n      delete lock;\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Unlock",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_cv_.Wait",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutting_down_.Release_Store",
          "args": [
            "this"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "Release_Store",
          "container": "AtomicPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/atomic_pointer.h",
          "lines": "198-205",
          "snippet": "inline void Release_Store(void* v) {\n    __asm__ __volatile__ (\n        \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n        :\n        : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n        : \"memory\"\n        );\n  }",
          "includes": [
            "#include <libkern/OSAtomic.h>",
            "#include <windows.h>",
            "#include <cstdatomic>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libkern/OSAtomic.h>\n#include <windows.h>\n#include <cstdatomic>\n#include <stdint.h>\n\nAtomicPointer {\n  inline void Release_Store(void* v) {\n      __asm__ __volatile__ (\n          \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n          :\n          : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n          : \"memory\"\n          );\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_.Lock",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  DBImpl::~DBImpl() {\n    // Wait for background work to finish\n    mutex_.Lock();\n    shutting_down_.Release_Store(this);  // Any non-NULL value is ok\n    while (bg_compaction_scheduled_) {\n      bg_cv_.Wait();\n    }\n    mutex_.Unlock();\n  \n    if (db_lock_ != NULL) {\n      env_->UnlockFile(db_lock_);\n    }\n  \n    delete versions_;\n    if (mem_ != NULL) mem_->Unref();\n    if (imm_ != NULL) imm_->Unref();\n    delete tmp_batch_;\n    delete log_;\n    delete logfile_;\n    delete table_cache_;\n  \n    if (owns_info_log_) {\n      delete options_.info_log;\n    }\n    if (owns_cache_) {\n      delete options_.block_cache;\n    }\n  }\n}"
  },
  {
    "function_name": "DBImpl",
    "container": "DBImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "116-146",
    "snippet": "DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)\n    : env_(raw_options.env),\n      internal_comparator_(raw_options.comparator),\n      internal_filter_policy_(raw_options.filter_policy),\n      options_(SanitizeOptions(dbname, &internal_comparator_,\n                               &internal_filter_policy_, raw_options)),\n      owns_info_log_(options_.info_log != raw_options.info_log),\n      owns_cache_(options_.block_cache != raw_options.block_cache),\n      dbname_(dbname),\n      db_lock_(NULL),\n      shutting_down_(NULL),\n      bg_cv_(&mutex_),\n      mem_(new MemTable(internal_comparator_)),\n      imm_(NULL),\n      logfile_(NULL),\n      logfile_number_(0),\n      log_(NULL),\n      seed_(0),\n      tmp_batch_(new WriteBatch),\n      bg_compaction_scheduled_(false),\n      manual_compaction_(NULL) {\n  mem_->Ref();\n  has_imm_.Release_Store(NULL);\n\n  // Reserve ten files or so for other uses and give the rest to TableCache.\n  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;\n  table_cache_ = new TableCache(dbname_, &options_, table_cache_size);\n\n  versions_ = new VersionSet(dbname_, &options_, table_cache_,\n                             &internal_comparator_);\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_imm_.Release_Store",
          "args": [
            "NULL"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "Release_Store",
          "container": "AtomicPointer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/atomic_pointer.h",
          "lines": "198-205",
          "snippet": "inline void Release_Store(void* v) {\n    __asm__ __volatile__ (\n        \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n        :\n        : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n        : \"memory\"\n        );\n  }",
          "includes": [
            "#include <libkern/OSAtomic.h>",
            "#include <windows.h>",
            "#include <cstdatomic>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libkern/OSAtomic.h>\n#include <windows.h>\n#include <cstdatomic>\n#include <stdint.h>\n\nAtomicPointer {\n  inline void Release_Store(void* v) {\n      __asm__ __volatile__ (\n          \"st8.rel [%[rep_]] = %[v]  \\n\\t\"\n          :\n          : [rep_] \"r\" (&rep_), [v] \"r\" (v)\n          : \"memory\"\n          );\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_->Ref",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SanitizeOptions",
          "args": [
            "dbname",
            "&internal_comparator_",
            "&internal_filter_policy_",
            "raw_options"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "SanitizeOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "90-114",
          "snippet": "Options SanitizeOptions(const std::string& dbname,\n                        const InternalKeyComparator* icmp,\n                        const InternalFilterPolicy* ipolicy,\n                        const Options& src) {\n  Options result = src;\n  result.comparator = icmp;\n  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n  ClipToRange(&result.block_size,        1<<10,                       4<<20);\n  if (result.info_log == NULL) {\n    // Open a log file in the same directory as the db\n    src.env->CreateDir(dbname);  // In case it does not exist\n    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n    if (!s.ok()) {\n      // No place suitable for logging\n      result.info_log = NULL;\n    }\n  }\n  if (result.block_cache == NULL) {\n    result.block_cache = NewLRUCache(8 << 20);\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nOptions SanitizeOptions(const std::string& dbname,\n                        const InternalKeyComparator* icmp,\n                        const InternalFilterPolicy* ipolicy,\n                        const Options& src) {\n  Options result = src;\n  result.comparator = icmp;\n  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n  ClipToRange(&result.block_size,        1<<10,                       4<<20);\n  if (result.info_log == NULL) {\n    // Open a log file in the same directory as the db\n    src.env->CreateDir(dbname);  // In case it does not exist\n    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n    if (!s.ok()) {\n      // No place suitable for logging\n      result.info_log = NULL;\n    }\n  }\n  if (result.block_cache == NULL) {\n    result.block_cache = NewLRUCache(8 << 20);\n  }\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)\n      : env_(raw_options.env),\n        internal_comparator_(raw_options.comparator),\n        internal_filter_policy_(raw_options.filter_policy),\n        options_(SanitizeOptions(dbname, &internal_comparator_,\n                                 &internal_filter_policy_, raw_options)),\n        owns_info_log_(options_.info_log != raw_options.info_log),\n        owns_cache_(options_.block_cache != raw_options.block_cache),\n        dbname_(dbname),\n        db_lock_(NULL),\n        shutting_down_(NULL),\n        bg_cv_(&mutex_),\n        mem_(new MemTable(internal_comparator_)),\n        imm_(NULL),\n        logfile_(NULL),\n        logfile_number_(0),\n        log_(NULL),\n        seed_(0),\n        tmp_batch_(new WriteBatch),\n        bg_compaction_scheduled_(false),\n        manual_compaction_(NULL) {\n    mem_->Ref();\n    has_imm_.Release_Store(NULL);\n  \n    // Reserve ten files or so for other uses and give the rest to TableCache.\n    const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;\n    table_cache_ = new TableCache(dbname_, &options_, table_cache_size);\n  \n    versions_ = new VersionSet(dbname_, &options_, table_cache_,\n                               &internal_comparator_);\n  }\n}"
  },
  {
    "function_name": "SanitizeOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "90-114",
    "snippet": "Options SanitizeOptions(const std::string& dbname,\n                        const InternalKeyComparator* icmp,\n                        const InternalFilterPolicy* ipolicy,\n                        const Options& src) {\n  Options result = src;\n  result.comparator = icmp;\n  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n  ClipToRange(&result.block_size,        1<<10,                       4<<20);\n  if (result.info_log == NULL) {\n    // Open a log file in the same directory as the db\n    src.env->CreateDir(dbname);  // In case it does not exist\n    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n    if (!s.ok()) {\n      // No place suitable for logging\n      result.info_log = NULL;\n    }\n  }\n  if (result.block_cache == NULL) {\n    result.block_cache = NewLRUCache(8 << 20);\n  }\n  return result;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NewLRUCache",
          "args": [
            "8 << 20"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.env->NewLogger",
          "args": [
            "InfoLogFileName(dbname)",
            "&result.info_log"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "NewLogger",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "980-992",
          "snippet": "Status Win32Env::NewLogger( const std::string& fname, Logger** result )\n{\n    Status sRet;\n    std::string path = fname;\n    Win32MapFile* pMapFile = new Win32MapFile(ModifyPath(path));\n    if(!pMapFile->isEnable()){\n        delete pMapFile;\n        *result = NULL;\n        sRet = Status::IOError(path,\"could not create a logger.\");\n    }else\n        *result = new Win32Logger(pMapFile);\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::NewLogger( const std::string& fname, Logger** result )\n  {\n      Status sRet;\n      std::string path = fname;\n      Win32MapFile* pMapFile = new Win32MapFile(ModifyPath(path));\n      if(!pMapFile->isEnable()){\n          delete pMapFile;\n          *result = NULL;\n          sRet = Status::IOError(path,\"could not create a logger.\");\n      }else\n          *result = new Win32Logger(pMapFile);\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InfoLogFileName",
          "args": [
            "dbname"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "OldInfoLogFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "73-75",
          "snippet": "std::string OldInfoLogFileName(const std::string& dbname) {\n  return dbname + \"/LOG.old\";\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string OldInfoLogFileName(const std::string& dbname) {\n  return dbname + \"/LOG.old\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.env->RenameFile",
          "args": [
            "InfoLogFileName(dbname)",
            "OldInfoLogFileName(dbname)"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "RenameFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "832-853",
          "snippet": "Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n{\n    Status sRet;\n    std::string src_path = src;\n    std::wstring wsrc_path;\n\tToWidePath(ModifyPath(src_path), wsrc_path);\n\tstd::string target_path = target;\n    std::wstring wtarget_path;\n\tToWidePath(ModifyPath(target_path), wtarget_path);\n\n    if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n        DWORD err = GetLastError();\n        if(err == 0x000000b7){\n            if(!::DeleteFileW(wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");\n\t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                 wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");    \n        }\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n  {\n      Status sRet;\n      std::string src_path = src;\n      std::wstring wsrc_path;\n  \tToWidePath(ModifyPath(src_path), wsrc_path);\n  \tstd::string target_path = target;\n      std::wstring wtarget_path;\n  \tToWidePath(ModifyPath(target_path), wtarget_path);\n  \n      if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n          DWORD err = GetLastError();\n          if(err == 0x000000b7){\n              if(!::DeleteFileW(wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");\n  \t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                   wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");    \n          }\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.env->CreateDir",
          "args": [
            "dbname"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "CreateDir",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "928-937",
          "snippet": "Status Win32Env::CreateDir( const std::string& dirname )\n{\n    std::string path = dirname;\n    if(path[path.length() - 1] != '\\\\'){\n        path += '\\\\';\n    }\n    ModifyPath(path);\n\n    return CreateDirInner(path);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::CreateDir( const std::string& dirname )\n  {\n      std::string path = dirname;\n      if(path[path.length() - 1] != '\\\\'){\n          path += '\\\\';\n      }\n      ModifyPath(path);\n  \n      return CreateDirInner(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClipToRange",
          "args": [
            "&result.block_size",
            "1<<10",
            "4<<20"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ClipToRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "86-89",
          "snippet": "static void ClipToRange(T* ptr, V minvalue, V maxvalue) {\n  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;\n  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nstatic void ClipToRange(T* ptr, V minvalue, V maxvalue) {\n  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;\n  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nOptions SanitizeOptions(const std::string& dbname,\n                        const InternalKeyComparator* icmp,\n                        const InternalFilterPolicy* ipolicy,\n                        const Options& src) {\n  Options result = src;\n  result.comparator = icmp;\n  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n  ClipToRange(&result.block_size,        1<<10,                       4<<20);\n  if (result.info_log == NULL) {\n    // Open a log file in the same directory as the db\n    src.env->CreateDir(dbname);  // In case it does not exist\n    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n    if (!s.ok()) {\n      // No place suitable for logging\n      result.info_log = NULL;\n    }\n  }\n  if (result.block_cache == NULL) {\n    result.block_cache = NewLRUCache(8 << 20);\n  }\n  return result;\n}"
  },
  {
    "function_name": "ClipToRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "86-89",
    "snippet": "static void ClipToRange(T* ptr, V minvalue, V maxvalue) {\n  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;\n  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<V>",
          "args": [
            "*ptr"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<V>",
          "args": [
            "*ptr"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nstatic void ClipToRange(T* ptr, V minvalue, V maxvalue) {\n  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;\n  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;\n}"
  },
  {
    "function_name": "CompactionState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "76-81",
    "snippet": "explicit CompactionState(Compaction* c)\n      : compaction(c),\n        outfile(NULL),\n        builder(NULL),\n        total_bytes(0) {\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nexplicit CompactionState(Compaction* c)\n      : compaction(c),\n        outfile(NULL),\n        builder(NULL),\n        total_bytes(0) {\n  }"
  },
  {
    "function_name": "Writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
    "lines": "48-48",
    "snippet": "explicit Writer(port::Mutex* mu) : cv(mu) { }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_iter.h\"",
      "#include \"db/builder.h\"",
      "#include <vector>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <string>",
      "#include <set>",
      "#include <algorithm>",
      "#include \"db/db_impl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nexplicit Writer(port::Mutex* mu) : cv(mu) { }"
  }
]