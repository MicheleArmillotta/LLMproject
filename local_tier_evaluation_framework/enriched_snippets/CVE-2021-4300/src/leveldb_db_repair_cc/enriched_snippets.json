[
  {
    "function_name": "RepairDB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "457-460",
    "snippet": "Status RepairDB(const std::string& dbname, const Options& options) {\n  Repairer repairer(dbname, options);\n  return repairer.Run();\n}",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "repairer.Run",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "Run",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "70-92",
          "snippet": "Status Run() {\n    Status status = FindFiles();\n    if (status.ok()) {\n      ConvertLogFilesToTables();\n      ExtractMetaData();\n      status = WriteDescriptor();\n    }\n    if (status.ok()) {\n      unsigned long long bytes = 0;\n      for (size_t i = 0; i < tables_.size(); i++) {\n        bytes += tables_[i].meta.file_size;\n      }\n      Log(options_.info_log,\n          \"**** Repaired leveldb %s; \"\n          \"recovered %d files; %llu bytes. \"\n          \"Some data may have been lost. \"\n          \"****\",\n          dbname_.c_str(),\n          static_cast<int>(tables_.size()),\n          bytes);\n    }\n    return status;\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status Run() {\n      Status status = FindFiles();\n      if (status.ok()) {\n        ConvertLogFilesToTables();\n        ExtractMetaData();\n        status = WriteDescriptor();\n      }\n      if (status.ok()) {\n        unsigned long long bytes = 0;\n        for (size_t i = 0; i < tables_.size(); i++) {\n          bytes += tables_[i].meta.file_size;\n        }\n        Log(options_.info_log,\n            \"**** Repaired leveldb %s; \"\n            \"recovered %d files; %llu bytes. \"\n            \"Some data may have been lost. \"\n            \"****\",\n            dbname_.c_str(),\n            static_cast<int>(tables_.size()),\n            bytes);\n      }\n      return status;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nStatus RepairDB(const std::string& dbname, const Options& options) {\n  Repairer repairer(dbname, options);\n  return repairer.Run();\n}"
  },
  {
    "function_name": "ArchiveFile",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "435-453",
    "snippet": "void ArchiveFile(const std::string& fname) {\n    // Move into another directory.  E.g., for\n    //    dir/foo\n    // rename to\n    //    dir/lost/foo\n    const char* slash = strrchr(fname.c_str(), '/');\n    std::string new_dir;\n    if (slash != NULL) {\n      new_dir.assign(fname.data(), slash - fname.data());\n    }\n    new_dir.append(\"/lost\");\n    env_->CreateDir(new_dir);  // Ignore error\n    std::string new_file = new_dir;\n    new_file.append(\"/\");\n    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n    Status s = env_->RenameFile(fname, new_file);\n    Log(options_.info_log, \"Archiving %s: %s\\n\",\n        fname.c_str(), s.ToString().c_str());\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Archiving %s: %s\\n\"",
            "fname.c_str()",
            "s.ToString().c_str()"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->RenameFile",
          "args": [
            "fname",
            "new_file"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "RenameFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "832-853",
          "snippet": "Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n{\n    Status sRet;\n    std::string src_path = src;\n    std::wstring wsrc_path;\n\tToWidePath(ModifyPath(src_path), wsrc_path);\n\tstd::string target_path = target;\n    std::wstring wtarget_path;\n\tToWidePath(ModifyPath(target_path), wtarget_path);\n\n    if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n        DWORD err = GetLastError();\n        if(err == 0x000000b7){\n            if(!::DeleteFileW(wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");\n\t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                 wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");    \n        }\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n  {\n      Status sRet;\n      std::string src_path = src;\n      std::wstring wsrc_path;\n  \tToWidePath(ModifyPath(src_path), wsrc_path);\n  \tstd::string target_path = target;\n      std::wstring wtarget_path;\n  \tToWidePath(ModifyPath(target_path), wtarget_path);\n  \n      if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n          DWORD err = GetLastError();\n          if(err == 0x000000b7){\n              if(!::DeleteFileW(wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");\n  \t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                   wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");    \n          }\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_file.append",
          "args": [
            "(slash == NULL) ? fname.c_str() : slash + 1"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_file.append",
          "args": [
            "\"/\""
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->CreateDir",
          "args": [
            "new_dir"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "CreateDir",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "928-937",
          "snippet": "Status Win32Env::CreateDir( const std::string& dirname )\n{\n    std::string path = dirname;\n    if(path[path.length() - 1] != '\\\\'){\n        path += '\\\\';\n    }\n    ModifyPath(path);\n\n    return CreateDirInner(path);\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::CreateDir( const std::string& dirname )\n  {\n      std::string path = dirname;\n      if(path[path.length() - 1] != '\\\\'){\n          path += '\\\\';\n      }\n      ModifyPath(path);\n  \n      return CreateDirInner(path);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_dir.append",
          "args": [
            "\"/lost\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_dir.assign",
          "args": [
            "fname.data()",
            "slash - fname.data()"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.data",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.data",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "fname.c_str()",
            "'/'"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ArchiveFile(const std::string& fname) {\n      // Move into another directory.  E.g., for\n      //    dir/foo\n      // rename to\n      //    dir/lost/foo\n      const char* slash = strrchr(fname.c_str(), '/');\n      std::string new_dir;\n      if (slash != NULL) {\n        new_dir.assign(fname.data(), slash - fname.data());\n      }\n      new_dir.append(\"/lost\");\n      env_->CreateDir(new_dir);  // Ignore error\n      std::string new_file = new_dir;\n      new_file.append(\"/\");\n      new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n      Status s = env_->RenameFile(fname, new_file);\n      Log(options_.info_log, \"Archiving %s: %s\\n\",\n          fname.c_str(), s.ToString().c_str());\n    }\n}"
  },
  {
    "function_name": "WriteDescriptor",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "376-433",
    "snippet": "Status WriteDescriptor() {\n    std::string tmp = TempFileName(dbname_, 1);\n    WritableFile* file;\n    Status status = env_->NewWritableFile(tmp, &file);\n    if (!status.ok()) {\n      return status;\n    }\n\n    SequenceNumber max_sequence = 0;\n    for (size_t i = 0; i < tables_.size(); i++) {\n      if (max_sequence < tables_[i].max_sequence) {\n        max_sequence = tables_[i].max_sequence;\n      }\n    }\n\n    edit_.SetComparatorName(icmp_.user_comparator()->Name());\n    edit_.SetLogNumber(0);\n    edit_.SetNextFile(next_file_number_);\n    edit_.SetLastSequence(max_sequence);\n\n    for (size_t i = 0; i < tables_.size(); i++) {\n      // TODO(opt): separate out into multiple levels\n      const TableInfo& t = tables_[i];\n      edit_.AddFile(0, t.meta.number, t.meta.file_size,\n                    t.meta.smallest, t.meta.largest);\n    }\n\n    //fprintf(stderr, \"NewDescriptor:\\n%s\\n\", edit_.DebugString().c_str());\n    {\n      log::Writer log(file);\n      std::string record;\n      edit_.EncodeTo(&record);\n      status = log.AddRecord(record);\n    }\n    if (status.ok()) {\n      status = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (!status.ok()) {\n      env_->DeleteFile(tmp);\n    } else {\n      // Discard older manifests\n      for (size_t i = 0; i < manifests_.size(); i++) {\n        ArchiveFile(dbname_ + \"/\" + manifests_[i]);\n      }\n\n      // Install new manifest\n      status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));\n      if (status.ok()) {\n        status = SetCurrentFile(env_, dbname_, 1);\n      } else {\n        env_->DeleteFile(tmp);\n      }\n    }\n    return status;\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [
            "tmp"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetCurrentFile",
          "args": [
            "env_",
            "dbname_",
            "1"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "SetCurrentFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "131-147",
          "snippet": "Status SetCurrentFile(Env* env, const std::string& dbname,\n                      uint64_t descriptor_number) {\n  // Remove leading \"dbname/\" and add newline to manifest file name\n  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n  Slice contents = manifest;\n  assert(contents.starts_with(dbname + \"/\"));\n  contents.remove_prefix(dbname.size() + 1);\n  std::string tmp = TempFileName(dbname, descriptor_number);\n  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n  if (s.ok()) {\n    s = env->RenameFile(tmp, CurrentFileName(dbname));\n  }\n  if (!s.ok()) {\n    env->DeleteFile(tmp);\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nStatus SetCurrentFile(Env* env, const std::string& dbname,\n                      uint64_t descriptor_number) {\n  // Remove leading \"dbname/\" and add newline to manifest file name\n  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n  Slice contents = manifest;\n  assert(contents.starts_with(dbname + \"/\"));\n  contents.remove_prefix(dbname.size() + 1);\n  std::string tmp = TempFileName(dbname, descriptor_number);\n  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n  if (s.ok()) {\n    s = env->RenameFile(tmp, CurrentFileName(dbname));\n  }\n  if (!s.ok()) {\n    env->DeleteFile(tmp);\n  }\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->RenameFile",
          "args": [
            "tmp",
            "DescriptorFileName(dbname_, 1)"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "RenameFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "832-853",
          "snippet": "Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n{\n    Status sRet;\n    std::string src_path = src;\n    std::wstring wsrc_path;\n\tToWidePath(ModifyPath(src_path), wsrc_path);\n\tstd::string target_path = target;\n    std::wstring wtarget_path;\n\tToWidePath(ModifyPath(target_path), wtarget_path);\n\n    if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n        DWORD err = GetLastError();\n        if(err == 0x000000b7){\n            if(!::DeleteFileW(wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");\n\t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                 wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");    \n        }\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n  {\n      Status sRet;\n      std::string src_path = src;\n      std::wstring wsrc_path;\n  \tToWidePath(ModifyPath(src_path), wsrc_path);\n  \tstd::string target_path = target;\n      std::wstring wtarget_path;\n  \tToWidePath(ModifyPath(target_path), wtarget_path);\n  \n      if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n          DWORD err = GetLastError();\n          if(err == 0x000000b7){\n              if(!::DeleteFileW(wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");\n  \t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                   wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");    \n          }\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DescriptorFileName",
          "args": [
            "dbname_",
            "1"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "DescriptorFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "47-53",
          "snippet": "std::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n           static_cast<unsigned long long>(number));\n  return dbname + buf;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n           static_cast<unsigned long long>(number));\n  return dbname + buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArchiveFile",
          "args": [
            "dbname_ + \"/\" + manifests_[i]"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ArchiveFile",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "435-453",
          "snippet": "void ArchiveFile(const std::string& fname) {\n    // Move into another directory.  E.g., for\n    //    dir/foo\n    // rename to\n    //    dir/lost/foo\n    const char* slash = strrchr(fname.c_str(), '/');\n    std::string new_dir;\n    if (slash != NULL) {\n      new_dir.assign(fname.data(), slash - fname.data());\n    }\n    new_dir.append(\"/lost\");\n    env_->CreateDir(new_dir);  // Ignore error\n    std::string new_file = new_dir;\n    new_file.append(\"/\");\n    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n    Status s = env_->RenameFile(fname, new_file);\n    Log(options_.info_log, \"Archiving %s: %s\\n\",\n        fname.c_str(), s.ToString().c_str());\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ArchiveFile(const std::string& fname) {\n      // Move into another directory.  E.g., for\n      //    dir/foo\n      // rename to\n      //    dir/lost/foo\n      const char* slash = strrchr(fname.c_str(), '/');\n      std::string new_dir;\n      if (slash != NULL) {\n        new_dir.assign(fname.data(), slash - fname.data());\n      }\n      new_dir.append(\"/lost\");\n      env_->CreateDir(new_dir);  // Ignore error\n      std::string new_file = new_dir;\n      new_file.append(\"/\");\n      new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n      Status s = env_->RenameFile(fname, new_file);\n      Log(options_.info_log, \"Archiving %s: %s\\n\",\n          fname.c_str(), s.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "manifests_.size",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Close",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "261-264",
          "snippet": "void Close() {\n    delete db_;\n    db_ = NULL;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  void Close() {\n      delete db_;\n      db_ = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "log.AddRecord",
          "args": [
            "record"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "AddRecord",
          "container": "Writer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
          "lines": "27-73",
          "snippet": "Status Writer::AddRecord(const Slice& slice) {\n  const char* ptr = slice.data();\n  size_t left = slice.size();\n\n  // Fragment the record if necessary and emit it.  Note that if slice\n  // is empty, we still want to iterate once to emit a single\n  // zero-length record\n  Status s;\n  bool begin = true;\n  do {\n    const int leftover = kBlockSize - block_offset_;\n    assert(leftover >= 0);\n    if (leftover < kHeaderSize) {\n      // Switch to a new block\n      if (leftover > 0) {\n        // Fill the trailer (literal below relies on kHeaderSize being 7)\n        assert(kHeaderSize == 7);\n        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n      }\n      block_offset_ = 0;\n    }\n\n    // Invariant: we never leave < kHeaderSize bytes in a block.\n    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n\n    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n    const size_t fragment_length = (left < avail) ? left : avail;\n\n    RecordType type;\n    const bool end = (left == fragment_length);\n    if (begin && end) {\n      type = kFullType;\n    } else if (begin) {\n      type = kFirstType;\n    } else if (end) {\n      type = kLastType;\n    } else {\n      type = kMiddleType;\n    }\n\n    s = EmitPhysicalRecord(type, ptr, fragment_length);\n    ptr += fragment_length;\n    left -= fragment_length;\n    begin = false;\n  } while (s.ok() && left > 0);\n  return s;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdint.h>",
            "#include \"db/log_writer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::AddRecord(const Slice& slice) {\n    const char* ptr = slice.data();\n    size_t left = slice.size();\n  \n    // Fragment the record if necessary and emit it.  Note that if slice\n    // is empty, we still want to iterate once to emit a single\n    // zero-length record\n    Status s;\n    bool begin = true;\n    do {\n      const int leftover = kBlockSize - block_offset_;\n      assert(leftover >= 0);\n      if (leftover < kHeaderSize) {\n        // Switch to a new block\n        if (leftover > 0) {\n          // Fill the trailer (literal below relies on kHeaderSize being 7)\n          assert(kHeaderSize == 7);\n          dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n        }\n        block_offset_ = 0;\n      }\n  \n      // Invariant: we never leave < kHeaderSize bytes in a block.\n      assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n  \n      const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n      const size_t fragment_length = (left < avail) ? left : avail;\n  \n      RecordType type;\n      const bool end = (left == fragment_length);\n      if (begin && end) {\n        type = kFullType;\n      } else if (begin) {\n        type = kFirstType;\n      } else if (end) {\n        type = kLastType;\n      } else {\n        type = kMiddleType;\n      }\n  \n      s = EmitPhysicalRecord(type, ptr, fragment_length);\n      ptr += fragment_length;\n      left -= fragment_length;\n      begin = false;\n    } while (s.ok() && left > 0);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit_.EncodeTo",
          "args": [
            "&record"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTo",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "41-86",
          "snippet": "void VersionEdit::EncodeTo(std::string* dst) const {\n  if (has_comparator_) {\n    PutVarint32(dst, kComparator);\n    PutLengthPrefixedSlice(dst, comparator_);\n  }\n  if (has_log_number_) {\n    PutVarint32(dst, kLogNumber);\n    PutVarint64(dst, log_number_);\n  }\n  if (has_prev_log_number_) {\n    PutVarint32(dst, kPrevLogNumber);\n    PutVarint64(dst, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    PutVarint32(dst, kNextFileNumber);\n    PutVarint64(dst, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    PutVarint32(dst, kLastSequence);\n    PutVarint64(dst, last_sequence_);\n  }\n\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    PutVarint32(dst, kCompactPointer);\n    PutVarint32(dst, compact_pointers_[i].first);  // level\n    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n  }\n\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    PutVarint32(dst, kDeletedFile);\n    PutVarint32(dst, iter->first);   // level\n    PutVarint64(dst, iter->second);  // file number\n  }\n\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    PutVarint32(dst, kNewFile);\n    PutVarint32(dst, new_files_[i].first);  // level\n    PutVarint64(dst, f.number);\n    PutVarint64(dst, f.file_size);\n    PutLengthPrefixedSlice(dst, f.smallest.Encode());\n    PutLengthPrefixedSlice(dst, f.largest.Encode());\n  }\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  void VersionEdit::EncodeTo(std::string* dst) const {\n    if (has_comparator_) {\n      PutVarint32(dst, kComparator);\n      PutLengthPrefixedSlice(dst, comparator_);\n    }\n    if (has_log_number_) {\n      PutVarint32(dst, kLogNumber);\n      PutVarint64(dst, log_number_);\n    }\n    if (has_prev_log_number_) {\n      PutVarint32(dst, kPrevLogNumber);\n      PutVarint64(dst, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      PutVarint32(dst, kNextFileNumber);\n      PutVarint64(dst, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      PutVarint32(dst, kLastSequence);\n      PutVarint64(dst, last_sequence_);\n    }\n  \n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      PutVarint32(dst, kCompactPointer);\n      PutVarint32(dst, compact_pointers_[i].first);  // level\n      PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n    }\n  \n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      PutVarint32(dst, kDeletedFile);\n      PutVarint32(dst, iter->first);   // level\n      PutVarint64(dst, iter->second);  // file number\n    }\n  \n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      PutVarint32(dst, kNewFile);\n      PutVarint32(dst, new_files_[i].first);  // level\n      PutVarint64(dst, f.number);\n      PutVarint64(dst, f.file_size);\n      PutLengthPrefixedSlice(dst, f.smallest.Encode());\n      PutLengthPrefixedSlice(dst, f.largest.Encode());\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit_.AddFile",
          "args": [
            "0",
            "t.meta.number",
            "t.meta.file_size",
            "t.meta.smallest",
            "t.meta.largest"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "AddFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "62-72",
          "snippet": "void AddFile(int level, uint64_t file,\n               uint64_t file_size,\n               const InternalKey& smallest,\n               const InternalKey& largest) {\n    FileMetaData f;\n    f.number = file;\n    f.file_size = file_size;\n    f.smallest = smallest;\n    f.largest = largest;\n    new_files_.push_back(std::make_pair(level, f));\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void AddFile(int level, uint64_t file,\n                 uint64_t file_size,\n                 const InternalKey& smallest,\n                 const InternalKey& largest) {\n      FileMetaData f;\n      f.number = file;\n      f.file_size = file_size;\n      f.smallest = smallest;\n      f.largest = largest;\n      new_files_.push_back(std::make_pair(level, f));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit_.SetLastSequence",
          "args": [
            "max_sequence"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "SetLastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "212-215",
          "snippet": "void SetLastSequence(uint64_t s) {\n    assert(s >= last_sequence_);\n    last_sequence_ = s;\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  void SetLastSequence(uint64_t s) {\n      assert(s >= last_sequence_);\n      last_sequence_ = s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit_.SetNextFile",
          "args": [
            "next_file_number_"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "SetNextFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "47-50",
          "snippet": "void SetNextFile(uint64_t num) {\n    has_next_file_number_ = true;\n    next_file_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetNextFile(uint64_t num) {\n      has_next_file_number_ = true;\n      next_file_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit_.SetLogNumber",
          "args": [
            "0"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "SetLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "39-42",
          "snippet": "void SetLogNumber(uint64_t num) {\n    has_log_number_ = true;\n    log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetLogNumber(uint64_t num) {\n      has_log_number_ = true;\n      log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit_.SetComparatorName",
          "args": [
            "icmp_.user_comparator()->Name()"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "SetComparatorName",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "35-38",
          "snippet": "void SetComparatorName(const Slice& name) {\n    has_comparator_ = true;\n    comparator_ = name.ToString();\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetComparatorName(const Slice& name) {\n      has_comparator_ = true;\n      comparator_ = name.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "tmp",
            "&file"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TempFileName",
          "args": [
            "dbname_",
            "1"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "TempFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "63-66",
          "snippet": "std::string TempFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(dbname, number, \"dbtmp\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string TempFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(dbname, number, \"dbtmp\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status WriteDescriptor() {\n      std::string tmp = TempFileName(dbname_, 1);\n      WritableFile* file;\n      Status status = env_->NewWritableFile(tmp, &file);\n      if (!status.ok()) {\n        return status;\n      }\n  \n      SequenceNumber max_sequence = 0;\n      for (size_t i = 0; i < tables_.size(); i++) {\n        if (max_sequence < tables_[i].max_sequence) {\n          max_sequence = tables_[i].max_sequence;\n        }\n      }\n  \n      edit_.SetComparatorName(icmp_.user_comparator()->Name());\n      edit_.SetLogNumber(0);\n      edit_.SetNextFile(next_file_number_);\n      edit_.SetLastSequence(max_sequence);\n  \n      for (size_t i = 0; i < tables_.size(); i++) {\n        // TODO(opt): separate out into multiple levels\n        const TableInfo& t = tables_[i];\n        edit_.AddFile(0, t.meta.number, t.meta.file_size,\n                      t.meta.smallest, t.meta.largest);\n      }\n  \n      //fprintf(stderr, \"NewDescriptor:\\n%s\\n\", edit_.DebugString().c_str());\n      {\n        log::Writer log(file);\n        std::string record;\n        edit_.EncodeTo(&record);\n        status = log.AddRecord(record);\n      }\n      if (status.ok()) {\n        status = file->Close();\n      }\n      delete file;\n      file = NULL;\n  \n      if (!status.ok()) {\n        env_->DeleteFile(tmp);\n      } else {\n        // Discard older manifests\n        for (size_t i = 0; i < manifests_.size(); i++) {\n          ArchiveFile(dbname_ + \"/\" + manifests_[i]);\n        }\n  \n        // Install new manifest\n        status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));\n        if (status.ok()) {\n          status = SetCurrentFile(env_, dbname_, 1);\n        } else {\n          env_->DeleteFile(tmp);\n        }\n      }\n      return status;\n    }\n}"
  },
  {
    "function_name": "RepairTable",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "322-374",
    "snippet": "void RepairTable(const std::string& src, TableInfo t) {\n    // We will copy src contents to a new table and then rename the\n    // new table over the source.\n\n    // Create builder.\n    std::string copy = TableFileName(dbname_, next_file_number_++);\n    WritableFile* file;\n    Status s = env_->NewWritableFile(copy, &file);\n    if (!s.ok()) {\n      return;\n    }\n    TableBuilder* builder = new TableBuilder(options_, file);\n\n    // Copy data.\n    Iterator* iter = NewTableIterator(t.meta);\n    int counter = 0;\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      builder->Add(iter->key(), iter->value());\n      counter++;\n    }\n    delete iter;\n\n    ArchiveFile(src);\n    if (counter == 0) {\n      builder->Abandon();  // Nothing to save\n    } else {\n      s = builder->Finish();\n      if (s.ok()) {\n        t.meta.file_size = builder->FileSize();\n      }\n    }\n    delete builder;\n    builder = NULL;\n\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (counter > 0 && s.ok()) {\n      std::string orig = TableFileName(dbname_, t.meta.number);\n      s = env_->RenameFile(copy, orig);\n      if (s.ok()) {\n        Log(options_.info_log, \"Table #%llu: %d entries repaired\",\n            (unsigned long long) t.meta.number, counter);\n        tables_.push_back(t);\n      }\n    }\n    if (!s.ok()) {\n      env_->DeleteFile(copy);\n    }\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [
            "copy"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tables_.push_back",
          "args": [
            "t"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Table #%llu: %d entries repaired\"",
            "(unsigned long long) t.meta.number",
            "counter"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->RenameFile",
          "args": [
            "copy",
            "orig"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "RenameFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "832-853",
          "snippet": "Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n{\n    Status sRet;\n    std::string src_path = src;\n    std::wstring wsrc_path;\n\tToWidePath(ModifyPath(src_path), wsrc_path);\n\tstd::string target_path = target;\n    std::wstring wtarget_path;\n\tToWidePath(ModifyPath(target_path), wtarget_path);\n\n    if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n        DWORD err = GetLastError();\n        if(err == 0x000000b7){\n            if(!::DeleteFileW(wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");\n\t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                 wtarget_path.c_str() ) )\n                sRet = Status::IOError(src, \"Could not rename file.\");    \n        }\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::RenameFile( const std::string& src, const std::string& target )\n  {\n      Status sRet;\n      std::string src_path = src;\n      std::wstring wsrc_path;\n  \tToWidePath(ModifyPath(src_path), wsrc_path);\n  \tstd::string target_path = target;\n      std::wstring wtarget_path;\n  \tToWidePath(ModifyPath(target_path), wtarget_path);\n  \n      if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){\n          DWORD err = GetLastError();\n          if(err == 0x000000b7){\n              if(!::DeleteFileW(wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");\n  \t\t\telse if(!::MoveFileW(wsrc_path.c_str(),\n                                   wtarget_path.c_str() ) )\n                  sRet = Status::IOError(src, \"Could not rename file.\");    \n          }\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TableFileName",
          "args": [
            "dbname_",
            "t.meta.number"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "SSTTableFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "42-45",
          "snippet": "std::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Close",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "261-264",
          "snippet": "void Close() {\n    delete db_;\n    db_ = NULL;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  void Close() {\n      delete db_;\n      db_ = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->FileSize",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "FileSize",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "266-268",
          "snippet": "uint64_t TableBuilder::FileSize() const {\n  return rep_->offset;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  uint64_t TableBuilder::FileSize() const {\n    return rep_->offset;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->Finish",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "Finish",
          "container": "FilterBlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
          "lines": "36-50",
          "snippet": "Slice FilterBlockBuilder::Finish() {\n  if (!start_.empty()) {\n    GenerateFilter();\n  }\n\n  // Append array of per-filter offsets\n  const uint32_t array_offset = result_.size();\n  for (size_t i = 0; i < filter_offsets_.size(); i++) {\n    PutFixed32(&result_, filter_offsets_[i]);\n  }\n\n  PutFixed32(&result_, array_offset);\n  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n  return Slice(result_);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"table/filter_block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  Slice FilterBlockBuilder::Finish() {\n    if (!start_.empty()) {\n      GenerateFilter();\n    }\n  \n    // Append array of per-filter offsets\n    const uint32_t array_offset = result_.size();\n    for (size_t i = 0; i < filter_offsets_.size(); i++) {\n      PutFixed32(&result_, filter_offsets_[i]);\n    }\n  \n    PutFixed32(&result_, array_offset);\n    result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n    return Slice(result_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->Abandon",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "Abandon",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "256-260",
          "snippet": "void TableBuilder::Abandon() {\n  Rep* r = rep_;\n  assert(!r->closed);\n  r->closed = true;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  void TableBuilder::Abandon() {\n    Rep* r = rep_;\n    assert(!r->closed);\n    r->closed = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArchiveFile",
          "args": [
            "src"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "ArchiveFile",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "435-453",
          "snippet": "void ArchiveFile(const std::string& fname) {\n    // Move into another directory.  E.g., for\n    //    dir/foo\n    // rename to\n    //    dir/lost/foo\n    const char* slash = strrchr(fname.c_str(), '/');\n    std::string new_dir;\n    if (slash != NULL) {\n      new_dir.assign(fname.data(), slash - fname.data());\n    }\n    new_dir.append(\"/lost\");\n    env_->CreateDir(new_dir);  // Ignore error\n    std::string new_file = new_dir;\n    new_file.append(\"/\");\n    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n    Status s = env_->RenameFile(fname, new_file);\n    Log(options_.info_log, \"Archiving %s: %s\\n\",\n        fname.c_str(), s.ToString().c_str());\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ArchiveFile(const std::string& fname) {\n      // Move into another directory.  E.g., for\n      //    dir/foo\n      // rename to\n      //    dir/lost/foo\n      const char* slash = strrchr(fname.c_str(), '/');\n      std::string new_dir;\n      if (slash != NULL) {\n        new_dir.assign(fname.data(), slash - fname.data());\n      }\n      new_dir.append(\"/lost\");\n      env_->CreateDir(new_dir);  // Ignore error\n      std::string new_file = new_dir;\n      new_file.append(\"/\");\n      new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n      Status s = env_->RenameFile(fname, new_file);\n      Log(options_.info_log, \"Archiving %s: %s\\n\",\n          fname.c_str(), s.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->Add",
          "args": [
            "iter->key()",
            "iter->value()"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "FindFileTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set_test.cc",
          "lines": "25-33",
          "snippet": "void Add(const char* smallest, const char* largest,\n           SequenceNumber smallest_seq = 100,\n           SequenceNumber largest_seq = 100) {\n    FileMetaData* f = new FileMetaData;\n    f->number = files_.size() + 1;\n    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n    f->largest = InternalKey(largest, largest_seq, kTypeValue);\n    files_.push_back(f);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n\nFindFileTest {\n  void Add(const char* smallest, const char* largest,\n             SequenceNumber smallest_seq = 100,\n             SequenceNumber largest_seq = 100) {\n      FileMetaData* f = new FileMetaData;\n      f->number = files_.size() + 1;\n      f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n      f->largest = InternalKey(largest, largest_seq, kTypeValue);\n      files_.push_back(f);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewTableIterator",
          "args": [
            "t.meta"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "copy",
            "&file"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void RepairTable(const std::string& src, TableInfo t) {\n      // We will copy src contents to a new table and then rename the\n      // new table over the source.\n  \n      // Create builder.\n      std::string copy = TableFileName(dbname_, next_file_number_++);\n      WritableFile* file;\n      Status s = env_->NewWritableFile(copy, &file);\n      if (!s.ok()) {\n        return;\n      }\n      TableBuilder* builder = new TableBuilder(options_, file);\n  \n      // Copy data.\n      Iterator* iter = NewTableIterator(t.meta);\n      int counter = 0;\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        builder->Add(iter->key(), iter->value());\n        counter++;\n      }\n      delete iter;\n  \n      ArchiveFile(src);\n      if (counter == 0) {\n        builder->Abandon();  // Nothing to save\n      } else {\n        s = builder->Finish();\n        if (s.ok()) {\n          t.meta.file_size = builder->FileSize();\n        }\n      }\n      delete builder;\n      builder = NULL;\n  \n      if (s.ok()) {\n        s = file->Close();\n      }\n      delete file;\n      file = NULL;\n  \n      if (counter > 0 && s.ok()) {\n        std::string orig = TableFileName(dbname_, t.meta.number);\n        s = env_->RenameFile(copy, orig);\n        if (s.ok()) {\n          Log(options_.info_log, \"Table #%llu: %d entries repaired\",\n              (unsigned long long) t.meta.number, counter);\n          tables_.push_back(t);\n        }\n      }\n      if (!s.ok()) {\n        env_->DeleteFile(copy);\n      }\n    }\n}"
  },
  {
    "function_name": "ScanTable",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "259-320",
    "snippet": "void ScanTable(uint64_t number) {\n    TableInfo t;\n    t.meta.number = number;\n    std::string fname = TableFileName(dbname_, number);\n    Status status = env_->GetFileSize(fname, &t.meta.file_size);\n    if (!status.ok()) {\n      // Try alternate file name.\n      fname = SSTTableFileName(dbname_, number);\n      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);\n      if (s2.ok()) {\n        status = Status::OK();\n      }\n    }\n    if (!status.ok()) {\n      ArchiveFile(TableFileName(dbname_, number));\n      ArchiveFile(SSTTableFileName(dbname_, number));\n      Log(options_.info_log, \"Table #%llu: dropped: %s\",\n          (unsigned long long) t.meta.number,\n          status.ToString().c_str());\n      return;\n    }\n\n    // Extract metadata by scanning through table.\n    int counter = 0;\n    Iterator* iter = NewTableIterator(t.meta);\n    bool empty = true;\n    ParsedInternalKey parsed;\n    t.max_sequence = 0;\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      if (!ParseInternalKey(key, &parsed)) {\n        Log(options_.info_log, \"Table #%llu: unparsable key %s\",\n            (unsigned long long) t.meta.number,\n            EscapeString(key).c_str());\n        continue;\n      }\n\n      counter++;\n      if (empty) {\n        empty = false;\n        t.meta.smallest.DecodeFrom(key);\n      }\n      t.meta.largest.DecodeFrom(key);\n      if (parsed.sequence > t.max_sequence) {\n        t.max_sequence = parsed.sequence;\n      }\n    }\n    if (!iter->status().ok()) {\n      status = iter->status();\n    }\n    delete iter;\n    Log(options_.info_log, \"Table #%llu: %d entries %s\",\n        (unsigned long long) t.meta.number,\n        counter,\n        status.ToString().c_str());\n\n    if (status.ok()) {\n      tables_.push_back(t);\n    } else {\n      RepairTable(fname, t);  // RepairTable archives input file.\n    }\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RepairTable",
          "args": [
            "fname",
            "t"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "RepairTable",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "322-374",
          "snippet": "void RepairTable(const std::string& src, TableInfo t) {\n    // We will copy src contents to a new table and then rename the\n    // new table over the source.\n\n    // Create builder.\n    std::string copy = TableFileName(dbname_, next_file_number_++);\n    WritableFile* file;\n    Status s = env_->NewWritableFile(copy, &file);\n    if (!s.ok()) {\n      return;\n    }\n    TableBuilder* builder = new TableBuilder(options_, file);\n\n    // Copy data.\n    Iterator* iter = NewTableIterator(t.meta);\n    int counter = 0;\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      builder->Add(iter->key(), iter->value());\n      counter++;\n    }\n    delete iter;\n\n    ArchiveFile(src);\n    if (counter == 0) {\n      builder->Abandon();  // Nothing to save\n    } else {\n      s = builder->Finish();\n      if (s.ok()) {\n        t.meta.file_size = builder->FileSize();\n      }\n    }\n    delete builder;\n    builder = NULL;\n\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (counter > 0 && s.ok()) {\n      std::string orig = TableFileName(dbname_, t.meta.number);\n      s = env_->RenameFile(copy, orig);\n      if (s.ok()) {\n        Log(options_.info_log, \"Table #%llu: %d entries repaired\",\n            (unsigned long long) t.meta.number, counter);\n        tables_.push_back(t);\n      }\n    }\n    if (!s.ok()) {\n      env_->DeleteFile(copy);\n    }\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void RepairTable(const std::string& src, TableInfo t) {\n      // We will copy src contents to a new table and then rename the\n      // new table over the source.\n  \n      // Create builder.\n      std::string copy = TableFileName(dbname_, next_file_number_++);\n      WritableFile* file;\n      Status s = env_->NewWritableFile(copy, &file);\n      if (!s.ok()) {\n        return;\n      }\n      TableBuilder* builder = new TableBuilder(options_, file);\n  \n      // Copy data.\n      Iterator* iter = NewTableIterator(t.meta);\n      int counter = 0;\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        builder->Add(iter->key(), iter->value());\n        counter++;\n      }\n      delete iter;\n  \n      ArchiveFile(src);\n      if (counter == 0) {\n        builder->Abandon();  // Nothing to save\n      } else {\n        s = builder->Finish();\n        if (s.ok()) {\n          t.meta.file_size = builder->FileSize();\n        }\n      }\n      delete builder;\n      builder = NULL;\n  \n      if (s.ok()) {\n        s = file->Close();\n      }\n      delete file;\n      file = NULL;\n  \n      if (counter > 0 && s.ok()) {\n        std::string orig = TableFileName(dbname_, t.meta.number);\n        s = env_->RenameFile(copy, orig);\n        if (s.ok()) {\n          Log(options_.info_log, \"Table #%llu: %d entries repaired\",\n              (unsigned long long) t.meta.number, counter);\n          tables_.push_back(t);\n        }\n      }\n      if (!s.ok()) {\n        env_->DeleteFile(copy);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tables_.push_back",
          "args": [
            "t"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Table #%llu: %d entries %s\"",
            "(unsigned long long) t.meta.number",
            "counter",
            "status.ToString().c_str()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->status",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "74-80",
          "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Status status() const {\n      if (status_.ok()) {\n        return iter_->status();\n      } else {\n        return status_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t.meta.largest.DecodeFrom",
          "args": [
            "key"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "153-153",
          "snippet": "void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Table #%llu: unparsable key %s\"",
            "(unsigned long long) t.meta.number",
            "EscapeString(key).c_str()"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [
            "key"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "EscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "42-46",
          "snippet": "std::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "key",
            "&parsed"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewTableIterator",
          "args": [
            "t.meta"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Table #%llu: dropped: %s\"",
            "(unsigned long long) t.meta.number",
            "status.ToString().c_str()"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArchiveFile",
          "args": [
            "SSTTableFileName(dbname_, number)"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ArchiveFile",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "435-453",
          "snippet": "void ArchiveFile(const std::string& fname) {\n    // Move into another directory.  E.g., for\n    //    dir/foo\n    // rename to\n    //    dir/lost/foo\n    const char* slash = strrchr(fname.c_str(), '/');\n    std::string new_dir;\n    if (slash != NULL) {\n      new_dir.assign(fname.data(), slash - fname.data());\n    }\n    new_dir.append(\"/lost\");\n    env_->CreateDir(new_dir);  // Ignore error\n    std::string new_file = new_dir;\n    new_file.append(\"/\");\n    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n    Status s = env_->RenameFile(fname, new_file);\n    Log(options_.info_log, \"Archiving %s: %s\\n\",\n        fname.c_str(), s.ToString().c_str());\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ArchiveFile(const std::string& fname) {\n      // Move into another directory.  E.g., for\n      //    dir/foo\n      // rename to\n      //    dir/lost/foo\n      const char* slash = strrchr(fname.c_str(), '/');\n      std::string new_dir;\n      if (slash != NULL) {\n        new_dir.assign(fname.data(), slash - fname.data());\n      }\n      new_dir.append(\"/lost\");\n      env_->CreateDir(new_dir);  // Ignore error\n      std::string new_file = new_dir;\n      new_file.append(\"/\");\n      new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n      Status s = env_->RenameFile(fname, new_file);\n      Log(options_.info_log, \"Archiving %s: %s\\n\",\n          fname.c_str(), s.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSTTableFileName",
          "args": [
            "dbname_",
            "number"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "SSTTableFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "42-45",
          "snippet": "std::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->GetFileSize",
          "args": [
            "fname",
            "&t.meta.file_size"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "GetFileSize",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "814-830",
          "snippet": "Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    HANDLE file = ::CreateFileW(wpath.c_str(),\n        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n    LARGE_INTEGER li;\n    if(::GetFileSizeEx(file,&li)){\n        *file_size = (uint64_t)li.QuadPart;\n    }else\n        sRet = Status::IOError(path,\"Could not get the file size.\");\n    CloseHandle(file);\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      HANDLE file = ::CreateFileW(wpath.c_str(),\n          GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n      LARGE_INTEGER li;\n      if(::GetFileSizeEx(file,&li)){\n          *file_size = (uint64_t)li.QuadPart;\n      }else\n          sRet = Status::IOError(path,\"Could not get the file size.\");\n      CloseHandle(file);\n      return sRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ScanTable(uint64_t number) {\n      TableInfo t;\n      t.meta.number = number;\n      std::string fname = TableFileName(dbname_, number);\n      Status status = env_->GetFileSize(fname, &t.meta.file_size);\n      if (!status.ok()) {\n        // Try alternate file name.\n        fname = SSTTableFileName(dbname_, number);\n        Status s2 = env_->GetFileSize(fname, &t.meta.file_size);\n        if (s2.ok()) {\n          status = Status::OK();\n        }\n      }\n      if (!status.ok()) {\n        ArchiveFile(TableFileName(dbname_, number));\n        ArchiveFile(SSTTableFileName(dbname_, number));\n        Log(options_.info_log, \"Table #%llu: dropped: %s\",\n            (unsigned long long) t.meta.number,\n            status.ToString().c_str());\n        return;\n      }\n  \n      // Extract metadata by scanning through table.\n      int counter = 0;\n      Iterator* iter = NewTableIterator(t.meta);\n      bool empty = true;\n      ParsedInternalKey parsed;\n      t.max_sequence = 0;\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        Slice key = iter->key();\n        if (!ParseInternalKey(key, &parsed)) {\n          Log(options_.info_log, \"Table #%llu: unparsable key %s\",\n              (unsigned long long) t.meta.number,\n              EscapeString(key).c_str());\n          continue;\n        }\n  \n        counter++;\n        if (empty) {\n          empty = false;\n          t.meta.smallest.DecodeFrom(key);\n        }\n        t.meta.largest.DecodeFrom(key);\n        if (parsed.sequence > t.max_sequence) {\n          t.max_sequence = parsed.sequence;\n        }\n      }\n      if (!iter->status().ok()) {\n        status = iter->status();\n      }\n      delete iter;\n      Log(options_.info_log, \"Table #%llu: %d entries %s\",\n          (unsigned long long) t.meta.number,\n          counter,\n          status.ToString().c_str());\n  \n      if (status.ok()) {\n        tables_.push_back(t);\n      } else {\n        RepairTable(fname, t);  // RepairTable archives input file.\n      }\n    }\n}"
  },
  {
    "function_name": "ExtractMetaData",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "244-249",
    "snippet": "void ExtractMetaData() {\n    std::vector<TableInfo> kept;\n    for (size_t i = 0; i < table_numbers_.size(); i++) {\n      ScanTable(table_numbers_[i]);\n    }\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ScanTable",
          "args": [
            "table_numbers_[i]"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "ScanTable",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "259-320",
          "snippet": "void ScanTable(uint64_t number) {\n    TableInfo t;\n    t.meta.number = number;\n    std::string fname = TableFileName(dbname_, number);\n    Status status = env_->GetFileSize(fname, &t.meta.file_size);\n    if (!status.ok()) {\n      // Try alternate file name.\n      fname = SSTTableFileName(dbname_, number);\n      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);\n      if (s2.ok()) {\n        status = Status::OK();\n      }\n    }\n    if (!status.ok()) {\n      ArchiveFile(TableFileName(dbname_, number));\n      ArchiveFile(SSTTableFileName(dbname_, number));\n      Log(options_.info_log, \"Table #%llu: dropped: %s\",\n          (unsigned long long) t.meta.number,\n          status.ToString().c_str());\n      return;\n    }\n\n    // Extract metadata by scanning through table.\n    int counter = 0;\n    Iterator* iter = NewTableIterator(t.meta);\n    bool empty = true;\n    ParsedInternalKey parsed;\n    t.max_sequence = 0;\n    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      if (!ParseInternalKey(key, &parsed)) {\n        Log(options_.info_log, \"Table #%llu: unparsable key %s\",\n            (unsigned long long) t.meta.number,\n            EscapeString(key).c_str());\n        continue;\n      }\n\n      counter++;\n      if (empty) {\n        empty = false;\n        t.meta.smallest.DecodeFrom(key);\n      }\n      t.meta.largest.DecodeFrom(key);\n      if (parsed.sequence > t.max_sequence) {\n        t.max_sequence = parsed.sequence;\n      }\n    }\n    if (!iter->status().ok()) {\n      status = iter->status();\n    }\n    delete iter;\n    Log(options_.info_log, \"Table #%llu: %d entries %s\",\n        (unsigned long long) t.meta.number,\n        counter,\n        status.ToString().c_str());\n\n    if (status.ok()) {\n      tables_.push_back(t);\n    } else {\n      RepairTable(fname, t);  // RepairTable archives input file.\n    }\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ScanTable(uint64_t number) {\n      TableInfo t;\n      t.meta.number = number;\n      std::string fname = TableFileName(dbname_, number);\n      Status status = env_->GetFileSize(fname, &t.meta.file_size);\n      if (!status.ok()) {\n        // Try alternate file name.\n        fname = SSTTableFileName(dbname_, number);\n        Status s2 = env_->GetFileSize(fname, &t.meta.file_size);\n        if (s2.ok()) {\n          status = Status::OK();\n        }\n      }\n      if (!status.ok()) {\n        ArchiveFile(TableFileName(dbname_, number));\n        ArchiveFile(SSTTableFileName(dbname_, number));\n        Log(options_.info_log, \"Table #%llu: dropped: %s\",\n            (unsigned long long) t.meta.number,\n            status.ToString().c_str());\n        return;\n      }\n  \n      // Extract metadata by scanning through table.\n      int counter = 0;\n      Iterator* iter = NewTableIterator(t.meta);\n      bool empty = true;\n      ParsedInternalKey parsed;\n      t.max_sequence = 0;\n      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n        Slice key = iter->key();\n        if (!ParseInternalKey(key, &parsed)) {\n          Log(options_.info_log, \"Table #%llu: unparsable key %s\",\n              (unsigned long long) t.meta.number,\n              EscapeString(key).c_str());\n          continue;\n        }\n  \n        counter++;\n        if (empty) {\n          empty = false;\n          t.meta.smallest.DecodeFrom(key);\n        }\n        t.meta.largest.DecodeFrom(key);\n        if (parsed.sequence > t.max_sequence) {\n          t.max_sequence = parsed.sequence;\n        }\n      }\n      if (!iter->status().ok()) {\n        status = iter->status();\n      }\n      delete iter;\n      Log(options_.info_log, \"Table #%llu: %d entries %s\",\n          (unsigned long long) t.meta.number,\n          counter,\n          status.ToString().c_str());\n  \n      if (status.ok()) {\n        tables_.push_back(t);\n      } else {\n        RepairTable(fname, t);  // RepairTable archives input file.\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_numbers_.size",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ExtractMetaData() {\n      std::vector<TableInfo> kept;\n      for (size_t i = 0; i < table_numbers_.size(); i++) {\n        ScanTable(table_numbers_[i]);\n      }\n    }\n}"
  },
  {
    "function_name": "ConvertLogToTable",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "162-242",
    "snippet": "Status ConvertLogToTable(uint64_t log) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      uint64_t lognum;\n      virtual void Corruption(size_t bytes, const Status& s) {\n        // We print error messages for corruption, but continue repairing.\n        Log(info_log, \"Log #%llu: dropping %d bytes; %s\",\n            (unsigned long long) lognum,\n            static_cast<int>(bytes),\n            s.ToString().c_str());\n      }\n    };\n\n    // Open the log file\n    std::string logname = LogFileName(dbname_, log);\n    SequentialFile* lfile;\n    Status status = env_->NewSequentialFile(logname, &lfile);\n    if (!status.ok()) {\n      return status;\n    }\n\n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.lognum = log;\n    // We intentially make log::Reader do checksumming so that\n    // corruptions cause entire commits to be skipped instead of\n    // propagating bad information (like overly large sequence\n    // numbers).\n    log::Reader reader(lfile, &reporter, false/*do not checksum*/,\n                       0/*initial_offset*/);\n\n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = new MemTable(icmp_);\n    mem->Ref();\n    int counter = 0;\n    while (reader.ReadRecord(&record, &scratch)) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      if (status.ok()) {\n        counter += WriteBatchInternal::Count(&batch);\n      } else {\n        Log(options_.info_log, \"Log #%llu: ignoring %s\",\n            (unsigned long long) log,\n            status.ToString().c_str());\n        status = Status::OK();  // Keep going with rest of file\n      }\n    }\n    delete lfile;\n\n    // Do not record a version edit for this conversion to a Table\n    // since ExtractMetaData() will also generate edits.\n    FileMetaData meta;\n    meta.number = next_file_number_++;\n    Iterator* iter = mem->NewIterator();\n    status = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n    delete iter;\n    mem->Unref();\n    mem = NULL;\n    if (status.ok()) {\n      if (meta.file_size > 0) {\n        table_numbers_.push_back(meta.number);\n      }\n    }\n    Log(options_.info_log, \"Log #%llu: %d ops saved to Table #%llu %s\",\n        (unsigned long long) log,\n        counter,\n        (unsigned long long) meta.number,\n        status.ToString().c_str());\n    return status;\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Log #%llu: %d ops saved to Table #%llu %s\"",
            "(unsigned long long) log",
            "counter",
            "(unsigned long long) meta.number",
            "status.ToString().c_str()"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_numbers_.push_back",
          "args": [
            "meta.number"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->Unref",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildTable",
          "args": [
            "dbname_",
            "env_",
            "options_",
            "table_cache_",
            "iter",
            "&meta"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "BuildTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/builder.cc",
          "lines": "17-86",
          "snippet": "Status BuildTable(const std::string& dbname,\n                  Env* env,\n                  const Options& options,\n                  TableCache* table_cache,\n                  Iterator* iter,\n                  FileMetaData* meta) {\n  Status s;\n  meta->file_size = 0;\n  iter->SeekToFirst();\n\n  std::string fname = TableFileName(dbname, meta->number);\n  if (iter->Valid()) {\n    WritableFile* file;\n    s = env->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n\n    TableBuilder* builder = new TableBuilder(options, file);\n    meta->smallest.DecodeFrom(iter->key());\n    for (; iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      meta->largest.DecodeFrom(key);\n      builder->Add(key, iter->value());\n    }\n\n    // Finish and check for builder errors\n    if (s.ok()) {\n      s = builder->Finish();\n      if (s.ok()) {\n        meta->file_size = builder->FileSize();\n        assert(meta->file_size > 0);\n      }\n    } else {\n      builder->Abandon();\n    }\n    delete builder;\n\n    // Finish and check for file errors\n    if (s.ok()) {\n      s = file->Sync();\n    }\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (s.ok()) {\n      // Verify that the table is usable\n      Iterator* it = table_cache->NewIterator(ReadOptions(),\n                                              meta->number,\n                                              meta->file_size);\n      s = it->status();\n      delete it;\n    }\n  }\n\n  // Check for input iterator errors\n  if (!iter->status().ok()) {\n    s = iter->status();\n  }\n\n  if (s.ok() && meta->file_size > 0) {\n    // Keep it\n  } else {\n    env->DeleteFile(fname);\n  }\n  return s;\n}",
          "includes": [
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include \"db/builder.h\"\n\nStatus BuildTable(const std::string& dbname,\n                  Env* env,\n                  const Options& options,\n                  TableCache* table_cache,\n                  Iterator* iter,\n                  FileMetaData* meta) {\n  Status s;\n  meta->file_size = 0;\n  iter->SeekToFirst();\n\n  std::string fname = TableFileName(dbname, meta->number);\n  if (iter->Valid()) {\n    WritableFile* file;\n    s = env->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n\n    TableBuilder* builder = new TableBuilder(options, file);\n    meta->smallest.DecodeFrom(iter->key());\n    for (; iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      meta->largest.DecodeFrom(key);\n      builder->Add(key, iter->value());\n    }\n\n    // Finish and check for builder errors\n    if (s.ok()) {\n      s = builder->Finish();\n      if (s.ok()) {\n        meta->file_size = builder->FileSize();\n        assert(meta->file_size > 0);\n      }\n    } else {\n      builder->Abandon();\n    }\n    delete builder;\n\n    // Finish and check for file errors\n    if (s.ok()) {\n      s = file->Sync();\n    }\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (s.ok()) {\n      // Verify that the table is usable\n      Iterator* it = table_cache->NewIterator(ReadOptions(),\n                                              meta->number,\n                                              meta->file_size);\n      s = it->status();\n      delete it;\n    }\n  }\n\n  // Check for input iterator errors\n  if (!iter->status().ok()) {\n    s = iter->status();\n  }\n\n  if (s.ok() && meta->file_size > 0) {\n    // Keep it\n  } else {\n    env->DeleteFile(fname);\n  }\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->NewIterator",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Log #%llu: ignoring %s\"",
            "(unsigned long long) log",
            "status.ToString().c_str()"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Count",
          "args": [
            "&batch"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "Count",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "82-84",
          "snippet": "int WriteBatchInternal::Count(const WriteBatch* b) {\n  return DecodeFixed32(b->rep_.data() + 8);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  int WriteBatchInternal::Count(const WriteBatch* b) {\n    return DecodeFixed32(b->rep_.data() + 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::InsertInto",
          "args": [
            "&batch",
            "mem"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "InsertInto",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "128-134",
          "snippet": "Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                      MemTable* memtable) {\n  MemTableInserter inserter;\n  inserter.sequence_ = WriteBatchInternal::Sequence(b);\n  inserter.mem_ = memtable;\n  return b->Iterate(&inserter);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                        MemTable* memtable) {\n    MemTableInserter inserter;\n    inserter.sequence_ = WriteBatchInternal::Sequence(b);\n    inserter.mem_ = memtable;\n    return b->Iterate(&inserter);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetContents",
          "args": [
            "&batch",
            "record"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "SetContents",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "136-139",
          "snippet": "void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n  assert(contents.size() >= kHeader);\n  b->rep_.assign(contents.data(), contents.size());\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n    assert(contents.size() >= kHeader);\n    b->rep_.assign(contents.data(), contents.size());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reporter.Corruption",
          "args": [
            "record.size()",
            "Status::Corruption(\"log record too small\")"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "CorruptionReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "38-42",
          "snippet": "virtual void Corruption(size_t bytes, const Status& status) {\n    printf(\"corruption: %d bytes; %s\\n\",\n            static_cast<int>(bytes),\n            status.ToString().c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nCorruptionReporter {\n  virtual void Corruption(size_t bytes, const Status& status) {\n      printf(\"corruption: %d bytes; %s\\n\",\n              static_cast<int>(bytes),\n              status.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"log record too small\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "record.size",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.ReadRecord",
          "args": [
            "&record",
            "&scratch"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ReadRecord",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "59-162",
          "snippet": "bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n  if (last_record_offset_ < initial_offset_) {\n    if (!SkipToInitialBlock()) {\n      return false;\n    }\n  }\n\n  scratch->clear();\n  record->clear();\n  bool in_fragmented_record = false;\n  // Record offset of the logical record that we're reading\n  // 0 is a dummy value to make compilers happy\n  uint64_t prospective_record_offset = 0;\n\n  Slice fragment;\n  while (true) {\n    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n    const unsigned int record_type = ReadPhysicalRecord(&fragment);\n    switch (record_type) {\n      case kFullType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(1)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->clear();\n        *record = fragment;\n        last_record_offset_ = prospective_record_offset;\n        return true;\n\n      case kFirstType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(2)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->assign(fragment.data(), fragment.size());\n        in_fragmented_record = true;\n        break;\n\n      case kMiddleType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(1)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n        }\n        break;\n\n      case kLastType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(2)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n          *record = Slice(*scratch);\n          last_record_offset_ = prospective_record_offset;\n          return true;\n        }\n        break;\n\n      case kEof:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"partial record without end(3)\");\n          scratch->clear();\n        }\n        return false;\n\n      case kBadRecord:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"error in middle of record\");\n          in_fragmented_record = false;\n          scratch->clear();\n        }\n        break;\n\n      default: {\n        char buf[40];\n        snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n        ReportCorruption(\n            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n            buf);\n        in_fragmented_record = false;\n        scratch->clear();\n        break;\n      }\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n    if (last_record_offset_ < initial_offset_) {\n      if (!SkipToInitialBlock()) {\n        return false;\n      }\n    }\n  \n    scratch->clear();\n    record->clear();\n    bool in_fragmented_record = false;\n    // Record offset of the logical record that we're reading\n    // 0 is a dummy value to make compilers happy\n    uint64_t prospective_record_offset = 0;\n  \n    Slice fragment;\n    while (true) {\n      uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n      const unsigned int record_type = ReadPhysicalRecord(&fragment);\n      switch (record_type) {\n        case kFullType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(1)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->clear();\n          *record = fragment;\n          last_record_offset_ = prospective_record_offset;\n          return true;\n  \n        case kFirstType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(2)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->assign(fragment.data(), fragment.size());\n          in_fragmented_record = true;\n          break;\n  \n        case kMiddleType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(1)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n          }\n          break;\n  \n        case kLastType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(2)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n            *record = Slice(*scratch);\n            last_record_offset_ = prospective_record_offset;\n            return true;\n          }\n          break;\n  \n        case kEof:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"partial record without end(3)\");\n            scratch->clear();\n          }\n          return false;\n  \n        case kBadRecord:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"error in middle of record\");\n            in_fragmented_record = false;\n            scratch->clear();\n          }\n          break;\n  \n        default: {\n          char buf[40];\n          snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n          ReportCorruption(\n              (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n              buf);\n          in_fragmented_record = false;\n          scratch->clear();\n          break;\n        }\n      }\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->Ref",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [
            "logname",
            "&lfile"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "951-964",
          "snippet": "Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n{\n    Status sRet;\n    std::string path = fname;\n    ModifyPath(path);\n    Win32SequentialFile* pFile = new Win32SequentialFile(path);\n    if(pFile->isEnable()){\n        *result = pFile;\n    }else {\n        delete pFile;\n        sRet = Status::IOError(path, Win32::GetLastErrSz());\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n  {\n      Status sRet;\n      std::string path = fname;\n      ModifyPath(path);\n      Win32SequentialFile* pFile = new Win32SequentialFile(path);\n      if(pFile->isEnable()){\n          *result = pFile;\n      }else {\n          delete pFile;\n          sRet = Status::IOError(path, Win32::GetLastErrSz());\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogFileName",
          "args": [
            "dbname_",
            "log"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "LogFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "27-30",
          "snippet": "std::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "info_log",
            "\"Log #%llu: dropping %d bytes; %s\"",
            "(unsigned long long) lognum",
            "static_cast<int>(bytes)",
            "s.ToString().c_str()"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "bytes"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status ConvertLogToTable(uint64_t log) {\n      struct LogReporter : public log::Reader::Reporter {\n        Env* env;\n        Logger* info_log;\n        uint64_t lognum;\n        virtual void Corruption(size_t bytes, const Status& s) {\n          // We print error messages for corruption, but continue repairing.\n          Log(info_log, \"Log #%llu: dropping %d bytes; %s\",\n              (unsigned long long) lognum,\n              static_cast<int>(bytes),\n              s.ToString().c_str());\n        }\n      };\n  \n      // Open the log file\n      std::string logname = LogFileName(dbname_, log);\n      SequentialFile* lfile;\n      Status status = env_->NewSequentialFile(logname, &lfile);\n      if (!status.ok()) {\n        return status;\n      }\n  \n      // Create the log reader.\n      LogReporter reporter;\n      reporter.env = env_;\n      reporter.info_log = options_.info_log;\n      reporter.lognum = log;\n      // We intentially make log::Reader do checksumming so that\n      // corruptions cause entire commits to be skipped instead of\n      // propagating bad information (like overly large sequence\n      // numbers).\n      log::Reader reader(lfile, &reporter, false/*do not checksum*/,\n                         0/*initial_offset*/);\n  \n      // Read all the records and add to a memtable\n      std::string scratch;\n      Slice record;\n      WriteBatch batch;\n      MemTable* mem = new MemTable(icmp_);\n      mem->Ref();\n      int counter = 0;\n      while (reader.ReadRecord(&record, &scratch)) {\n        if (record.size() < 12) {\n          reporter.Corruption(\n              record.size(), Status::Corruption(\"log record too small\"));\n          continue;\n        }\n        WriteBatchInternal::SetContents(&batch, record);\n        status = WriteBatchInternal::InsertInto(&batch, mem);\n        if (status.ok()) {\n          counter += WriteBatchInternal::Count(&batch);\n        } else {\n          Log(options_.info_log, \"Log #%llu: ignoring %s\",\n              (unsigned long long) log,\n              status.ToString().c_str());\n          status = Status::OK();  // Keep going with rest of file\n        }\n      }\n      delete lfile;\n  \n      // Do not record a version edit for this conversion to a Table\n      // since ExtractMetaData() will also generate edits.\n      FileMetaData meta;\n      meta.number = next_file_number_++;\n      Iterator* iter = mem->NewIterator();\n      status = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n      delete iter;\n      mem->Unref();\n      mem = NULL;\n      if (status.ok()) {\n        if (meta.file_size > 0) {\n          table_numbers_.push_back(meta.number);\n        }\n      }\n      Log(options_.info_log, \"Log #%llu: %d ops saved to Table #%llu %s\",\n          (unsigned long long) log,\n          counter,\n          (unsigned long long) meta.number,\n          status.ToString().c_str());\n      return status;\n    }\n}"
  },
  {
    "function_name": "ConvertLogFilesToTables",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "149-160",
    "snippet": "void ConvertLogFilesToTables() {\n    for (size_t i = 0; i < logs_.size(); i++) {\n      std::string logname = LogFileName(dbname_, logs_[i]);\n      Status status = ConvertLogToTable(logs_[i]);\n      if (!status.ok()) {\n        Log(options_.info_log, \"Log #%llu: ignoring conversion error: %s\",\n            (unsigned long long) logs_[i],\n            status.ToString().c_str());\n      }\n      ArchiveFile(logname);\n    }\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ArchiveFile",
          "args": [
            "logname"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ArchiveFile",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "435-453",
          "snippet": "void ArchiveFile(const std::string& fname) {\n    // Move into another directory.  E.g., for\n    //    dir/foo\n    // rename to\n    //    dir/lost/foo\n    const char* slash = strrchr(fname.c_str(), '/');\n    std::string new_dir;\n    if (slash != NULL) {\n      new_dir.assign(fname.data(), slash - fname.data());\n    }\n    new_dir.append(\"/lost\");\n    env_->CreateDir(new_dir);  // Ignore error\n    std::string new_file = new_dir;\n    new_file.append(\"/\");\n    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n    Status s = env_->RenameFile(fname, new_file);\n    Log(options_.info_log, \"Archiving %s: %s\\n\",\n        fname.c_str(), s.ToString().c_str());\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ArchiveFile(const std::string& fname) {\n      // Move into another directory.  E.g., for\n      //    dir/foo\n      // rename to\n      //    dir/lost/foo\n      const char* slash = strrchr(fname.c_str(), '/');\n      std::string new_dir;\n      if (slash != NULL) {\n        new_dir.assign(fname.data(), slash - fname.data());\n      }\n      new_dir.append(\"/lost\");\n      env_->CreateDir(new_dir);  // Ignore error\n      std::string new_file = new_dir;\n      new_file.append(\"/\");\n      new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n      Status s = env_->RenameFile(fname, new_file);\n      Log(options_.info_log, \"Archiving %s: %s\\n\",\n          fname.c_str(), s.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"Log #%llu: ignoring conversion error: %s\"",
            "(unsigned long long) logs_[i]",
            "status.ToString().c_str()"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConvertLogToTable",
          "args": [
            "logs_[i]"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertLogToTable",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "162-242",
          "snippet": "Status ConvertLogToTable(uint64_t log) {\n    struct LogReporter : public log::Reader::Reporter {\n      Env* env;\n      Logger* info_log;\n      uint64_t lognum;\n      virtual void Corruption(size_t bytes, const Status& s) {\n        // We print error messages for corruption, but continue repairing.\n        Log(info_log, \"Log #%llu: dropping %d bytes; %s\",\n            (unsigned long long) lognum,\n            static_cast<int>(bytes),\n            s.ToString().c_str());\n      }\n    };\n\n    // Open the log file\n    std::string logname = LogFileName(dbname_, log);\n    SequentialFile* lfile;\n    Status status = env_->NewSequentialFile(logname, &lfile);\n    if (!status.ok()) {\n      return status;\n    }\n\n    // Create the log reader.\n    LogReporter reporter;\n    reporter.env = env_;\n    reporter.info_log = options_.info_log;\n    reporter.lognum = log;\n    // We intentially make log::Reader do checksumming so that\n    // corruptions cause entire commits to be skipped instead of\n    // propagating bad information (like overly large sequence\n    // numbers).\n    log::Reader reader(lfile, &reporter, false/*do not checksum*/,\n                       0/*initial_offset*/);\n\n    // Read all the records and add to a memtable\n    std::string scratch;\n    Slice record;\n    WriteBatch batch;\n    MemTable* mem = new MemTable(icmp_);\n    mem->Ref();\n    int counter = 0;\n    while (reader.ReadRecord(&record, &scratch)) {\n      if (record.size() < 12) {\n        reporter.Corruption(\n            record.size(), Status::Corruption(\"log record too small\"));\n        continue;\n      }\n      WriteBatchInternal::SetContents(&batch, record);\n      status = WriteBatchInternal::InsertInto(&batch, mem);\n      if (status.ok()) {\n        counter += WriteBatchInternal::Count(&batch);\n      } else {\n        Log(options_.info_log, \"Log #%llu: ignoring %s\",\n            (unsigned long long) log,\n            status.ToString().c_str());\n        status = Status::OK();  // Keep going with rest of file\n      }\n    }\n    delete lfile;\n\n    // Do not record a version edit for this conversion to a Table\n    // since ExtractMetaData() will also generate edits.\n    FileMetaData meta;\n    meta.number = next_file_number_++;\n    Iterator* iter = mem->NewIterator();\n    status = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n    delete iter;\n    mem->Unref();\n    mem = NULL;\n    if (status.ok()) {\n      if (meta.file_size > 0) {\n        table_numbers_.push_back(meta.number);\n      }\n    }\n    Log(options_.info_log, \"Log #%llu: %d ops saved to Table #%llu %s\",\n        (unsigned long long) log,\n        counter,\n        (unsigned long long) meta.number,\n        status.ToString().c_str());\n    return status;\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status ConvertLogToTable(uint64_t log) {\n      struct LogReporter : public log::Reader::Reporter {\n        Env* env;\n        Logger* info_log;\n        uint64_t lognum;\n        virtual void Corruption(size_t bytes, const Status& s) {\n          // We print error messages for corruption, but continue repairing.\n          Log(info_log, \"Log #%llu: dropping %d bytes; %s\",\n              (unsigned long long) lognum,\n              static_cast<int>(bytes),\n              s.ToString().c_str());\n        }\n      };\n  \n      // Open the log file\n      std::string logname = LogFileName(dbname_, log);\n      SequentialFile* lfile;\n      Status status = env_->NewSequentialFile(logname, &lfile);\n      if (!status.ok()) {\n        return status;\n      }\n  \n      // Create the log reader.\n      LogReporter reporter;\n      reporter.env = env_;\n      reporter.info_log = options_.info_log;\n      reporter.lognum = log;\n      // We intentially make log::Reader do checksumming so that\n      // corruptions cause entire commits to be skipped instead of\n      // propagating bad information (like overly large sequence\n      // numbers).\n      log::Reader reader(lfile, &reporter, false/*do not checksum*/,\n                         0/*initial_offset*/);\n  \n      // Read all the records and add to a memtable\n      std::string scratch;\n      Slice record;\n      WriteBatch batch;\n      MemTable* mem = new MemTable(icmp_);\n      mem->Ref();\n      int counter = 0;\n      while (reader.ReadRecord(&record, &scratch)) {\n        if (record.size() < 12) {\n          reporter.Corruption(\n              record.size(), Status::Corruption(\"log record too small\"));\n          continue;\n        }\n        WriteBatchInternal::SetContents(&batch, record);\n        status = WriteBatchInternal::InsertInto(&batch, mem);\n        if (status.ok()) {\n          counter += WriteBatchInternal::Count(&batch);\n        } else {\n          Log(options_.info_log, \"Log #%llu: ignoring %s\",\n              (unsigned long long) log,\n              status.ToString().c_str());\n          status = Status::OK();  // Keep going with rest of file\n        }\n      }\n      delete lfile;\n  \n      // Do not record a version edit for this conversion to a Table\n      // since ExtractMetaData() will also generate edits.\n      FileMetaData meta;\n      meta.number = next_file_number_++;\n      Iterator* iter = mem->NewIterator();\n      status = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n      delete iter;\n      mem->Unref();\n      mem = NULL;\n      if (status.ok()) {\n        if (meta.file_size > 0) {\n          table_numbers_.push_back(meta.number);\n        }\n      }\n      Log(options_.info_log, \"Log #%llu: %d ops saved to Table #%llu %s\",\n          (unsigned long long) log,\n          counter,\n          (unsigned long long) meta.number,\n          status.ToString().c_str());\n      return status;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LogFileName",
          "args": [
            "dbname_",
            "logs_[i]"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "LogFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "27-30",
          "snippet": "std::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string LogFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"log\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "logs_.size",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ConvertLogFilesToTables() {\n      for (size_t i = 0; i < logs_.size(); i++) {\n        std::string logname = LogFileName(dbname_, logs_[i]);\n        Status status = ConvertLogToTable(logs_[i]);\n        if (!status.ok()) {\n          Log(options_.info_log, \"Log #%llu: ignoring conversion error: %s\",\n              (unsigned long long) logs_[i],\n              status.ToString().c_str());\n        }\n        ArchiveFile(logname);\n      }\n    }\n}"
  },
  {
    "function_name": "FindFiles",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "116-147",
    "snippet": "Status FindFiles() {\n    std::vector<std::string> filenames;\n    Status status = env_->GetChildren(dbname_, &filenames);\n    if (!status.ok()) {\n      return status;\n    }\n    if (filenames.empty()) {\n      return Status::IOError(dbname_, \"repair found no files\");\n    }\n\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        if (type == kDescriptorFile) {\n          manifests_.push_back(filenames[i]);\n        } else {\n          if (number + 1 > next_file_number_) {\n            next_file_number_ = number + 1;\n          }\n          if (type == kLogFile) {\n            logs_.push_back(number);\n          } else if (type == kTableFile) {\n            table_numbers_.push_back(number);\n          } else {\n            // Ignore other files\n          }\n        }\n      }\n    }\n    return status;\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table_numbers_.push_back",
          "args": [
            "number"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logs_.push_back",
          "args": [
            "number"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manifests_.push_back",
          "args": [
            "filenames[i]"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseFileName",
          "args": [
            "filenames[i]",
            "&number",
            "&type"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "85-129",
          "snippet": "bool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nbool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filenames.size",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::IOError",
          "args": [
            "dbname_",
            "\"repair found no files\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "IOError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_posix.cc",
          "lines": "35-37",
          "snippet": "static Status IOError(const std::string& context, int err_number) {\n  return Status::IOError(context, strerror(err_number));\n}",
          "includes": [
            "#include \"util/posix_logger.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <set>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/posix_logger.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <sys/stat.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <set>\n#include <deque>\n\nstatic Status IOError(const std::string& context, int err_number) {\n  return Status::IOError(context, strerror(err_number));\n}"
        }
      },
      {
        "call_info": {
          "callee": "filenames.empty",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->GetChildren",
          "args": [
            "dbname_",
            "&filenames"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "GetChildren",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "767-793",
          "snippet": "Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n{\n    Status sRet;\n    ::WIN32_FIND_DATAW wfd;\n    std::string path = dir;\n    ModifyPath(path);\n    path += \"\\\\*.*\";\n\tstd::wstring wpath;\n\tToWidePath(path, wpath);\n\n\t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n    if(hFind && hFind != INVALID_HANDLE_VALUE){\n        BOOL hasNext = TRUE;\n        std::string child;\n        while(hasNext){\n            ToNarrowPath(wfd.cFileName, child); \n            if(child != \"..\" && child != \".\")  {\n                result->push_back(child);\n            }\n            hasNext = ::FindNextFileW(hFind,&wfd);\n        }\n        ::FindClose(hFind);\n    }\n    else\n        sRet = Status::IOError(dir,\"Could not get children.\");\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)\n  {\n      Status sRet;\n      ::WIN32_FIND_DATAW wfd;\n      std::string path = dir;\n      ModifyPath(path);\n      path += \"\\\\*.*\";\n  \tstd::wstring wpath;\n  \tToWidePath(path, wpath);\n  \n  \t::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);\n      if(hFind && hFind != INVALID_HANDLE_VALUE){\n          BOOL hasNext = TRUE;\n          std::string child;\n          while(hasNext){\n              ToNarrowPath(wfd.cFileName, child); \n              if(child != \"..\" && child != \".\")  {\n                  result->push_back(child);\n              }\n              hasNext = ::FindNextFileW(hFind,&wfd);\n          }\n          ::FindClose(hFind);\n      }\n      else\n          sRet = Status::IOError(dir,\"Could not get children.\");\n      return sRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status FindFiles() {\n      std::vector<std::string> filenames;\n      Status status = env_->GetChildren(dbname_, &filenames);\n      if (!status.ok()) {\n        return status;\n      }\n      if (filenames.empty()) {\n        return Status::IOError(dbname_, \"repair found no files\");\n      }\n  \n      uint64_t number;\n      FileType type;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type)) {\n          if (type == kDescriptorFile) {\n            manifests_.push_back(filenames[i]);\n          } else {\n            if (number + 1 > next_file_number_) {\n              next_file_number_ = number + 1;\n            }\n            if (type == kLogFile) {\n              logs_.push_back(number);\n            } else if (type == kTableFile) {\n              table_numbers_.push_back(number);\n            } else {\n              // Ignore other files\n            }\n          }\n        }\n      }\n      return status;\n    }\n}"
  },
  {
    "function_name": "Run",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "70-92",
    "snippet": "Status Run() {\n    Status status = FindFiles();\n    if (status.ok()) {\n      ConvertLogFilesToTables();\n      ExtractMetaData();\n      status = WriteDescriptor();\n    }\n    if (status.ok()) {\n      unsigned long long bytes = 0;\n      for (size_t i = 0; i < tables_.size(); i++) {\n        bytes += tables_[i].meta.file_size;\n      }\n      Log(options_.info_log,\n          \"**** Repaired leveldb %s; \"\n          \"recovered %d files; %llu bytes. \"\n          \"Some data may have been lost. \"\n          \"****\",\n          dbname_.c_str(),\n          static_cast<int>(tables_.size()),\n          bytes);\n    }\n    return status;\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_.info_log",
            "\"**** Repaired leveldb %s; \"\n          \"recovered %d files; %llu bytes. \"\n          \"Some data may have been lost. \"\n          \"****\"",
            "dbname_.c_str()",
            "static_cast<int>(tables_.size())",
            "bytes"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "tables_.size()"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tables_.size",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbname_.c_str",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteDescriptor",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "WriteDescriptor",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "376-433",
          "snippet": "Status WriteDescriptor() {\n    std::string tmp = TempFileName(dbname_, 1);\n    WritableFile* file;\n    Status status = env_->NewWritableFile(tmp, &file);\n    if (!status.ok()) {\n      return status;\n    }\n\n    SequenceNumber max_sequence = 0;\n    for (size_t i = 0; i < tables_.size(); i++) {\n      if (max_sequence < tables_[i].max_sequence) {\n        max_sequence = tables_[i].max_sequence;\n      }\n    }\n\n    edit_.SetComparatorName(icmp_.user_comparator()->Name());\n    edit_.SetLogNumber(0);\n    edit_.SetNextFile(next_file_number_);\n    edit_.SetLastSequence(max_sequence);\n\n    for (size_t i = 0; i < tables_.size(); i++) {\n      // TODO(opt): separate out into multiple levels\n      const TableInfo& t = tables_[i];\n      edit_.AddFile(0, t.meta.number, t.meta.file_size,\n                    t.meta.smallest, t.meta.largest);\n    }\n\n    //fprintf(stderr, \"NewDescriptor:\\n%s\\n\", edit_.DebugString().c_str());\n    {\n      log::Writer log(file);\n      std::string record;\n      edit_.EncodeTo(&record);\n      status = log.AddRecord(record);\n    }\n    if (status.ok()) {\n      status = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (!status.ok()) {\n      env_->DeleteFile(tmp);\n    } else {\n      // Discard older manifests\n      for (size_t i = 0; i < manifests_.size(); i++) {\n        ArchiveFile(dbname_ + \"/\" + manifests_[i]);\n      }\n\n      // Install new manifest\n      status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));\n      if (status.ok()) {\n        status = SetCurrentFile(env_, dbname_, 1);\n      } else {\n        env_->DeleteFile(tmp);\n      }\n    }\n    return status;\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status WriteDescriptor() {\n      std::string tmp = TempFileName(dbname_, 1);\n      WritableFile* file;\n      Status status = env_->NewWritableFile(tmp, &file);\n      if (!status.ok()) {\n        return status;\n      }\n  \n      SequenceNumber max_sequence = 0;\n      for (size_t i = 0; i < tables_.size(); i++) {\n        if (max_sequence < tables_[i].max_sequence) {\n          max_sequence = tables_[i].max_sequence;\n        }\n      }\n  \n      edit_.SetComparatorName(icmp_.user_comparator()->Name());\n      edit_.SetLogNumber(0);\n      edit_.SetNextFile(next_file_number_);\n      edit_.SetLastSequence(max_sequence);\n  \n      for (size_t i = 0; i < tables_.size(); i++) {\n        // TODO(opt): separate out into multiple levels\n        const TableInfo& t = tables_[i];\n        edit_.AddFile(0, t.meta.number, t.meta.file_size,\n                      t.meta.smallest, t.meta.largest);\n      }\n  \n      //fprintf(stderr, \"NewDescriptor:\\n%s\\n\", edit_.DebugString().c_str());\n      {\n        log::Writer log(file);\n        std::string record;\n        edit_.EncodeTo(&record);\n        status = log.AddRecord(record);\n      }\n      if (status.ok()) {\n        status = file->Close();\n      }\n      delete file;\n      file = NULL;\n  \n      if (!status.ok()) {\n        env_->DeleteFile(tmp);\n      } else {\n        // Discard older manifests\n        for (size_t i = 0; i < manifests_.size(); i++) {\n          ArchiveFile(dbname_ + \"/\" + manifests_[i]);\n        }\n  \n        // Install new manifest\n        status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));\n        if (status.ok()) {\n          status = SetCurrentFile(env_, dbname_, 1);\n        } else {\n          env_->DeleteFile(tmp);\n        }\n      }\n      return status;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractMetaData",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractMetaData",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "244-249",
          "snippet": "void ExtractMetaData() {\n    std::vector<TableInfo> kept;\n    for (size_t i = 0; i < table_numbers_.size(); i++) {\n      ScanTable(table_numbers_[i]);\n    }\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ExtractMetaData() {\n      std::vector<TableInfo> kept;\n      for (size_t i = 0; i < table_numbers_.size(); i++) {\n        ScanTable(table_numbers_[i]);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConvertLogFilesToTables",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertLogFilesToTables",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "149-160",
          "snippet": "void ConvertLogFilesToTables() {\n    for (size_t i = 0; i < logs_.size(); i++) {\n      std::string logname = LogFileName(dbname_, logs_[i]);\n      Status status = ConvertLogToTable(logs_[i]);\n      if (!status.ok()) {\n        Log(options_.info_log, \"Log #%llu: ignoring conversion error: %s\",\n            (unsigned long long) logs_[i],\n            status.ToString().c_str());\n      }\n      ArchiveFile(logname);\n    }\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  void ConvertLogFilesToTables() {\n      for (size_t i = 0; i < logs_.size(); i++) {\n        std::string logname = LogFileName(dbname_, logs_[i]);\n        Status status = ConvertLogToTable(logs_[i]);\n        if (!status.ok()) {\n          Log(options_.info_log, \"Log #%llu: ignoring conversion error: %s\",\n              (unsigned long long) logs_[i],\n              status.ToString().c_str());\n        }\n        ArchiveFile(logname);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFiles",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "FindFiles",
          "container": "Repairer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
          "lines": "116-147",
          "snippet": "Status FindFiles() {\n    std::vector<std::string> filenames;\n    Status status = env_->GetChildren(dbname_, &filenames);\n    if (!status.ok()) {\n      return status;\n    }\n    if (filenames.empty()) {\n      return Status::IOError(dbname_, \"repair found no files\");\n    }\n\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type)) {\n        if (type == kDescriptorFile) {\n          manifests_.push_back(filenames[i]);\n        } else {\n          if (number + 1 > next_file_number_) {\n            next_file_number_ = number + 1;\n          }\n          if (type == kLogFile) {\n            logs_.push_back(number);\n          } else if (type == kTableFile) {\n            table_numbers_.push_back(number);\n          } else {\n            // Ignore other files\n          }\n        }\n      }\n    }\n    return status;\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status FindFiles() {\n      std::vector<std::string> filenames;\n      Status status = env_->GetChildren(dbname_, &filenames);\n      if (!status.ok()) {\n        return status;\n      }\n      if (filenames.empty()) {\n        return Status::IOError(dbname_, \"repair found no files\");\n      }\n  \n      uint64_t number;\n      FileType type;\n      for (size_t i = 0; i < filenames.size(); i++) {\n        if (ParseFileName(filenames[i], &number, &type)) {\n          if (type == kDescriptorFile) {\n            manifests_.push_back(filenames[i]);\n          } else {\n            if (number + 1 > next_file_number_) {\n              next_file_number_ = number + 1;\n            }\n            if (type == kLogFile) {\n              logs_.push_back(number);\n            } else if (type == kTableFile) {\n              table_numbers_.push_back(number);\n            } else {\n              // Ignore other files\n            }\n          }\n        }\n      }\n      return status;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Status Run() {\n      Status status = FindFiles();\n      if (status.ok()) {\n        ConvertLogFilesToTables();\n        ExtractMetaData();\n        status = WriteDescriptor();\n      }\n      if (status.ok()) {\n        unsigned long long bytes = 0;\n        for (size_t i = 0; i < tables_.size(); i++) {\n          bytes += tables_[i].meta.file_size;\n        }\n        Log(options_.info_log,\n            \"**** Repaired leveldb %s; \"\n            \"recovered %d files; %llu bytes. \"\n            \"Some data may have been lost. \"\n            \"****\",\n            dbname_.c_str(),\n            static_cast<int>(tables_.size()),\n            bytes);\n      }\n      return status;\n    }\n}"
  },
  {
    "function_name": "Repairer",
    "container": "Repairer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/repair.cc",
    "lines": "47-58",
    "snippet": "Repairer(const std::string& dbname, const Options& options)\n      : dbname_(dbname),\n        env_(options.env),\n        icmp_(options.comparator),\n        ipolicy_(options.filter_policy),\n        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),\n        owns_info_log_(options_.info_log != options.info_log),\n        owns_cache_(options_.block_cache != options.block_cache),\n        next_file_number_(1) {\n    // TableCache can be small since we expect each table to be opened once.\n    table_cache_ = new TableCache(dbname_, &options_, 10);\n  }",
    "includes": [
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SanitizeOptions",
          "args": [
            "dbname",
            "&icmp_",
            "&ipolicy_",
            "options"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "SanitizeOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "90-114",
          "snippet": "Options SanitizeOptions(const std::string& dbname,\n                        const InternalKeyComparator* icmp,\n                        const InternalFilterPolicy* ipolicy,\n                        const Options& src) {\n  Options result = src;\n  result.comparator = icmp;\n  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n  ClipToRange(&result.block_size,        1<<10,                       4<<20);\n  if (result.info_log == NULL) {\n    // Open a log file in the same directory as the db\n    src.env->CreateDir(dbname);  // In case it does not exist\n    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n    if (!s.ok()) {\n      // No place suitable for logging\n      result.info_log = NULL;\n    }\n  }\n  if (result.block_cache == NULL) {\n    result.block_cache = NewLRUCache(8 << 20);\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nOptions SanitizeOptions(const std::string& dbname,\n                        const InternalKeyComparator* icmp,\n                        const InternalFilterPolicy* ipolicy,\n                        const Options& src) {\n  Options result = src;\n  result.comparator = icmp;\n  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n  ClipToRange(&result.block_size,        1<<10,                       4<<20);\n  if (result.info_log == NULL) {\n    // Open a log file in the same directory as the db\n    src.env->CreateDir(dbname);  // In case it does not exist\n    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n    if (!s.ok()) {\n      // No place suitable for logging\n      result.info_log = NULL;\n    }\n  }\n  if (result.block_cache == NULL) {\n    result.block_cache = NewLRUCache(8 << 20);\n  }\n  return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/builder.h\"\n\nRepairer {\n  Repairer(const std::string& dbname, const Options& options)\n        : dbname_(dbname),\n          env_(options.env),\n          icmp_(options.comparator),\n          ipolicy_(options.filter_policy),\n          options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),\n          owns_info_log_(options_.info_log != options.info_log),\n          owns_cache_(options_.block_cache != options.block_cache),\n          next_file_number_(1) {\n      // TableCache can be small since we expect each table to be opened once.\n      table_cache_ = new TableCache(dbname_, &options_, 10);\n    }\n}"
  }
]