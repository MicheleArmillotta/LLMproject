[
  {
    "function_name": "scrypt_blockhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "193-197",
    "snippet": "uint256 scrypt_blockhash(const void* input)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt_nosalt(input, 80, scratchpad);\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define SCRYPT_BUFFER_SIZE (131072 + 63)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrypt_nosalt",
          "args": [
            "input",
            "80",
            "scratchpad"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_nosalt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "139-151",
          "snippet": "uint256 scrypt_nosalt(const void* input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (const uint8_t*)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt_nosalt(const void* input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (const uint8_t*)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\n#define SCRYPT_BUFFER_SIZE (131072 + 63)\n\nuint256 scrypt_blockhash(const void* input)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt_nosalt(input, 80, scratchpad);\n}"
  },
  {
    "function_name": "scrypt_salted_multiround_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "179-191",
    "snippet": "uint256 scrypt_salted_multiround_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen, const unsigned int nRounds)\n{\n    uint256 resultHash = scrypt_salted_hash(input, inputlen, salt, saltlen);\n    uint256 transitionalHash = resultHash;\n\n    for(unsigned int i = 1; i < nRounds; i++)\n    {\n        resultHash = scrypt_salted_hash(input, inputlen, (const void*)&transitionalHash, 32);\n        transitionalHash = resultHash;\n    }\n\n    return resultHash;\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrypt_salted_hash",
          "args": [
            "input",
            "inputlen",
            "(const void*)&transitionalHash",
            "32"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_salted_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "173-177",
          "snippet": "uint256 scrypt_salted_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt(input, inputlen, salt, saltlen, scratchpad);\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define SCRYPT_BUFFER_SIZE (131072 + 63)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\n#define SCRYPT_BUFFER_SIZE (131072 + 63)\n\nuint256 scrypt_salted_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt(input, inputlen, salt, saltlen, scratchpad);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt_salted_multiround_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen, const unsigned int nRounds)\n{\n    uint256 resultHash = scrypt_salted_hash(input, inputlen, salt, saltlen);\n    uint256 transitionalHash = resultHash;\n\n    for(unsigned int i = 1; i < nRounds; i++)\n    {\n        resultHash = scrypt_salted_hash(input, inputlen, (const void*)&transitionalHash, 32);\n        transitionalHash = resultHash;\n    }\n\n    return resultHash;\n}"
  },
  {
    "function_name": "scrypt_salted_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "173-177",
    "snippet": "uint256 scrypt_salted_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt(input, inputlen, salt, saltlen, scratchpad);\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define SCRYPT_BUFFER_SIZE (131072 + 63)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrypt",
          "args": [
            "input",
            "inputlen",
            "salt",
            "saltlen",
            "scratchpad"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_salted_multiround_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "179-191",
          "snippet": "uint256 scrypt_salted_multiround_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen, const unsigned int nRounds)\n{\n    uint256 resultHash = scrypt_salted_hash(input, inputlen, salt, saltlen);\n    uint256 transitionalHash = resultHash;\n\n    for(unsigned int i = 1; i < nRounds; i++)\n    {\n        resultHash = scrypt_salted_hash(input, inputlen, (const void*)&transitionalHash, 32);\n        transitionalHash = resultHash;\n    }\n\n    return resultHash;\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt_salted_multiround_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen, const unsigned int nRounds)\n{\n    uint256 resultHash = scrypt_salted_hash(input, inputlen, salt, saltlen);\n    uint256 transitionalHash = resultHash;\n\n    for(unsigned int i = 1; i < nRounds; i++)\n    {\n        resultHash = scrypt_salted_hash(input, inputlen, (const void*)&transitionalHash, 32);\n        transitionalHash = resultHash;\n    }\n\n    return resultHash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\n#define SCRYPT_BUFFER_SIZE (131072 + 63)\n\nuint256 scrypt_salted_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt(input, inputlen, salt, saltlen, scratchpad);\n}"
  },
  {
    "function_name": "scrypt_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "167-171",
    "snippet": "uint256 scrypt_hash(const void* input, size_t inputlen)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt_nosalt(input, inputlen, scratchpad);\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [
      "#define SCRYPT_BUFFER_SIZE (131072 + 63)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scrypt_nosalt",
          "args": [
            "input",
            "inputlen",
            "scratchpad"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_nosalt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "139-151",
          "snippet": "uint256 scrypt_nosalt(const void* input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (const uint8_t*)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt_nosalt(const void* input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (const uint8_t*)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\n#define SCRYPT_BUFFER_SIZE (131072 + 63)\n\nuint256 scrypt_hash(const void* input, size_t inputlen)\n{\n    unsigned char scratchpad[SCRYPT_BUFFER_SIZE];\n    return scrypt_nosalt(input, inputlen, scratchpad);\n}"
  },
  {
    "function_name": "scrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "153-165",
    "snippet": "uint256 scrypt(const void* data, size_t datalen, const void* salt, size_t saltlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)data, datalen, (const uint8_t*)salt, saltlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)data, datalen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PBKDF2_SHA256",
          "args": [
            "(const uint8_t*)data",
            "datalen",
            "(uint8_t *)X",
            "128",
            "1",
            "(uint8_t*)&result",
            "32"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "PBKDF2_SHA256",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/pbkdf2.cpp",
          "lines": "97-147",
          "snippet": "void\nPBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n    HMAC_SHA256_CTX PShctx, hctx;\n    size_t i;\n    uint8_t ivec[4];\n    uint8_t U[32];\n    uint8_t T[32];\n    uint64_t j;\n    int k;\n    size_t clen;\n\n    /* Compute HMAC state after processing P and S. */\n    HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n    HMAC_SHA256_Update(&PShctx, salt, saltlen);\n\n    /* Iterate through the blocks. */\n    for (i = 0; i * 32 < dkLen; i++) {\n        /* Generate INT(i + 1). */\n        be32enc(ivec, (uint32_t)(i + 1));\n\n        /* Compute U_1 = PRF(P, S || INT(i)). */\n        memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n        HMAC_SHA256_Update(&hctx, ivec, 4);\n        HMAC_SHA256_Final(U, &hctx);\n\n        /* T_i = U_1 ... */\n        memcpy(T, U, 32);\n\n        for (j = 2; j <= c; j++) {\n            /* Compute U_j. */\n            HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n            HMAC_SHA256_Update(&hctx, U, 32);\n            HMAC_SHA256_Final(U, &hctx);\n\n            /* ... xor U_j ... */\n            for (k = 0; k < 32; k++)\n                T[k] ^= U[k];\n        }\n\n        /* Copy as many bytes as necessary into buf. */\n        clen = dkLen - i * 32;\n        if (clen > 32)\n            clen = 32;\n        memcpy(&buf[i * 32], T, clen);\n    }\n\n    /* Clean PShctx, since we never called _Final on it. */\n    memset(&PShctx, 0, sizeof(HMAC_SHA256_CTX));\n}",
          "includes": [
            "#include \"pbkdf2.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pbkdf2.h\"\n#include <string.h>\n\nvoid\nPBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n    HMAC_SHA256_CTX PShctx, hctx;\n    size_t i;\n    uint8_t ivec[4];\n    uint8_t U[32];\n    uint8_t T[32];\n    uint64_t j;\n    int k;\n    size_t clen;\n\n    /* Compute HMAC state after processing P and S. */\n    HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n    HMAC_SHA256_Update(&PShctx, salt, saltlen);\n\n    /* Iterate through the blocks. */\n    for (i = 0; i * 32 < dkLen; i++) {\n        /* Generate INT(i + 1). */\n        be32enc(ivec, (uint32_t)(i + 1));\n\n        /* Compute U_1 = PRF(P, S || INT(i)). */\n        memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n        HMAC_SHA256_Update(&hctx, ivec, 4);\n        HMAC_SHA256_Final(U, &hctx);\n\n        /* T_i = U_1 ... */\n        memcpy(T, U, 32);\n\n        for (j = 2; j <= c; j++) {\n            /* Compute U_j. */\n            HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n            HMAC_SHA256_Update(&hctx, U, 32);\n            HMAC_SHA256_Final(U, &hctx);\n\n            /* ... xor U_j ... */\n            for (k = 0; k < 32; k++)\n                T[k] ^= U[k];\n        }\n\n        /* Copy as many bytes as necessary into buf. */\n        clen = dkLen - i * 32;\n        if (clen > 32)\n            clen = 32;\n        memcpy(&buf[i * 32], T, clen);\n    }\n\n    /* Clean PShctx, since we never called _Final on it. */\n    memset(&PShctx, 0, sizeof(HMAC_SHA256_CTX));\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrypt_core",
          "args": [
            "X",
            "V"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "114-130",
          "snippet": "static inline void scrypt_core(unsigned int *X, unsigned int *V)\n{\n    unsigned int i, j, k;\n\n    for (i = 0; i < 1024; i++) {\n        memcpy(&V[i * 32], X, 128);\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n    for (i = 0; i < 1024; i++) {\n        j = 32 * (X[16] & 1023);\n        for (k = 0; k < 32; k++)\n            X[k] ^= V[j + k];\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nstatic inline void scrypt_core(unsigned int *X, unsigned int *V)\n{\n    unsigned int i, j, k;\n\n    for (i = 0; i < 1024; i++) {\n        memcpy(&V[i * 32], X, 128);\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n    for (i = 0; i < 1024; i++) {\n        j = 32 * (X[16] & 1023);\n        for (k = 0; k < 32; k++)\n            X[k] ^= V[j + k];\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt(const void* data, size_t datalen, const void* salt, size_t saltlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)data, datalen, (const uint8_t*)salt, saltlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)data, datalen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}"
  },
  {
    "function_name": "scrypt_nosalt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "139-151",
    "snippet": "uint256 scrypt_nosalt(const void* input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (const uint8_t*)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PBKDF2_SHA256",
          "args": [
            "(const uint8_t*)input",
            "inputlen",
            "(uint8_t *)X",
            "128",
            "1",
            "(uint8_t*)&result",
            "32"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "PBKDF2_SHA256",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/pbkdf2.cpp",
          "lines": "97-147",
          "snippet": "void\nPBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n    HMAC_SHA256_CTX PShctx, hctx;\n    size_t i;\n    uint8_t ivec[4];\n    uint8_t U[32];\n    uint8_t T[32];\n    uint64_t j;\n    int k;\n    size_t clen;\n\n    /* Compute HMAC state after processing P and S. */\n    HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n    HMAC_SHA256_Update(&PShctx, salt, saltlen);\n\n    /* Iterate through the blocks. */\n    for (i = 0; i * 32 < dkLen; i++) {\n        /* Generate INT(i + 1). */\n        be32enc(ivec, (uint32_t)(i + 1));\n\n        /* Compute U_1 = PRF(P, S || INT(i)). */\n        memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n        HMAC_SHA256_Update(&hctx, ivec, 4);\n        HMAC_SHA256_Final(U, &hctx);\n\n        /* T_i = U_1 ... */\n        memcpy(T, U, 32);\n\n        for (j = 2; j <= c; j++) {\n            /* Compute U_j. */\n            HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n            HMAC_SHA256_Update(&hctx, U, 32);\n            HMAC_SHA256_Final(U, &hctx);\n\n            /* ... xor U_j ... */\n            for (k = 0; k < 32; k++)\n                T[k] ^= U[k];\n        }\n\n        /* Copy as many bytes as necessary into buf. */\n        clen = dkLen - i * 32;\n        if (clen > 32)\n            clen = 32;\n        memcpy(&buf[i * 32], T, clen);\n    }\n\n    /* Clean PShctx, since we never called _Final on it. */\n    memset(&PShctx, 0, sizeof(HMAC_SHA256_CTX));\n}",
          "includes": [
            "#include \"pbkdf2.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pbkdf2.h\"\n#include <string.h>\n\nvoid\nPBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n    HMAC_SHA256_CTX PShctx, hctx;\n    size_t i;\n    uint8_t ivec[4];\n    uint8_t U[32];\n    uint8_t T[32];\n    uint64_t j;\n    int k;\n    size_t clen;\n\n    /* Compute HMAC state after processing P and S. */\n    HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n    HMAC_SHA256_Update(&PShctx, salt, saltlen);\n\n    /* Iterate through the blocks. */\n    for (i = 0; i * 32 < dkLen; i++) {\n        /* Generate INT(i + 1). */\n        be32enc(ivec, (uint32_t)(i + 1));\n\n        /* Compute U_1 = PRF(P, S || INT(i)). */\n        memcpy(&hctx, &PShctx, sizeof(HMAC_SHA256_CTX));\n        HMAC_SHA256_Update(&hctx, ivec, 4);\n        HMAC_SHA256_Final(U, &hctx);\n\n        /* T_i = U_1 ... */\n        memcpy(T, U, 32);\n\n        for (j = 2; j <= c; j++) {\n            /* Compute U_j. */\n            HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n            HMAC_SHA256_Update(&hctx, U, 32);\n            HMAC_SHA256_Final(U, &hctx);\n\n            /* ... xor U_j ... */\n            for (k = 0; k < 32; k++)\n                T[k] ^= U[k];\n        }\n\n        /* Copy as many bytes as necessary into buf. */\n        clen = dkLen - i * 32;\n        if (clen > 32)\n            clen = 32;\n        memcpy(&buf[i * 32], T, clen);\n    }\n\n    /* Clean PShctx, since we never called _Final on it. */\n    memset(&PShctx, 0, sizeof(HMAC_SHA256_CTX));\n}"
        }
      },
      {
        "call_info": {
          "callee": "scrypt_core",
          "args": [
            "X",
            "V"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "114-130",
          "snippet": "static inline void scrypt_core(unsigned int *X, unsigned int *V)\n{\n    unsigned int i, j, k;\n\n    for (i = 0; i < 1024; i++) {\n        memcpy(&V[i * 32], X, 128);\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n    for (i = 0; i < 1024; i++) {\n        j = 32 * (X[16] & 1023);\n        for (k = 0; k < 32; k++)\n            X[k] ^= V[j + k];\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nstatic inline void scrypt_core(unsigned int *X, unsigned int *V)\n{\n    unsigned int i, j, k;\n\n    for (i = 0; i < 1024; i++) {\n        memcpy(&V[i * 32], X, 128);\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n    for (i = 0; i < 1024; i++) {\n        j = 32 * (X[16] & 1023);\n        for (k = 0; k < 32; k++)\n            X[k] ^= V[j + k];\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt_nosalt(const void* input, size_t inputlen, void *scratchpad)\n{\n    unsigned int *V;\n    unsigned int X[32];\n    uint256 result = 0;\n    V = (unsigned int *)(((uintptr_t)(scratchpad) + 63) & ~ (uintptr_t)(63));\n\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (const uint8_t*)input, inputlen, 1, (uint8_t *)X, 128);\n    scrypt_core(X, V);\n    PBKDF2_SHA256((const uint8_t*)input, inputlen, (uint8_t *)X, 128, 1, (uint8_t*)&result, 32);\n\n    return result;\n}"
  },
  {
    "function_name": "scrypt_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "114-130",
    "snippet": "static inline void scrypt_core(unsigned int *X, unsigned int *V)\n{\n    unsigned int i, j, k;\n\n    for (i = 0; i < 1024; i++) {\n        memcpy(&V[i * 32], X, 128);\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n    for (i = 0; i < 1024; i++) {\n        j = 32 * (X[16] & 1023);\n        for (k = 0; k < 32; k++)\n            X[k] ^= V[j + k];\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xor_salsa8",
          "args": [
            "&X[16]",
            "&X[0]"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "xor_salsa8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "46-112",
          "snippet": "static inline void xor_salsa8(unsigned int B[16], const unsigned int Bx[16])\n{\n    unsigned int x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10,x11,x12,x13,x14,x15;\n    int i;\n\n    x00 = (B[0] ^= Bx[0]);\n    x01 = (B[1] ^= Bx[1]);\n    x02 = (B[2] ^= Bx[2]);\n    x03 = (B[3] ^= Bx[3]);\n    x04 = (B[4] ^= Bx[4]);\n    x05 = (B[5] ^= Bx[5]);\n    x06 = (B[6] ^= Bx[6]);\n    x07 = (B[7] ^= Bx[7]);\n    x08 = (B[8] ^= Bx[8]);\n    x09 = (B[9] ^= Bx[9]);\n    x10 = (B[10] ^= Bx[10]);\n    x11 = (B[11] ^= Bx[11]);\n    x12 = (B[12] ^= Bx[12]);\n    x13 = (B[13] ^= Bx[13]);\n    x14 = (B[14] ^= Bx[14]);\n    x15 = (B[15] ^= Bx[15]);\n    for (i = 0; i < 8; i += 2) {\n#define R(a, b) (((a) << (b)) | ((a) >> (32 - (b))))\n        /* Operate on columns. */\n        x04 ^= R(x00+x12, 7); x09 ^= R(x05+x01, 7);\n        x14 ^= R(x10+x06, 7); x03 ^= R(x15+x11, 7);\n\n        x08 ^= R(x04+x00, 9); x13 ^= R(x09+x05, 9);\n        x02 ^= R(x14+x10, 9); x07 ^= R(x03+x15, 9);\n\n        x12 ^= R(x08+x04,13); x01 ^= R(x13+x09,13);\n        x06 ^= R(x02+x14,13); x11 ^= R(x07+x03,13);\n\n        x00 ^= R(x12+x08,18); x05 ^= R(x01+x13,18);\n        x10 ^= R(x06+x02,18); x15 ^= R(x11+x07,18);\n\n        /* Operate on rows. */\n        x01 ^= R(x00+x03, 7); x06 ^= R(x05+x04, 7);\n        x11 ^= R(x10+x09, 7); x12 ^= R(x15+x14, 7);\n\n        x02 ^= R(x01+x00, 9); x07 ^= R(x06+x05, 9);\n        x08 ^= R(x11+x10, 9); x13 ^= R(x12+x15, 9);\n\n        x03 ^= R(x02+x01,13); x04 ^= R(x07+x06,13);\n        x09 ^= R(x08+x11,13); x14 ^= R(x13+x12,13);\n\n        x00 ^= R(x03+x02,18); x05 ^= R(x04+x07,18);\n        x10 ^= R(x09+x08,18); x15 ^= R(x14+x13,18);\n#undef R\n    }\n    B[0] += x00;\n    B[1] += x01;\n    B[2] += x02;\n    B[3] += x03;\n    B[4] += x04;\n    B[5] += x05;\n    B[6] += x06;\n    B[7] += x07;\n    B[8] += x08;\n    B[9] += x09;\n    B[10] += x10;\n    B[11] += x11;\n    B[12] += x12;\n    B[13] += x13;\n    B[14] += x14;\n    B[15] += x15;\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nstatic inline void xor_salsa8(unsigned int B[16], const unsigned int Bx[16])\n{\n    unsigned int x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10,x11,x12,x13,x14,x15;\n    int i;\n\n    x00 = (B[0] ^= Bx[0]);\n    x01 = (B[1] ^= Bx[1]);\n    x02 = (B[2] ^= Bx[2]);\n    x03 = (B[3] ^= Bx[3]);\n    x04 = (B[4] ^= Bx[4]);\n    x05 = (B[5] ^= Bx[5]);\n    x06 = (B[6] ^= Bx[6]);\n    x07 = (B[7] ^= Bx[7]);\n    x08 = (B[8] ^= Bx[8]);\n    x09 = (B[9] ^= Bx[9]);\n    x10 = (B[10] ^= Bx[10]);\n    x11 = (B[11] ^= Bx[11]);\n    x12 = (B[12] ^= Bx[12]);\n    x13 = (B[13] ^= Bx[13]);\n    x14 = (B[14] ^= Bx[14]);\n    x15 = (B[15] ^= Bx[15]);\n    for (i = 0; i < 8; i += 2) {\n#define R(a, b) (((a) << (b)) | ((a) >> (32 - (b))))\n        /* Operate on columns. */\n        x04 ^= R(x00+x12, 7); x09 ^= R(x05+x01, 7);\n        x14 ^= R(x10+x06, 7); x03 ^= R(x15+x11, 7);\n\n        x08 ^= R(x04+x00, 9); x13 ^= R(x09+x05, 9);\n        x02 ^= R(x14+x10, 9); x07 ^= R(x03+x15, 9);\n\n        x12 ^= R(x08+x04,13); x01 ^= R(x13+x09,13);\n        x06 ^= R(x02+x14,13); x11 ^= R(x07+x03,13);\n\n        x00 ^= R(x12+x08,18); x05 ^= R(x01+x13,18);\n        x10 ^= R(x06+x02,18); x15 ^= R(x11+x07,18);\n\n        /* Operate on rows. */\n        x01 ^= R(x00+x03, 7); x06 ^= R(x05+x04, 7);\n        x11 ^= R(x10+x09, 7); x12 ^= R(x15+x14, 7);\n\n        x02 ^= R(x01+x00, 9); x07 ^= R(x06+x05, 9);\n        x08 ^= R(x11+x10, 9); x13 ^= R(x12+x15, 9);\n\n        x03 ^= R(x02+x01,13); x04 ^= R(x07+x06,13);\n        x09 ^= R(x08+x11,13); x14 ^= R(x13+x12,13);\n\n        x00 ^= R(x03+x02,18); x05 ^= R(x04+x07,18);\n        x10 ^= R(x09+x08,18); x15 ^= R(x14+x13,18);\n#undef R\n    }\n    B[0] += x00;\n    B[1] += x01;\n    B[2] += x02;\n    B[3] += x03;\n    B[4] += x04;\n    B[5] += x05;\n    B[6] += x06;\n    B[7] += x07;\n    B[8] += x08;\n    B[9] += x09;\n    B[10] += x10;\n    B[11] += x11;\n    B[12] += x12;\n    B[13] += x13;\n    B[14] += x14;\n    B[15] += x15;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&V[i * 32]",
            "X",
            "128"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nstatic inline void scrypt_core(unsigned int *X, unsigned int *V)\n{\n    unsigned int i, j, k;\n\n    for (i = 0; i < 1024; i++) {\n        memcpy(&V[i * 32], X, 128);\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n    for (i = 0; i < 1024; i++) {\n        j = 32 * (X[16] & 1023);\n        for (k = 0; k < 32; k++)\n            X[k] ^= V[j + k];\n        xor_salsa8(&X[0], &X[16]);\n        xor_salsa8(&X[16], &X[0]);\n    }\n}"
  },
  {
    "function_name": "xor_salsa8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
    "lines": "46-112",
    "snippet": "static inline void xor_salsa8(unsigned int B[16], const unsigned int Bx[16])\n{\n    unsigned int x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10,x11,x12,x13,x14,x15;\n    int i;\n\n    x00 = (B[0] ^= Bx[0]);\n    x01 = (B[1] ^= Bx[1]);\n    x02 = (B[2] ^= Bx[2]);\n    x03 = (B[3] ^= Bx[3]);\n    x04 = (B[4] ^= Bx[4]);\n    x05 = (B[5] ^= Bx[5]);\n    x06 = (B[6] ^= Bx[6]);\n    x07 = (B[7] ^= Bx[7]);\n    x08 = (B[8] ^= Bx[8]);\n    x09 = (B[9] ^= Bx[9]);\n    x10 = (B[10] ^= Bx[10]);\n    x11 = (B[11] ^= Bx[11]);\n    x12 = (B[12] ^= Bx[12]);\n    x13 = (B[13] ^= Bx[13]);\n    x14 = (B[14] ^= Bx[14]);\n    x15 = (B[15] ^= Bx[15]);\n    for (i = 0; i < 8; i += 2) {\n#define R(a, b) (((a) << (b)) | ((a) >> (32 - (b))))\n        /* Operate on columns. */\n        x04 ^= R(x00+x12, 7); x09 ^= R(x05+x01, 7);\n        x14 ^= R(x10+x06, 7); x03 ^= R(x15+x11, 7);\n\n        x08 ^= R(x04+x00, 9); x13 ^= R(x09+x05, 9);\n        x02 ^= R(x14+x10, 9); x07 ^= R(x03+x15, 9);\n\n        x12 ^= R(x08+x04,13); x01 ^= R(x13+x09,13);\n        x06 ^= R(x02+x14,13); x11 ^= R(x07+x03,13);\n\n        x00 ^= R(x12+x08,18); x05 ^= R(x01+x13,18);\n        x10 ^= R(x06+x02,18); x15 ^= R(x11+x07,18);\n\n        /* Operate on rows. */\n        x01 ^= R(x00+x03, 7); x06 ^= R(x05+x04, 7);\n        x11 ^= R(x10+x09, 7); x12 ^= R(x15+x14, 7);\n\n        x02 ^= R(x01+x00, 9); x07 ^= R(x06+x05, 9);\n        x08 ^= R(x11+x10, 9); x13 ^= R(x12+x15, 9);\n\n        x03 ^= R(x02+x01,13); x04 ^= R(x07+x06,13);\n        x09 ^= R(x08+x11,13); x14 ^= R(x13+x12,13);\n\n        x00 ^= R(x03+x02,18); x05 ^= R(x04+x07,18);\n        x10 ^= R(x09+x08,18); x15 ^= R(x14+x13,18);\n#undef R\n    }\n    B[0] += x00;\n    B[1] += x01;\n    B[2] += x02;\n    B[3] += x03;\n    B[4] += x04;\n    B[5] += x05;\n    B[6] += x06;\n    B[7] += x07;\n    B[8] += x08;\n    B[9] += x09;\n    B[10] += x10;\n    B[11] += x11;\n    B[12] += x12;\n    B[13] += x13;\n    B[14] += x14;\n    B[15] += x15;\n}",
    "includes": [
      "#include \"net.h\"",
      "#include \"util.h\"",
      "#include \"pbkdf2.h\"",
      "#include \"scrypt.h\"",
      "#include <stdint.h>",
      "#include <stdlib.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "R",
          "args": [
            "x14+x13",
            "18"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ReadSetting",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "168-171",
          "snippet": "bool ReadSetting(const std::string& strKey, T& value)\n    {\n        return Read(std::make_pair(std::string(\"setting\"), strKey), value);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool ReadSetting(const std::string& strKey, T& value)\n      {\n          return Read(std::make_pair(std::string(\"setting\"), strKey), value);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nstatic inline void xor_salsa8(unsigned int B[16], const unsigned int Bx[16])\n{\n    unsigned int x00,x01,x02,x03,x04,x05,x06,x07,x08,x09,x10,x11,x12,x13,x14,x15;\n    int i;\n\n    x00 = (B[0] ^= Bx[0]);\n    x01 = (B[1] ^= Bx[1]);\n    x02 = (B[2] ^= Bx[2]);\n    x03 = (B[3] ^= Bx[3]);\n    x04 = (B[4] ^= Bx[4]);\n    x05 = (B[5] ^= Bx[5]);\n    x06 = (B[6] ^= Bx[6]);\n    x07 = (B[7] ^= Bx[7]);\n    x08 = (B[8] ^= Bx[8]);\n    x09 = (B[9] ^= Bx[9]);\n    x10 = (B[10] ^= Bx[10]);\n    x11 = (B[11] ^= Bx[11]);\n    x12 = (B[12] ^= Bx[12]);\n    x13 = (B[13] ^= Bx[13]);\n    x14 = (B[14] ^= Bx[14]);\n    x15 = (B[15] ^= Bx[15]);\n    for (i = 0; i < 8; i += 2) {\n#define R(a, b) (((a) << (b)) | ((a) >> (32 - (b))))\n        /* Operate on columns. */\n        x04 ^= R(x00+x12, 7); x09 ^= R(x05+x01, 7);\n        x14 ^= R(x10+x06, 7); x03 ^= R(x15+x11, 7);\n\n        x08 ^= R(x04+x00, 9); x13 ^= R(x09+x05, 9);\n        x02 ^= R(x14+x10, 9); x07 ^= R(x03+x15, 9);\n\n        x12 ^= R(x08+x04,13); x01 ^= R(x13+x09,13);\n        x06 ^= R(x02+x14,13); x11 ^= R(x07+x03,13);\n\n        x00 ^= R(x12+x08,18); x05 ^= R(x01+x13,18);\n        x10 ^= R(x06+x02,18); x15 ^= R(x11+x07,18);\n\n        /* Operate on rows. */\n        x01 ^= R(x00+x03, 7); x06 ^= R(x05+x04, 7);\n        x11 ^= R(x10+x09, 7); x12 ^= R(x15+x14, 7);\n\n        x02 ^= R(x01+x00, 9); x07 ^= R(x06+x05, 9);\n        x08 ^= R(x11+x10, 9); x13 ^= R(x12+x15, 9);\n\n        x03 ^= R(x02+x01,13); x04 ^= R(x07+x06,13);\n        x09 ^= R(x08+x11,13); x14 ^= R(x13+x12,13);\n\n        x00 ^= R(x03+x02,18); x05 ^= R(x04+x07,18);\n        x10 ^= R(x09+x08,18); x15 ^= R(x14+x13,18);\n#undef R\n    }\n    B[0] += x00;\n    B[1] += x01;\n    B[2] += x02;\n    B[3] += x03;\n    B[4] += x04;\n    B[5] += x05;\n    B[6] += x06;\n    B[7] += x07;\n    B[8] += x08;\n    B[9] += x09;\n    B[10] += x10;\n    B[11] += x11;\n    B[12] += x12;\n    B[13] += x13;\n    B[14] += x14;\n    B[15] += x15;\n}"
  }
]