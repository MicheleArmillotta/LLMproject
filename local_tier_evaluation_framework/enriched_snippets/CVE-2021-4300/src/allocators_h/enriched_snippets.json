[
  {
    "function_name": "deallocate",
    "container": "zero_after_free_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "246-251",
    "snippet": "void deallocate(T* p, std::size_t n)\n    {\n        if (p != NULL)\n            memset(p, 0, sizeof(T) * n);\n        std::allocator<T>::deallocate(p, n);\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::allocator<T>::deallocate",
          "args": [
            "p",
            "n"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "deallocate",
          "container": "zero_after_free_allocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "246-251",
          "snippet": "void deallocate(T* p, std::size_t n)\n    {\n        if (p != NULL)\n            memset(p, 0, sizeof(T) * n);\n        std::allocator<T>::deallocate(p, n);\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(T) * n"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nzero_after_free_allocator {\n  void deallocate(T* p, std::size_t n)\n      {\n          if (p != NULL)\n              memset(p, 0, sizeof(T) * n);\n          std::allocator<T>::deallocate(p, n);\n      }\n}"
  },
  {
    "function_name": "zero_after_free_allocator",
    "container": "zero_after_free_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "241-241",
    "snippet": "zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a) {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nzero_after_free_allocator {\n  zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a) {}\n}"
  },
  {
    "function_name": "zero_after_free_allocator",
    "container": "zero_after_free_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "239-239",
    "snippet": "zero_after_free_allocator(const zero_after_free_allocator& a) throw() : base(a) {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nzero_after_free_allocator {\n  zero_after_free_allocator(const zero_after_free_allocator& a) throw() : base(a) {}\n}"
  },
  {
    "function_name": "zero_after_free_allocator",
    "container": "zero_after_free_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "238-238",
    "snippet": "zero_after_free_allocator() throw() {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nzero_after_free_allocator {\n  zero_after_free_allocator() throw() {}\n}"
  },
  {
    "function_name": "deallocate",
    "container": "secure_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "211-219",
    "snippet": "void deallocate(T* p, std::size_t n)\n    {\n        if (p != NULL)\n        {\n            memset(p, 0, sizeof(T) * n);\n            LockedPageManager::instance.UnlockRange(p, sizeof(T) * n);\n        }\n        std::allocator<T>::deallocate(p, n);\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::allocator<T>::deallocate",
          "args": [
            "p",
            "n"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "deallocate",
          "container": "zero_after_free_allocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "246-251",
          "snippet": "void deallocate(T* p, std::size_t n)\n    {\n        if (p != NULL)\n            memset(p, 0, sizeof(T) * n);\n        std::allocator<T>::deallocate(p, n);\n    }",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nzero_after_free_allocator {\n  void deallocate(T* p, std::size_t n)\n      {\n          if (p != NULL)\n              memset(p, 0, sizeof(T) * n);\n          std::allocator<T>::deallocate(p, n);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LockedPageManager::instance.UnlockRange",
          "args": [
            "p",
            "sizeof(T) * n"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "UnlockRange",
          "container": "LockedPageManagerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "79-99",
          "snippet": "void UnlockRange(void *p, size_t size)\n    {\n        boost::mutex::scoped_lock lock(mutex);\n        if(!size) return;\n        const size_t base_addr = reinterpret_cast<size_t>(p);\n        const size_t start_page = base_addr & page_mask;\n        const size_t end_page = (base_addr + size - 1) & page_mask;\n        for(size_t page = start_page; page <= end_page; page += page_size)\n        {\n            Histogram::iterator it = histogram.find(page);\n            assert(it != histogram.end()); // Cannot unlock an area that was not locked\n            // Decrease counter for page, when it is zero, the page will be unlocked\n            it->second -= 1;\n            if(it->second == 0) // Nothing on the page anymore that keeps it locked\n            {\n                // Unlock page and remove the count from histogram\n                locker.Unlock(reinterpret_cast<void*>(page), page_size);\n                histogram.erase(it);\n            }\n        }\n    }",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManagerBase {\n  void UnlockRange(void *p, size_t size)\n      {\n          boost::mutex::scoped_lock lock(mutex);\n          if(!size) return;\n          const size_t base_addr = reinterpret_cast<size_t>(p);\n          const size_t start_page = base_addr & page_mask;\n          const size_t end_page = (base_addr + size - 1) & page_mask;\n          for(size_t page = start_page; page <= end_page; page += page_size)\n          {\n              Histogram::iterator it = histogram.find(page);\n              assert(it != histogram.end()); // Cannot unlock an area that was not locked\n              // Decrease counter for page, when it is zero, the page will be unlocked\n              it->second -= 1;\n              if(it->second == 0) // Nothing on the page anymore that keeps it locked\n              {\n                  // Unlock page and remove the count from histogram\n                  locker.Unlock(reinterpret_cast<void*>(page), page_size);\n                  histogram.erase(it);\n              }\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(T) * n"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nsecure_allocator {\n  void deallocate(T* p, std::size_t n)\n      {\n          if (p != NULL)\n          {\n              memset(p, 0, sizeof(T) * n);\n              LockedPageManager::instance.UnlockRange(p, sizeof(T) * n);\n          }\n          std::allocator<T>::deallocate(p, n);\n      }\n}"
  },
  {
    "function_name": "secure_allocator",
    "container": "secure_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "197-197",
    "snippet": "secure_allocator(const secure_allocator<U>& a) throw() : base(a) {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nsecure_allocator {\n  secure_allocator(const secure_allocator<U>& a) throw() : base(a) {}\n}"
  },
  {
    "function_name": "secure_allocator",
    "container": "secure_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "195-195",
    "snippet": "secure_allocator(const secure_allocator& a) throw() : base(a) {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nsecure_allocator {\n  secure_allocator(const secure_allocator& a) throw() : base(a) {}\n}"
  },
  {
    "function_name": "secure_allocator",
    "container": "secure_allocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "194-194",
    "snippet": "secure_allocator() throw() {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nsecure_allocator {\n  secure_allocator() throw() {}\n}"
  },
  {
    "function_name": "LockedPageManager",
    "container": "LockedPageManager",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "173-175",
    "snippet": "LockedPageManager():\n        LockedPageManagerBase<MemoryPageLocker>(GetSystemPageSize())\n    {}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSystemPageSize",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "GetSystemPageSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "118-131",
          "snippet": "static inline size_t GetSystemPageSize()\n{\n    size_t page_size;\n#if defined(WIN32)\n    SYSTEM_INFO sSysInfo;\n    GetSystemInfo(&sSysInfo);\n    page_size = sSysInfo.dwPageSize;\n#elif defined(PAGESIZE) // defined in limits.h\n    page_size = PAGESIZE;\n#else // assume some POSIX OS\n    page_size = sysconf(_SC_PAGESIZE);\n#endif\n    return page_size;\n}",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nstatic inline size_t GetSystemPageSize()\n{\n    size_t page_size;\n#if defined(WIN32)\n    SYSTEM_INFO sSysInfo;\n    GetSystemInfo(&sSysInfo);\n    page_size = sSysInfo.dwPageSize;\n#elif defined(PAGESIZE) // defined in limits.h\n    page_size = PAGESIZE;\n#else // assume some POSIX OS\n    page_size = sysconf(_SC_PAGESIZE);\n#endif\n    return page_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManager {\n  LockedPageManager():\n          LockedPageManagerBase<MemoryPageLocker>(GetSystemPageSize())\n      {}\n}"
  },
  {
    "function_name": "Unlock",
    "container": "MemoryPageLocker",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "154-161",
    "snippet": "bool Unlock(const void *addr, size_t len)\n    {\n#ifdef WIN32\n        return VirtualUnlock(const_cast<void*>(addr), len);\n#else\n        return munlock(addr, len) == 0;\n#endif\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munlock",
          "args": [
            "addr",
            "len"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VirtualUnlock",
          "args": [
            "const_cast<void*>(addr)",
            "len"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<void*>",
          "args": [
            "addr"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nMemoryPageLocker {\n  bool Unlock(const void *addr, size_t len)\n      {\n  #ifdef WIN32\n          return VirtualUnlock(const_cast<void*>(addr), len);\n  #else\n          return munlock(addr, len) == 0;\n  #endif\n      }\n}"
  },
  {
    "function_name": "Lock",
    "container": "MemoryPageLocker",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "143-150",
    "snippet": "bool Lock(const void *addr, size_t len)\n    {\n#ifdef WIN32\n        return VirtualLock(const_cast<void*>(addr), len);\n#else\n        return mlock(addr, len) == 0;\n#endif\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlock",
          "args": [
            "addr",
            "len"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VirtualLock",
          "args": [
            "const_cast<void*>(addr)",
            "len"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<void*>",
          "args": [
            "addr"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nMemoryPageLocker {\n  bool Lock(const void *addr, size_t len)\n      {\n  #ifdef WIN32\n          return VirtualLock(const_cast<void*>(addr), len);\n  #else\n          return mlock(addr, len) == 0;\n  #endif\n      }\n}"
  },
  {
    "function_name": "GetSystemPageSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "118-131",
    "snippet": "static inline size_t GetSystemPageSize()\n{\n    size_t page_size;\n#if defined(WIN32)\n    SYSTEM_INFO sSysInfo;\n    GetSystemInfo(&sSysInfo);\n    page_size = sSysInfo.dwPageSize;\n#elif defined(PAGESIZE) // defined in limits.h\n    page_size = PAGESIZE;\n#else // assume some POSIX OS\n    page_size = sysconf(_SC_PAGESIZE);\n#endif\n    return page_size;\n}",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_PAGESIZE"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSystemInfo",
          "args": [
            "&sSysInfo"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nstatic inline size_t GetSystemPageSize()\n{\n    size_t page_size;\n#if defined(WIN32)\n    SYSTEM_INFO sSysInfo;\n    GetSystemInfo(&sSysInfo);\n    page_size = sSysInfo.dwPageSize;\n#elif defined(PAGESIZE) // defined in limits.h\n    page_size = PAGESIZE;\n#else // assume some POSIX OS\n    page_size = sysconf(_SC_PAGESIZE);\n#endif\n    return page_size;\n}"
  },
  {
    "function_name": "GetLockedPageCount",
    "container": "LockedPageManagerBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "102-106",
    "snippet": "int GetLockedPageCount()\n    {\n        boost::mutex::scoped_lock lock(mutex);\n        return histogram.size();\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "histogram.size",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManagerBase {\n  int GetLockedPageCount()\n      {\n          boost::mutex::scoped_lock lock(mutex);\n          return histogram.size();\n      }\n}"
  },
  {
    "function_name": "UnlockRange",
    "container": "LockedPageManagerBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "79-99",
    "snippet": "void UnlockRange(void *p, size_t size)\n    {\n        boost::mutex::scoped_lock lock(mutex);\n        if(!size) return;\n        const size_t base_addr = reinterpret_cast<size_t>(p);\n        const size_t start_page = base_addr & page_mask;\n        const size_t end_page = (base_addr + size - 1) & page_mask;\n        for(size_t page = start_page; page <= end_page; page += page_size)\n        {\n            Histogram::iterator it = histogram.find(page);\n            assert(it != histogram.end()); // Cannot unlock an area that was not locked\n            // Decrease counter for page, when it is zero, the page will be unlocked\n            it->second -= 1;\n            if(it->second == 0) // Nothing on the page anymore that keeps it locked\n            {\n                // Unlock page and remove the count from histogram\n                locker.Unlock(reinterpret_cast<void*>(page), page_size);\n                histogram.erase(it);\n            }\n        }\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "histogram.erase",
          "args": [
            "it"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "locker.Unlock",
          "args": [
            "reinterpret_cast<void*>(page)",
            "page_size"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "MemoryPageLocker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "154-161",
          "snippet": "bool Unlock(const void *addr, size_t len)\n    {\n#ifdef WIN32\n        return VirtualUnlock(const_cast<void*>(addr), len);\n#else\n        return munlock(addr, len) == 0;\n#endif\n    }",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nMemoryPageLocker {\n  bool Unlock(const void *addr, size_t len)\n      {\n  #ifdef WIN32\n          return VirtualUnlock(const_cast<void*>(addr), len);\n  #else\n          return munlock(addr, len) == 0;\n  #endif\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<void*>",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "it != histogram.end()"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "histogram.end",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "histogram.find",
          "args": [
            "page"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<size_t>",
          "args": [
            "p"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManagerBase {\n  void UnlockRange(void *p, size_t size)\n      {\n          boost::mutex::scoped_lock lock(mutex);\n          if(!size) return;\n          const size_t base_addr = reinterpret_cast<size_t>(p);\n          const size_t start_page = base_addr & page_mask;\n          const size_t end_page = (base_addr + size - 1) & page_mask;\n          for(size_t page = start_page; page <= end_page; page += page_size)\n          {\n              Histogram::iterator it = histogram.find(page);\n              assert(it != histogram.end()); // Cannot unlock an area that was not locked\n              // Decrease counter for page, when it is zero, the page will be unlocked\n              it->second -= 1;\n              if(it->second == 0) // Nothing on the page anymore that keeps it locked\n              {\n                  // Unlock page and remove the count from histogram\n                  locker.Unlock(reinterpret_cast<void*>(page), page_size);\n                  histogram.erase(it);\n              }\n          }\n      }\n}"
  },
  {
    "function_name": "LockRange",
    "container": "LockedPageManagerBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "56-76",
    "snippet": "void LockRange(void *p, size_t size)\n    {\n        boost::mutex::scoped_lock lock(mutex);\n        if(!size) return;\n        const size_t base_addr = reinterpret_cast<size_t>(p);\n        const size_t start_page = base_addr & page_mask;\n        const size_t end_page = (base_addr + size - 1) & page_mask;\n        for(size_t page = start_page; page <= end_page; page += page_size)\n        {\n            Histogram::iterator it = histogram.find(page);\n            if(it == histogram.end()) // Newly locked page\n            {\n                locker.Lock(reinterpret_cast<void*>(page), page_size);\n                histogram.insert(std::make_pair(page, 1));\n            }\n            else // Page was already locked; increase counter\n            {\n                it->second += 1;\n            }\n        }\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "histogram.insert",
          "args": [
            "std::make_pair(page, 1)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "page",
            "1"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locker.Lock",
          "args": [
            "reinterpret_cast<void*>(page)",
            "page_size"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "MemoryPageLocker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "143-150",
          "snippet": "bool Lock(const void *addr, size_t len)\n    {\n#ifdef WIN32\n        return VirtualLock(const_cast<void*>(addr), len);\n#else\n        return mlock(addr, len) == 0;\n#endif\n    }",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nMemoryPageLocker {\n  bool Lock(const void *addr, size_t len)\n      {\n  #ifdef WIN32\n          return VirtualLock(const_cast<void*>(addr), len);\n  #else\n          return mlock(addr, len) == 0;\n  #endif\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<void*>",
          "args": [
            "page"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "histogram.end",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "histogram.find",
          "args": [
            "page"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<size_t>",
          "args": [
            "p"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManagerBase {\n  void LockRange(void *p, size_t size)\n      {\n          boost::mutex::scoped_lock lock(mutex);\n          if(!size) return;\n          const size_t base_addr = reinterpret_cast<size_t>(p);\n          const size_t start_page = base_addr & page_mask;\n          const size_t end_page = (base_addr + size - 1) & page_mask;\n          for(size_t page = start_page; page <= end_page; page += page_size)\n          {\n              Histogram::iterator it = histogram.find(page);\n              if(it == histogram.end()) // Newly locked page\n              {\n                  locker.Lock(reinterpret_cast<void*>(page), page_size);\n                  histogram.insert(std::make_pair(page, 1));\n              }\n              else // Page was already locked; increase counter\n              {\n                  it->second += 1;\n              }\n          }\n      }\n}"
  },
  {
    "function_name": "LockedPageManagerBase",
    "container": "LockedPageManagerBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
    "lines": "47-53",
    "snippet": "LockedPageManagerBase(size_t page_size):\n        page_size(page_size)\n    {\n        // Determine bitmask for extracting page from address\n        assert(!(page_size & (page_size-1))); // size must be power of two\n        page_mask = ~(page_size - 1);\n    }",
    "includes": [
      "#include <unistd.h> // for sysconf",
      "#include <limits.h> // for PAGESIZE",
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <map>",
      "#include <boost/thread/mutex.hpp>",
      "#include <string>",
      "#include <string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!(page_size & (page_size-1))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManagerBase {\n  LockedPageManagerBase(size_t page_size):\n          page_size(page_size)\n      {\n          // Determine bitmask for extracting page from address\n          assert(!(page_size & (page_size-1))); // size must be power of two\n          page_mask = ~(page_size - 1);\n      }\n}"
  }
]