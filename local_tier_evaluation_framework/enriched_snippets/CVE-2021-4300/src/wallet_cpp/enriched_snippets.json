[
  {
    "function_name": "ReacceptWalletTransactions",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "876-2476",
    "snippet": "void CWallet::ReacceptWalletTransactions()\n{\n    CTxDB txdb(\"r\");\n    bool fRepeat = true;\n    while (fRepeat)\n    {\n        LOCK(cs_wallet);\n        fRepeat = false;\n        vector<CDiskTxPos> vMissingTx;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                continue;\n\n            CTxIndex txindex;\n            bool fUpdated = false;\n            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n            {\n                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                if (txindex.vSpent.size() != wtx.vout.size())\n                {\n                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                {\n                    if (wtx.IsSpent(i))\n                        continue;\n                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                    {\n                        wtx.MarkSpent(i);\n                        fUpdated = true;\n                        vMissingTx.push_back(txindex.vSpent[i]);\n                    }\n                }\n                if (fUpdated)\n                {\n                    printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkDirty();\n                    wtx.WriteToDisk();\n                }\n            }\n            else\n            {\n                // Re-accept any txes of ours that aren't already in a block\n                if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                    wtx.AcceptWalletTransaction(txdb);\n            }\n        }\n        if (!vMissingTx.empty())\n        {\n            // TODO: optimize this to scan just part of the block chain?\n            if (ScanForWalletTransactions(pindexGenesisBlock))\n                fRepeat = true;  // Found missing transactions: re-do re-accept.\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n{\n    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n    {\n        if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n        {\n            uint256 hash = tx.GetHash();\n            if (!txdb.ContainsTx(hash))\n                RelayTransaction((CTransaction)tx, hash);\n        }\n    }\n    if (!(IsCoinBase() || IsCoinStake()))\n    {\n        uint256 hash = GetHash();\n        if (!txdb.ContainsTx(hash))\n        {\n            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n            RelayTransaction((CTransaction)*this, hash);\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction()\n{\n   CTxDB txdb(\"r\");\n   RelayWalletTransaction(txdb);\n}\n\nvoid CWallet::ResendWalletTransactions(bool fForce)\n{\n    if (!fForce)\n    {\n        // Do this infrequently and randomly to avoid giving away\n        // that these are our transactions.\n        static int64_t nNextTime;\n        if (GetTime() < nNextTime)\n            return;\n        bool fFirst = (nNextTime == 0);\n        nNextTime = GetTime() + GetRand(30 * 60);\n        if (fFirst)\n            return;\n\n        // Only do it if there's been a new block since last time\n        static int64_t nLastTime;\n        if (nTimeBestReceived < nLastTime)\n            return;\n        nLastTime = GetTime();\n    }\n\n    // Rebroadcast any of our txes that aren't in a block yet\n    printf(\"ResendWalletTransactions()\\n\");\n    CTxDB txdb(\"r\");\n    {\n        LOCK(cs_wallet);\n        // Sort them in chronological order\n        multimap<unsigned int, CWalletTx*> mapSorted;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            // Don't rebroadcast until it's had plenty of time that\n            // it should have gotten in already by now.\n            if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n        }\n        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n        {\n            CWalletTx& wtx = *item.second;\n            if (wtx.CheckTransaction())\n                wtx.RelayWalletTransaction(txdb);\n            else\n                printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n        }\n    }\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Actions\n//\n\n\nint64_t CWallet::GetBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nint64_t CWallet::GetUnconfirmedBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetImmatureBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx& pcoin = (*it).second;\n            if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                nTotal += GetCredit(pcoin);\n        }\n    }\n    return nTotal;\n}\n\n// populate vCoins with vector of spendable COutputs\nvoid CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if (fOnlyConfirmed && !pcoin->IsTrusted())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < 0)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                    vCoins.push_back(COutput(pcoin, i, nDepth));\n\n        }\n    }\n}\n\nvoid CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if(pcoin->GetDepthInMainChain() < nConf)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n        }\n    }\n}\n\nstatic void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                  vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n{\n    vector<char> vfIncluded;\n\n    vfBest.assign(vValue.size(), true);\n    nBest = nTotalLower;\n\n    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n    {\n        vfIncluded.assign(vValue.size(), false);\n        int64_t nTotal = 0;\n        bool fReachedTarget = false;\n        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n        {\n            for (unsigned int i = 0; i < vValue.size(); i++)\n            {\n                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                {\n                    nTotal += vValue[i].first;\n                    vfIncluded[i] = true;\n                    if (nTotal >= nTargetValue)\n                    {\n                        fReachedTarget = true;\n                        if (nTotal < nBest)\n                        {\n                            nBest = nTotal;\n                            vfBest = vfIncluded;\n                        }\n                        nTotal -= vValue[i].first;\n                        vfIncluded[i] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// ppcoin: total coins staked (non-spendable until maturity)\nint64_t CWallet::GetStake() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetNewMint() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nbool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    // List of values less than target\n    pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n    coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n    coinLowestLarger.second.first = NULL;\n    vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n    int64_t nTotalLower = 0;\n\n    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n\n        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n            continue;\n\n        int i = output.i;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n == nTargetValue)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            return true;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            vValue.push_back(coin);\n            nTotalLower += n;\n        }\n        else if (n < coinLowestLarger.first)\n        {\n            coinLowestLarger = coin;\n        }\n    }\n\n    if (nTotalLower == nTargetValue)\n    {\n        for (unsigned int i = 0; i < vValue.size(); ++i)\n        {\n            setCoinsRet.insert(vValue[i].second);\n            nValueRet += vValue[i].first;\n        }\n        return true;\n    }\n\n    if (nTotalLower < nTargetValue)\n    {\n        if (coinLowestLarger.second.first == NULL)\n            return false;\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n        return true;\n    }\n\n    // Solve subset sum by stochastic approximation\n    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n    vector<char> vfBest;\n    int64_t nBest;\n\n    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n\n    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n    //                                   or the next bigger coin is closer), return the bigger coin\n    if (coinLowestLarger.second.first &&\n        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n    {\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n    }\n    else {\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n            {\n                setCoinsRet.insert(vValue[i].second);\n                nValueRet += vValue[i].first;\n            }\n\n        if (fDebug && GetBoolArg(\"-printpriority\"))\n        {\n            //// debug print\n            printf(\"SelectCoins() best subset: \");\n            for (unsigned int i = 0; i < vValue.size(); i++)\n                if (vfBest[i])\n                    printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n            printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n{\n    vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n\n    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n    if (coinControl && coinControl->HasSelected())\n    {\n        BOOST_FOREACH(const COutput& out, vCoins)\n        {\n            nValueRet += out.tx->vout[out.i].nValue;\n            setCoinsRet.insert(make_pair(out.tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n}\n\n// Select some coins without random shuffle or best subset approximation\nbool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    vector<COutput> vCoins;\n    AvailableCoinsMinConf(vCoins, nMinConf);\n\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n        int i = output.i;\n\n        // Stop if we've chosen enough inputs\n        if (nValueRet >= nTargetValue)\n            break;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n >= nTargetValue)\n        {\n            // If input value is greater or equal to target then simply insert\n            //    it into the current subset and exit\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            break;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    int64_t nValue = 0;\n    BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n    {\n        if (nValue < 0)\n            return false;\n        nValue += s.second;\n    }\n    if (vecSend.empty() || nValue < 0)\n        return false;\n\n    wtxNew.BindWallet(this);\n\n    {\n        LOCK2(cs_main, cs_wallet);\n        // txdb must be opened before the mapWallet lock\n        CTxDB txdb(\"r\");\n        {\n            nFeeRet = nTransactionFee;\n            while (true)\n            {\n                wtxNew.vin.clear();\n                wtxNew.vout.clear();\n                wtxNew.fFromMe = true;\n\n                int64_t nTotalValue = nValue + nFeeRet;\n                double dPriority = 0;\n                // vouts to the payees\n                BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n\n                // Choose coins to use\n                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                int64_t nValueIn = 0;\n                if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                    return false;\n                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                {\n                    int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                }\n\n                int64_t nChange = nValueIn - nValue - nFeeRet;\n                // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                // or until nChange becomes zero\n                // NOTE: this depends on the exact behaviour of GetMinFee\n                if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                {\n                    int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                    nChange -= nMoveToFee;\n                    nFeeRet += nMoveToFee;\n                }\n\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    // TODO: pass in scriptChange instead of reservekey so\n                    // change transaction isn't always pay-to-bitcoin-address\n                    CScript scriptChange;\n\n                    // coin control: send change to custom address\n                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                        scriptChange.SetDestination(coinControl->destChange);\n\n                    // no coin control: send change to newly generated address\n                    else\n                    {\n                        // Note: We use a new key here to keep it from being obvious which side is the change.\n                        //  The drawback is that by not reusing a previous key, the change may be lost if a\n                        //  backup is restored, if the backup doesn't have the new private key for the change.\n                        //  If we reused the old key, it would be possible to add code to look for and\n                        //  rediscover unknown transactions that were written with keys of ours to recover\n                        //  post-backup change.\n\n                        // Reserve a new key pair from key pool\n                        CPubKey vchPubKey = reservekey.GetReservedKey();\n\n                        scriptChange.SetDestination(vchPubKey.GetID());\n                    }\n\n                    // Insert change txn at random position:\n                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                }\n                else\n                    reservekey.ReturnKey();\n\n                // Fill vin\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n\n                // Sign\n                int nIn = 0;\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                        return false;\n\n                // Limit size\n                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                    return false;\n                dPriority /= nBytes;\n\n                // Check that enough fee is included\n                int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n\n                if (nFeeRet < max(nPayFee, nMinFee))\n                {\n                    nFeeRet = max(nPayFee, nMinFee);\n                    continue;\n                }\n\n                // Fill vtxPrev by copying from previous transactions vtxPrev\n                wtxNew.AddSupportingTransactions(txdb);\n                wtxNew.fTimeReceivedIsTxTime = true;\n\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nbool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    vector< pair<CScript, int64_t> > vecSend;\n    vecSend.push_back(make_pair(scriptPubKey, nValue));\n    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n}\n\n// NovaCoin: get current stake weight\nbool CWallet::GetStakeWeight(const CKeyStore& keystore,\n  uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n        CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n\n        // Weight is greater than zero\n        if (nTimeWeight > 0)\n        {\n            nWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Weight is greater than zero, but the maximum value isn't reached yet\n        if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n        {\n            nMinWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Maximum weight was reached\n        if (nTimeWeight == nStakeMaxAge)\n        {\n            nMaxWeight += bnCoinDayWeight.getuint64();\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n  int64_t nFees, CTransaction& txNew, CKey& key) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    /* Don't split inputs above this age */\n    const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n    /* Time limit for searching a single input */\n    const uint nMaxStakeSearchInterval = 60;\n\n    CBlockIndex* pindexPrev = pindexBest;\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n\n    txNew.vin.clear();\n    txNew.vout.clear();\n\n    // Mark coin stake transaction\n    CScript scriptEmpty;\n    scriptEmpty.clear();\n    txNew.vout.push_back(CTxOut(0, scriptEmpty));\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    // Select coins with suitable depth\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    int64_t nCredit = 0;\n    CScript scriptPubKeyKernel;\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        // Read block header\n        CBlock block;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                continue;\n        }\n\n        if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n            continue; // only count coins meeting min age requirement\n\n        bool fKernelFound = false;\n        for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n        {\n            // Search backward in time from the given txNew timestamp \n            // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n            uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n            COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n            if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n            {\n                // Found a kernel\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : kernel found\\n\");\n                vector<valtype> vSolutions;\n                txnouttype whichType;\n                CScript scriptPubKeyOut;\n                scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                    break;\n                }\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                    break;  // only support pay to public key and pay to address\n                }\n                if (whichType == TX_PUBKEYHASH) // pay to address type\n                {\n                    // convert to pay to public key type\n                    if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n                    scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                }\n                if (whichType == TX_PUBKEY)\n                {\n                    valtype& vchPubKey = vSolutions[0];\n                    if (!keystore.GetKey(Hash160(vchPubKey), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                        break; // keys mismatch\n                    }\n\n                    scriptPubKeyOut = scriptPubKeyKernel;\n                }\n\n                txNew.nTime -= n;\n                txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                nCredit += pcoin.first->vout[pcoin.second].nValue;\n                vwtxPrev.push_back(pcoin.first);\n                txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                /* Split large inputs into two near halves;\n                 * exact amounts to be defined after reward processing */\n                if((nCredit >= nSplitThreshold) &&\n                  (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                fKernelFound = true;\n                break;\n            }\n        }\n\n        if (fKernelFound || fShutdown)\n            break; // if kernel is found stop searching\n    }\n\n    /* At this point, stake amount must be positive and within the stake limit if defined */\n    if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n      return(false);\n\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n\n        /* Make a larger stake by inserting additional inputs\n         * of the same public key (address) as the generating input */\n        if((txNew.vout.size() == 2) &&\n          (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n          (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n          (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n            int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n\n            /* Do not add too many inputs */\n            if(txNew.vin.size() >= 10)\n              break;\n            /* Do not add any inputs if reached or exceeded the threshold already */\n            if(nCredit >= nCombineThreshold)\n              break;\n            /* Do not add a new input exceeding the stake limit if defined */\n            if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n              break;\n            /* Do not add any large inputs capable of stake generation on their own */\n            if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n              continue;\n            /* Do not add any inputs under the min. age */\n            if(nTimeWeight < nStakeMinAge)\n              continue;\n\n            txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n            nCredit += pcoin.first->vout[pcoin.second].nValue;\n            vwtxPrev.push_back(pcoin.first);\n        }\n\n    }\n\n    // Calculate coin age reward\n    {\n        uint64_t nCoinAge;\n        CTxDB txdb(\"r\");\n        if (!txNew.GetCoinAge(txdb, nCoinAge))\n            return error(\"CreateCoinStake : failed to calculate coin age\");\n\n        int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n        if (nReward <= 0)\n            return false;\n\n        nCredit += nReward;\n    }\n\n    // Set output amount\n    if (txNew.vout.size() == 3)\n    {\n        txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n        txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n    }\n    else\n        txNew.vout[1].nValue = nCredit;\n\n    // Sign\n    int nIn = 0;\n    BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n    {\n        if (!SignSignature(*this, *pcoin, txNew, nIn++))\n            return error(\"CreateCoinStake : failed to sign coinstake\");\n    }\n\n    // Limit size\n    unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n    if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n        return error(\"CreateCoinStake : exceeded coinstake size limit\");\n\n    // Successfully generated coinstake\n    return true;\n}\n\n\n// Call after CreateTransaction unless you want to abort\nbool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}\n\n\n\n\nstring CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    CReserveKey reservekey(this);\n    int64_t nFeeRequired;\n\n    if (IsLocked())\n    {\n        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (fWalletUnlockStakingOnly)\n    {\n        string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n    {\n        string strError;\n        if (nValue + nFeeRequired > GetBalance())\n            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n        else\n            strError = _(\"Error: Transaction creation failed  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n\n    if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n        return \"ABORTED\";\n\n    if (!CommitTransaction(wtxNew, reservekey))\n        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n\n    return \"\";\n}\n\n\n\nstring CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    // Check amount\n    if (nValue <= 0)\n        return _(\"Invalid amount\");\n    if (nValue + nTransactionFee > GetBalance())\n        return _(\"Insufficient funds\");\n\n    // Parse Bitcoin address\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n\n    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n}\n\n\n\n\nDBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    if (!fFileBacked)\n        return DB_LOAD_OK;\n    fFirstRunRet = false;\n    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n        {\n            setKeyPool.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // the requires a new key.\n        }\n    }\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n    fFirstRunRet = !vchDefaultKey.IsValid();\n\n    NewThread(ThreadFlushWalletDB, &strWalletFile);\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n{\n    std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n    mapAddressBook[address] = strName;\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n}\n\nbool CWallet::DelAddressBookName(const CTxDestination& address)\n{\n    mapAddressBook.erase(address);\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n}\n\n\nvoid CWallet::PrintWallet(const CBlock& block)\n{\n    {\n        LOCK(cs_wallet);\n        if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n            printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n        }\n        if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n            printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n         }\n\n    }\n    printf(\"\\n\");\n}\n\nbool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n        {\n            wtx = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n{\n    if (fFileBacked)\n    {\n        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n            return false;\n    }\n    vchDefaultKey = vchPubKey;\n    return true;\n}\n\nbool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n{\n    if (!pwallet->fFileBacked)\n        return false;\n    strWalletFileOut = pwallet->strWalletFile;\n    return true;\n}\n\n//\n// Mark old keypool keys as used,\n// and generate all new keys\n//\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n        BOOST_FOREACH(int64_t nIndex, setKeyPool)\n            walletdb.ErasePool(nIndex);\n        setKeyPool.clear();\n\n        if (IsLocked())\n            return false;\n\n        int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n        for (int i = 0; i < nKeys; i++)\n        {\n            int64_t nIndex = i+1;\n            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n            setKeyPool.insert(nIndex);\n        }\n        printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n    }\n    return true;\n}\n\nbool CWallet::TopUpKeyPool(unsigned int nSize)\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        CWalletDB walletdb(strWalletFile);\n\n        // Top up key pool\n        unsigned int nTargetSize;\n        if (nSize > 0)\n            nTargetSize = nSize;\n        else\n            nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n\n        while (setKeyPool.size() < (nTargetSize + 1))\n        {\n            int64_t nEnd = 1;\n            if (!setKeyPool.empty())\n                nEnd = *(--setKeyPool.end()) + 1;\n            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n            setKeyPool.insert(nEnd);\n            printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(strWalletFile);\n\n        nIndex = *(setKeyPool.begin());\n        setKeyPool.erase(setKeyPool.begin());\n        if (!walletdb.ReadPool(nIndex, keypool))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n        if (!HaveKey(keypool.vchPubKey.GetID()))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n        assert(keypool.vchPubKey.IsValid());\n        if (fDebug && GetBoolArg(\"-printkeypool\"))\n            printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n    }\n}\n\nint64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n\n        int64_t nIndex = 1 + *(--setKeyPool.end());\n        if (!walletdb.WritePool(nIndex, keypool))\n            throw runtime_error(\"AddReserveKey() : writing added key failed\");\n        setKeyPool.insert(nIndex);\n        return nIndex;\n    }\n    return -1;\n}\n\nvoid CWallet::KeepKey(int64_t nIndex)\n{\n    // Remove from key pool\n    if (fFileBacked)\n    {\n        CWalletDB walletdb(strWalletFile);\n        walletdb.ErasePool(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64_t nIndex)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        setKeyPool.insert(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex == -1)\n        {\n            if (fAllowReuse && vchDefaultKey.IsValid())\n            {\n                result = vchDefaultKey;\n                return true;\n            }\n            if (IsLocked()) return false;\n            result = GenerateNewKey();\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nint64_t CWallet::GetOldestKeyPoolTime()\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    ReserveKeyFromKeyPool(nIndex, keypool);\n    if (nIndex == -1)\n        return GetTime();\n    ReturnKey(nIndex);\n    return keypool.nTime;\n}\n\nstd::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n{\n    map<CTxDestination, int64_t> balances;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n        {\n            CWalletTx *pcoin = &walletEntry.second;\n\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                continue;\n\n            if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            {\n                CTxDestination addr;\n                if (!IsMine(pcoin->vout[i]))\n                    continue;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                    continue;\n\n                int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n\n                if (!balances.count(addr))\n                    balances[addr] = 0;\n                balances[addr] += n;\n            }\n        }\n    }\n\n    return balances;\n}\n\nset< set<CTxDestination> > CWallet::GetAddressGroupings()\n{\n    set< set<CTxDestination> > groupings;\n    set<CTxDestination> grouping;\n\n    BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n    {\n        CWalletTx *pcoin = &walletEntry.second;\n\n        if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n        {\n            // group all input addresses with each other\n            BOOST_FOREACH(CTxIn txin, pcoin->vin)\n            {\n                CTxDestination address;\n                if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n            }\n\n            // group change with input addresses\n            BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                if (IsChange(txout))\n                {\n                    CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                    CTxDestination txoutAddr;\n                    if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                        continue;\n                    grouping.insert(txoutAddr);\n                }\n            groupings.insert(grouping);\n            grouping.clear();\n        }\n\n        // group lone addrs by themselves\n        for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            if (IsMine(pcoin->vout[i]))\n            {\n                CTxDestination address;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n    }\n\n    set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n    map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n    BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n    {\n        // make a set of all the groups hit by this new group\n        set< set<CTxDestination>* > hits;\n        map< CTxDestination, set<CTxDestination>* >::iterator it;\n        BOOST_FOREACH(CTxDestination address, grouping)\n            if ((it = setmap.find(address)) != setmap.end())\n                hits.insert((*it).second);\n\n        // merge all hit groups into a new single group and delete old groups\n        set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n        BOOST_FOREACH(set<CTxDestination>* hit, hits)\n        {\n            merged->insert(hit->begin(), hit->end());\n            uniqueGroupings.erase(hit);\n            delete hit;\n        }\n        uniqueGroupings.insert(merged);\n\n        // update setmap\n        BOOST_FOREACH(CTxDestination element, *merged)\n            setmap[element] = merged;\n    }\n\n    set< set<CTxDestination> > ret;\n    BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n    {\n        ret.insert(*uniqueGrouping);\n        delete uniqueGrouping;\n    }\n\n    return ret;\n}\n\n\n/* Checks for wallet vs. transaction index consistency;\n * reports any spent state inconsistency found and\n * (optionally) fixes the wallet according to the transaction index */\nvoid CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n  bool fCheckOnly) {\n    nMismatchFound = 0;\n    nOrphansFound = 0;\n    nBalanceInQuestion = 0;\n\n    LOCK(cs_wallet);\n    vector<CWalletTx*> vCoins;\n    vCoins.reserve(mapWallet.size());\n    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        vCoins.push_back(&(*it).second);\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n        uint256 hash = pcoin->GetHash();\n        CTxIndex txindex;\n        uint n;\n\n        if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n            continue;\n\n        for(n = 0; n < pcoin->vout.size(); n++) {\n            bool fUpdated = false;\n\n            if(IsMine(pcoin->vout[n])) {\n                if(pcoin->IsSpent(n) &&\n                  ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkUnspent(n);\n                        pcoin->WriteToDisk();\n                    }\n                } else if(!pcoin->IsSpent(n) &&\n                  (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkSpent(n);\n                        pcoin->WriteToDisk();\n                    }\n                }\n\n            }\n\n            if(fUpdated)\n              NotifyTransactionChanged(this, hash, CT_UPDATED);\n        }\n\n        if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n           nOrphansFound++;\n           if(!fCheckOnly) {\n               EraseFromWallet(hash);\n               NotifyTransactionChanged(this, hash, CT_DELETED);\n           }\n           printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n             fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n        }\n    }\n}\n\n\n// ppcoin: disable transaction (only for coinstake)\nvoid CWallet::DisableTransaction(const CTransaction &tx)\n{\n    if (!tx.IsCoinStake() || !IsFromMe(tx))\n        return; // only disconnecting coinstake requires marking input unspent\n\n    LOCK(cs_wallet);\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n            {\n                prev.MarkUnspent(txin.prevout.n);\n                prev.WriteToDisk();\n            }\n        }\n    }\n}\n\nCPubKey CReserveKey::GetReservedKey()\n{\n    if (nIndex == -1)\n    {\n        CKeyPool keypool;\n        pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex != -1)\n            vchPubKey = keypool.vchPubKey;\n        else\n        {\n            printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n            vchPubKey = pwallet->vchDefaultKey;\n        }\n    }\n    assert(vchPubKey.IsValid());\n    return vchPubKey;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1)\n        pwallet->ReturnKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n{\n    setAddress.clear();\n\n    CWalletDB walletdb(strWalletFile);\n\n    LOCK2(cs_main, cs_wallet);\n    BOOST_FOREACH(const int64_t& id, setKeyPool)\n    {\n        CKeyPool keypool;\n        if (!walletdb.ReadPool(id, keypool))\n            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n        assert(keypool.vchPubKey.IsValid());\n        CKeyID keyID = keypool.vchPubKey.GetID();\n        if (!HaveKey(keyID))\n            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n        setAddress.insert(keyID);\n    }\n}\n\nvoid CWallet::UpdatedTransaction(const uint256 &hashTx)\n{\n    {\n        LOCK(cs_wallet);\n        // Only notify UI if this transaction is in this wallet\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n    }\n}\n\nvoid CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n    mapKeyBirth.clear();\n\n    // get birth times for keys with metadata\n    for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n        if (it->second.nCreateTime)\n            mapKeyBirth[it->first] = it->second.nCreateTime;\n\n    // map in which we'll infer heights of other keys\n    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n    std::set<CKeyID> setKeys;\n    GetKeys(setKeys);\n    BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n        if (mapKeyBirth.count(keyid) == 0)\n            mapKeyFirstBlock[keyid] = pindexMax;\n    }\n    setKeys.clear();\n\n    // if there are no such keys, we're done\n    if (mapKeyFirstBlock.empty())\n        return;\n\n    // find first block that affects those keys, if there are any left\n    std::vector<CKeyID> vAffected;\n    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n        // iterate over all wallet transactions...\n        const CWalletTx &wtx = (*it).second;\n        std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n        if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n            // ... which are already in a block\n            int nHeight = blit->second->nHeight;\n            BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                // iterate over all their outputs\n                ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                    // ... and all their affected keys\n                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                        rit->second = blit->second;\n                }\n                vAffected.clear();\n            }\n        }\n    }\n\n    // Extract block timestamps for those keys\n    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n        mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned int nStakeMaxAge;",
      "bool fWalletUnlockStakingOnly = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapKeyFirstBlock.end",
          "args": [],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapKeyFirstBlock.begin",
          "args": [],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vAffected.clear",
          "args": [],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapKeyFirstBlock.find",
          "args": [
            "keyid"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::ExtractAffectedKeys",
          "args": [
            "*this",
            "txout.scriptPubKey",
            "vAffected"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractAffectedKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1649-1651",
          "snippet": "void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys) {\n    CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nvoid ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys) {\n    CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blit->second->IsInMainChain",
          "args": [],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapKeyFirstBlock.empty",
          "args": [],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapKeyBirth.count",
          "args": [
            "keyid"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetKeys",
          "args": [
            "setKeys"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "GetKeys",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "162-176",
          "snippet": "void GetKeys(std::set<CKeyID> &setAddress) const\n    {\n        if (!IsCrypted())\n        {\n            CBasicKeyStore::GetKeys(setAddress);\n            return;\n        }\n        setAddress.clear();\n        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n        while (mi != mapCryptedKeys.end())\n        {\n            setAddress.insert((*mi).first);\n            mi++;\n        }\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  void GetKeys(std::set<CKeyID> &setAddress) const\n      {\n          if (!IsCrypted())\n          {\n              CBasicKeyStore::GetKeys(setAddress);\n              return;\n          }\n          setAddress.clear();\n          CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n          while (mi != mapCryptedKeys.end())\n          {\n              setAddress.insert((*mi).first);\n              mi++;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindBlockByHeight",
          "args": [
            "std::max(0, nBestHeight - 144)"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::max",
          "args": [
            "0",
            "nBestHeight - 144"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "hashTx",
            "CT_UPDATED"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setAddress.insert",
          "args": [
            "keyID"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"GetAllReserveKeyHashes() : unknown key in key pool\""
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HaveKey",
          "args": [
            "keyID"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "HaveKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "150-159",
          "snippet": "bool HaveKey(const CKeyID &address) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            if (!IsCrypted())\n                return CBasicKeyStore::HaveKey(address);\n            return mapCryptedKeys.count(address) > 0;\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool HaveKey(const CKeyID &address) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              if (!IsCrypted())\n                  return CBasicKeyStore::HaveKey(address);\n              return mapCryptedKeys.count(address) > 0;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keypool.vchPubKey.GetID",
          "args": [],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "keypool.vchPubKey.IsValid()"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keypool.vchPubKey.IsValid",
          "args": [],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"GetAllReserveKeyHashes() : read failed\""
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walletdb.ReadPool",
          "args": [
            "id",
            "keypool"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "ReadPool",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "148-151",
          "snippet": "bool ReadPool(int64_t nPool, CKeyPool& keypool)\n    {\n        return Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool ReadPool(int64_t nPool, CKeyPool& keypool)\n      {\n          return Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->ReturnKey",
          "args": [
            "nIndex"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwallet->KeepKey",
          "args": [
            "nIndex"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vchPubKey.IsValid()"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwallet->ReserveKeyFromKeyPool",
          "args": [
            "nIndex",
            "keypool"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev.WriteToDisk",
          "args": [],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "WriteToDisk",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "830-833",
          "snippet": "bool CWalletTx::WriteToDisk()\n{\n    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  bool CWalletTx::WriteToDisk()\n  {\n      return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prev.MarkUnspent",
          "args": [
            "txin.prevout.n"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "MarkUnspent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "553-563",
          "snippet": "void MarkUnspent(unsigned int nOut)\n    {\n        if (nOut >= vout.size())\n            throw std::runtime_error(\"CWalletTx::MarkUnspent() : nOut out of range\");\n        vfSpent.resize(vout.size());\n        if (vfSpent[nOut])\n        {\n            vfSpent[nOut] = false;\n            fAvailableCreditCached = false;\n        }\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void MarkUnspent(unsigned int nOut)\n      {\n          if (nOut >= vout.size())\n              throw std::runtime_error(\"CWalletTx::MarkUnspent() : nOut out of range\");\n          vfSpent.resize(vout.size());\n          if (vfSpent[nOut])\n          {\n              vfSpent[nOut] = false;\n              fAvailableCreditCached = false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsMine",
          "args": [
            "prev.vout[txin.prevout.n]"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "581-595",
          "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsMine(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prev.vout.size",
          "args": [],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsFromMe",
          "args": [
            "tx"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "IsFromMe",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "237-240",
          "snippet": "bool IsFromMe(const CTransaction& tx) const\n    {\n        return (GetDebit(tx) > 0);\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  bool IsFromMe(const CTransaction& tx) const\n      {\n          return (GetDebit(tx) > 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"FixSpentCoins() %s orphaned generation tx %s\\n\"",
            "fCheckOnly ? \"found\" : \"removed\"",
            "hash.ToString().c_str()"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "COutput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "725-728",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCOutput {\n  std::string ToString() const\n      {\n          return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "hash",
            "CT_DELETED"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EraseFromWallet",
          "args": [
            "hash"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "EraseFromWallet",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "568-578",
          "snippet": "bool CWallet::EraseFromWallet(uint256 hash)\n{\n    if (!fFileBacked)\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.erase(hash))\n            CWalletDB(strWalletFile).EraseTx(hash);\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::EraseFromWallet(uint256 hash)\n  {\n      if (!fFileBacked)\n          return false;\n      {\n          LOCK(cs_wallet);\n          if (mapWallet.erase(hash))\n              CWalletDB(strWalletFile).EraseTx(hash);\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->GetDepthInMainChain",
          "args": [],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "GetDepthInMainChain",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "765-765",
          "snippet": "int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCMerkleTx {\n  int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->IsCoinBase",
          "args": [],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "hash",
            "CT_UPDATED"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcoin->MarkSpent",
          "args": [
            "n"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "MarkSpent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "541-551",
          "snippet": "void MarkSpent(unsigned int nOut)\n    {\n        if (nOut >= vout.size())\n            throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n        vfSpent.resize(vout.size());\n        if (!vfSpent[nOut])\n        {\n            vfSpent[nOut] = true;\n            fAvailableCreditCached = false;\n        }\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void MarkSpent(unsigned int nOut)\n      {\n          if (nOut >= vout.size())\n              throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n          vfSpent.resize(vout.size());\n          if (!vfSpent[nOut])\n          {\n              vfSpent[nOut] = true;\n              fAvailableCreditCached = false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\"",
            "FormatMoney(pcoin->vout[n].nValue).c_str()",
            "hash.ToString().c_str()",
            "n",
            "fCheckOnly? \"repair not attempted\" : \"repairing\""
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "pcoin->vout[n].nValue"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txindex.vSpent[n].IsNull",
          "args": [],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "133-136",
          "snippet": "bool IsNull() const\n    {\n        return (hashCheckpoint == 0);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool IsNull() const\n      {\n          return (hashCheckpoint == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->IsSpent",
          "args": [
            "n"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "IsSpent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "565-572",
          "snippet": "bool IsSpent(unsigned int nOut) const\n    {\n        if (nOut >= vout.size())\n            throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n        if (nOut >= vfSpent.size())\n            return false;\n        return (!!vfSpent[nOut]);\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  bool IsSpent(unsigned int nOut) const\n      {\n          if (nOut >= vout.size())\n              throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n          if (nOut >= vfSpent.size())\n              return false;\n          return (!!vfSpent[nOut]);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\"",
            "FormatMoney(pcoin->vout[n].nValue).c_str()",
            "hash.ToString().c_str()",
            "n",
            "fCheckOnly? \"repair not attempted\" : \"repairing\""
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "pcoin->vout[n].nValue"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txdb.ReadTxIndex",
          "args": [
            "hash",
            "txindex"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->GetHash",
          "args": [],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vCoins.push_back",
          "args": [
            "&(*it).second"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vCoins.reserve",
          "args": [
            "mapWallet.size()"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uniqueGroupings.erase",
          "args": [
            "hit"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "merged->insert",
          "args": [
            "hit->begin()",
            "hit->end()"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExtractDestination",
          "args": [
            "pcoin->vout[i].scriptPubKey",
            "address"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1590-1614",
          "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BOOST_FOREACH",
          "args": [
            "PAIRTYPE(uint256, CWalletTx)walletEntry",
            "mapWallet"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAIRTYPE",
          "args": [
            "uint256",
            "CWalletTx"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcoin->IsFromMe",
          "args": [],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "IsFromMe",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "641-644",
          "snippet": "bool IsFromMe() const\n    {\n        return (GetDebit() > 0);\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  bool IsFromMe() const\n      {\n          return (GetDebit() > 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->GetBlocksToMaturity",
          "args": [],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlocksToMaturity",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "817-822",
          "snippet": "int CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!(IsCoinBase() || IsCoinStake()))\n        return 0;\n    return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nCoinbaseMaturity = 50;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nCoinbaseMaturity = 50;\n\nCMerkleTx {\n  int CMerkleTx::GetBlocksToMaturity() const\n  {\n      if (!(IsCoinBase() || IsCoinStake()))\n          return 0;\n      return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->IsTrusted",
          "args": [],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "IsTrusted",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "646-694",
          "snippet": "bool IsTrusted() const\n    {\n        // Quick answer in most cases\n        if (!IsFinal())\n            return false;\n        int nDepth = GetDepthInMainChain();\n        if (nDepth >= 1)\n            return true;\n        if (nDepth < 0)\n            return false;\n        if (fConfChange || !IsFromMe()) // using wtx's cached debit\n            return false;\n\n        // If no confirmations but it's from us, we can still\n        // consider it confirmed if all dependencies are confirmed\n        std::map<uint256, const CMerkleTx*> mapPrev;\n        std::vector<const CMerkleTx*> vWorkQueue;\n        vWorkQueue.reserve(vtxPrev.size()+1);\n        vWorkQueue.push_back(this);\n        for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n        {\n            const CMerkleTx* ptx = vWorkQueue[i];\n\n            if (!ptx->IsFinal())\n                return false;\n            int nPDepth = ptx->GetDepthInMainChain();\n            if (nPDepth >= 1)\n                continue;\n            if (nPDepth < 0)\n                return false;\n            if (!pwallet->IsFromMe(*ptx))\n                return false;\n\n            if (mapPrev.empty())\n            {\n                BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n                    mapPrev[tx.GetHash()] = &tx;\n            }\n\n            BOOST_FOREACH(const CTxIn& txin, ptx->vin)\n            {\n                if (!mapPrev.count(txin.prevout.hash))\n                    return false;\n                vWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n            }\n        }\n\n        return true;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  bool IsTrusted() const\n      {\n          // Quick answer in most cases\n          if (!IsFinal())\n              return false;\n          int nDepth = GetDepthInMainChain();\n          if (nDepth >= 1)\n              return true;\n          if (nDepth < 0)\n              return false;\n          if (fConfChange || !IsFromMe()) // using wtx's cached debit\n              return false;\n  \n          // If no confirmations but it's from us, we can still\n          // consider it confirmed if all dependencies are confirmed\n          std::map<uint256, const CMerkleTx*> mapPrev;\n          std::vector<const CMerkleTx*> vWorkQueue;\n          vWorkQueue.reserve(vtxPrev.size()+1);\n          vWorkQueue.push_back(this);\n          for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n          {\n              const CMerkleTx* ptx = vWorkQueue[i];\n  \n              if (!ptx->IsFinal())\n                  return false;\n              int nPDepth = ptx->GetDepthInMainChain();\n              if (nPDepth >= 1)\n                  continue;\n              if (nPDepth < 0)\n                  return false;\n              if (!pwallet->IsFromMe(*ptx))\n                  return false;\n  \n              if (mapPrev.empty())\n              {\n                  BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n                      mapPrev[tx.GetHash()] = &tx;\n              }\n  \n              BOOST_FOREACH(const CTxIn& txin, ptx->vin)\n              {\n                  if (!mapPrev.count(txin.prevout.hash))\n                      return false;\n                  vWorkQueue.push_back(mapPrev[txin.prevout.hash]);\n              }\n          }\n  \n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcoin->IsFinal",
          "args": [],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "IsFinal",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "491-506",
          "snippet": "bool IsFinal(int nBlockHeight=0, int64_t nBlockTime=0) const\n    {\n        // Time based nLockTime implemented in 0.1.6\n        if (nLockTime == 0)\n            return true;\n        if (nBlockHeight == 0)\n            nBlockHeight = nBestHeight;\n        if (nBlockTime == 0)\n            nBlockTime = GetAdjustedTime();\n        if ((int64_t)nLockTime < ((int64_t)nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n            return true;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (!txin.IsFinal())\n                return false;\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsFinal(int nBlockHeight=0, int64_t nBlockTime=0) const\n      {\n          // Time based nLockTime implemented in 0.1.6\n          if (nLockTime == 0)\n              return true;\n          if (nBlockHeight == 0)\n              nBlockHeight = nBestHeight;\n          if (nBlockTime == 0)\n              nBlockTime = GetAdjustedTime();\n          if ((int64_t)nLockTime < ((int64_t)nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n              return true;\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (!txin.IsFinal())\n                  return false;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BOOST_FOREACH",
          "args": [
            "PAIRTYPE(uint256, CWalletTx)walletEntry",
            "mapWallet"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAIRTYPE",
          "args": [
            "uint256",
            "CWalletTx"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReturnKey",
          "args": [
            "nIndex"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReserveKeyFromKeyPool",
          "args": [
            "nIndex",
            "keypool"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeepKey",
          "args": [
            "nIndex"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GenerateNewKey",
          "args": [],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateNewKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "33-56",
          "snippet": "CPubKey CWallet::GenerateNewKey()\n{\n    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n\n    RandAddSeedPerfmon();\n    CKey key;\n    key.MakeNewKey(fCompressed);\n\n    // Compressed public keys were introduced in version 0.6.0\n    if (fCompressed)\n        SetMinVersion(FEATURE_COMPRPUBKEY);\n\n    CPubKey pubkey = key.GetPubKey();\n\n    // Create new metadata\n    int64_t nCreationTime = GetTime();\n    mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n    if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n        nTimeFirstKey = nCreationTime;\n\n    if (!AddKey(key))\n        throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n    return key.GetPubKey();\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  CPubKey CWallet::GenerateNewKey()\n  {\n      bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n  \n      RandAddSeedPerfmon();\n      CKey key;\n      key.MakeNewKey(fCompressed);\n  \n      // Compressed public keys were introduced in version 0.6.0\n      if (fCompressed)\n          SetMinVersion(FEATURE_COMPRPUBKEY);\n  \n      CPubKey pubkey = key.GetPubKey();\n  \n      // Create new metadata\n      int64_t nCreationTime = GetTime();\n      mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n      if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n          nTimeFirstKey = nCreationTime;\n  \n      if (!AddKey(key))\n          throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n      return key.GetPubKey();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLocked",
          "args": [],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocked",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "134-144",
          "snippet": "bool IsLocked() const\n    {\n        if (!IsCrypted())\n            return false;\n        bool result;\n        {\n            LOCK(cs_KeyStore);\n            result = vMasterKey.empty();\n        }\n        return result;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsLocked() const\n      {\n          if (!IsCrypted())\n              return false;\n          bool result;\n          {\n              LOCK(cs_KeyStore);\n              result = vMasterKey.empty();\n          }\n          return result;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReserveKeyFromKeyPool",
          "args": [
            "nIndex",
            "keypool"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"keypool return %\"PRId64\"\\n\"",
            "nIndex"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walletdb.ErasePool",
          "args": [
            "nIndex"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "ErasePool",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "159-163",
          "snippet": "bool ErasePool(int64_t nPool)\n    {\n        nWalletDBUpdated++;\n        return Erase(std::make_pair(std::string(\"pool\"), nPool));\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool ErasePool(int64_t nPool)\n      {\n          nWalletDBUpdated++;\n          return Erase(std::make_pair(std::string(\"pool\"), nPool));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"AddReserveKey() : writing added key failed\""
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walletdb.WritePool",
          "args": [
            "nIndex",
            "keypool"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "WritePool",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "153-157",
          "snippet": "bool WritePool(int64_t nPool, const CKeyPool& keypool)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WritePool(int64_t nPool, const CKeyPool& keypool)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printkeypool\""
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "keypool.vchPubKey.IsValid()"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"ReserveKeyFromKeyPool() : unknown key in key pool\""
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"ReserveKeyFromKeyPool() : read failed\""
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TopUpKeyPool",
          "args": [],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\"",
            "nEnd",
            "setKeyPool.size()"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"TopUpKeyPool() : writing generated key failed\""
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CKeyPool",
          "args": [
            "GenerateNewKey()"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyPool",
          "container": "CKeyPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "52-56",
          "snippet": "CKeyPool(const CPubKey& vchPubKeyIn)\n    {\n        nTime = GetTime();\n        vchPubKey = vchPubKeyIn;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCKeyPool {\n  CKeyPool(const CPubKey& vchPubKeyIn)\n      {\n          nTime = GetTime();\n          vchPubKey = vchPubKeyIn;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "GetArg(\"-keypool\", 100)",
            "(int64_t)0"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-keypool\"",
            "100"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "vchPubKey"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    stake: %d  %d  %\"PRId64\"\"",
            "wtx.GetDepthInMainChain()",
            "wtx.GetBlocksToMaturity()",
            "wtx.GetCredit()"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.GetCredit",
          "args": [],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "GetCredit",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "585-597",
          "snippet": "int64_t GetCredit(bool fUseCache=true) const\n    {\n        // Must wait until coinbase is safely deep enough in the chain before valuing it\n        if ((IsCoinBase() || IsCoinStake()) && GetBlocksToMaturity() > 0)\n            return 0;\n\n        // GetBalance can assume transactions in mapWallet won't change\n        if (fUseCache && fCreditCached)\n            return nCreditCached;\n        nCreditCached = pwallet->GetCredit(*this);\n        fCreditCached = true;\n        return nCreditCached;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  int64_t GetCredit(bool fUseCache=true) const\n      {\n          // Must wait until coinbase is safely deep enough in the chain before valuing it\n          if ((IsCoinBase() || IsCoinStake()) && GetBlocksToMaturity() > 0)\n              return 0;\n  \n          // GetBalance can assume transactions in mapWallet won't change\n          if (fUseCache && fCreditCached)\n              return nCreditCached;\n          nCreditCached = pwallet->GetCredit(*this);\n          fCreditCached = true;\n          return nCreditCached;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.IsProofOfStake",
          "args": [],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    mine:  %d  %d  %\"PRId64\"\"",
            "wtx.GetDepthInMainChain()",
            "wtx.GetBlocksToMaturity()",
            "wtx.GetCredit()"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.IsProofOfWork",
          "args": [],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "address"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyAddressBookChanged",
          "args": [
            "this",
            "address",
            "\"\"",
            "::IsMine(*this, address)",
            "CT_DELETED"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::IsMine",
          "args": [
            "*this",
            "address"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1551-1588",
          "snippet": "bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "CBitcoinAddress(address).ToString()",
            "strName"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSetting",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "173-177",
          "snippet": "bool WriteSetting(const std::string& strKey, const T& value)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteSetting(const std::string& strKey, const T& value)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyAddressBookChanged",
          "args": [
            "this",
            "address",
            "strName",
            "::IsMine(*this, address)",
            "(mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "ThreadFlushWalletDB",
            "&strWalletFile"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CDB::Rewrite",
          "args": [
            "strWalletFile",
            "\"\\x04pool\""
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "Rewrite",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "351-442",
          "snippet": "bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n{\n    while (!fShutdown)\n    {\n        {\n            LOCK(bitdb.cs_db);\n            if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0)\n            {\n                // Flush log data to the dat file\n                bitdb.CloseDb(strFile);\n                bitdb.CheckpointLSN(strFile);\n                bitdb.mapFileUseCount.erase(strFile);\n\n                bool fSuccess = true;\n                printf(\"Rewriting %s...\\n\", strFile.c_str());\n                string strFileRes = strFile + \".rewrite\";\n                { // surround usage of db with extra {}\n                    CDB db(strFile.c_str(), \"r\");\n                    Db* pdbCopy = new Db(&bitdb.dbenv, 0);\n\n                    int ret = pdbCopy->open(NULL,                 // Txn pointer\n                                            strFileRes.c_str(),   // Filename\n                                            \"main\",    // Logical db name\n                                            DB_BTREE,  // Database type\n                                            DB_CREATE,    // Flags\n                                            0);\n                    if (ret > 0)\n                    {\n                        printf(\"Cannot create database file %s\\n\", strFileRes.c_str());\n                        fSuccess = false;\n                    }\n\n                    Dbc* pcursor = db.GetCursor();\n                    if (pcursor)\n                        while (fSuccess)\n                        {\n                            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n                            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n                            int ret = db.ReadAtCursor(pcursor, ssKey, ssValue, DB_NEXT);\n                            if (ret == DB_NOTFOUND)\n                            {\n                                pcursor->close();\n                                break;\n                            }\n                            else if (ret != 0)\n                            {\n                                pcursor->close();\n                                fSuccess = false;\n                                break;\n                            }\n                            if (pszSkip &&\n                                strncmp(&ssKey[0], pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n                                continue;\n                            if (strncmp(&ssKey[0], \"\\x07version\", 8) == 0)\n                            {\n                                // Update version:\n                                ssValue.clear();\n                                ssValue << CLIENT_VERSION;\n                            }\n                            Dbt datKey(&ssKey[0], ssKey.size());\n                            Dbt datValue(&ssValue[0], ssValue.size());\n                            int ret2 = pdbCopy->put(NULL, &datKey, &datValue, DB_NOOVERWRITE);\n                            if (ret2 > 0)\n                                fSuccess = false;\n                        }\n                    if (fSuccess)\n                    {\n                        db.Close();\n                        bitdb.CloseDb(strFile);\n                        if (pdbCopy->close(0))\n                            fSuccess = false;\n                        delete pdbCopy;\n                    }\n                }\n                if (fSuccess)\n                {\n                    Db dbA(&bitdb.dbenv, 0);\n                    if (dbA.remove(strFile.c_str(), NULL, 0))\n                        fSuccess = false;\n                    Db dbB(&bitdb.dbenv, 0);\n                    if (dbB.rename(strFileRes.c_str(), NULL, strFile.c_str(), 0))\n                        fSuccess = false;\n                }\n                if (!fSuccess)\n                    printf(\"Rewriting of %s FAILED!\\n\", strFileRes.c_str());\n                return fSuccess;\n            }\n        }\n        MilliSleep(100);\n    }\n    return false;\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CDBEnv bitdb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv bitdb;\n\nCDB {\n  bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n  {\n      while (!fShutdown)\n      {\n          {\n              LOCK(bitdb.cs_db);\n              if (!bitdb.mapFileUseCount.count(strFile) || bitdb.mapFileUseCount[strFile] == 0)\n              {\n                  // Flush log data to the dat file\n                  bitdb.CloseDb(strFile);\n                  bitdb.CheckpointLSN(strFile);\n                  bitdb.mapFileUseCount.erase(strFile);\n  \n                  bool fSuccess = true;\n                  printf(\"Rewriting %s...\\n\", strFile.c_str());\n                  string strFileRes = strFile + \".rewrite\";\n                  { // surround usage of db with extra {}\n                      CDB db(strFile.c_str(), \"r\");\n                      Db* pdbCopy = new Db(&bitdb.dbenv, 0);\n  \n                      int ret = pdbCopy->open(NULL,                 // Txn pointer\n                                              strFileRes.c_str(),   // Filename\n                                              \"main\",    // Logical db name\n                                              DB_BTREE,  // Database type\n                                              DB_CREATE,    // Flags\n                                              0);\n                      if (ret > 0)\n                      {\n                          printf(\"Cannot create database file %s\\n\", strFileRes.c_str());\n                          fSuccess = false;\n                      }\n  \n                      Dbc* pcursor = db.GetCursor();\n                      if (pcursor)\n                          while (fSuccess)\n                          {\n                              CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n                              CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n                              int ret = db.ReadAtCursor(pcursor, ssKey, ssValue, DB_NEXT);\n                              if (ret == DB_NOTFOUND)\n                              {\n                                  pcursor->close();\n                                  break;\n                              }\n                              else if (ret != 0)\n                              {\n                                  pcursor->close();\n                                  fSuccess = false;\n                                  break;\n                              }\n                              if (pszSkip &&\n                                  strncmp(&ssKey[0], pszSkip, std::min(ssKey.size(), strlen(pszSkip))) == 0)\n                                  continue;\n                              if (strncmp(&ssKey[0], \"\\x07version\", 8) == 0)\n                              {\n                                  // Update version:\n                                  ssValue.clear();\n                                  ssValue << CLIENT_VERSION;\n                              }\n                              Dbt datKey(&ssKey[0], ssKey.size());\n                              Dbt datValue(&ssValue[0], ssValue.size());\n                              int ret2 = pdbCopy->put(NULL, &datKey, &datValue, DB_NOOVERWRITE);\n                              if (ret2 > 0)\n                                  fSuccess = false;\n                          }\n                      if (fSuccess)\n                      {\n                          db.Close();\n                          bitdb.CloseDb(strFile);\n                          if (pdbCopy->close(0))\n                              fSuccess = false;\n                          delete pdbCopy;\n                      }\n                  }\n                  if (fSuccess)\n                  {\n                      Db dbA(&bitdb.dbenv, 0);\n                      if (dbA.remove(strFile.c_str(), NULL, 0))\n                          fSuccess = false;\n                      Db dbB(&bitdb.dbenv, 0);\n                      if (dbB.rename(strFileRes.c_str(), NULL, strFile.c_str(), 0))\n                          fSuccess = false;\n                  }\n                  if (!fSuccess)\n                      printf(\"Rewriting of %s FAILED!\\n\", strFileRes.c_str());\n                  return fSuccess;\n              }\n          }\n          MilliSleep(100);\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendMoney",
          "args": [
            "scriptPubKey",
            "nValue",
            "wtxNew",
            "fAskFee"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptPubKey.SetDestination",
          "args": [
            "address"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "SetDestination",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "2011-2014",
          "snippet": "void CScript::SetDestination(const CTxDestination& dest)\n{\n    boost::apply_visitor(CScriptVisitor(this), dest);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetDestination(const CTxDestination& dest)\n  {\n      boost::apply_visitor(CScriptVisitor(this), dest);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Insufficient funds\""
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBalance",
          "args": [],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CommitTransaction",
          "args": [
            "wtxNew",
            "reservekey"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiInterface.ThreadSafeAskFee",
          "args": [
            "nFeeRequired",
            "_(\"Sending...\")"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSafeAskFee",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "58-71",
          "snippet": "static bool ThreadSafeAskFee(int64_t nFeeRequired, const std::string& strCaption)\n{\n    if(!guiref)\n        return false;\n    if(nFeeRequired < MIN_TX_FEE || nFeeRequired <= nTransactionFee || fDaemon)\n        return true;\n    bool payFee = false;\n\n    QMetaObject::invokeMethod(guiref, \"askFee\", GUIUtil::blockingGUIThreadConnection(),\n                               Q_ARG(qint64, nFeeRequired),\n                               Q_ARG(bool*, &payFee));\n\n    return payFee;\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BitcoinGUI *guiref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic BitcoinGUI *guiref;\n\nstatic bool ThreadSafeAskFee(int64_t nFeeRequired, const std::string& strCaption)\n{\n    if(!guiref)\n        return false;\n    if(nFeeRequired < MIN_TX_FEE || nFeeRequired <= nTransactionFee || fDaemon)\n        return true;\n    bool payFee = false;\n\n    QMetaObject::invokeMethod(guiref, \"askFee\", GUIUtil::blockingGUIThreadConnection(),\n                               Q_ARG(qint64, nFeeRequired),\n                               Q_ARG(bool*, &payFee));\n\n    return payFee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strError.c_str",
          "args": [],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "nFeeRequired"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBalance",
          "args": [],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTransaction",
          "args": [
            "scriptPubKey",
            "nValue",
            "wtxNew",
            "reservekey",
            "nFeeRequired"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strError.c_str",
          "args": [],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strError.c_str",
          "args": [],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxNew.RelayWalletTransaction",
          "args": [],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CommitTransaction() : Error: Transaction not valid\\n\""
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxNew.AcceptToMemoryPool",
          "args": [],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptToMemoryPool",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "839-843",
          "snippet": "bool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMerkleTx {\n  bool CMerkleTx::AcceptToMemoryPool()\n  {\n      CTxDB txdb(\"r\");\n      return AcceptToMemoryPool(txdb);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "coin.GetHash()",
            "CT_UPDATED"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coin.BindWallet",
          "args": [
            "this"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "BindWallet",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "535-539",
          "snippet": "void BindWallet(CWallet *pwalletIn)\n    {\n        pwallet = pwalletIn;\n        MarkDirty();\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void BindWallet(CWallet *pwalletIn)\n      {\n          pwallet = pwalletIn;\n          MarkDirty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddToWallet",
          "args": [
            "wtxNew"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "AddToWallet",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "416-542",
          "snippet": "bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    {\n        LOCK(cs_wallet);\n        // Inserts only if not already there, returns tx inserted or tx found\n        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n        CWalletTx& wtx = (*ret.first).second;\n        wtx.BindWallet(this);\n        bool fInsertedNew = ret.second;\n        if (fInsertedNew)\n        {\n            wtx.nTimeReceived = GetAdjustedTime();\n            wtx.nOrderPos = IncOrderPosNext();\n\n            wtx.nTimeSmart = wtx.nTimeReceived;\n            if (wtxIn.hashBlock != 0)\n            {\n                if (mapBlockIndex.count(wtxIn.hashBlock))\n                {\n                    unsigned int latestNow = wtx.nTimeReceived;\n                    unsigned int latestEntry = 0;\n                    {\n                        // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                        int64_t latestTolerated = latestNow + 300;\n                        std::list<CAccountingEntry> acentries;\n                        TxItems txOrdered = OrderedTxItems(acentries);\n                        for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                        {\n                            CWalletTx *const pwtx = (*it).second.first;\n                            if (pwtx == &wtx)\n                                continue;\n                            CAccountingEntry *const pacentry = (*it).second.second;\n                            int64_t nSmartTime;\n                            if (pwtx)\n                            {\n                                nSmartTime = pwtx->nTimeSmart;\n                                if (!nSmartTime)\n                                    nSmartTime = pwtx->nTimeReceived;\n                            }\n                            else\n                                nSmartTime = pacentry->nTime;\n                            if (nSmartTime <= latestTolerated)\n                            {\n                                latestEntry = nSmartTime;\n                                if (nSmartTime > latestNow)\n                                    latestNow = nSmartTime;\n                                break;\n                            }\n                        }\n                    }\n\n                    unsigned int& blocktime = mapBlockIndex[wtxIn.hashBlock]->nTime;\n                    wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                }\n                else\n                    printf(\"AddToWallet() : found %s in block %s not in index\\n\",\n                           wtxIn.GetHash().ToString().substr(0,10).c_str(),\n                           wtxIn.hashBlock.ToString().c_str());\n            }\n        }\n\n        bool fUpdated = false;\n        if (!fInsertedNew)\n        {\n            // Merge\n            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n            {\n                wtx.hashBlock = wtxIn.hashBlock;\n                fUpdated = true;\n            }\n            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n            {\n                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                wtx.nIndex = wtxIn.nIndex;\n                fUpdated = true;\n            }\n            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n            {\n                wtx.fFromMe = wtxIn.fFromMe;\n                fUpdated = true;\n            }\n            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n        }\n\n        //// debug print\n        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n        // Write to disk\n        if (fInsertedNew || fUpdated)\n            if (!wtx.WriteToDisk())\n                return false;\n#ifndef QT_GUI\n        // If default receiving address gets used, replace it with a new one\n        CScript scriptDefaultKey;\n        scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n        {\n            if (txout.scriptPubKey == scriptDefaultKey)\n            {\n                CPubKey newDefaultKey;\n                if (GetKeyFromPool(newDefaultKey, false))\n                {\n                    SetDefaultKey(newDefaultKey);\n                    SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                }\n            }\n        }\n#endif\n        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n        WalletUpdateSpent(wtx, (wtxIn.hashBlock != 0));\n\n        // Notify UI of new or updated transaction\n        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n\n        // notify an external script when a wallet transaction comes in or is updated\n        std::string strCmd = GetArg(\"-walletnotify\", \"\");\n\n        if ( !strCmd.empty())\n        {\n            boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n            boost::thread t(runCommand, strCmd); // thread runs free\n        }\n\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n  {\n      uint256 hash = wtxIn.GetHash();\n      {\n          LOCK(cs_wallet);\n          // Inserts only if not already there, returns tx inserted or tx found\n          pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n          CWalletTx& wtx = (*ret.first).second;\n          wtx.BindWallet(this);\n          bool fInsertedNew = ret.second;\n          if (fInsertedNew)\n          {\n              wtx.nTimeReceived = GetAdjustedTime();\n              wtx.nOrderPos = IncOrderPosNext();\n  \n              wtx.nTimeSmart = wtx.nTimeReceived;\n              if (wtxIn.hashBlock != 0)\n              {\n                  if (mapBlockIndex.count(wtxIn.hashBlock))\n                  {\n                      unsigned int latestNow = wtx.nTimeReceived;\n                      unsigned int latestEntry = 0;\n                      {\n                          // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                          int64_t latestTolerated = latestNow + 300;\n                          std::list<CAccountingEntry> acentries;\n                          TxItems txOrdered = OrderedTxItems(acentries);\n                          for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                          {\n                              CWalletTx *const pwtx = (*it).second.first;\n                              if (pwtx == &wtx)\n                                  continue;\n                              CAccountingEntry *const pacentry = (*it).second.second;\n                              int64_t nSmartTime;\n                              if (pwtx)\n                              {\n                                  nSmartTime = pwtx->nTimeSmart;\n                                  if (!nSmartTime)\n                                      nSmartTime = pwtx->nTimeReceived;\n                              }\n                              else\n                                  nSmartTime = pacentry->nTime;\n                              if (nSmartTime <= latestTolerated)\n                              {\n                                  latestEntry = nSmartTime;\n                                  if (nSmartTime > latestNow)\n                                      latestNow = nSmartTime;\n                                  break;\n                              }\n                          }\n                      }\n  \n                      unsigned int& blocktime = mapBlockIndex[wtxIn.hashBlock]->nTime;\n                      wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                  }\n                  else\n                      printf(\"AddToWallet() : found %s in block %s not in index\\n\",\n                             wtxIn.GetHash().ToString().substr(0,10).c_str(),\n                             wtxIn.hashBlock.ToString().c_str());\n              }\n          }\n  \n          bool fUpdated = false;\n          if (!fInsertedNew)\n          {\n              // Merge\n              if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n              {\n                  wtx.hashBlock = wtxIn.hashBlock;\n                  fUpdated = true;\n              }\n              if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n              {\n                  wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                  wtx.nIndex = wtxIn.nIndex;\n                  fUpdated = true;\n              }\n              if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n              {\n                  wtx.fFromMe = wtxIn.fFromMe;\n                  fUpdated = true;\n              }\n              fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n          }\n  \n          //// debug print\n          printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n  \n          // Write to disk\n          if (fInsertedNew || fUpdated)\n              if (!wtx.WriteToDisk())\n                  return false;\n  #ifndef QT_GUI\n          // If default receiving address gets used, replace it with a new one\n          CScript scriptDefaultKey;\n          scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n          BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n          {\n              if (txout.scriptPubKey == scriptDefaultKey)\n              {\n                  CPubKey newDefaultKey;\n                  if (GetKeyFromPool(newDefaultKey, false))\n                  {\n                      SetDefaultKey(newDefaultKey);\n                      SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                  }\n              }\n          }\n  #endif\n          // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n          WalletUpdateSpent(wtx, (wtxIn.hashBlock != 0));\n  \n          // Notify UI of new or updated transaction\n          NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n  \n          // notify an external script when a wallet transaction comes in or is updated\n          std::string strCmd = GetArg(\"-walletnotify\", \"\");\n  \n          if ( !strCmd.empty())\n          {\n              boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n              boost::thread t(runCommand, strCmd); // thread runs free\n          }\n  \n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reservekey.KeepKey",
          "args": [],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::GetSerializeSize",
          "args": [
            "txNew",
            "SER_NETWORK",
            "PROTOCOL_VERSION"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "632-638",
          "snippet": "unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignSignature",
          "args": [
            "*this",
            "*pcoin",
            "txNew",
            "nIn++"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProofOfStakeReward",
          "args": [
            "pindexBest->nHeight + 1",
            "nCoinAge",
            "nFees"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfStakeReward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1005-1029",
          "snippet": "int64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txNew.GetCoinAge",
          "args": [
            "txdb",
            "nCoinAge"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "GetCoinAge",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1962-2001",
          "snippet": "bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint nStakeMinAge = 60 * 60 * 12;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nuint nStakeMinAge = 60 * 60 * 12;\n\nCTransaction {\n  bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n  {\n      CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n      nCoinAge = 0;\n  \n      if (IsCoinBase())\n          return true;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // First try finding the previous transaction in database\n          CTransaction txPrev;\n          CTxIndex txindex;\n          if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n              continue;  // previous transaction not in main chain\n          if (nTime < txPrev.nTime)\n              return false;  // Transaction timestamp violation\n  \n          // Read block header\n          CBlock block;\n          if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n              return false; // unable to read block of previous transaction\n          if (block.GetBlockTime() + nStakeMinAge > nTime)\n              continue; // only count coins meeting min age requirement\n  \n          int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n          bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n  \n          if(fDebug && GetBoolArg(\"-printcoinage\"))\n            printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n              nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n      }\n  \n      CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n      nCoinAge = bnCoinDay.getuint64();\n      if(fDebug && GetBoolArg(\"-printcoinage\"))\n        printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n  \n      return(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vwtxPrev.push_back",
          "args": [
            "pcoin.first"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txNew.vin.push_back",
          "args": [
            "CTxIn(pcoin.first->GetHash(), pcoin.second)"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTxIn",
          "args": [
            "pcoin.first->GetHash()",
            "pcoin.second"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "CTxIndex",
          "container": "CTxIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "790-794",
          "snippet": "CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n    {\n        pos = posIn;\n        vSpent.resize(nOutputs);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxIndex {\n  CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n      {\n          pos = posIn;\n          vSpent.resize(nOutputs);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetWeight",
          "args": [
            "(int64)pcoin.first->nTime",
            "(int64)txNew.nTime"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "GetWeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "38-46",
          "snippet": "int64_t GetWeight(int64_t nIntervalBegin, int64_t nIntervalEnd) {\n    uint nStakeMaxAge = GetStakeMaxAge(nIntervalEnd);\n\n    int64_t nTimeWeight = nIntervalEnd - nIntervalBegin - nStakeMinAge;\n    if(nTimeWeight > (int64)nStakeMaxAge)\n      nTimeWeight = (int64)nStakeMaxAge;\n\n    return(nTimeWeight);\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nint64_t GetWeight(int64_t nIntervalBegin, int64_t nIntervalEnd) {\n    uint nStakeMaxAge = GetStakeMaxAge(nIntervalEnd);\n\n    int64_t nTimeWeight = nIntervalEnd - nIntervalBegin - nStakeMinAge;\n    if(nTimeWeight > (int64)nStakeMaxAge)\n      nTimeWeight = (int64)nStakeMaxAge;\n\n    return(nTimeWeight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txNew.vout.push_back",
          "args": [
            "CTxOut(0, scriptPubKeyOut)"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTxOut",
          "args": [
            "0",
            "scriptPubKeyOut"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "CTxOut",
          "container": "CTxOut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "358-362",
          "snippet": "CTxOut(int64_t nValueIn, CScript scriptPubKeyIn)\n    {\n        nValue = nValueIn;\n        scriptPubKey = scriptPubKeyIn;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxOut {\n  CTxOut(int64_t nValueIn, CScript scriptPubKeyIn)\n      {\n          nValue = nValueIn;\n          scriptPubKey = scriptPubKeyIn;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.GetBlockTime",
          "args": [],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txNew.vout.push_back",
          "args": [
            "CTxOut(0, scriptPubKeyOut)"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vwtxPrev.push_back",
          "args": [
            "pcoin.first"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txNew.vin.push_back",
          "args": [
            "CTxIn(pcoin.first->GetHash(), pcoin.second)"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keystore.GetKey",
          "args": [
            "Hash160(vchPubKey)",
            "key"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "GetKey",
          "container": "CBasicKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "81-94",
          "snippet": "bool GetKey(const CKeyID &address, CKey &keyOut) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            KeyMap::const_iterator mi = mapKeys.find(address);\n            if (mi != mapKeys.end())\n            {\n                keyOut.Reset();\n                keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n                return true;\n            }\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCBasicKeyStore {\n  bool GetKey(const CKeyID &address, CKey &keyOut) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              KeyMap::const_iterator mi = mapKeys.find(address);\n              if (mi != mapKeys.end())\n              {\n                  keyOut.Reset();\n                  keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n                  return true;\n              }\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash160",
          "args": [
            "vchPubKey"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "Hash160",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "554-561",
          "snippet": "inline uint160 Hash160(const std::vector<unsigned char>& vch)\n{\n    uint256 hash1;\n    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n    uint160 hash2;\n    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n    return hash2;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline uint160 Hash160(const std::vector<unsigned char>& vch)\n{\n    uint256 hash1;\n    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n    uint160 hash2;\n    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n    return hash2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint160",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "uint160",
          "container": "uint160",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "450-456",
          "snippet": "explicit uint160(const std::vector<unsigned char>& vch)\n    {\n        if (vch.size() == sizeof(pn))\n            memcpy(pn, &vch[0], sizeof(pn));\n        else\n            *this = 0;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nuint160 {\n  explicit uint160(const std::vector<unsigned char>& vch)\n      {\n          if (vch.size() == sizeof(pn))\n              memcpy(pn, &vch[0], sizeof(pn));\n          else\n              *this = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CreateCoinStake : failed to parse kernel\\n\""
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKeyKernel",
            "whichType",
            "vSolutions"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CreateCoinStake : kernel found\\n\""
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinstake\""
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckStakeKernelHash",
          "args": [
            "nBits",
            "block",
            "txindex.pos.nTxPos - txindex.pos.nBlockPos",
            "*pcoin.first",
            "prevoutStake",
            "txNew.nTime - n",
            "hashProofOfStake",
            "targetProofOfStake"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COutPoint",
          "args": [
            "pcoin.first->GetHash()",
            "pcoin.second"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "COutPoint",
          "container": "COutPoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "227-227",
          "snippet": "COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCOutPoint {\n  COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nSearchInterval",
            "(int64_t)nMaxStakeSearchInterval"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "txindex.pos.nFile",
            "txindex.pos.nBlockPos",
            "false"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SelectCoinsSimple",
          "args": [
            "nBalance - nReserveBalance",
            "txNew.nTime",
            "nCoinbaseMaturity + 10",
            "setCoins",
            "nValueIn"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBalance",
          "args": [],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txNew.vout.push_back",
          "args": [
            "CTxOut(0, scriptEmpty)"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnTargetPerCoinDay.SetCompact",
          "args": [
            "nBits"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetStakeMaxAge",
          "args": [
            "GetTime()"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeMaxAge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "28-34",
          "snippet": "uint GetStakeMaxAge(uint nStakeTime) {\n\n    if(nStakeTime > nStakeMaxAgeForkTime)\n      return(nStakeMaxAgeTwo);\n    else\n      return(nStakeMaxAgeOne);\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nuint GetStakeMaxAge(uint nStakeTime) {\n\n    if(nStakeTime > nStakeMaxAgeForkTime)\n      return(nStakeMaxAgeTwo);\n    else\n      return(nStakeMaxAgeOne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bnCoinDayWeight.getuint64",
          "args": [],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "getuint64",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "208-221",
          "snippet": "uint64_t getuint64()\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        if (nSize < 4)\n            return 0;\n        std::vector<unsigned char> vch(nSize);\n        BN_bn2mpi(this, &vch[0]);\n        if (vch.size() > 4)\n            vch[4] &= 0x7f;\n        uint64_t n = 0;\n        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n            ((unsigned char*)&n)[i] = vch[j];\n        return n;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  uint64_t getuint64()\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          if (nSize < 4)\n              return 0;\n          std::vector<unsigned char> vch(nSize);\n          BN_bn2mpi(this, &vch[0]);\n          if (vch.size() > 4)\n              vch[4] &= 0x7f;\n          uint64_t n = 0;\n          for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n              ((unsigned char*)&n)[i] = vch[j];\n          return n;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "pcoin.first->vout[pcoin.second].nValue"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SelectCoinsSimple",
          "args": [
            "nBalance - nReserveBalance",
            "GetTime()",
            "nCoinbaseMaturity + 10",
            "setCoins",
            "nValueIn"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBalance",
          "args": [],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTransaction",
          "args": [
            "vecSend",
            "wtxNew",
            "reservekey",
            "nFeeRet",
            "coinControl"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vecSend.push_back",
          "args": [
            "make_pair(scriptPubKey, nValue)"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "scriptPubKey",
            "nValue"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxNew.AddSupportingTransactions",
          "args": [
            "txdb"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "AddSupportingTransactions",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "770-828",
          "snippet": "void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n{\n    vtxPrev.clear();\n\n    const int COPY_DEPTH = 3;\n    if (SetMerkleBranch() < COPY_DEPTH)\n    {\n        vector<uint256> vWorkQueue;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            vWorkQueue.push_back(txin.prevout.hash);\n\n        // This critsect is OK because txdb is already open\n        {\n            LOCK(pwallet->cs_wallet);\n            map<uint256, const CMerkleTx*> mapWalletPrev;\n            set<uint256> setAlreadyDone;\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hash = vWorkQueue[i];\n                if (setAlreadyDone.count(hash))\n                    continue;\n                setAlreadyDone.insert(hash);\n\n                CMerkleTx tx;\n                map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n                if (mi != pwallet->mapWallet.end())\n                {\n                    tx = (*mi).second;\n                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                }\n                else if (mapWalletPrev.count(hash))\n                {\n                    tx = *mapWalletPrev[hash];\n                }\n                else if (!fClient && txdb.ReadDiskTx(hash, tx))\n                {\n                    ;\n                }\n                else\n                {\n                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                    continue;\n                }\n\n                int nDepth = tx.SetMerkleBranch();\n                vtxPrev.push_back(tx);\n\n                if (nDepth < COPY_DEPTH)\n                {\n                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                        vWorkQueue.push_back(txin.prevout.hash);\n                }\n            }\n        }\n    }\n\n    reverse(vtxPrev.begin(), vtxPrev.end());\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n  {\n      vtxPrev.clear();\n  \n      const int COPY_DEPTH = 3;\n      if (SetMerkleBranch() < COPY_DEPTH)\n      {\n          vector<uint256> vWorkQueue;\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              vWorkQueue.push_back(txin.prevout.hash);\n  \n          // This critsect is OK because txdb is already open\n          {\n              LOCK(pwallet->cs_wallet);\n              map<uint256, const CMerkleTx*> mapWalletPrev;\n              set<uint256> setAlreadyDone;\n              for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n              {\n                  uint256 hash = vWorkQueue[i];\n                  if (setAlreadyDone.count(hash))\n                      continue;\n                  setAlreadyDone.insert(hash);\n  \n                  CMerkleTx tx;\n                  map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n                  if (mi != pwallet->mapWallet.end())\n                  {\n                      tx = (*mi).second;\n                      BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                          mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                  }\n                  else if (mapWalletPrev.count(hash))\n                  {\n                      tx = *mapWalletPrev[hash];\n                  }\n                  else if (!fClient && txdb.ReadDiskTx(hash, tx))\n                  {\n                      ;\n                  }\n                  else\n                  {\n                      printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                      continue;\n                  }\n  \n                  int nDepth = tx.SetMerkleBranch();\n                  vtxPrev.push_back(tx);\n  \n                  if (nDepth < COPY_DEPTH)\n                  {\n                      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                          vWorkQueue.push_back(txin.prevout.hash);\n                  }\n              }\n          }\n      }\n  \n      reverse(vtxPrev.begin(), vtxPrev.end());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtxNew.GetMinFee",
          "args": [
            "1",
            "GMF_SEND",
            "nBytes"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "GetMinFee",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "529-556",
          "snippet": "int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n{\n    // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n    int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n    unsigned int nNewBlockSize = nBlockSize + nBytes;\n    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n\n    // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n    if (nMinFee < nBaseFee)\n    {\n        BOOST_FOREACH(const CTxOut& txout, vout)\n            if (txout.nValue < CENT)\n                nMinFee = nBaseFee;\n    }\n\n    // Raise the price as the block approaches full\n    if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n    {\n        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n            return MAX_MONEY;\n        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n    }\n\n    if (!MoneyRange(nMinFee))\n        nMinFee = MAX_MONEY;\n    return nMinFee;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n  {\n      // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n      int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n  \n      unsigned int nNewBlockSize = nBlockSize + nBytes;\n      int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n  \n      // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n      if (nMinFee < nBaseFee)\n      {\n          BOOST_FOREACH(const CTxOut& txout, vout)\n              if (txout.nValue < CENT)\n                  nMinFee = nBaseFee;\n      }\n  \n      // Raise the price as the block approaches full\n      if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n      {\n          if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n              return MAX_MONEY;\n          nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n      }\n  \n      if (!MoneyRange(nMinFee))\n          nMinFee = MAX_MONEY;\n      return nMinFee;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignSignature",
          "args": [
            "*this",
            "*coin.first",
            "wtxNew",
            "nIn++"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxNew.vin.push_back",
          "args": [
            "CTxIn(coin.first->GetHash(),coin.second)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reservekey.ReturnKey",
          "args": [],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxNew.vout.insert",
          "args": [
            "position",
            "CTxOut(nChange, scriptChange)"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "wtxNew.vout.size()"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reservekey.GetReservedKey",
          "args": [],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::get<CNoDestination>",
          "args": [
            "&coinControl->destChange"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SelectCoins",
          "args": [
            "nTotalValue",
            "wtxNew.nTime",
            "setCoins",
            "nValueIn",
            "coinControl"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxNew.vout.push_back",
          "args": [
            "CTxOut(s.second, s.first)"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "cs_wallet"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "n",
            "make_pair(pcoin, i)"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pcoin",
            "i"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AvailableCoinsMinConf",
          "args": [
            "vCoins",
            "nMinConf"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SelectCoinsMinConf",
          "args": [
            "nTargetValue",
            "nSpendTime",
            "0",
            "1",
            "vCoins",
            "setCoinsRet",
            "nValueRet"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SelectCoinsMinConf",
          "args": [
            "nTargetValue",
            "nSpendTime",
            "1",
            "1",
            "vCoins",
            "setCoinsRet",
            "nValueRet"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SelectCoinsMinConf",
          "args": [
            "nTargetValue",
            "nSpendTime",
            "1",
            "6",
            "vCoins",
            "setCoinsRet",
            "nValueRet"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "out.tx",
            "out.i"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coinControl->HasSelected",
          "args": [],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "HasSelected",
          "container": "CCoinControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/coincontrol.h",
          "lines": "21-24",
          "snippet": "bool HasSelected() const\n    {\n        return (setSelected.size() > 0);\n    }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "CCoinControl {\n  bool HasSelected() const\n      {\n          return (setSelected.size() > 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AvailableCoins",
          "args": [
            "vCoins",
            "true",
            "coinControl"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "nBest"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "vValue[i].first"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SelectCoins() best subset: \""
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printpriority\""
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApproximateBestSubset",
          "args": [
            "vValue",
            "nTotalLower",
            "nTargetValue + CENT",
            "vfBest",
            "nBest",
            "1000"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ApproximateBestSubset",
          "args": [
            "vValue",
            "nTotalLower",
            "nTargetValue",
            "vfBest",
            "nBest",
            "1000"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "vValue.rbegin()",
            "vValue.rend()",
            "CompareValueOnly()"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CompareValueOnly",
          "args": [],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vValue.rend",
          "args": [],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vValue.rbegin",
          "args": [],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vValue.push_back",
          "args": [
            "coin"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "n",
            "make_pair(pcoin, i)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pcoin",
            "i"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random_shuffle",
          "args": [
            "vCoins.begin()",
            "vCoins.end()",
            "GetRandInt"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int64_t>::max",
          "args": [],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CWallet::GetCredit",
          "args": [
            "*pcoin"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "GetCredit",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "252-262",
          "snippet": "int64_t GetCredit(const CTransaction& tx) const\n    {\n        int64_t nCredit = 0;\n        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n        {\n            nCredit += GetCredit(txout);\n            if (!MoneyRange(nCredit))\n                throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n        }\n        return nCredit;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  int64_t GetCredit(const CTransaction& tx) const\n      {\n          int64_t nCredit = 0;\n          BOOST_FOREACH(const CTxOut& txout, tx.vout)\n          {\n              nCredit += GetCredit(txout);\n              if (!MoneyRange(nCredit))\n                  throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n          }\n          return nCredit;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfIncluded.assign",
          "args": [
            "vValue.size()",
            "false"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfBest.assign",
          "args": [
            "vValue.size()",
            "true"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vCoins.push_back",
          "args": [
            "COutput(pcoin, i, pcoin->GetDepthInMainChain())"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COutput",
          "args": [
            "pcoin",
            "i",
            "pcoin->GetDepthInMainChain()"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "COutput",
          "container": "COutput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "720-723",
          "snippet": "COutput(const CWalletTx *txIn, int iIn, int nDepthIn)\n    {\n        tx = txIn; i = iIn; nDepth = nDepthIn;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCOutput {\n  COutput(const CWalletTx *txIn, int iIn, int nDepthIn)\n      {\n          tx = txIn; i = iIn; nDepth = nDepthIn;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vCoins.push_back",
          "args": [
            "COutput(pcoin, i, nDepth)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coinControl->IsSelected",
          "args": [
            "(*it).first",
            "i"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "IsSelected",
          "container": "CCoinControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/coincontrol.h",
          "lines": "26-30",
          "snippet": "bool IsSelected(const uint256& hash, unsigned int n) const\n    {\n        COutPoint outpt(hash, n);\n        return (setSelected.count(outpt) > 0);\n    }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "CCoinControl {\n  bool IsSelected(const uint256& hash, unsigned int n) const\n      {\n          COutPoint outpt(hash, n);\n          return (setSelected.count(outpt) > 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcoin->GetAvailableCredit",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "GetAvailableCredit",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "599-623",
          "snippet": "int64_t GetAvailableCredit(bool fUseCache=true) const\n    {\n        // Must wait until coinbase is safely deep enough in the chain before valuing it\n        if ((IsCoinBase() || IsCoinStake()) && GetBlocksToMaturity() > 0)\n            return 0;\n\n        if (fUseCache && fAvailableCreditCached)\n            return nAvailableCreditCached;\n\n        int64_t nCredit = 0;\n        for (unsigned int i = 0; i < vout.size(); i++)\n        {\n            if (!IsSpent(i))\n            {\n                const CTxOut &txout = vout[i];\n                nCredit += pwallet->GetCredit(txout);\n                if (!MoneyRange(nCredit))\n                    throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n            }\n        }\n\n        nAvailableCreditCached = nCredit;\n        fAvailableCreditCached = true;\n        return nCredit;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  int64_t GetAvailableCredit(bool fUseCache=true) const\n      {\n          // Must wait until coinbase is safely deep enough in the chain before valuing it\n          if ((IsCoinBase() || IsCoinStake()) && GetBlocksToMaturity() > 0)\n              return 0;\n  \n          if (fUseCache && fAvailableCreditCached)\n              return nAvailableCreditCached;\n  \n          int64_t nCredit = 0;\n          for (unsigned int i = 0; i < vout.size(); i++)\n          {\n              if (!IsSpent(i))\n              {\n                  const CTxOut &txout = vout[i];\n                  nCredit += pwallet->GetCredit(txout);\n                  if (!MoneyRange(nCredit))\n                      throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n              }\n          }\n  \n          nAvailableCreditCached = nCredit;\n          fAvailableCreditCached = true;\n          return nCredit;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.RelayWalletTransaction",
          "args": [
            "txdb"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.CheckTransaction",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "CheckTransaction",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "478-527",
          "snippet": "bool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::CheckTransaction() const\n  {\n      // Basic checks that don't depend on any context\n      if (vin.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n      if (vout.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n      // Size limits\n      if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n  \n      // Check for negative or overflow output values\n      int64_t nValueOut = 0;\n      for (unsigned int i = 0; i < vout.size(); i++)\n      {\n          const CTxOut& txout = vout[i];\n          if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n          if (txout.nValue < 0)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n          if (txout.nValue > MAX_MONEY)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n          nValueOut += txout.nValue;\n          if (!MoneyRange(nValueOut))\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n      }\n  \n      // Check for duplicate inputs\n      set<COutPoint> vInOutPoints;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          if (vInOutPoints.count(txin.prevout))\n              return false;\n          vInOutPoints.insert(txin.prevout);\n      }\n  \n      if (IsCoinBase())\n      {\n          if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n      }\n      else\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (txin.prevout.IsNull())\n                  return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "wtx.nTimeReceived",
            "&wtx"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ResendWalletTransactions()\\n\""
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelayWalletTransaction",
          "args": [
            "txdb"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelayTransaction",
          "args": [
            "(CTransaction)*this",
            "hash"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "2004-2010",
          "snippet": "void RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [
            "0",
            "10"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ContainsTx",
          "args": [
            "hash"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "ContainsTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "230-234",
          "snippet": "bool CTxDB::ContainsTx(uint256 hash)\n{\n    assert(!fClient);\n    return Exists(make_pair(string(\"tx\"), hash));\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ContainsTx(uint256 hash)\n  {\n      assert(!fClient);\n      return Exists(make_pair(string(\"tx\"), hash));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ScanForWalletTransactions",
          "args": [
            "pindexGenesisBlock"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.AcceptWalletTransaction",
          "args": [
            "txdb"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.MarkDirty",
          "args": [],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "MarkDirty",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "407-414",
          "snippet": "void CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n            item.second.MarkDirty();\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  void CWallet::MarkDirty()\n  {\n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n              item.second.MarkDirty();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\"",
            "FormatMoney(wtx.GetCredit()).c_str()",
            "wtx.GetHash().ToString().c_str()"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "wtx.GetCredit()"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vMissingTx.push_back",
          "args": [
            "txindex.vSpent[i]"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size()"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nextern unsigned int nStakeMaxAge;\nbool fWalletUnlockStakingOnly = false;\n\nCWallet {\n  void CWallet::ReacceptWalletTransactions()\n  {\n      CTxDB txdb(\"r\");\n      bool fRepeat = true;\n      while (fRepeat)\n      {\n          LOCK(cs_wallet);\n          fRepeat = false;\n          vector<CDiskTxPos> vMissingTx;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                  continue;\n  \n              CTxIndex txindex;\n              bool fUpdated = false;\n              if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n              {\n                  // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                  if (txindex.vSpent.size() != wtx.vout.size())\n                  {\n                      printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                      continue;\n                  }\n                  for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                  {\n                      if (wtx.IsSpent(i))\n                          continue;\n                      if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                      {\n                          wtx.MarkSpent(i);\n                          fUpdated = true;\n                          vMissingTx.push_back(txindex.vSpent[i]);\n                      }\n                  }\n                  if (fUpdated)\n                  {\n                      printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                      wtx.MarkDirty();\n                      wtx.WriteToDisk();\n                  }\n              }\n              else\n              {\n                  // Re-accept any txes of ours that aren't already in a block\n                  if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                      wtx.AcceptWalletTransaction(txdb);\n              }\n          }\n          if (!vMissingTx.empty())\n          {\n              // TODO: optimize this to scan just part of the block chain?\n              if (ScanForWalletTransactions(pindexGenesisBlock))\n                  fRepeat = true;  // Found missing transactions: re-do re-accept.\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n  {\n      BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n      {\n          if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n          {\n              uint256 hash = tx.GetHash();\n              if (!txdb.ContainsTx(hash))\n                  RelayTransaction((CTransaction)tx, hash);\n          }\n      }\n      if (!(IsCoinBase() || IsCoinStake()))\n      {\n          uint256 hash = GetHash();\n          if (!txdb.ContainsTx(hash))\n          {\n              printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n              RelayTransaction((CTransaction)*this, hash);\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction()\n  {\n     CTxDB txdb(\"r\");\n     RelayWalletTransaction(txdb);\n  }\n  \n  void CWallet::ResendWalletTransactions(bool fForce)\n  {\n      if (!fForce)\n      {\n          // Do this infrequently and randomly to avoid giving away\n          // that these are our transactions.\n          static int64_t nNextTime;\n          if (GetTime() < nNextTime)\n              return;\n          bool fFirst = (nNextTime == 0);\n          nNextTime = GetTime() + GetRand(30 * 60);\n          if (fFirst)\n              return;\n  \n          // Only do it if there's been a new block since last time\n          static int64_t nLastTime;\n          if (nTimeBestReceived < nLastTime)\n              return;\n          nLastTime = GetTime();\n      }\n  \n      // Rebroadcast any of our txes that aren't in a block yet\n      printf(\"ResendWalletTransactions()\\n\");\n      CTxDB txdb(\"r\");\n      {\n          LOCK(cs_wallet);\n          // Sort them in chronological order\n          multimap<unsigned int, CWalletTx*> mapSorted;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              // Don't rebroadcast until it's had plenty of time that\n              // it should have gotten in already by now.\n              if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                  mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n          }\n          BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n          {\n              CWalletTx& wtx = *item.second;\n              if (wtx.CheckTransaction())\n                  wtx.RelayWalletTransaction(txdb);\n              else\n                  printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n          }\n      }\n  }\n  \n  \n  \n  \n  \n  \n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Actions\n  //\n  \n  \n  int64_t CWallet::GetBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n  \n      return nTotal;\n  }\n  \n  int64_t CWallet::GetUnconfirmedBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetImmatureBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx& pcoin = (*it).second;\n              if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                  nTotal += GetCredit(pcoin);\n          }\n      }\n      return nTotal;\n  }\n  \n  // populate vCoins with vector of spendable COutputs\n  void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if (fOnlyConfirmed && !pcoin->IsTrusted())\n                  continue;\n  \n              if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < 0)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                      vCoins.push_back(COutput(pcoin, i, nDepth));\n  \n          }\n      }\n  }\n  \n  void CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if(pcoin->GetDepthInMainChain() < nConf)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                      vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n          }\n      }\n  }\n  \n  static void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                    vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n  {\n      vector<char> vfIncluded;\n  \n      vfBest.assign(vValue.size(), true);\n      nBest = nTotalLower;\n  \n      for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n      {\n          vfIncluded.assign(vValue.size(), false);\n          int64_t nTotal = 0;\n          bool fReachedTarget = false;\n          for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n          {\n              for (unsigned int i = 0; i < vValue.size(); i++)\n              {\n                  if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                  {\n                      nTotal += vValue[i].first;\n                      vfIncluded[i] = true;\n                      if (nTotal >= nTargetValue)\n                      {\n                          fReachedTarget = true;\n                          if (nTotal < nBest)\n                          {\n                              nBest = nTotal;\n                              vfBest = vfIncluded;\n                          }\n                          nTotal -= vValue[i].first;\n                          vfIncluded[i] = false;\n                      }\n                  }\n              }\n          }\n      }\n  }\n  \n  // ppcoin: total coins staked (non-spendable until maturity)\n  int64_t CWallet::GetStake() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetNewMint() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  bool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      // List of values less than target\n      pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n      coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n      coinLowestLarger.second.first = NULL;\n      vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n      int64_t nTotalLower = 0;\n  \n      random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n  \n          if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n              continue;\n  \n          int i = output.i;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n == nTargetValue)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              return true;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              vValue.push_back(coin);\n              nTotalLower += n;\n          }\n          else if (n < coinLowestLarger.first)\n          {\n              coinLowestLarger = coin;\n          }\n      }\n  \n      if (nTotalLower == nTargetValue)\n      {\n          for (unsigned int i = 0; i < vValue.size(); ++i)\n          {\n              setCoinsRet.insert(vValue[i].second);\n              nValueRet += vValue[i].first;\n          }\n          return true;\n      }\n  \n      if (nTotalLower < nTargetValue)\n      {\n          if (coinLowestLarger.second.first == NULL)\n              return false;\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n          return true;\n      }\n  \n      // Solve subset sum by stochastic approximation\n      sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n      vector<char> vfBest;\n      int64_t nBest;\n  \n      ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n      if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n          ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n  \n      // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n      //                                   or the next bigger coin is closer), return the bigger coin\n      if (coinLowestLarger.second.first &&\n          ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n      {\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n      }\n      else {\n          for (unsigned int i = 0; i < vValue.size(); i++)\n              if (vfBest[i])\n              {\n                  setCoinsRet.insert(vValue[i].second);\n                  nValueRet += vValue[i].first;\n              }\n  \n          if (fDebug && GetBoolArg(\"-printpriority\"))\n          {\n              //// debug print\n              printf(\"SelectCoins() best subset: \");\n              for (unsigned int i = 0; i < vValue.size(); i++)\n                  if (vfBest[i])\n                      printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n              printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoins(vCoins, true, coinControl);\n  \n      // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n      if (coinControl && coinControl->HasSelected())\n      {\n          BOOST_FOREACH(const COutput& out, vCoins)\n          {\n              nValueRet += out.tx->vout[out.i].nValue;\n              setCoinsRet.insert(make_pair(out.tx, out.i));\n          }\n          return (nValueRet >= nTargetValue);\n      }\n  \n      return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n  }\n  \n  // Select some coins without random shuffle or best subset approximation\n  bool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoinsMinConf(vCoins, nMinConf);\n  \n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n          int i = output.i;\n  \n          // Stop if we've chosen enough inputs\n          if (nValueRet >= nTargetValue)\n              break;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n >= nTargetValue)\n          {\n              // If input value is greater or equal to target then simply insert\n              //    it into the current subset and exit\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              break;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      int64_t nValue = 0;\n      BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n      {\n          if (nValue < 0)\n              return false;\n          nValue += s.second;\n      }\n      if (vecSend.empty() || nValue < 0)\n          return false;\n  \n      wtxNew.BindWallet(this);\n  \n      {\n          LOCK2(cs_main, cs_wallet);\n          // txdb must be opened before the mapWallet lock\n          CTxDB txdb(\"r\");\n          {\n              nFeeRet = nTransactionFee;\n              while (true)\n              {\n                  wtxNew.vin.clear();\n                  wtxNew.vout.clear();\n                  wtxNew.fFromMe = true;\n  \n                  int64_t nTotalValue = nValue + nFeeRet;\n                  double dPriority = 0;\n                  // vouts to the payees\n                  BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                      wtxNew.vout.push_back(CTxOut(s.second, s.first));\n  \n                  // Choose coins to use\n                  set<pair<const CWalletTx*,unsigned int> > setCoins;\n                  int64_t nValueIn = 0;\n                  if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                      return false;\n                  BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                  {\n                      int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                      dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                  }\n  \n                  int64_t nChange = nValueIn - nValue - nFeeRet;\n                  // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                  // or until nChange becomes zero\n                  // NOTE: this depends on the exact behaviour of GetMinFee\n                  if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                  {\n                      int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                      nChange -= nMoveToFee;\n                      nFeeRet += nMoveToFee;\n                  }\n  \n                  if (nChange > 0)\n                  {\n                      // Fill a vout to ourself\n                      // TODO: pass in scriptChange instead of reservekey so\n                      // change transaction isn't always pay-to-bitcoin-address\n                      CScript scriptChange;\n  \n                      // coin control: send change to custom address\n                      if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                          scriptChange.SetDestination(coinControl->destChange);\n  \n                      // no coin control: send change to newly generated address\n                      else\n                      {\n                          // Note: We use a new key here to keep it from being obvious which side is the change.\n                          //  The drawback is that by not reusing a previous key, the change may be lost if a\n                          //  backup is restored, if the backup doesn't have the new private key for the change.\n                          //  If we reused the old key, it would be possible to add code to look for and\n                          //  rediscover unknown transactions that were written with keys of ours to recover\n                          //  post-backup change.\n  \n                          // Reserve a new key pair from key pool\n                          CPubKey vchPubKey = reservekey.GetReservedKey();\n  \n                          scriptChange.SetDestination(vchPubKey.GetID());\n                      }\n  \n                      // Insert change txn at random position:\n                      vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                      wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                  }\n                  else\n                      reservekey.ReturnKey();\n  \n                  // Fill vin\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n  \n                  // Sign\n                  int nIn = 0;\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                          return false;\n  \n                  // Limit size\n                  unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                  if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                      return false;\n                  dPriority /= nBytes;\n  \n                  // Check that enough fee is included\n                  int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                  int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n  \n                  if (nFeeRet < max(nPayFee, nMinFee))\n                  {\n                      nFeeRet = max(nPayFee, nMinFee);\n                      continue;\n                  }\n  \n                  // Fill vtxPrev by copying from previous transactions vtxPrev\n                  wtxNew.AddSupportingTransactions(txdb);\n                  wtxNew.fTimeReceivedIsTxTime = true;\n  \n                  break;\n              }\n          }\n      }\n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      vector< pair<CScript, int64_t> > vecSend;\n      vecSend.push_back(make_pair(scriptPubKey, nValue));\n      return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n  }\n  \n  // NovaCoin: get current stake weight\n  bool CWallet::GetStakeWeight(const CKeyStore& keystore,\n    uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n          CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n  \n          // Weight is greater than zero\n          if (nTimeWeight > 0)\n          {\n              nWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Weight is greater than zero, but the maximum value isn't reached yet\n          if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n          {\n              nMinWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Maximum weight was reached\n          if (nTimeWeight == nStakeMaxAge)\n          {\n              nMaxWeight += bnCoinDayWeight.getuint64();\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n    int64_t nFees, CTransaction& txNew, CKey& key) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      /* Don't split inputs above this age */\n      const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n      /* Time limit for searching a single input */\n      const uint nMaxStakeSearchInterval = 60;\n  \n      CBlockIndex* pindexPrev = pindexBest;\n  \n      CBigNum bnTargetPerCoinDay;\n      bnTargetPerCoinDay.SetCompact(nBits);\n  \n      txNew.vin.clear();\n      txNew.vout.clear();\n  \n      // Mark coin stake transaction\n      CScript scriptEmpty;\n      scriptEmpty.clear();\n      txNew.vout.push_back(CTxOut(0, scriptEmpty));\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      // Select coins with suitable depth\n      if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      int64_t nCredit = 0;\n      CScript scriptPubKeyKernel;\n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          // Read block header\n          CBlock block;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                  continue;\n          }\n  \n          if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n              continue; // only count coins meeting min age requirement\n  \n          bool fKernelFound = false;\n          for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n          {\n              // Search backward in time from the given txNew timestamp \n              // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n              uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n              COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n              if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n              {\n                  // Found a kernel\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : kernel found\\n\");\n                  vector<valtype> vSolutions;\n                  txnouttype whichType;\n                  CScript scriptPubKeyOut;\n                  scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                  if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                      break;\n                  }\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                  if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                      break;  // only support pay to public key and pay to address\n                  }\n                  if (whichType == TX_PUBKEYHASH) // pay to address type\n                  {\n                      // convert to pay to public key type\n                      if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n                      scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                  }\n                  if (whichType == TX_PUBKEY)\n                  {\n                      valtype& vchPubKey = vSolutions[0];\n                      if (!keystore.GetKey(Hash160(vchPubKey), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n  \n                  if (key.GetPubKey() != vchPubKey)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                          break; // keys mismatch\n                      }\n  \n                      scriptPubKeyOut = scriptPubKeyKernel;\n                  }\n  \n                  txNew.nTime -= n;\n                  txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                  nCredit += pcoin.first->vout[pcoin.second].nValue;\n                  vwtxPrev.push_back(pcoin.first);\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  /* Split large inputs into two near halves;\n                   * exact amounts to be defined after reward processing */\n                  if((nCredit >= nSplitThreshold) &&\n                    (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                    txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                  fKernelFound = true;\n                  break;\n              }\n          }\n  \n          if (fKernelFound || fShutdown)\n              break; // if kernel is found stop searching\n      }\n  \n      /* At this point, stake amount must be positive and within the stake limit if defined */\n      if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n        return(false);\n  \n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n  \n          /* Make a larger stake by inserting additional inputs\n           * of the same public key (address) as the generating input */\n          if((txNew.vout.size() == 2) &&\n            (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n            (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n            (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n              int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n  \n              /* Do not add too many inputs */\n              if(txNew.vin.size() >= 10)\n                break;\n              /* Do not add any inputs if reached or exceeded the threshold already */\n              if(nCredit >= nCombineThreshold)\n                break;\n              /* Do not add a new input exceeding the stake limit if defined */\n              if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n                break;\n              /* Do not add any large inputs capable of stake generation on their own */\n              if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n                continue;\n              /* Do not add any inputs under the min. age */\n              if(nTimeWeight < nStakeMinAge)\n                continue;\n  \n              txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n              nCredit += pcoin.first->vout[pcoin.second].nValue;\n              vwtxPrev.push_back(pcoin.first);\n          }\n  \n      }\n  \n      // Calculate coin age reward\n      {\n          uint64_t nCoinAge;\n          CTxDB txdb(\"r\");\n          if (!txNew.GetCoinAge(txdb, nCoinAge))\n              return error(\"CreateCoinStake : failed to calculate coin age\");\n  \n          int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n          if (nReward <= 0)\n              return false;\n  \n          nCredit += nReward;\n      }\n  \n      // Set output amount\n      if (txNew.vout.size() == 3)\n      {\n          txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n          txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n      }\n      else\n          txNew.vout[1].nValue = nCredit;\n  \n      // Sign\n      int nIn = 0;\n      BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n      {\n          if (!SignSignature(*this, *pcoin, txNew, nIn++))\n              return error(\"CreateCoinStake : failed to sign coinstake\");\n      }\n  \n      // Limit size\n      unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n      if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n          return error(\"CreateCoinStake : exceeded coinstake size limit\");\n  \n      // Successfully generated coinstake\n      return true;\n  }\n  \n  \n  // Call after CreateTransaction unless you want to abort\n  bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n          {\n              // This is only to keep the database open to defeat the auto-flush for the\n              // duration of this scope.  This is the only place where this optimization\n              // maybe makes sense; please don't do it anywhere else.\n              CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n  \n              // Take key pair from key pool so it won't be used again\n              reservekey.KeepKey();\n  \n              // Add tx to wallet, because if it has change it's also ours,\n              // otherwise just for transaction history.\n              AddToWallet(wtxNew);\n  \n              // Mark old coins as spent\n              set<CWalletTx*> setCoins;\n              BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n              {\n                  CWalletTx &coin = mapWallet[txin.prevout.hash];\n                  coin.BindWallet(this);\n                  coin.MarkSpent(txin.prevout.n);\n                  coin.WriteToDisk();\n                  NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n              }\n  \n              if (fFileBacked)\n                  delete pwalletdb;\n          }\n  \n          // Track how many getdata requests our transaction gets\n          mapRequestCount[wtxNew.GetHash()] = 0;\n  \n          // Broadcast\n          if (!wtxNew.AcceptToMemoryPool())\n          {\n              // This must not fail. The transaction has already been signed and recorded.\n              printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n              return false;\n          }\n          wtxNew.RelayWalletTransaction();\n      }\n      return true;\n  }\n  \n  \n  \n  \n  string CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      CReserveKey reservekey(this);\n      int64_t nFeeRequired;\n  \n      if (IsLocked())\n      {\n          string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (fWalletUnlockStakingOnly)\n      {\n          string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n      {\n          string strError;\n          if (nValue + nFeeRequired > GetBalance())\n              strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n          else\n              strError = _(\"Error: Transaction creation failed  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n  \n      if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n          return \"ABORTED\";\n  \n      if (!CommitTransaction(wtxNew, reservekey))\n          return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n  \n      return \"\";\n  }\n  \n  \n  \n  string CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      // Check amount\n      if (nValue <= 0)\n          return _(\"Invalid amount\");\n      if (nValue + nTransactionFee > GetBalance())\n          return _(\"Insufficient funds\");\n  \n      // Parse Bitcoin address\n      CScript scriptPubKey;\n      scriptPubKey.SetDestination(address);\n  \n      return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n  }\n  \n  \n  \n  \n  DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n  {\n      if (!fFileBacked)\n          return DB_LOAD_OK;\n      fFirstRunRet = false;\n      DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n      if (nLoadWalletRet == DB_NEED_REWRITE)\n      {\n          if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n          {\n              setKeyPool.clear();\n              // Note: can't top-up keypool here, because wallet is locked.\n              // User will be prompted to unlock wallet the next operation\n              // the requires a new key.\n          }\n      }\n  \n      if (nLoadWalletRet != DB_LOAD_OK)\n          return nLoadWalletRet;\n      fFirstRunRet = !vchDefaultKey.IsValid();\n  \n      NewThread(ThreadFlushWalletDB, &strWalletFile);\n      return DB_LOAD_OK;\n  }\n  \n  \n  bool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n  {\n      std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n      mapAddressBook[address] = strName;\n      NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n  }\n  \n  bool CWallet::DelAddressBookName(const CTxDestination& address)\n  {\n      mapAddressBook.erase(address);\n      NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n  }\n  \n  \n  void CWallet::PrintWallet(const CBlock& block)\n  {\n      {\n          LOCK(cs_wallet);\n          if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n              printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n          }\n          if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n              printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n           }\n  \n      }\n      printf(\"\\n\");\n  }\n  \n  bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n          {\n              wtx = (*mi).second;\n              return true;\n          }\n      }\n      return false;\n  }\n  \n  bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n  {\n      if (fFileBacked)\n      {\n          if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n              return false;\n      }\n      vchDefaultKey = vchPubKey;\n      return true;\n  }\n  \n  bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n  {\n      if (!pwallet->fFileBacked)\n          return false;\n      strWalletFileOut = pwallet->strWalletFile;\n      return true;\n  }\n  \n  //\n  // Mark old keypool keys as used,\n  // and generate all new keys\n  //\n  bool CWallet::NewKeyPool()\n  {\n      {\n          LOCK(cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n          BOOST_FOREACH(int64_t nIndex, setKeyPool)\n              walletdb.ErasePool(nIndex);\n          setKeyPool.clear();\n  \n          if (IsLocked())\n              return false;\n  \n          int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n          for (int i = 0; i < nKeys; i++)\n          {\n              int64_t nIndex = i+1;\n              walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n              setKeyPool.insert(nIndex);\n          }\n          printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n      }\n      return true;\n  }\n  \n  bool CWallet::TopUpKeyPool(unsigned int nSize)\n  {\n      {\n          LOCK(cs_wallet);\n  \n          if (IsLocked())\n              return false;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          // Top up key pool\n          unsigned int nTargetSize;\n          if (nSize > 0)\n              nTargetSize = nSize;\n          else\n              nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n  \n          while (setKeyPool.size() < (nTargetSize + 1))\n          {\n              int64_t nEnd = 1;\n              if (!setKeyPool.empty())\n                  nEnd = *(--setKeyPool.end()) + 1;\n              if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                  throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n              setKeyPool.insert(nEnd);\n              printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n          }\n      }\n      return true;\n  }\n  \n  void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n  {\n      nIndex = -1;\n      keypool.vchPubKey = CPubKey();\n      {\n          LOCK(cs_wallet);\n  \n          if (!IsLocked())\n              TopUpKeyPool();\n  \n          // Get the oldest key\n          if(setKeyPool.empty())\n              return;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          nIndex = *(setKeyPool.begin());\n          setKeyPool.erase(setKeyPool.begin());\n          if (!walletdb.ReadPool(nIndex, keypool))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n          if (!HaveKey(keypool.vchPubKey.GetID()))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n          assert(keypool.vchPubKey.IsValid());\n          if (fDebug && GetBoolArg(\"-printkeypool\"))\n              printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n      }\n  }\n  \n  int64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n  \n          int64_t nIndex = 1 + *(--setKeyPool.end());\n          if (!walletdb.WritePool(nIndex, keypool))\n              throw runtime_error(\"AddReserveKey() : writing added key failed\");\n          setKeyPool.insert(nIndex);\n          return nIndex;\n      }\n      return -1;\n  }\n  \n  void CWallet::KeepKey(int64_t nIndex)\n  {\n      // Remove from key pool\n      if (fFileBacked)\n      {\n          CWalletDB walletdb(strWalletFile);\n          walletdb.ErasePool(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n  }\n  \n  void CWallet::ReturnKey(int64_t nIndex)\n  {\n      // Return to key pool\n      {\n          LOCK(cs_wallet);\n          setKeyPool.insert(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n  }\n  \n  bool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      {\n          LOCK(cs_wallet);\n          ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex == -1)\n          {\n              if (fAllowReuse && vchDefaultKey.IsValid())\n              {\n                  result = vchDefaultKey;\n                  return true;\n              }\n              if (IsLocked()) return false;\n              result = GenerateNewKey();\n              return true;\n          }\n          KeepKey(nIndex);\n          result = keypool.vchPubKey;\n      }\n      return true;\n  }\n  \n  int64_t CWallet::GetOldestKeyPoolTime()\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      ReserveKeyFromKeyPool(nIndex, keypool);\n      if (nIndex == -1)\n          return GetTime();\n      ReturnKey(nIndex);\n      return keypool.nTime;\n  }\n  \n  std::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n  {\n      map<CTxDestination, int64_t> balances;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n          {\n              CWalletTx *pcoin = &walletEntry.second;\n  \n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  continue;\n  \n              if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              {\n                  CTxDestination addr;\n                  if (!IsMine(pcoin->vout[i]))\n                      continue;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                      continue;\n  \n                  int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n  \n                  if (!balances.count(addr))\n                      balances[addr] = 0;\n                  balances[addr] += n;\n              }\n          }\n      }\n  \n      return balances;\n  }\n  \n  set< set<CTxDestination> > CWallet::GetAddressGroupings()\n  {\n      set< set<CTxDestination> > groupings;\n      set<CTxDestination> grouping;\n  \n      BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n      {\n          CWalletTx *pcoin = &walletEntry.second;\n  \n          if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n          {\n              // group all input addresses with each other\n              BOOST_FOREACH(CTxIn txin, pcoin->vin)\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n              }\n  \n              // group change with input addresses\n              BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                  if (IsChange(txout))\n                  {\n                      CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                      CTxDestination txoutAddr;\n                      if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                          continue;\n                      grouping.insert(txoutAddr);\n                  }\n              groupings.insert(grouping);\n              grouping.clear();\n          }\n  \n          // group lone addrs by themselves\n          for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              if (IsMine(pcoin->vout[i]))\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n                  groupings.insert(grouping);\n                  grouping.clear();\n              }\n      }\n  \n      set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n      map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n      BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n      {\n          // make a set of all the groups hit by this new group\n          set< set<CTxDestination>* > hits;\n          map< CTxDestination, set<CTxDestination>* >::iterator it;\n          BOOST_FOREACH(CTxDestination address, grouping)\n              if ((it = setmap.find(address)) != setmap.end())\n                  hits.insert((*it).second);\n  \n          // merge all hit groups into a new single group and delete old groups\n          set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n          BOOST_FOREACH(set<CTxDestination>* hit, hits)\n          {\n              merged->insert(hit->begin(), hit->end());\n              uniqueGroupings.erase(hit);\n              delete hit;\n          }\n          uniqueGroupings.insert(merged);\n  \n          // update setmap\n          BOOST_FOREACH(CTxDestination element, *merged)\n              setmap[element] = merged;\n      }\n  \n      set< set<CTxDestination> > ret;\n      BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n      {\n          ret.insert(*uniqueGrouping);\n          delete uniqueGrouping;\n      }\n  \n      return ret;\n  }\n  \n  \n  /* Checks for wallet vs. transaction index consistency;\n   * reports any spent state inconsistency found and\n   * (optionally) fixes the wallet according to the transaction index */\n  void CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n    bool fCheckOnly) {\n      nMismatchFound = 0;\n      nOrphansFound = 0;\n      nBalanceInQuestion = 0;\n  \n      LOCK(cs_wallet);\n      vector<CWalletTx*> vCoins;\n      vCoins.reserve(mapWallet.size());\n      for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          vCoins.push_back(&(*it).second);\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n          uint256 hash = pcoin->GetHash();\n          CTxIndex txindex;\n          uint n;\n  \n          if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n              continue;\n  \n          for(n = 0; n < pcoin->vout.size(); n++) {\n              bool fUpdated = false;\n  \n              if(IsMine(pcoin->vout[n])) {\n                  if(pcoin->IsSpent(n) &&\n                    ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkUnspent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  } else if(!pcoin->IsSpent(n) &&\n                    (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkSpent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  }\n  \n              }\n  \n              if(fUpdated)\n                NotifyTransactionChanged(this, hash, CT_UPDATED);\n          }\n  \n          if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n             nOrphansFound++;\n             if(!fCheckOnly) {\n                 EraseFromWallet(hash);\n                 NotifyTransactionChanged(this, hash, CT_DELETED);\n             }\n             printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n               fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n          }\n      }\n  }\n  \n  \n  // ppcoin: disable transaction (only for coinstake)\n  void CWallet::DisableTransaction(const CTransaction &tx)\n  {\n      if (!tx.IsCoinStake() || !IsFromMe(tx))\n          return; // only disconnecting coinstake requires marking input unspent\n  \n      LOCK(cs_wallet);\n      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n      {\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n              {\n                  prev.MarkUnspent(txin.prevout.n);\n                  prev.WriteToDisk();\n              }\n          }\n      }\n  }\n  \n  CPubKey CReserveKey::GetReservedKey()\n  {\n      if (nIndex == -1)\n      {\n          CKeyPool keypool;\n          pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex != -1)\n              vchPubKey = keypool.vchPubKey;\n          else\n          {\n              printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n              vchPubKey = pwallet->vchDefaultKey;\n          }\n      }\n      assert(vchPubKey.IsValid());\n      return vchPubKey;\n  }\n  \n  void CReserveKey::KeepKey()\n  {\n      if (nIndex != -1)\n          pwallet->KeepKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CReserveKey::ReturnKey()\n  {\n      if (nIndex != -1)\n          pwallet->ReturnKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n  {\n      setAddress.clear();\n  \n      CWalletDB walletdb(strWalletFile);\n  \n      LOCK2(cs_main, cs_wallet);\n      BOOST_FOREACH(const int64_t& id, setKeyPool)\n      {\n          CKeyPool keypool;\n          if (!walletdb.ReadPool(id, keypool))\n              throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n          assert(keypool.vchPubKey.IsValid());\n          CKeyID keyID = keypool.vchPubKey.GetID();\n          if (!HaveKey(keyID))\n              throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n          setAddress.insert(keyID);\n      }\n  }\n  \n  void CWallet::UpdatedTransaction(const uint256 &hashTx)\n  {\n      {\n          LOCK(cs_wallet);\n          // Only notify UI if this transaction is in this wallet\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n              NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n      }\n  }\n  \n  void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n      mapKeyBirth.clear();\n  \n      // get birth times for keys with metadata\n      for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n          if (it->second.nCreateTime)\n              mapKeyBirth[it->first] = it->second.nCreateTime;\n  \n      // map in which we'll infer heights of other keys\n      CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n      std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n      std::set<CKeyID> setKeys;\n      GetKeys(setKeys);\n      BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n          if (mapKeyBirth.count(keyid) == 0)\n              mapKeyFirstBlock[keyid] = pindexMax;\n      }\n      setKeys.clear();\n  \n      // if there are no such keys, we're done\n      if (mapKeyFirstBlock.empty())\n          return;\n  \n      // find first block that affects those keys, if there are any left\n      std::vector<CKeyID> vAffected;\n      for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n          // iterate over all wallet transactions...\n          const CWalletTx &wtx = (*it).second;\n          std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n          if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n              // ... which are already in a block\n              int nHeight = blit->second->nHeight;\n              BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                  // iterate over all their outputs\n                  ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                  BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                      // ... and all their affected keys\n                      std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                      if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                          rit->second = blit->second;\n                  }\n                  vAffected.clear();\n              }\n          }\n      }\n  \n      // Extract block timestamps for those keys\n      for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n          mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n  }\n}"
  },
  {
    "function_name": "ScanForWalletTransaction",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "867-874",
    "snippet": "int CWallet::ScanForWalletTransaction(const uint256& hashTx)\n{\n    CTransaction tx;\n    tx.ReadFromDisk(COutPoint(hashTx, 0));\n    if (AddToWalletIfInvolvingMe(tx, NULL, true, true))\n        return 1;\n    return 0;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddToWalletIfInvolvingMe",
          "args": [
            "tx",
            "NULL",
            "true",
            "true"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "AddToWalletIfInvolvingMe",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "547-566",
          "snippet": "bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n{\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs_wallet);\n        bool fExisted = mapWallet.count(hash);\n        if (fExisted && !fUpdate) return false;\n        if (fExisted || IsMine(tx) || IsFromMe(tx))\n        {\n            CWalletTx wtx(this,tx);\n            // Get merkle branch if transaction was found in a block\n            if (pblock)\n                wtx.SetMerkleBranch(pblock);\n            return AddToWallet(wtx);\n        }\n        else\n            WalletUpdateSpent(tx);\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n  {\n      uint256 hash = tx.GetHash();\n      {\n          LOCK(cs_wallet);\n          bool fExisted = mapWallet.count(hash);\n          if (fExisted && !fUpdate) return false;\n          if (fExisted || IsMine(tx) || IsFromMe(tx))\n          {\n              CWalletTx wtx(this,tx);\n              // Get merkle branch if transaction was found in a block\n              if (pblock)\n                  wtx.SetMerkleBranch(pblock);\n              return AddToWallet(wtx);\n          }\n          else\n              WalletUpdateSpent(tx);\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.ReadFromDisk",
          "args": [
            "COutPoint(hashTx, 0)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "COutPoint",
          "args": [
            "hashTx",
            "0"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "COutPoint",
          "container": "COutPoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "227-227",
          "snippet": "COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCOutPoint {\n  COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  int CWallet::ScanForWalletTransaction(const uint256& hashTx)\n  {\n      CTransaction tx;\n      tx.ReadFromDisk(COutPoint(hashTx, 0));\n      if (AddToWalletIfInvolvingMe(tx, NULL, true, true))\n          return 1;\n      return 0;\n  }\n}"
  },
  {
    "function_name": "ScanForWalletTransactions",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "838-865",
    "snippet": "int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n{\n    int ret = 0;\n\n    CBlockIndex* pindex = pindexStart;\n    {\n        LOCK(cs_wallet);\n        while (pindex)\n        {\n            // no need to read and scan block, if block was created before\n            // our wallet birthday (as adjusted for block time variability)\n            if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n                pindex = pindex->pnext;\n                continue;\n            }\n\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            BOOST_FOREACH(CTransaction& tx, block.vtx)\n            {\n                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                    ret++;\n            }\n            pindex = pindex->pnext;\n        }\n    }\n    return ret;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddToWalletIfInvolvingMe",
          "args": [
            "tx",
            "&block",
            "fUpdate"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BOOST_FOREACH",
          "args": [
            "CTransaction& tx",
            "block.vtx"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindex",
            "true"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1097-1117",
          "snippet": "bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n    {\n        SetNull();\n\n        // Open history file to read\n        CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n        if (!fReadTransactions)\n            filein.nType |= SER_BLOCKHEADERONLY;\n\n        // Read block\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n      {\n          SetNull();\n  \n          // Open history file to read\n          CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n          if (!fReadTransactions)\n              filein.nType |= SER_BLOCKHEADERONLY;\n  \n          // Read block\n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n  {\n      int ret = 0;\n  \n      CBlockIndex* pindex = pindexStart;\n      {\n          LOCK(cs_wallet);\n          while (pindex)\n          {\n              // no need to read and scan block, if block was created before\n              // our wallet birthday (as adjusted for block time variability)\n              if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n                  pindex = pindex->pnext;\n                  continue;\n              }\n  \n              CBlock block;\n              block.ReadFromDisk(pindex, true);\n              BOOST_FOREACH(CTransaction& tx, block.vtx)\n              {\n                  if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                      ret++;\n              }\n              pindex = pindex->pnext;\n          }\n      }\n      return ret;\n  }\n}"
  },
  {
    "function_name": "WriteToDisk",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "830-833",
    "snippet": "bool CWalletTx::WriteToDisk()\n{\n    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "GetHash()",
            "*this"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSetting",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "173-177",
          "snippet": "bool WriteSetting(const std::string& strKey, const T& value)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteSetting(const std::string& strKey, const T& value)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "pwallet->strWalletFile"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  bool CWalletTx::WriteToDisk()\n  {\n      return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n  }\n}"
  },
  {
    "function_name": "AddSupportingTransactions",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "770-828",
    "snippet": "void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n{\n    vtxPrev.clear();\n\n    const int COPY_DEPTH = 3;\n    if (SetMerkleBranch() < COPY_DEPTH)\n    {\n        vector<uint256> vWorkQueue;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            vWorkQueue.push_back(txin.prevout.hash);\n\n        // This critsect is OK because txdb is already open\n        {\n            LOCK(pwallet->cs_wallet);\n            map<uint256, const CMerkleTx*> mapWalletPrev;\n            set<uint256> setAlreadyDone;\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hash = vWorkQueue[i];\n                if (setAlreadyDone.count(hash))\n                    continue;\n                setAlreadyDone.insert(hash);\n\n                CMerkleTx tx;\n                map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n                if (mi != pwallet->mapWallet.end())\n                {\n                    tx = (*mi).second;\n                    BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                }\n                else if (mapWalletPrev.count(hash))\n                {\n                    tx = *mapWalletPrev[hash];\n                }\n                else if (!fClient && txdb.ReadDiskTx(hash, tx))\n                {\n                    ;\n                }\n                else\n                {\n                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                    continue;\n                }\n\n                int nDepth = tx.SetMerkleBranch();\n                vtxPrev.push_back(tx);\n\n                if (nDepth < COPY_DEPTH)\n                {\n                    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                        vWorkQueue.push_back(txin.prevout.hash);\n                }\n            }\n        }\n    }\n\n    reverse(vtxPrev.begin(), vtxPrev.end());\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reverse",
          "args": [
            "vtxPrev.begin()",
            "vtxPrev.end()"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtxPrev.end",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtxPrev.begin",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vWorkQueue.push_back",
          "args": [
            "txin.prevout.hash"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtxPrev.push_back",
          "args": [
            "tx"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.SetMerkleBranch",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txdb.ReadDiskTx",
          "args": [
            "hash",
            "tx"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "256-260",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWalletPrev.count",
          "args": [
            "hash"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txWalletPrev.GetHash",
          "args": [],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapWallet.find",
          "args": [
            "hash"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setAlreadyDone.insert",
          "args": [
            "hash"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vWorkQueue.size",
          "args": [],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pwallet->cs_wallet"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWorkQueue.push_back",
          "args": [
            "txin.prevout.hash"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetMerkleBranch",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtxPrev.clear",
          "args": [],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n  {\n      vtxPrev.clear();\n  \n      const int COPY_DEPTH = 3;\n      if (SetMerkleBranch() < COPY_DEPTH)\n      {\n          vector<uint256> vWorkQueue;\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              vWorkQueue.push_back(txin.prevout.hash);\n  \n          // This critsect is OK because txdb is already open\n          {\n              LOCK(pwallet->cs_wallet);\n              map<uint256, const CMerkleTx*> mapWalletPrev;\n              set<uint256> setAlreadyDone;\n              for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n              {\n                  uint256 hash = vWorkQueue[i];\n                  if (setAlreadyDone.count(hash))\n                      continue;\n                  setAlreadyDone.insert(hash);\n  \n                  CMerkleTx tx;\n                  map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(hash);\n                  if (mi != pwallet->mapWallet.end())\n                  {\n                      tx = (*mi).second;\n                      BOOST_FOREACH(const CMerkleTx& txWalletPrev, (*mi).second.vtxPrev)\n                          mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;\n                  }\n                  else if (mapWalletPrev.count(hash))\n                  {\n                      tx = *mapWalletPrev[hash];\n                  }\n                  else if (!fClient && txdb.ReadDiskTx(hash, tx))\n                  {\n                      ;\n                  }\n                  else\n                  {\n                      printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n                      continue;\n                  }\n  \n                  int nDepth = tx.SetMerkleBranch();\n                  vtxPrev.push_back(tx);\n  \n                  if (nDepth < COPY_DEPTH)\n                  {\n                      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                          vWorkQueue.push_back(txin.prevout.hash);\n                  }\n              }\n          }\n      }\n  \n      reverse(vtxPrev.begin(), vtxPrev.end());\n  }\n}"
  },
  {
    "function_name": "GetAccountAmounts",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "735-768",
    "snippet": "void CWalletTx::GetAccountAmounts(const string& strAccount, int64_t& nReceived,\n                                  int64_t& nSent, int64_t& nFee) const\n{\n    nReceived = nSent = nFee = 0;\n\n    int64_t allFee;\n    string strSentAccount;\n    list<pair<CTxDestination, int64_t> > listReceived;\n    list<pair<CTxDestination, int64_t> > listSent;\n    GetAmounts(listReceived, listSent, allFee, strSentAccount);\n\n    if (strAccount == strSentAccount)\n    {\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64_t)& s, listSent)\n            nSent += s.second;\n        nFee = allFee;\n    }\n    {\n        LOCK(pwallet->cs_wallet);\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64_t)& r, listReceived)\n        {\n            if (pwallet->mapAddressBook.count(r.first))\n            {\n                map<CTxDestination, string>::const_iterator mi = pwallet->mapAddressBook.find(r.first);\n                if (mi != pwallet->mapAddressBook.end() && (*mi).second == strAccount)\n                    nReceived += r.second;\n            }\n            else if (strAccount.empty())\n            {\n                nReceived += r.second;\n            }\n        }\n    }\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strAccount.empty",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapAddressBook.end",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapAddressBook.find",
          "args": [
            "r.first"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapAddressBook.count",
          "args": [
            "r.first"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pwallet->cs_wallet"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAmounts",
          "args": [
            "listReceived",
            "listSent",
            "allFee",
            "strSentAccount"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "GetAmounts",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "678-733",
          "snippet": "void CWalletTx::GetAmounts(list<pair<CTxDestination, int64_t> >& listReceived,\n                           list<pair<CTxDestination, int64_t> >& listSent, int64_t& nFee, string& strSentAccount) const\n{\n    nFee = 0;\n    listReceived.clear();\n    listSent.clear();\n    strSentAccount = strFromAccount;\n\n    // Compute fee:\n    int64_t nDebit = GetDebit();\n    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n    {\n        int64_t nValueOut = GetValueOut();\n        nFee = nDebit - nValueOut;\n    }\n\n    // Sent/received.\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        // Skip special stake out\n        if (txout.scriptPubKey.empty())\n            continue;\n\n        bool fIsMine;\n        // Only need to handle txouts if AT LEAST one of these is true:\n        //   1) they debit from us (sent)\n        //   2) the output is to us (received)\n        if (nDebit > 0)\n        {\n            // Don't report 'change' txouts\n            if (pwallet->IsChange(txout))\n                continue;\n            fIsMine = pwallet->IsMine(txout);\n        }\n        else if (!(fIsMine = pwallet->IsMine(txout)))\n            continue;\n\n        // In either case, we need to get the destination address\n        CTxDestination address;\n        if (!ExtractDestination(txout.scriptPubKey, address))\n        {\n            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                   this->GetHash().ToString().c_str());\n            address = CNoDestination();\n        }\n\n        // If we are debited by the transaction, add the output as a \"sent\" entry\n        if (nDebit > 0)\n            listSent.push_back(make_pair(address, txout.nValue));\n\n        // If we are receiving the output, add it as a \"received\" entry\n        if (fIsMine)\n            listReceived.push_back(make_pair(address, txout.nValue));\n    }\n\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  void CWalletTx::GetAmounts(list<pair<CTxDestination, int64_t> >& listReceived,\n                             list<pair<CTxDestination, int64_t> >& listSent, int64_t& nFee, string& strSentAccount) const\n  {\n      nFee = 0;\n      listReceived.clear();\n      listSent.clear();\n      strSentAccount = strFromAccount;\n  \n      // Compute fee:\n      int64_t nDebit = GetDebit();\n      if (nDebit > 0) // debit>0 means we signed/sent this transaction\n      {\n          int64_t nValueOut = GetValueOut();\n          nFee = nDebit - nValueOut;\n      }\n  \n      // Sent/received.\n      BOOST_FOREACH(const CTxOut& txout, vout)\n      {\n          // Skip special stake out\n          if (txout.scriptPubKey.empty())\n              continue;\n  \n          bool fIsMine;\n          // Only need to handle txouts if AT LEAST one of these is true:\n          //   1) they debit from us (sent)\n          //   2) the output is to us (received)\n          if (nDebit > 0)\n          {\n              // Don't report 'change' txouts\n              if (pwallet->IsChange(txout))\n                  continue;\n              fIsMine = pwallet->IsMine(txout);\n          }\n          else if (!(fIsMine = pwallet->IsMine(txout)))\n              continue;\n  \n          // In either case, we need to get the destination address\n          CTxDestination address;\n          if (!ExtractDestination(txout.scriptPubKey, address))\n          {\n              printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                     this->GetHash().ToString().c_str());\n              address = CNoDestination();\n          }\n  \n          // If we are debited by the transaction, add the output as a \"sent\" entry\n          if (nDebit > 0)\n              listSent.push_back(make_pair(address, txout.nValue));\n  \n          // If we are receiving the output, add it as a \"received\" entry\n          if (fIsMine)\n              listReceived.push_back(make_pair(address, txout.nValue));\n      }\n  \n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  void CWalletTx::GetAccountAmounts(const string& strAccount, int64_t& nReceived,\n                                    int64_t& nSent, int64_t& nFee) const\n  {\n      nReceived = nSent = nFee = 0;\n  \n      int64_t allFee;\n      string strSentAccount;\n      list<pair<CTxDestination, int64_t> > listReceived;\n      list<pair<CTxDestination, int64_t> > listSent;\n      GetAmounts(listReceived, listSent, allFee, strSentAccount);\n  \n      if (strAccount == strSentAccount)\n      {\n          BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64_t)& s, listSent)\n              nSent += s.second;\n          nFee = allFee;\n      }\n      {\n          LOCK(pwallet->cs_wallet);\n          BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64_t)& r, listReceived)\n          {\n              if (pwallet->mapAddressBook.count(r.first))\n              {\n                  map<CTxDestination, string>::const_iterator mi = pwallet->mapAddressBook.find(r.first);\n                  if (mi != pwallet->mapAddressBook.end() && (*mi).second == strAccount)\n                      nReceived += r.second;\n              }\n              else if (strAccount.empty())\n              {\n                  nReceived += r.second;\n              }\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "GetAmounts",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "678-733",
    "snippet": "void CWalletTx::GetAmounts(list<pair<CTxDestination, int64_t> >& listReceived,\n                           list<pair<CTxDestination, int64_t> >& listSent, int64_t& nFee, string& strSentAccount) const\n{\n    nFee = 0;\n    listReceived.clear();\n    listSent.clear();\n    strSentAccount = strFromAccount;\n\n    // Compute fee:\n    int64_t nDebit = GetDebit();\n    if (nDebit > 0) // debit>0 means we signed/sent this transaction\n    {\n        int64_t nValueOut = GetValueOut();\n        nFee = nDebit - nValueOut;\n    }\n\n    // Sent/received.\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        // Skip special stake out\n        if (txout.scriptPubKey.empty())\n            continue;\n\n        bool fIsMine;\n        // Only need to handle txouts if AT LEAST one of these is true:\n        //   1) they debit from us (sent)\n        //   2) the output is to us (received)\n        if (nDebit > 0)\n        {\n            // Don't report 'change' txouts\n            if (pwallet->IsChange(txout))\n                continue;\n            fIsMine = pwallet->IsMine(txout);\n        }\n        else if (!(fIsMine = pwallet->IsMine(txout)))\n            continue;\n\n        // In either case, we need to get the destination address\n        CTxDestination address;\n        if (!ExtractDestination(txout.scriptPubKey, address))\n        {\n            printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                   this->GetHash().ToString().c_str());\n            address = CNoDestination();\n        }\n\n        // If we are debited by the transaction, add the output as a \"sent\" entry\n        if (nDebit > 0)\n            listSent.push_back(make_pair(address, txout.nValue));\n\n        // If we are receiving the output, add it as a \"received\" entry\n        if (fIsMine)\n            listReceived.push_back(make_pair(address, txout.nValue));\n    }\n\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "listReceived.push_back",
          "args": [
            "make_pair(address, txout.nValue)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "address",
            "txout.nValue"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listSent.push_back",
          "args": [
            "make_pair(address, txout.nValue)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "address",
            "txout.nValue"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNoDestination",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\"",
            "this->GetHash().ToString().c_str()"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetHash",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractDestination",
          "args": [
            "txout.scriptPubKey",
            "address"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1590-1614",
          "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->IsMine",
          "args": [
            "txout"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "581-595",
          "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsMine(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->IsChange",
          "args": [
            "txout"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "IsChange",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "613-631",
          "snippet": "bool CWallet::IsChange(const CTxOut& txout) const\n{\n    CTxDestination address;\n\n    // TODO: fix handling of 'change' outputs. The assumption is that any\n    // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n    // is change. That assumption is likely to break when we implement multisignature\n    // wallets that return change back into a multi-signature-protected address;\n    // a better way of identifying which outputs are 'the send' and which are\n    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n    // which output, if any, was change).\n    if (ExtractDestination(txout.scriptPubKey, address) && ::IsMine(*this, address))\n    {\n        LOCK(cs_wallet);\n        if (!mapAddressBook.count(address))\n            return true;\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsChange(const CTxOut& txout) const\n  {\n      CTxDestination address;\n  \n      // TODO: fix handling of 'change' outputs. The assumption is that any\n      // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n      // is change. That assumption is likely to break when we implement multisignature\n      // wallets that return change back into a multi-signature-protected address;\n      // a better way of identifying which outputs are 'the send' and which are\n      // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n      // which output, if any, was change).\n      if (ExtractDestination(txout.scriptPubKey, address) && ::IsMine(*this, address))\n      {\n          LOCK(cs_wallet);\n          if (!mapAddressBook.count(address))\n              return true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txout.scriptPubKey.empty",
          "args": [],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetValueOut",
          "args": [],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDebit",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "GetDebit",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "574-583",
          "snippet": "int64_t GetDebit() const\n    {\n        if (vin.empty())\n            return 0;\n        if (fDebitCached)\n            return nDebitCached;\n        nDebitCached = pwallet->GetDebit(*this);\n        fDebitCached = true;\n        return nDebitCached;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  int64_t GetDebit() const\n      {\n          if (vin.empty())\n              return 0;\n          if (fDebitCached)\n              return nDebitCached;\n          nDebitCached = pwallet->GetDebit(*this);\n          fDebitCached = true;\n          return nDebitCached;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "listSent.clear",
          "args": [],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  void CWalletTx::GetAmounts(list<pair<CTxDestination, int64_t> >& listReceived,\n                             list<pair<CTxDestination, int64_t> >& listSent, int64_t& nFee, string& strSentAccount) const\n  {\n      nFee = 0;\n      listReceived.clear();\n      listSent.clear();\n      strSentAccount = strFromAccount;\n  \n      // Compute fee:\n      int64_t nDebit = GetDebit();\n      if (nDebit > 0) // debit>0 means we signed/sent this transaction\n      {\n          int64_t nValueOut = GetValueOut();\n          nFee = nDebit - nValueOut;\n      }\n  \n      // Sent/received.\n      BOOST_FOREACH(const CTxOut& txout, vout)\n      {\n          // Skip special stake out\n          if (txout.scriptPubKey.empty())\n              continue;\n  \n          bool fIsMine;\n          // Only need to handle txouts if AT LEAST one of these is true:\n          //   1) they debit from us (sent)\n          //   2) the output is to us (received)\n          if (nDebit > 0)\n          {\n              // Don't report 'change' txouts\n              if (pwallet->IsChange(txout))\n                  continue;\n              fIsMine = pwallet->IsMine(txout);\n          }\n          else if (!(fIsMine = pwallet->IsMine(txout)))\n              continue;\n  \n          // In either case, we need to get the destination address\n          CTxDestination address;\n          if (!ExtractDestination(txout.scriptPubKey, address))\n          {\n              printf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n                     this->GetHash().ToString().c_str());\n              address = CNoDestination();\n          }\n  \n          // If we are debited by the transaction, add the output as a \"sent\" entry\n          if (nDebit > 0)\n              listSent.push_back(make_pair(address, txout.nValue));\n  \n          // If we are receiving the output, add it as a \"received\" entry\n          if (fIsMine)\n              listReceived.push_back(make_pair(address, txout.nValue));\n      }\n  \n  }\n}"
  },
  {
    "function_name": "GetRequestCount",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "639-676",
    "snippet": "int CWalletTx::GetRequestCount() const\n{\n    // Returns -1 if it wasn't being tracked\n    int nRequests = -1;\n    {\n        LOCK(pwallet->cs_wallet);\n        if (IsCoinBase() || IsCoinStake())\n        {\n            // Generated block\n            if (hashBlock != 0)\n            {\n                map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                if (mi != pwallet->mapRequestCount.end())\n                    nRequests = (*mi).second;\n            }\n        }\n        else\n        {\n            // Did anyone request this transaction?\n            map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n            if (mi != pwallet->mapRequestCount.end())\n            {\n                nRequests = (*mi).second;\n\n                // How about the block it's in?\n                if (nRequests == 0 && hashBlock != 0)\n                {\n                    map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                    if (mi != pwallet->mapRequestCount.end())\n                        nRequests = (*mi).second;\n                    else\n                        nRequests = 1; // If it's in someone else's block it must have got out\n                }\n            }\n        }\n    }\n    return nRequests;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->mapRequestCount.end",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapRequestCount.find",
          "args": [
            "hashBlock"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinStake",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pwallet->cs_wallet"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  int CWalletTx::GetRequestCount() const\n  {\n      // Returns -1 if it wasn't being tracked\n      int nRequests = -1;\n      {\n          LOCK(pwallet->cs_wallet);\n          if (IsCoinBase() || IsCoinStake())\n          {\n              // Generated block\n              if (hashBlock != 0)\n              {\n                  map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                  if (mi != pwallet->mapRequestCount.end())\n                      nRequests = (*mi).second;\n              }\n          }\n          else\n          {\n              // Did anyone request this transaction?\n              map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n              if (mi != pwallet->mapRequestCount.end())\n              {\n                  nRequests = (*mi).second;\n  \n                  // How about the block it's in?\n                  if (nRequests == 0 && hashBlock != 0)\n                  {\n                      map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                      if (mi != pwallet->mapRequestCount.end())\n                          nRequests = (*mi).second;\n                      else\n                          nRequests = 1; // If it's in someone else's block it must have got out\n                  }\n              }\n          }\n      }\n      return nRequests;\n  }\n}"
  },
  {
    "function_name": "GetTxTime",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "633-637",
    "snippet": "int64_t CWalletTx::GetTxTime() const\n{\n    int64_t n = nTimeSmart;\n    return n ? n : nTimeReceived;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  int64_t CWalletTx::GetTxTime() const\n  {\n      int64_t n = nTimeSmart;\n      return n ? n : nTimeReceived;\n  }\n}"
  },
  {
    "function_name": "IsChange",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "613-631",
    "snippet": "bool CWallet::IsChange(const CTxOut& txout) const\n{\n    CTxDestination address;\n\n    // TODO: fix handling of 'change' outputs. The assumption is that any\n    // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n    // is change. That assumption is likely to break when we implement multisignature\n    // wallets that return change back into a multi-signature-protected address;\n    // a better way of identifying which outputs are 'the send' and which are\n    // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n    // which output, if any, was change).\n    if (ExtractDestination(txout.scriptPubKey, address) && ::IsMine(*this, address))\n    {\n        LOCK(cs_wallet);\n        if (!mapAddressBook.count(address))\n            return true;\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapAddressBook.count",
          "args": [
            "address"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::IsMine",
          "args": [
            "*this",
            "address"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1551-1588",
          "snippet": "bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractDestination",
          "args": [
            "txout.scriptPubKey",
            "address"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1590-1614",
          "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsChange(const CTxOut& txout) const\n  {\n      CTxDestination address;\n  \n      // TODO: fix handling of 'change' outputs. The assumption is that any\n      // payment to a TX_PUBKEYHASH that is mine but isn't in the address book\n      // is change. That assumption is likely to break when we implement multisignature\n      // wallets that return change back into a multi-signature-protected address;\n      // a better way of identifying which outputs are 'the send' and which are\n      // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n      // which output, if any, was change).\n      if (ExtractDestination(txout.scriptPubKey, address) && ::IsMine(*this, address))\n      {\n          LOCK(cs_wallet);\n          if (!mapAddressBook.count(address))\n              return true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "GetDebit",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "597-611",
    "snippet": "int64_t CWallet::GetDebit(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return prev.vout[txin.prevout.n].nValue;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsMine",
          "args": [
            "prev.vout[txin.prevout.n]"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "581-595",
          "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsMine(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "prev.vout.size",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.end",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.find",
          "args": [
            "txin.prevout.hash"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  int64_t CWallet::GetDebit(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return prev.vout[txin.prevout.n].nValue;\n          }\n      }\n      return 0;\n  }\n}"
  },
  {
    "function_name": "IsMine",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "581-595",
    "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsMine",
          "args": [
            "prev.vout[txin.prevout.n]"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "581-595",
          "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "prev.vout.size",
          "args": [],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.end",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.find",
          "args": [
            "txin.prevout.hash"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsMine(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return true;\n          }\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "EraseFromWallet",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "568-578",
    "snippet": "bool CWallet::EraseFromWallet(uint256 hash)\n{\n    if (!fFileBacked)\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.erase(hash))\n            CWalletDB(strWalletFile).EraseTx(hash);\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "hash"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.erase",
          "args": [
            "hash"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::EraseFromWallet(uint256 hash)\n  {\n      if (!fFileBacked)\n          return false;\n      {\n          LOCK(cs_wallet);\n          if (mapWallet.erase(hash))\n              CWalletDB(strWalletFile).EraseTx(hash);\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "AddToWalletIfInvolvingMe",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "547-566",
    "snippet": "bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n{\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs_wallet);\n        bool fExisted = mapWallet.count(hash);\n        if (fExisted && !fUpdate) return false;\n        if (fExisted || IsMine(tx) || IsFromMe(tx))\n        {\n            CWalletTx wtx(this,tx);\n            // Get merkle branch if transaction was found in a block\n            if (pblock)\n                wtx.SetMerkleBranch(pblock);\n            return AddToWallet(wtx);\n        }\n        else\n            WalletUpdateSpent(tx);\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WalletUpdateSpent",
          "args": [
            "tx"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddToWallet",
          "args": [
            "wtx"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "AddToWallet",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "416-542",
          "snippet": "bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    {\n        LOCK(cs_wallet);\n        // Inserts only if not already there, returns tx inserted or tx found\n        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n        CWalletTx& wtx = (*ret.first).second;\n        wtx.BindWallet(this);\n        bool fInsertedNew = ret.second;\n        if (fInsertedNew)\n        {\n            wtx.nTimeReceived = GetAdjustedTime();\n            wtx.nOrderPos = IncOrderPosNext();\n\n            wtx.nTimeSmart = wtx.nTimeReceived;\n            if (wtxIn.hashBlock != 0)\n            {\n                if (mapBlockIndex.count(wtxIn.hashBlock))\n                {\n                    unsigned int latestNow = wtx.nTimeReceived;\n                    unsigned int latestEntry = 0;\n                    {\n                        // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                        int64_t latestTolerated = latestNow + 300;\n                        std::list<CAccountingEntry> acentries;\n                        TxItems txOrdered = OrderedTxItems(acentries);\n                        for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                        {\n                            CWalletTx *const pwtx = (*it).second.first;\n                            if (pwtx == &wtx)\n                                continue;\n                            CAccountingEntry *const pacentry = (*it).second.second;\n                            int64_t nSmartTime;\n                            if (pwtx)\n                            {\n                                nSmartTime = pwtx->nTimeSmart;\n                                if (!nSmartTime)\n                                    nSmartTime = pwtx->nTimeReceived;\n                            }\n                            else\n                                nSmartTime = pacentry->nTime;\n                            if (nSmartTime <= latestTolerated)\n                            {\n                                latestEntry = nSmartTime;\n                                if (nSmartTime > latestNow)\n                                    latestNow = nSmartTime;\n                                break;\n                            }\n                        }\n                    }\n\n                    unsigned int& blocktime = mapBlockIndex[wtxIn.hashBlock]->nTime;\n                    wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                }\n                else\n                    printf(\"AddToWallet() : found %s in block %s not in index\\n\",\n                           wtxIn.GetHash().ToString().substr(0,10).c_str(),\n                           wtxIn.hashBlock.ToString().c_str());\n            }\n        }\n\n        bool fUpdated = false;\n        if (!fInsertedNew)\n        {\n            // Merge\n            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n            {\n                wtx.hashBlock = wtxIn.hashBlock;\n                fUpdated = true;\n            }\n            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n            {\n                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                wtx.nIndex = wtxIn.nIndex;\n                fUpdated = true;\n            }\n            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n            {\n                wtx.fFromMe = wtxIn.fFromMe;\n                fUpdated = true;\n            }\n            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n        }\n\n        //// debug print\n        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n        // Write to disk\n        if (fInsertedNew || fUpdated)\n            if (!wtx.WriteToDisk())\n                return false;\n#ifndef QT_GUI\n        // If default receiving address gets used, replace it with a new one\n        CScript scriptDefaultKey;\n        scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n        {\n            if (txout.scriptPubKey == scriptDefaultKey)\n            {\n                CPubKey newDefaultKey;\n                if (GetKeyFromPool(newDefaultKey, false))\n                {\n                    SetDefaultKey(newDefaultKey);\n                    SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                }\n            }\n        }\n#endif\n        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n        WalletUpdateSpent(wtx, (wtxIn.hashBlock != 0));\n\n        // Notify UI of new or updated transaction\n        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n\n        // notify an external script when a wallet transaction comes in or is updated\n        std::string strCmd = GetArg(\"-walletnotify\", \"\");\n\n        if ( !strCmd.empty())\n        {\n            boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n            boost::thread t(runCommand, strCmd); // thread runs free\n        }\n\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n  {\n      uint256 hash = wtxIn.GetHash();\n      {\n          LOCK(cs_wallet);\n          // Inserts only if not already there, returns tx inserted or tx found\n          pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n          CWalletTx& wtx = (*ret.first).second;\n          wtx.BindWallet(this);\n          bool fInsertedNew = ret.second;\n          if (fInsertedNew)\n          {\n              wtx.nTimeReceived = GetAdjustedTime();\n              wtx.nOrderPos = IncOrderPosNext();\n  \n              wtx.nTimeSmart = wtx.nTimeReceived;\n              if (wtxIn.hashBlock != 0)\n              {\n                  if (mapBlockIndex.count(wtxIn.hashBlock))\n                  {\n                      unsigned int latestNow = wtx.nTimeReceived;\n                      unsigned int latestEntry = 0;\n                      {\n                          // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                          int64_t latestTolerated = latestNow + 300;\n                          std::list<CAccountingEntry> acentries;\n                          TxItems txOrdered = OrderedTxItems(acentries);\n                          for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                          {\n                              CWalletTx *const pwtx = (*it).second.first;\n                              if (pwtx == &wtx)\n                                  continue;\n                              CAccountingEntry *const pacentry = (*it).second.second;\n                              int64_t nSmartTime;\n                              if (pwtx)\n                              {\n                                  nSmartTime = pwtx->nTimeSmart;\n                                  if (!nSmartTime)\n                                      nSmartTime = pwtx->nTimeReceived;\n                              }\n                              else\n                                  nSmartTime = pacentry->nTime;\n                              if (nSmartTime <= latestTolerated)\n                              {\n                                  latestEntry = nSmartTime;\n                                  if (nSmartTime > latestNow)\n                                      latestNow = nSmartTime;\n                                  break;\n                              }\n                          }\n                      }\n  \n                      unsigned int& blocktime = mapBlockIndex[wtxIn.hashBlock]->nTime;\n                      wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                  }\n                  else\n                      printf(\"AddToWallet() : found %s in block %s not in index\\n\",\n                             wtxIn.GetHash().ToString().substr(0,10).c_str(),\n                             wtxIn.hashBlock.ToString().c_str());\n              }\n          }\n  \n          bool fUpdated = false;\n          if (!fInsertedNew)\n          {\n              // Merge\n              if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n              {\n                  wtx.hashBlock = wtxIn.hashBlock;\n                  fUpdated = true;\n              }\n              if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n              {\n                  wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                  wtx.nIndex = wtxIn.nIndex;\n                  fUpdated = true;\n              }\n              if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n              {\n                  wtx.fFromMe = wtxIn.fFromMe;\n                  fUpdated = true;\n              }\n              fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n          }\n  \n          //// debug print\n          printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n  \n          // Write to disk\n          if (fInsertedNew || fUpdated)\n              if (!wtx.WriteToDisk())\n                  return false;\n  #ifndef QT_GUI\n          // If default receiving address gets used, replace it with a new one\n          CScript scriptDefaultKey;\n          scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n          BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n          {\n              if (txout.scriptPubKey == scriptDefaultKey)\n              {\n                  CPubKey newDefaultKey;\n                  if (GetKeyFromPool(newDefaultKey, false))\n                  {\n                      SetDefaultKey(newDefaultKey);\n                      SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                  }\n              }\n          }\n  #endif\n          // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n          WalletUpdateSpent(wtx, (wtxIn.hashBlock != 0));\n  \n          // Notify UI of new or updated transaction\n          NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n  \n          // notify an external script when a wallet transaction comes in or is updated\n          std::string strCmd = GetArg(\"-walletnotify\", \"\");\n  \n          if ( !strCmd.empty())\n          {\n              boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n              boost::thread t(runCommand, strCmd); // thread runs free\n          }\n  \n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.SetMerkleBranch",
          "args": [
            "pblock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "SetMerkleBranch",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "421-470",
          "snippet": "int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n{\n    if (fClient)\n    {\n        if (hashBlock == 0)\n            return 0;\n    }\n    else\n    {\n        CBlock blockTmp;\n        if (pblock == NULL)\n        {\n            // Load the block this tx is in\n            CTxIndex txindex;\n            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                return 0;\n            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                return 0;\n            pblock = &blockTmp;\n        }\n\n        // Update the tx's hashBlock\n        hashBlock = pblock->GetHash();\n\n        // Locate the transaction\n        for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n            if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                break;\n        if (nIndex == (int)pblock->vtx.size())\n        {\n            vMerkleBranch.clear();\n            nIndex = -1;\n            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n            return 0;\n        }\n\n        // Fill in merkle branch\n        vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n    }\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\n\nCMerkleTx {\n  int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n  {\n      if (fClient)\n      {\n          if (hashBlock == 0)\n              return 0;\n      }\n      else\n      {\n          CBlock blockTmp;\n          if (pblock == NULL)\n          {\n              // Load the block this tx is in\n              CTxIndex txindex;\n              if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                  return 0;\n              if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                  return 0;\n              pblock = &blockTmp;\n          }\n  \n          // Update the tx's hashBlock\n          hashBlock = pblock->GetHash();\n  \n          // Locate the transaction\n          for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n              if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                  break;\n          if (nIndex == (int)pblock->vtx.size())\n          {\n              vMerkleBranch.clear();\n              nIndex = -1;\n              printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n              return 0;\n          }\n  \n          // Fill in merkle branch\n          vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n      }\n  \n      // Is the tx in a block that's in the main chain\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n      if (mi == mapBlockIndex.end())\n          return 0;\n      CBlockIndex* pindex = (*mi).second;\n      if (!pindex || !pindex->IsInMainChain())\n          return 0;\n  \n      return pindexBest->nHeight - pindex->nHeight + 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsFromMe",
          "args": [
            "tx"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "IsFromMe",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "237-240",
          "snippet": "bool IsFromMe(const CTransaction& tx) const\n    {\n        return (GetDebit(tx) > 0);\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  bool IsFromMe(const CTransaction& tx) const\n      {\n          return (GetDebit(tx) > 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsMine",
          "args": [
            "tx"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "581-595",
          "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsMine(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.count",
          "args": [
            "hash"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n  {\n      uint256 hash = tx.GetHash();\n      {\n          LOCK(cs_wallet);\n          bool fExisted = mapWallet.count(hash);\n          if (fExisted && !fUpdate) return false;\n          if (fExisted || IsMine(tx) || IsFromMe(tx))\n          {\n              CWalletTx wtx(this,tx);\n              // Get merkle branch if transaction was found in a block\n              if (pblock)\n                  wtx.SetMerkleBranch(pblock);\n              return AddToWallet(wtx);\n          }\n          else\n              WalletUpdateSpent(tx);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "AddToWallet",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "416-542",
    "snippet": "bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n{\n    uint256 hash = wtxIn.GetHash();\n    {\n        LOCK(cs_wallet);\n        // Inserts only if not already there, returns tx inserted or tx found\n        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n        CWalletTx& wtx = (*ret.first).second;\n        wtx.BindWallet(this);\n        bool fInsertedNew = ret.second;\n        if (fInsertedNew)\n        {\n            wtx.nTimeReceived = GetAdjustedTime();\n            wtx.nOrderPos = IncOrderPosNext();\n\n            wtx.nTimeSmart = wtx.nTimeReceived;\n            if (wtxIn.hashBlock != 0)\n            {\n                if (mapBlockIndex.count(wtxIn.hashBlock))\n                {\n                    unsigned int latestNow = wtx.nTimeReceived;\n                    unsigned int latestEntry = 0;\n                    {\n                        // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                        int64_t latestTolerated = latestNow + 300;\n                        std::list<CAccountingEntry> acentries;\n                        TxItems txOrdered = OrderedTxItems(acentries);\n                        for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                        {\n                            CWalletTx *const pwtx = (*it).second.first;\n                            if (pwtx == &wtx)\n                                continue;\n                            CAccountingEntry *const pacentry = (*it).second.second;\n                            int64_t nSmartTime;\n                            if (pwtx)\n                            {\n                                nSmartTime = pwtx->nTimeSmart;\n                                if (!nSmartTime)\n                                    nSmartTime = pwtx->nTimeReceived;\n                            }\n                            else\n                                nSmartTime = pacentry->nTime;\n                            if (nSmartTime <= latestTolerated)\n                            {\n                                latestEntry = nSmartTime;\n                                if (nSmartTime > latestNow)\n                                    latestNow = nSmartTime;\n                                break;\n                            }\n                        }\n                    }\n\n                    unsigned int& blocktime = mapBlockIndex[wtxIn.hashBlock]->nTime;\n                    wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                }\n                else\n                    printf(\"AddToWallet() : found %s in block %s not in index\\n\",\n                           wtxIn.GetHash().ToString().substr(0,10).c_str(),\n                           wtxIn.hashBlock.ToString().c_str());\n            }\n        }\n\n        bool fUpdated = false;\n        if (!fInsertedNew)\n        {\n            // Merge\n            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n            {\n                wtx.hashBlock = wtxIn.hashBlock;\n                fUpdated = true;\n            }\n            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n            {\n                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                wtx.nIndex = wtxIn.nIndex;\n                fUpdated = true;\n            }\n            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n            {\n                wtx.fFromMe = wtxIn.fFromMe;\n                fUpdated = true;\n            }\n            fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n        }\n\n        //// debug print\n        printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n\n        // Write to disk\n        if (fInsertedNew || fUpdated)\n            if (!wtx.WriteToDisk())\n                return false;\n#ifndef QT_GUI\n        // If default receiving address gets used, replace it with a new one\n        CScript scriptDefaultKey;\n        scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n        BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n        {\n            if (txout.scriptPubKey == scriptDefaultKey)\n            {\n                CPubKey newDefaultKey;\n                if (GetKeyFromPool(newDefaultKey, false))\n                {\n                    SetDefaultKey(newDefaultKey);\n                    SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                }\n            }\n        }\n#endif\n        // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n        WalletUpdateSpent(wtx, (wtxIn.hashBlock != 0));\n\n        // Notify UI of new or updated transaction\n        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n\n        // notify an external script when a wallet transaction comes in or is updated\n        std::string strCmd = GetArg(\"-walletnotify\", \"\");\n\n        if ( !strCmd.empty())\n        {\n            boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n            boost::thread t(runCommand, strCmd); // thread runs free\n        }\n\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boost::replace_all",
          "args": [
            "strCmd",
            "\"%s\"",
            "wtxIn.GetHash().GetHex()"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxIn.GetHash",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strCmd.empty",
          "args": [],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-walletnotify\"",
            "\"\""
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "hash",
            "fInsertedNew ? CT_NEW : CT_UPDATED"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WalletUpdateSpent",
          "args": [
            "wtx",
            "(wtxIn.hashBlock != 0)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "WalletUpdateSpent",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "362-405",
          "snippet": "void CWallet::WalletUpdateSpent(const CTransaction &tx, bool fBlock)\n{\n    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n    // restored from backup or the user making copies of wallet.dat.\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        {\n            map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n            if (mi != mapWallet.end())\n            {\n                CWalletTx& wtx = (*mi).second;\n                if (txin.prevout.n >= wtx.vout.size())\n                    printf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n                else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                {\n                    printf(\"WalletUpdateSpent found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkSpent(txin.prevout.n);\n                    wtx.WriteToDisk();\n                    NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n                }\n            }\n        }\n\n        if (fBlock)\n        {\n            uint256 hash = tx.GetHash();\n            map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n            CWalletTx& wtx = (*mi).second;\n\n            BOOST_FOREACH(const CTxOut& txout, tx.vout)\n            {\n                if (IsMine(txout))\n                {\n                    wtx.MarkUnspent(&txout - &tx.vout[0]);\n                    wtx.WriteToDisk();\n                    NotifyTransactionChanged(this, hash, CT_UPDATED);\n                }\n            }\n        }\n\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  void CWallet::WalletUpdateSpent(const CTransaction &tx, bool fBlock)\n  {\n      // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n      // Update the wallet spent flag if it doesn't know due to wallet.dat being\n      // restored from backup or the user making copies of wallet.dat.\n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(const CTxIn& txin, tx.vin)\n          {\n              map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n              if (mi != mapWallet.end())\n              {\n                  CWalletTx& wtx = (*mi).second;\n                  if (txin.prevout.n >= wtx.vout.size())\n                      printf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n                  else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                  {\n                      printf(\"WalletUpdateSpent found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                      wtx.MarkSpent(txin.prevout.n);\n                      wtx.WriteToDisk();\n                      NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n                  }\n              }\n          }\n  \n          if (fBlock)\n          {\n              uint256 hash = tx.GetHash();\n              map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n              CWalletTx& wtx = (*mi).second;\n  \n              BOOST_FOREACH(const CTxOut& txout, tx.vout)\n              {\n                  if (IsMine(txout))\n                  {\n                      wtx.MarkUnspent(&txout - &tx.vout[0]);\n                      wtx.WriteToDisk();\n                      NotifyTransactionChanged(this, hash, CT_UPDATED);\n                  }\n              }\n          }\n  \n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetAddressBookName",
          "args": [
            "vchDefaultKey.GetID()",
            "\"\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchDefaultKey.GetID",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetDefaultKey",
          "args": [
            "newDefaultKey"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetKeyFromPool",
          "args": [
            "newDefaultKey",
            "false"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptDefaultKey.SetDestination",
          "args": [
            "vchDefaultKey.GetID()"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "SetDestination",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "2011-2014",
          "snippet": "void CScript::SetDestination(const CTxDestination& dest)\n{\n    boost::apply_visitor(CScriptVisitor(this), dest);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetDestination(const CTxDestination& dest)\n  {\n      boost::apply_visitor(CScriptVisitor(this), dest);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.WriteToDisk",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "WriteToDisk",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "830-833",
          "snippet": "bool CWalletTx::WriteToDisk()\n{\n    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  bool CWalletTx::WriteToDisk()\n  {\n      return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AddToWallet %s  %s%s\\n\"",
            "wtxIn.GetHash().ToString().substr(0,10).c_str()",
            "(fInsertedNew ? \"new\" : \"\")",
            "(fUpdated ? \"update\" : \"\")"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxIn.GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.UpdateSpent",
          "args": [
            "wtxIn.vfSpent"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateSpent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "508-524",
          "snippet": "bool UpdateSpent(const std::vector<char>& vfNewSpent)\n    {\n        bool fReturn = false;\n        for (unsigned int i = 0; i < vfNewSpent.size(); i++)\n        {\n            if (i == vfSpent.size())\n                break;\n\n            if (vfNewSpent[i] && !vfSpent[i])\n            {\n                vfSpent[i] = true;\n                fReturn = true;\n                fAvailableCreditCached = false;\n            }\n        }\n        return fReturn;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  bool UpdateSpent(const std::vector<char>& vfNewSpent)\n      {\n          bool fReturn = false;\n          for (unsigned int i = 0; i < vfNewSpent.size(); i++)\n          {\n              if (i == vfSpent.size())\n                  break;\n  \n              if (vfNewSpent[i] && !vfSpent[i])\n              {\n                  vfSpent[i] = true;\n                  fReturn = true;\n                  fAvailableCreditCached = false;\n              }\n          }\n          return fReturn;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AddToWallet() : found %s in block %s not in index\\n\"",
            "wtxIn.GetHash().ToString().substr(0,10).c_str()",
            "wtxIn.hashBlock.ToString().c_str()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtxIn.hashBlock.ToString",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "COutput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "725-728",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCOutput {\n  std::string ToString() const\n      {\n          return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().substr(0,10).c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtxIn.GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::max",
          "args": [
            "latestEntry",
            "std::min(blocktime, latestNow)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "blocktime",
            "latestNow"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txOrdered.rend",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txOrdered.rbegin",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OrderedTxItems",
          "args": [
            "acentries"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "wtxIn.hashBlock"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IncOrderPosNext",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.BindWallet",
          "args": [
            "this"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "BindWallet",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "535-539",
          "snippet": "void BindWallet(CWallet *pwalletIn)\n    {\n        pwallet = pwalletIn;\n        MarkDirty();\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void BindWallet(CWallet *pwalletIn)\n      {\n          pwallet = pwalletIn;\n          MarkDirty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.insert",
          "args": [
            "make_pair(hash, wtxIn)"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "hash",
            "wtxIn"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n  {\n      uint256 hash = wtxIn.GetHash();\n      {\n          LOCK(cs_wallet);\n          // Inserts only if not already there, returns tx inserted or tx found\n          pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n          CWalletTx& wtx = (*ret.first).second;\n          wtx.BindWallet(this);\n          bool fInsertedNew = ret.second;\n          if (fInsertedNew)\n          {\n              wtx.nTimeReceived = GetAdjustedTime();\n              wtx.nOrderPos = IncOrderPosNext();\n  \n              wtx.nTimeSmart = wtx.nTimeReceived;\n              if (wtxIn.hashBlock != 0)\n              {\n                  if (mapBlockIndex.count(wtxIn.hashBlock))\n                  {\n                      unsigned int latestNow = wtx.nTimeReceived;\n                      unsigned int latestEntry = 0;\n                      {\n                          // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                          int64_t latestTolerated = latestNow + 300;\n                          std::list<CAccountingEntry> acentries;\n                          TxItems txOrdered = OrderedTxItems(acentries);\n                          for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                          {\n                              CWalletTx *const pwtx = (*it).second.first;\n                              if (pwtx == &wtx)\n                                  continue;\n                              CAccountingEntry *const pacentry = (*it).second.second;\n                              int64_t nSmartTime;\n                              if (pwtx)\n                              {\n                                  nSmartTime = pwtx->nTimeSmart;\n                                  if (!nSmartTime)\n                                      nSmartTime = pwtx->nTimeReceived;\n                              }\n                              else\n                                  nSmartTime = pacentry->nTime;\n                              if (nSmartTime <= latestTolerated)\n                              {\n                                  latestEntry = nSmartTime;\n                                  if (nSmartTime > latestNow)\n                                      latestNow = nSmartTime;\n                                  break;\n                              }\n                          }\n                      }\n  \n                      unsigned int& blocktime = mapBlockIndex[wtxIn.hashBlock]->nTime;\n                      wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                  }\n                  else\n                      printf(\"AddToWallet() : found %s in block %s not in index\\n\",\n                             wtxIn.GetHash().ToString().substr(0,10).c_str(),\n                             wtxIn.hashBlock.ToString().c_str());\n              }\n          }\n  \n          bool fUpdated = false;\n          if (!fInsertedNew)\n          {\n              // Merge\n              if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)\n              {\n                  wtx.hashBlock = wtxIn.hashBlock;\n                  fUpdated = true;\n              }\n              if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n              {\n                  wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n                  wtx.nIndex = wtxIn.nIndex;\n                  fUpdated = true;\n              }\n              if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n              {\n                  wtx.fFromMe = wtxIn.fFromMe;\n                  fUpdated = true;\n              }\n              fUpdated |= wtx.UpdateSpent(wtxIn.vfSpent);\n          }\n  \n          //// debug print\n          printf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().substr(0,10).c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n  \n          // Write to disk\n          if (fInsertedNew || fUpdated)\n              if (!wtx.WriteToDisk())\n                  return false;\n  #ifndef QT_GUI\n          // If default receiving address gets used, replace it with a new one\n          CScript scriptDefaultKey;\n          scriptDefaultKey.SetDestination(vchDefaultKey.GetID());\n          BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n          {\n              if (txout.scriptPubKey == scriptDefaultKey)\n              {\n                  CPubKey newDefaultKey;\n                  if (GetKeyFromPool(newDefaultKey, false))\n                  {\n                      SetDefaultKey(newDefaultKey);\n                      SetAddressBookName(vchDefaultKey.GetID(), \"\");\n                  }\n              }\n          }\n  #endif\n          // since AddToWallet is called directly for self-originating transactions, check for consumption of own coins\n          WalletUpdateSpent(wtx, (wtxIn.hashBlock != 0));\n  \n          // Notify UI of new or updated transaction\n          NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n  \n          // notify an external script when a wallet transaction comes in or is updated\n          std::string strCmd = GetArg(\"-walletnotify\", \"\");\n  \n          if ( !strCmd.empty())\n          {\n              boost::replace_all(strCmd, \"%s\", wtxIn.GetHash().GetHex());\n              boost::thread t(runCommand, strCmd); // thread runs free\n          }\n  \n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "MarkDirty",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "407-414",
    "snippet": "void CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n            item.second.MarkDirty();\n    }\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "item.second.MarkDirty",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "MarkDirty",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "407-414",
          "snippet": "void CWallet::MarkDirty()\n{\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n            item.second.MarkDirty();\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  void CWallet::MarkDirty()\n  {\n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n              item.second.MarkDirty();\n      }\n  }\n}"
  },
  {
    "function_name": "WalletUpdateSpent",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "362-405",
    "snippet": "void CWallet::WalletUpdateSpent(const CTransaction &tx, bool fBlock)\n{\n    // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n    // Update the wallet spent flag if it doesn't know due to wallet.dat being\n    // restored from backup or the user making copies of wallet.dat.\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        {\n            map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n            if (mi != mapWallet.end())\n            {\n                CWalletTx& wtx = (*mi).second;\n                if (txin.prevout.n >= wtx.vout.size())\n                    printf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n                else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                {\n                    printf(\"WalletUpdateSpent found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkSpent(txin.prevout.n);\n                    wtx.WriteToDisk();\n                    NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n                }\n            }\n        }\n\n        if (fBlock)\n        {\n            uint256 hash = tx.GetHash();\n            map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n            CWalletTx& wtx = (*mi).second;\n\n            BOOST_FOREACH(const CTxOut& txout, tx.vout)\n            {\n                if (IsMine(txout))\n                {\n                    wtx.MarkUnspent(&txout - &tx.vout[0]);\n                    wtx.WriteToDisk();\n                    NotifyTransactionChanged(this, hash, CT_UPDATED);\n                }\n            }\n        }\n\n    }\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "hash",
            "CT_UPDATED"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.WriteToDisk",
          "args": [],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "WriteToDisk",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "830-833",
          "snippet": "bool CWalletTx::WriteToDisk()\n{\n    return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWalletTx {\n  bool CWalletTx::WriteToDisk()\n  {\n      return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.MarkUnspent",
          "args": [
            "&txout - &tx.vout[0]"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "MarkUnspent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "553-563",
          "snippet": "void MarkUnspent(unsigned int nOut)\n    {\n        if (nOut >= vout.size())\n            throw std::runtime_error(\"CWalletTx::MarkUnspent() : nOut out of range\");\n        vfSpent.resize(vout.size());\n        if (vfSpent[nOut])\n        {\n            vfSpent[nOut] = false;\n            fAvailableCreditCached = false;\n        }\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void MarkUnspent(unsigned int nOut)\n      {\n          if (nOut >= vout.size())\n              throw std::runtime_error(\"CWalletTx::MarkUnspent() : nOut out of range\");\n          vfSpent.resize(vout.size());\n          if (vfSpent[nOut])\n          {\n              vfSpent[nOut] = false;\n              fAvailableCreditCached = false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsMine",
          "args": [
            "txout"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "581-595",
          "snippet": "bool CWallet::IsMine(const CTxIn &txin) const\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            const CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size())\n                if (IsMine(prev.vout[txin.prevout.n]))\n                    return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::IsMine(const CTxIn &txin) const\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              const CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size())\n                  if (IsMine(prev.vout[txin.prevout.n]))\n                      return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.find",
          "args": [
            "hash"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NotifyTransactionChanged",
          "args": [
            "this",
            "txin.prevout.hash",
            "CT_UPDATED"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.MarkSpent",
          "args": [
            "txin.prevout.n"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "MarkSpent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "541-551",
          "snippet": "void MarkSpent(unsigned int nOut)\n    {\n        if (nOut >= vout.size())\n            throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n        vfSpent.resize(vout.size());\n        if (!vfSpent[nOut])\n        {\n            vfSpent[nOut] = true;\n            fAvailableCreditCached = false;\n        }\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void MarkSpent(unsigned int nOut)\n      {\n          if (nOut >= vout.size())\n              throw std::runtime_error(\"CWalletTx::MarkSpent() : nOut out of range\");\n          vfSpent.resize(vout.size());\n          if (!vfSpent[nOut])\n          {\n              vfSpent[nOut] = true;\n              fAvailableCreditCached = false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WalletUpdateSpent found spent coin %s SUM %s\\n\"",
            "FormatMoney(wtx.GetCredit()).c_str()",
            "wtx.GetHash().ToString().c_str()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "wtx.GetCredit()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.GetCredit",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "GetCredit",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "585-597",
          "snippet": "int64_t GetCredit(bool fUseCache=true) const\n    {\n        // Must wait until coinbase is safely deep enough in the chain before valuing it\n        if ((IsCoinBase() || IsCoinStake()) && GetBlocksToMaturity() > 0)\n            return 0;\n\n        // GetBalance can assume transactions in mapWallet won't change\n        if (fUseCache && fCreditCached)\n            return nCreditCached;\n        nCreditCached = pwallet->GetCredit(*this);\n        fCreditCached = true;\n        return nCreditCached;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  int64_t GetCredit(bool fUseCache=true) const\n      {\n          // Must wait until coinbase is safely deep enough in the chain before valuing it\n          if ((IsCoinBase() || IsCoinStake()) && GetBlocksToMaturity() > 0)\n              return 0;\n  \n          // GetBalance can assume transactions in mapWallet won't change\n          if (fUseCache && fCreditCached)\n              return nCreditCached;\n          nCreditCached = pwallet->GetCredit(*this);\n          fCreditCached = true;\n          return nCreditCached;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.IsSpent",
          "args": [
            "txin.prevout.n"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "IsSpent",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "565-572",
          "snippet": "bool IsSpent(unsigned int nOut) const\n    {\n        if (nOut >= vout.size())\n            throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n        if (nOut >= vfSpent.size())\n            return false;\n        return (!!vfSpent[nOut]);\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  bool IsSpent(unsigned int nOut) const\n      {\n          if (nOut >= vout.size())\n              throw std::runtime_error(\"CWalletTx::IsSpent() : nOut out of range\");\n          if (nOut >= vfSpent.size())\n              return false;\n          return (!!vfSpent[nOut]);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WalletUpdateSpent: bad wtx %s\\n\"",
            "wtx.GetHash().ToString().c_str()"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.vout.size",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.end",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  void CWallet::WalletUpdateSpent(const CTransaction &tx, bool fBlock)\n  {\n      // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n      // Update the wallet spent flag if it doesn't know due to wallet.dat being\n      // restored from backup or the user making copies of wallet.dat.\n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(const CTxIn& txin, tx.vin)\n          {\n              map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n              if (mi != mapWallet.end())\n              {\n                  CWalletTx& wtx = (*mi).second;\n                  if (txin.prevout.n >= wtx.vout.size())\n                      printf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n                  else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                  {\n                      printf(\"WalletUpdateSpent found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                      wtx.MarkSpent(txin.prevout.n);\n                      wtx.WriteToDisk();\n                      NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n                  }\n              }\n          }\n  \n          if (fBlock)\n          {\n              uint256 hash = tx.GetHash();\n              map<uint256, CWalletTx>::iterator mi = mapWallet.find(hash);\n              CWalletTx& wtx = (*mi).second;\n  \n              BOOST_FOREACH(const CTxOut& txout, tx.vout)\n              {\n                  if (IsMine(txout))\n                  {\n                      wtx.MarkUnspent(&txout - &tx.vout[0]);\n                      wtx.WriteToDisk();\n                      NotifyTransactionChanged(this, hash, CT_UPDATED);\n                  }\n              }\n          }\n  \n      }\n  }\n}"
  },
  {
    "function_name": "OrderedTxItems",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "338-360",
    "snippet": "CWallet::TxItems CWallet::OrderedTxItems(std::list<CAccountingEntry>& acentries, std::string strAccount)\n{\n    CWalletDB walletdb(strWalletFile);\n\n    // First: get all CWalletTx and CAccountingEntry into a sorted-by-order multimap.\n    TxItems txOrdered;\n\n    // Note: maintaining indices in the database of (account,time) --> txid and (account, time) --> acentry\n    // would make this much faster for applications that do this a lot.\n    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        CWalletTx* wtx = &((*it).second);\n        txOrdered.insert(make_pair(wtx->nOrderPos, TxPair(wtx, (CAccountingEntry*)0)));\n    }\n    acentries.clear();\n    walletdb.ListAccountCreditDebit(strAccount, acentries);\n    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n    {\n        txOrdered.insert(make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n    }\n\n    return txOrdered;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txOrdered.insert",
          "args": [
            "make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry))"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "entry.nOrderPos",
            "TxPair((CWalletTx*)0, &entry)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TxPair",
          "args": [
            "(CWalletTx*)0",
            "&entry"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walletdb.ListAccountCreditDebit",
          "args": [
            "strAccount",
            "acentries"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ListAccountCreditDebit",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "69-110",
          "snippet": "void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n{\n    bool fAllAccounts = (strAccount == \"*\");\n\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n    unsigned int fFlags = DB_SET_RANGE;\n    while (true)\n    {\n        // Read next record\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        if (fFlags == DB_SET_RANGE)\n            ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n        {\n            pcursor->close();\n            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n        }\n\n        // Unserialize\n        string strType;\n        ssKey >> strType;\n        if (strType != \"acentry\")\n            break;\n        CAccountingEntry acentry;\n        ssKey >> acentry.strAccount;\n        if (!fAllAccounts && acentry.strAccount != strAccount)\n            break;\n\n        ssValue >> acentry;\n        ssKey >> acentry.nEntryNo;\n        entries.push_back(acentry);\n    }\n\n    pcursor->close();\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n  {\n      bool fAllAccounts = (strAccount == \"*\");\n  \n      Dbc* pcursor = GetCursor();\n      if (!pcursor)\n          throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n      unsigned int fFlags = DB_SET_RANGE;\n      while (true)\n      {\n          // Read next record\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          if (fFlags == DB_SET_RANGE)\n              ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n          fFlags = DB_NEXT;\n          if (ret == DB_NOTFOUND)\n              break;\n          else if (ret != 0)\n          {\n              pcursor->close();\n              throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n          }\n  \n          // Unserialize\n          string strType;\n          ssKey >> strType;\n          if (strType != \"acentry\")\n              break;\n          CAccountingEntry acentry;\n          ssKey >> acentry.strAccount;\n          if (!fAllAccounts && acentry.strAccount != strAccount)\n              break;\n  \n          ssValue >> acentry;\n          ssKey >> acentry.nEntryNo;\n          entries.push_back(acentry);\n      }\n  \n      pcursor->close();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "acentries.clear",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "wtx->nOrderPos",
            "TxPair(wtx, (CAccountingEntry*)0)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TxPair",
          "args": [
            "wtx",
            "(CAccountingEntry*)0"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapWallet.end",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapWallet.begin",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  CWallet::TxItems CWallet::OrderedTxItems(std::list<CAccountingEntry>& acentries, std::string strAccount)\n  {\n      CWalletDB walletdb(strWalletFile);\n  \n      // First: get all CWalletTx and CAccountingEntry into a sorted-by-order multimap.\n      TxItems txOrdered;\n  \n      // Note: maintaining indices in the database of (account,time) --> txid and (account, time) --> acentry\n      // would make this much faster for applications that do this a lot.\n      for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          CWalletTx* wtx = &((*it).second);\n          txOrdered.insert(make_pair(wtx->nOrderPos, TxPair(wtx, (CAccountingEntry*)0)));\n      }\n      acentries.clear();\n      walletdb.ListAccountCreditDebit(strAccount, acentries);\n      BOOST_FOREACH(CAccountingEntry& entry, acentries)\n      {\n          txOrdered.insert(make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n      }\n  \n      return txOrdered;\n  }\n}"
  },
  {
    "function_name": "IncOrderPosNext",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "327-336",
    "snippet": "int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n{\n    int64_t nRet = nOrderPosNext++;\n    if (pwalletdb) {\n        pwalletdb->WriteOrderPosNext(nOrderPosNext);\n    } else {\n        CWalletDB(strWalletFile).WriteOrderPosNext(nOrderPosNext);\n    }\n    return nRet;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "nOrderPosNext"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletdb->WriteOrderPosNext",
          "args": [
            "nOrderPosNext"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOrderPosNext",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "136-140",
          "snippet": "bool WriteOrderPosNext(int64_t nOrderPosNext)\n    {\n        nWalletDBUpdated++;\n        return Write(std::string(\"orderposnext\"), nOrderPosNext);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteOrderPosNext(int64_t nOrderPosNext)\n      {\n          nWalletDBUpdated++;\n          return Write(std::string(\"orderposnext\"), nOrderPosNext);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n  {\n      int64_t nRet = nOrderPosNext++;\n      if (pwalletdb) {\n          pwalletdb->WriteOrderPosNext(nOrderPosNext);\n      } else {\n          CWalletDB(strWalletFile).WriteOrderPosNext(nOrderPosNext);\n      }\n      return nRet;\n  }\n}"
  },
  {
    "function_name": "EncryptWallet",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "246-325",
    "snippet": "bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n{\n    if (IsCrypted())\n        return false;\n\n    CKeyingMaterial vMasterKey;\n    RandAddSeedPerfmon();\n\n    vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n    RAND_bytes(&vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n\n    CMasterKey kMasterKey(nDerivationMethodIndex);\n\n    RandAddSeedPerfmon();\n    kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n    RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n\n    CCrypter crypter;\n    int64_t nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n\n    nStartTime = GetTimeMillis();\n    crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n\n    if (kMasterKey.nDeriveIterations < 25000)\n        kMasterKey.nDeriveIterations = 25000;\n\n    printf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n\n    if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n        return false;\n    if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n        return false;\n\n    {\n        LOCK(cs_wallet);\n        mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n        if (fFileBacked)\n        {\n            pwalletdbEncryption = new CWalletDB(strWalletFile);\n            if (!pwalletdbEncryption->TxnBegin())\n                return false;\n            pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n        }\n\n        if (!EncryptKeys(vMasterKey))\n        {\n            if (fFileBacked)\n                pwalletdbEncryption->TxnAbort();\n            exit(1); //We now probably have half of our keys encrypted in memory, and half not...die and let the user reload their unencrypted wallet.\n        }\n\n        // Encryption was introduced in version 0.4.0\n        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n\n        if (fFileBacked)\n        {\n            if (!pwalletdbEncryption->TxnCommit())\n                exit(1); //We now have keys encrypted in memory, but no on disk...die to avoid confusion and let the user reload their unencrypted wallet.\n\n            delete pwalletdbEncryption;\n            pwalletdbEncryption = NULL;\n        }\n\n        Lock();\n        Unlock(strWalletPassphrase);\n        NewKeyPool();\n        Lock();\n\n        // Need to completely rewrite the wallet file; if we don't, bdb might keep\n        // bits of the unencrypted private key in slack space in the database file.\n        CDB::Rewrite(strWalletFile);\n\n    }\n    NotifyStatusChanged(this);\n\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NotifyStatusChanged",
          "args": [
            "this"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CDB::Rewrite",
          "args": [
            "strWalletFile"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Lock",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocked",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "134-144",
          "snippet": "bool IsLocked() const\n    {\n        if (!IsCrypted())\n            return false;\n        bool result;\n        {\n            LOCK(cs_KeyStore);\n            result = vMasterKey.empty();\n        }\n        return result;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsLocked() const\n      {\n          if (!IsCrypted())\n              return false;\n          bool result;\n          {\n              LOCK(cs_KeyStore);\n              result = vMasterKey.empty();\n          }\n          return result;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewKeyPool",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Unlock",
          "args": [
            "strWalletPassphrase"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "115-136",
          "snippet": "bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    if (!IsLocked())\n        return false;\n\n    CCrypter crypter;\n    CKeyingMaterial vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n  {\n      if (!IsLocked())\n          return false;\n  \n      CCrypter crypter;\n      CKeyingMaterial vMasterKey;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n          {\n              if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                  return false;\n              if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                  return false;\n              if (CCryptoKeyStore::Unlock(vMasterKey))\n                  return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletdbEncryption->TxnCommit",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetMinVersion",
          "args": [
            "FEATURE_WALLETCRYPT",
            "pwalletdbEncryption",
            "true"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "SetMinVersion",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "202-233",
          "snippet": "bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n{\n    if (nWalletVersion >= nVersion)\n        return true;\n\n    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n    if (fExplicit && nVersion > nWalletMaxVersion)\n            nVersion = FEATURE_LATEST;\n\n    nWalletVersion = nVersion;\n\n    if (nVersion > nWalletMaxVersion)\n        nWalletMaxVersion = nVersion;\n\n    if (fFileBacked)\n    {\n        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n        if (nWalletVersion >= 40000)\n        {\n            // Versions prior to 0.4.0 did not support the \"minversion\" record.\n            // Use a CCorruptAddress to make them crash instead.\n            CCorruptAddress corruptAddress;\n            pwalletdb->WriteSetting(\"addrIncoming\", corruptAddress);\n        }\n        if (nWalletVersion > 40000)\n            pwalletdb->WriteMinVersion(nWalletVersion);\n        if (!pwalletdbIn)\n            delete pwalletdb;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n  {\n      if (nWalletVersion >= nVersion)\n          return true;\n  \n      // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n      if (fExplicit && nVersion > nWalletMaxVersion)\n              nVersion = FEATURE_LATEST;\n  \n      nWalletVersion = nVersion;\n  \n      if (nVersion > nWalletMaxVersion)\n          nWalletMaxVersion = nVersion;\n  \n      if (fFileBacked)\n      {\n          CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n          if (nWalletVersion >= 40000)\n          {\n              // Versions prior to 0.4.0 did not support the \"minversion\" record.\n              // Use a CCorruptAddress to make them crash instead.\n              CCorruptAddress corruptAddress;\n              pwalletdb->WriteSetting(\"addrIncoming\", corruptAddress);\n          }\n          if (nWalletVersion > 40000)\n              pwalletdb->WriteMinVersion(nWalletVersion);\n          if (!pwalletdbIn)\n              delete pwalletdb;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletdbEncryption->TxnAbort",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "TxnAbort",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "168-173",
          "snippet": "bool TxnAbort()\n    {\n        delete activeBatch;\n        activeBatch = NULL;\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool TxnAbort()\n      {\n          delete activeBatch;\n          activeBatch = NULL;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncryptKeys",
          "args": [
            "vMasterKey"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "EncryptKeys",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "197-221",
          "snippet": "bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n{\n    {\n        LOCK(cs_KeyStore);\n        if (!mapCryptedKeys.empty() || IsCrypted())\n            return false;\n\n        fUseCrypto = true;\n        BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n        {\n            CKey key;\n            if (!key.SetSecret(mKey.second.first, mKey.second.second))\n                return false;\n            const CPubKey vchPubKey = key.GetPubKey();\n            std::vector<unsigned char> vchCryptedSecret;\n            bool fCompressed;\n            if (!EncryptSecret(vMasterKeyIn, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n                return false;\n            if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n                return false;\n        }\n        mapKeys.clear();\n    }\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n  {\n      {\n          LOCK(cs_KeyStore);\n          if (!mapCryptedKeys.empty() || IsCrypted())\n              return false;\n  \n          fUseCrypto = true;\n          BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n          {\n              CKey key;\n              if (!key.SetSecret(mKey.second.first, mKey.second.second))\n                  return false;\n              const CPubKey vchPubKey = key.GetPubKey();\n              std::vector<unsigned char> vchCryptedSecret;\n              bool fCompressed;\n              if (!EncryptSecret(vMasterKeyIn, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n                  return false;\n              if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n                  return false;\n          }\n          mapKeys.clear();\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletdbEncryption->WriteMasterKey",
          "args": [
            "nMasterKeyMaxID",
            "kMasterKey"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMasterKey",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "113-117",
          "snippet": "bool WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletdbEncryption->TxnBegin",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "TxnBegin",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "271-280",
          "snippet": "bool TxnBegin()\n    {\n        if (!pdb || activeTxn)\n            return false;\n        DbTxn* ptxn = bitdb.TxnBegin();\n        if (!ptxn)\n            return false;\n        activeTxn = ptxn;\n        return true;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnBegin()\n      {\n          if (!pdb || activeTxn)\n              return false;\n          DbTxn* ptxn = bitdb.TxnBegin();\n          if (!ptxn)\n              return false;\n          activeTxn = ptxn;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypter.Encrypt",
          "args": [
            "vMasterKey",
            "kMasterKey.vchCryptedKey"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "Encrypt",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "62-87",
          "snippet": "bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n{\n    if (!fKeySet)\n        return false;\n\n    // max ciphertext len for a n bytes of plaintext is\n    // n + AES_BLOCK_SIZE - 1 bytes\n    int nLen = vchPlaintext.size();\n    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n    vchCiphertext = std::vector<unsigned char> (nCLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchCiphertext.resize(nCLen + nFLen);\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // max ciphertext len for a n bytes of plaintext is\n      // n + AES_BLOCK_SIZE - 1 bytes\n      int nLen = vchPlaintext.size();\n      int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n      vchCiphertext = std::vector<unsigned char> (nCLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n      if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchCiphertext.resize(nCLen + nFLen);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypter.SetKeyFromPassphrase",
          "args": [
            "strWalletPassphrase",
            "kMasterKey.vchSalt",
            "kMasterKey.nDeriveIterations",
            "kMasterKey.nDerivationMethod"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "SetKeyFromPassphrase",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "16-48",
          "snippet": "bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n{\n    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n        return false;\n\n    int i = 0;\n    if (nDerivationMethod == 0)\n    {\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n    }\n\n    if (nDerivationMethod == 1)\n    {\n        // Passphrase conversion\n        uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n        OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n    }\n\n\n    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n    {\n        OPENSSL_cleanse(&chKey, sizeof chKey);\n        OPENSSL_cleanse(&chIV, sizeof chIV);\n        return false;\n    }\n\n    fKeySet = true;\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n  {\n      if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n          return false;\n  \n      int i = 0;\n      if (nDerivationMethod == 0)\n      {\n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n      }\n  \n      if (nDerivationMethod == 1)\n      {\n          // Passphrase conversion\n          uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n  \n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n          OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n      }\n  \n  \n      if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n      {\n          OPENSSL_cleanse(&chKey, sizeof chKey);\n          OPENSSL_cleanse(&chIV, sizeof chIV);\n          return false;\n      }\n  \n      fKeySet = true;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Encrypting Wallet with an nDeriveIterations of %i\\n\"",
            "kMasterKey.nDeriveIterations"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTimeMillis",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "&kMasterKey.vchSalt[0]",
            "WALLET_CRYPTO_SALT_SIZE"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kMasterKey.vchSalt.resize",
          "args": [
            "WALLET_CRYPTO_SALT_SIZE"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandAddSeedPerfmon",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "RandAddSeedPerfmon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "146-171",
          "snippet": "void RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "&vMasterKey[0]",
            "WALLET_CRYPTO_KEY_SIZE"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsCrypted",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "IsCrypted",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "129-132",
          "snippet": "bool IsCrypted() const\n    {\n        return fUseCrypto;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsCrypted() const\n      {\n          return fUseCrypto;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n  {\n      if (IsCrypted())\n          return false;\n  \n      CKeyingMaterial vMasterKey;\n      RandAddSeedPerfmon();\n  \n      vMasterKey.resize(WALLET_CRYPTO_KEY_SIZE);\n      RAND_bytes(&vMasterKey[0], WALLET_CRYPTO_KEY_SIZE);\n  \n      CMasterKey kMasterKey(nDerivationMethodIndex);\n  \n      RandAddSeedPerfmon();\n      kMasterKey.vchSalt.resize(WALLET_CRYPTO_SALT_SIZE);\n      RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n  \n      CCrypter crypter;\n      int64_t nStartTime = GetTimeMillis();\n      crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n      kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n  \n      nStartTime = GetTimeMillis();\n      crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n      kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n  \n      if (kMasterKey.nDeriveIterations < 25000)\n          kMasterKey.nDeriveIterations = 25000;\n  \n      printf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n  \n      if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n          return false;\n      if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n          return false;\n  \n      {\n          LOCK(cs_wallet);\n          mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n          if (fFileBacked)\n          {\n              pwalletdbEncryption = new CWalletDB(strWalletFile);\n              if (!pwalletdbEncryption->TxnBegin())\n                  return false;\n              pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n          }\n  \n          if (!EncryptKeys(vMasterKey))\n          {\n              if (fFileBacked)\n                  pwalletdbEncryption->TxnAbort();\n              exit(1); //We now probably have half of our keys encrypted in memory, and half not...die and let the user reload their unencrypted wallet.\n          }\n  \n          // Encryption was introduced in version 0.4.0\n          SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n  \n          if (fFileBacked)\n          {\n              if (!pwalletdbEncryption->TxnCommit())\n                  exit(1); //We now have keys encrypted in memory, but no on disk...die to avoid confusion and let the user reload their unencrypted wallet.\n  \n              delete pwalletdbEncryption;\n              pwalletdbEncryption = NULL;\n          }\n  \n          Lock();\n          Unlock(strWalletPassphrase);\n          NewKeyPool();\n          Lock();\n  \n          // Need to completely rewrite the wallet file; if we don't, bdb might keep\n          // bits of the unencrypted private key in slack space in the database file.\n          CDB::Rewrite(strWalletFile);\n  \n      }\n      NotifyStatusChanged(this);\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "SetMaxVersion",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "235-244",
    "snippet": "bool CWallet::SetMaxVersion(int nVersion)\n{\n    // cannot downgrade below current version\n    if (nWalletVersion > nVersion)\n        return false;\n\n    nWalletMaxVersion = nVersion;\n\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::SetMaxVersion(int nVersion)\n  {\n      // cannot downgrade below current version\n      if (nWalletVersion > nVersion)\n          return false;\n  \n      nWalletMaxVersion = nVersion;\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "SetMinVersion",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "202-233",
    "snippet": "bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n{\n    if (nWalletVersion >= nVersion)\n        return true;\n\n    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n    if (fExplicit && nVersion > nWalletMaxVersion)\n            nVersion = FEATURE_LATEST;\n\n    nWalletVersion = nVersion;\n\n    if (nVersion > nWalletMaxVersion)\n        nWalletMaxVersion = nVersion;\n\n    if (fFileBacked)\n    {\n        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n        if (nWalletVersion >= 40000)\n        {\n            // Versions prior to 0.4.0 did not support the \"minversion\" record.\n            // Use a CCorruptAddress to make them crash instead.\n            CCorruptAddress corruptAddress;\n            pwalletdb->WriteSetting(\"addrIncoming\", corruptAddress);\n        }\n        if (nWalletVersion > 40000)\n            pwalletdb->WriteMinVersion(nWalletVersion);\n        if (!pwalletdbIn)\n            delete pwalletdb;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwalletdb->WriteMinVersion",
          "args": [
            "nWalletVersion"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletdb->WriteSetting",
          "args": [
            "\"addrIncoming\"",
            "corruptAddress"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSetting",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "173-177",
          "snippet": "bool WriteSetting(const std::string& strKey, const T& value)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteSetting(const std::string& strKey, const T& value)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n  {\n      if (nWalletVersion >= nVersion)\n          return true;\n  \n      // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n      if (fExplicit && nVersion > nWalletMaxVersion)\n              nVersion = FEATURE_LATEST;\n  \n      nWalletVersion = nVersion;\n  \n      if (nVersion > nWalletMaxVersion)\n          nWalletMaxVersion = nVersion;\n  \n      if (fFileBacked)\n      {\n          CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n          if (nWalletVersion >= 40000)\n          {\n              // Versions prior to 0.4.0 did not support the \"minversion\" record.\n              // Use a CCorruptAddress to make them crash instead.\n              CCorruptAddress corruptAddress;\n              pwalletdb->WriteSetting(\"addrIncoming\", corruptAddress);\n          }\n          if (nWalletVersion > 40000)\n              pwalletdb->WriteMinVersion(nWalletVersion);\n          if (!pwalletdbIn)\n              delete pwalletdb;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "SetBestChain",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "184-188",
    "snippet": "void CWallet::SetBestChain(const CBlockLocator& loc)\n{\n    CWalletDB walletdb(strWalletFile);\n    walletdb.WriteBestBlock(loc);\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walletdb.WriteBestBlock",
          "args": [
            "loc"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "WriteBestBlock",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "125-129",
          "snippet": "bool WriteBestBlock(const CBlockLocator& locator)\n    {\n        nWalletDBUpdated++;\n        return Write(std::string(\"bestblock\"), locator);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteBestBlock(const CBlockLocator& locator)\n      {\n          nWalletDBUpdated++;\n          return Write(std::string(\"bestblock\"), locator);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  void CWallet::SetBestChain(const CBlockLocator& loc)\n  {\n      CWalletDB walletdb(strWalletFile);\n      walletdb.WriteBestBlock(loc);\n  }\n}"
  },
  {
    "function_name": "ChangeWalletPassphrase",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "138-182",
    "snippet": "bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n{\n    bool fWasLocked = IsLocked();\n\n    {\n        LOCK(cs_wallet);\n        Lock();\n\n        CCrypter crypter;\n        CKeyingMaterial vMasterKey;\n        BOOST_FOREACH(MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n            {\n                int64_t nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime)));\n\n                nStartTime = GetTimeMillis();\n                crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n\n                if (pMasterKey.second.nDeriveIterations < 25000)\n                    pMasterKey.second.nDeriveIterations = 25000;\n\n                printf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n\n                if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                    return false;\n                if (!crypter.Encrypt(vMasterKey, pMasterKey.second.vchCryptedKey))\n                    return false;\n                CWalletDB(strWalletFile).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                if (fWasLocked)\n                    Lock();\n                return true;\n            }\n        }\n    }\n\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lock",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocked",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "134-144",
          "snippet": "bool IsLocked() const\n    {\n        if (!IsCrypted())\n            return false;\n        bool result;\n        {\n            LOCK(cs_KeyStore);\n            result = vMasterKey.empty();\n        }\n        return result;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsLocked() const\n      {\n          if (!IsCrypted())\n              return false;\n          bool result;\n          {\n              LOCK(cs_KeyStore);\n              result = vMasterKey.empty();\n          }\n          return result;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "pMasterKey.first",
            "pMasterKey.second"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSetting",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "173-177",
          "snippet": "bool WriteSetting(const std::string& strKey, const T& value)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteSetting(const std::string& strKey, const T& value)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "strWalletFile"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypter.Encrypt",
          "args": [
            "vMasterKey",
            "pMasterKey.second.vchCryptedKey"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "Encrypt",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "62-87",
          "snippet": "bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n{\n    if (!fKeySet)\n        return false;\n\n    // max ciphertext len for a n bytes of plaintext is\n    // n + AES_BLOCK_SIZE - 1 bytes\n    int nLen = vchPlaintext.size();\n    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n    vchCiphertext = std::vector<unsigned char> (nCLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchCiphertext.resize(nCLen + nFLen);\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // max ciphertext len for a n bytes of plaintext is\n      // n + AES_BLOCK_SIZE - 1 bytes\n      int nLen = vchPlaintext.size();\n      int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n      vchCiphertext = std::vector<unsigned char> (nCLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n      if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchCiphertext.resize(nCLen + nFLen);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypter.SetKeyFromPassphrase",
          "args": [
            "strNewWalletPassphrase",
            "pMasterKey.second.vchSalt",
            "pMasterKey.second.nDeriveIterations",
            "pMasterKey.second.nDerivationMethod"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "SetKeyFromPassphrase",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "16-48",
          "snippet": "bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n{\n    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n        return false;\n\n    int i = 0;\n    if (nDerivationMethod == 0)\n    {\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n    }\n\n    if (nDerivationMethod == 1)\n    {\n        // Passphrase conversion\n        uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n        OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n    }\n\n\n    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n    {\n        OPENSSL_cleanse(&chKey, sizeof chKey);\n        OPENSSL_cleanse(&chIV, sizeof chIV);\n        return false;\n    }\n\n    fKeySet = true;\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n  {\n      if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n          return false;\n  \n      int i = 0;\n      if (nDerivationMethod == 0)\n      {\n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n      }\n  \n      if (nDerivationMethod == 1)\n      {\n          // Passphrase conversion\n          uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n  \n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n          OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n      }\n  \n  \n      if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n      {\n          OPENSSL_cleanse(&chKey, sizeof chKey);\n          OPENSSL_cleanse(&chIV, sizeof chIV);\n          return false;\n      }\n  \n      fKeySet = true;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Wallet passphrase changed to an nDeriveIterations of %i\\n\"",
            "pMasterKey.second.nDeriveIterations"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTimeMillis",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCryptoKeyStore::Unlock",
          "args": [
            "vMasterKey"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "115-136",
          "snippet": "bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    if (!IsLocked())\n        return false;\n\n    CCrypter crypter;\n    CKeyingMaterial vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n  {\n      if (!IsLocked())\n          return false;\n  \n      CCrypter crypter;\n      CKeyingMaterial vMasterKey;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n          {\n              if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                  return false;\n              if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                  return false;\n              if (CCryptoKeyStore::Unlock(vMasterKey))\n                  return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypter.Decrypt",
          "args": [
            "pMasterKey.second.vchCryptedKey",
            "vMasterKey"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "Decrypt",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "89-114",
          "snippet": "bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n{\n    if (!fKeySet)\n        return false;\n\n    // plaintext will always be equal to or lesser than length of ciphertext\n    int nLen = vchCiphertext.size();\n    int nPLen = nLen, nFLen = 0;\n\n    vchPlaintext = CKeyingMaterial(nPLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchPlaintext.resize(nPLen + nFLen);\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // plaintext will always be equal to or lesser than length of ciphertext\n      int nLen = vchCiphertext.size();\n      int nPLen = nLen, nFLen = 0;\n  \n      vchPlaintext = CKeyingMaterial(nPLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n      if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchPlaintext.resize(nPLen + nFLen);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n  {\n      bool fWasLocked = IsLocked();\n  \n      {\n          LOCK(cs_wallet);\n          Lock();\n  \n          CCrypter crypter;\n          CKeyingMaterial vMasterKey;\n          BOOST_FOREACH(MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n          {\n              if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                  return false;\n              if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                  return false;\n              if (CCryptoKeyStore::Unlock(vMasterKey))\n              {\n                  int64_t nStartTime = GetTimeMillis();\n                  crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                  pMasterKey.second.nDeriveIterations = pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime)));\n  \n                  nStartTime = GetTimeMillis();\n                  crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n                  pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n  \n                  if (pMasterKey.second.nDeriveIterations < 25000)\n                      pMasterKey.second.nDeriveIterations = 25000;\n  \n                  printf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n  \n                  if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                      return false;\n                  if (!crypter.Encrypt(vMasterKey, pMasterKey.second.vchCryptedKey))\n                      return false;\n                  CWalletDB(strWalletFile).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                  if (fWasLocked)\n                      Lock();\n                  return true;\n              }\n          }\n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "Unlock",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "115-136",
    "snippet": "bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    if (!IsLocked())\n        return false;\n\n    CCrypter crypter;\n    CKeyingMaterial vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CCryptoKeyStore::Unlock",
          "args": [
            "vMasterKey"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "115-136",
          "snippet": "bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n{\n    if (!IsLocked())\n        return false;\n\n    CCrypter crypter;\n    CKeyingMaterial vMasterKey;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n        {\n            if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                return false;\n            if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                return false;\n            if (CCryptoKeyStore::Unlock(vMasterKey))\n                return true;\n        }\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "crypter.Decrypt",
          "args": [
            "pMasterKey.second.vchCryptedKey",
            "vMasterKey"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "Decrypt",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "89-114",
          "snippet": "bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n{\n    if (!fKeySet)\n        return false;\n\n    // plaintext will always be equal to or lesser than length of ciphertext\n    int nLen = vchCiphertext.size();\n    int nPLen = nLen, nFLen = 0;\n\n    vchPlaintext = CKeyingMaterial(nPLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchPlaintext.resize(nPLen + nFLen);\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // plaintext will always be equal to or lesser than length of ciphertext\n      int nLen = vchCiphertext.size();\n      int nPLen = nLen, nFLen = 0;\n  \n      vchPlaintext = CKeyingMaterial(nPLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n      if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchPlaintext.resize(nPLen + nFLen);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypter.SetKeyFromPassphrase",
          "args": [
            "strWalletPassphrase",
            "pMasterKey.second.vchSalt",
            "pMasterKey.second.nDeriveIterations",
            "pMasterKey.second.nDerivationMethod"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "SetKeyFromPassphrase",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "16-48",
          "snippet": "bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n{\n    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n        return false;\n\n    int i = 0;\n    if (nDerivationMethod == 0)\n    {\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n    }\n\n    if (nDerivationMethod == 1)\n    {\n        // Passphrase conversion\n        uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n        OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n    }\n\n\n    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n    {\n        OPENSSL_cleanse(&chKey, sizeof chKey);\n        OPENSSL_cleanse(&chIV, sizeof chIV);\n        return false;\n    }\n\n    fKeySet = true;\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n  {\n      if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n          return false;\n  \n      int i = 0;\n      if (nDerivationMethod == 0)\n      {\n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n      }\n  \n      if (nDerivationMethod == 1)\n      {\n          // Passphrase conversion\n          uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n  \n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n          OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n      }\n  \n  \n      if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n      {\n          OPENSSL_cleanse(&chKey, sizeof chKey);\n          OPENSSL_cleanse(&chIV, sizeof chIV);\n          return false;\n      }\n  \n      fKeySet = true;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsLocked",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocked",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "134-144",
          "snippet": "bool IsLocked() const\n    {\n        if (!IsCrypted())\n            return false;\n        bool result;\n        {\n            LOCK(cs_KeyStore);\n            result = vMasterKey.empty();\n        }\n        return result;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsLocked() const\n      {\n          if (!IsCrypted())\n              return false;\n          bool result;\n          {\n              LOCK(cs_KeyStore);\n              result = vMasterKey.empty();\n          }\n          return result;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n  {\n      if (!IsLocked())\n          return false;\n  \n      CCrypter crypter;\n      CKeyingMaterial vMasterKey;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n          {\n              if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                  return false;\n              if (!crypter.Decrypt(pMasterKey.second.vchCryptedKey, vMasterKey))\n                  return false;\n              if (CCryptoKeyStore::Unlock(vMasterKey))\n                  return true;\n          }\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "AddCScript",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "101-108",
    "snippet": "bool CWallet::AddCScript(const CScript& redeemScript)\n{\n    if (!CCryptoKeyStore::AddCScript(redeemScript))\n        return false;\n    if (!fFileBacked)\n        return true;\n    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "Hash160(redeemScript)",
            "redeemScript"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSetting",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "173-177",
          "snippet": "bool WriteSetting(const std::string& strKey, const T& value)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteSetting(const std::string& strKey, const T& value)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"setting\"), strKey), value);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash160",
          "args": [
            "redeemScript"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "Hash160",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "554-561",
          "snippet": "inline uint160 Hash160(const std::vector<unsigned char>& vch)\n{\n    uint256 hash1;\n    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n    uint160 hash2;\n    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n    return hash2;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline uint160 Hash160(const std::vector<unsigned char>& vch)\n{\n    uint256 hash1;\n    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n    uint160 hash2;\n    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n    return hash2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "strWalletFile"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCryptoKeyStore::AddCScript",
          "args": [
            "redeemScript"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "AddCScript",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "101-108",
          "snippet": "bool CWallet::AddCScript(const CScript& redeemScript)\n{\n    if (!CCryptoKeyStore::AddCScript(redeemScript))\n        return false;\n    if (!fFileBacked)\n        return true;\n    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddCScript(const CScript& redeemScript)\n  {\n      if (!CCryptoKeyStore::AddCScript(redeemScript))\n          return false;\n      if (!fFileBacked)\n          return true;\n      return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n  }\n}"
  },
  {
    "function_name": "LoadCryptedKey",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "96-99",
    "snippet": "bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n{\n    return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CCryptoKeyStore::AddCryptedKey",
          "args": [
            "vchPubKey",
            "vchCryptedSecret"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "AddCryptedKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "71-85",
          "snippet": "bool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    if (!fFileBacked)\n        return true;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n        else\n            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n  {\n      if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n          return false;\n      if (!fFileBacked)\n          return true;\n      {\n          LOCK(cs_wallet);\n          if (pwalletdbEncryption)\n              return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n          else\n              return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n  {\n      return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n  }\n}"
  },
  {
    "function_name": "LoadKeyMetadata",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "87-94",
    "snippet": "bool CWallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n{\n    if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n        nTimeFirstKey = meta.nCreateTime;\n\n    mapKeyMetadata[pubkey.GetID()] = meta;\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pubkey.GetID",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n  {\n      if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n          nTimeFirstKey = meta.nCreateTime;\n  \n      mapKeyMetadata[pubkey.GetID()] = meta;\n      return true;\n  }\n}"
  },
  {
    "function_name": "AddCryptedKey",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "71-85",
    "snippet": "bool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    if (!fFileBacked)\n        return true;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n        else\n            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "vchPubKey",
            "vchCryptedSecret",
            "mapKeyMetadata[vchPubKey.GetID()]"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "WriteCryptedKey",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "95-111",
          "snippet": "bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, const CKeyMetadata &keyMeta)\n    {\n        nWalletDBUpdated++;\n        bool fEraseUnencryptedKey = true;\n\n        if(!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta))\n            return false;\n\n        if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey.Raw()), vchCryptedSecret, false))\n            return false;\n        if (fEraseUnencryptedKey)\n        {\n            Erase(std::make_pair(std::string(\"key\"), vchPubKey.Raw()));\n            Erase(std::make_pair(std::string(\"wkey\"), vchPubKey.Raw()));\n        }\n        return true;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, const CKeyMetadata &keyMeta)\n      {\n          nWalletDBUpdated++;\n          bool fEraseUnencryptedKey = true;\n  \n          if(!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta))\n              return false;\n  \n          if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey.Raw()), vchCryptedSecret, false))\n              return false;\n          if (fEraseUnencryptedKey)\n          {\n              Erase(std::make_pair(std::string(\"key\"), vchPubKey.Raw()));\n              Erase(std::make_pair(std::string(\"wkey\"), vchPubKey.Raw()));\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchPubKey.GetID",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "strWalletFile"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_wallet"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCryptoKeyStore::AddCryptedKey",
          "args": [
            "vchPubKey",
            "vchCryptedSecret"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "AddCryptedKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "71-85",
          "snippet": "bool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n{\n    if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n        return false;\n    if (!fFileBacked)\n        return true;\n    {\n        LOCK(cs_wallet);\n        if (pwalletdbEncryption)\n            return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n        else\n            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddCryptedKey(const CPubKey &vchPubKey, const vector<unsigned char> &vchCryptedSecret)\n  {\n      if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n          return false;\n      if (!fFileBacked)\n          return true;\n      {\n          LOCK(cs_wallet);\n          if (pwalletdbEncryption)\n              return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n          else\n              return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey, vchCryptedSecret, mapKeyMetadata[vchPubKey.GetID()]);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "AddKey",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "58-69",
    "snippet": "bool CWallet::AddKey(const CKey& key)\n{\n    CPubKey pubkey = key.GetPubKey();\n\n    if (!CCryptoKeyStore::AddKey(key))\n        return false;\n    if (!fFileBacked)\n        return true;\n    if (!IsCrypted())\n        return CWalletDB(strWalletFile).WriteKey(pubkey, key.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "pubkey",
            "key.GetPrivKey()",
            "mapKeyMetadata[pubkey.GetID()]"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "WriteCryptedKey",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "95-111",
          "snippet": "bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, const CKeyMetadata &keyMeta)\n    {\n        nWalletDBUpdated++;\n        bool fEraseUnencryptedKey = true;\n\n        if(!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta))\n            return false;\n\n        if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey.Raw()), vchCryptedSecret, false))\n            return false;\n        if (fEraseUnencryptedKey)\n        {\n            Erase(std::make_pair(std::string(\"key\"), vchPubKey.Raw()));\n            Erase(std::make_pair(std::string(\"wkey\"), vchPubKey.Raw()));\n        }\n        return true;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteCryptedKey(const CPubKey& vchPubKey, const std::vector<unsigned char>& vchCryptedSecret, const CKeyMetadata &keyMeta)\n      {\n          nWalletDBUpdated++;\n          bool fEraseUnencryptedKey = true;\n  \n          if(!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta))\n              return false;\n  \n          if (!Write(std::make_pair(std::string(\"ckey\"), vchPubKey.Raw()), vchCryptedSecret, false))\n              return false;\n          if (fEraseUnencryptedKey)\n          {\n              Erase(std::make_pair(std::string(\"key\"), vchPubKey.Raw()));\n              Erase(std::make_pair(std::string(\"wkey\"), vchPubKey.Raw()));\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubkey.GetID",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.GetPrivKey",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "GetPrivKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "247-257",
          "snippet": "CPrivKey CKey::GetPrivKey() const\n{\n    int nSize = i2d_ECPrivateKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n    CPrivKey vchPrivKey(nSize, 0);\n    unsigned char* pbegin = &vchPrivKey[0];\n    if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n    return vchPrivKey;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPrivKey CKey::GetPrivKey() const\n  {\n      int nSize = i2d_ECPrivateKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n      CPrivKey vchPrivKey(nSize, 0);\n      unsigned char* pbegin = &vchPrivKey[0];\n      if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n      return vchPrivKey;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CWalletDB",
          "args": [
            "strWalletFile"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "WriteMinVersion",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "184-187",
          "snippet": "bool WriteMinVersion(int nVersion)\n    {\n        return Write(std::string(\"minversion\"), nVersion);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteMinVersion(int nVersion)\n      {\n          return Write(std::string(\"minversion\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCrypted",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "IsCrypted",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "129-132",
          "snippet": "bool IsCrypted() const\n    {\n        return fUseCrypto;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsCrypted() const\n      {\n          return fUseCrypto;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCryptoKeyStore::AddKey",
          "args": [
            "key"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "AddKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "58-69",
          "snippet": "bool CWallet::AddKey(const CKey& key)\n{\n    CPubKey pubkey = key.GetPubKey();\n\n    if (!CCryptoKeyStore::AddKey(key))\n        return false;\n    if (!fFileBacked)\n        return true;\n    if (!IsCrypted())\n        return CWalletDB(strWalletFile).WriteKey(pubkey, key.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddKey(const CKey& key)\n  {\n      CPubKey pubkey = key.GetPubKey();\n  \n      if (!CCryptoKeyStore::AddKey(key))\n          return false;\n      if (!fFileBacked)\n          return true;\n      if (!IsCrypted())\n          return CWalletDB(strWalletFile).WriteKey(pubkey, key.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n      return true;\n  }\n}"
  },
  {
    "function_name": "GenerateNewKey",
    "container": "CWallet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
    "lines": "33-56",
    "snippet": "CPubKey CWallet::GenerateNewKey()\n{\n    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n\n    RandAddSeedPerfmon();\n    CKey key;\n    key.MakeNewKey(fCompressed);\n\n    // Compressed public keys were introduced in version 0.6.0\n    if (fCompressed)\n        SetMinVersion(FEATURE_COMPRPUBKEY);\n\n    CPubKey pubkey = key.GetPubKey();\n\n    // Create new metadata\n    int64_t nCreationTime = GetTime();\n    mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n    if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n        nTimeFirstKey = nCreationTime;\n\n    if (!AddKey(key))\n        throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n    return key.GetPubKey();\n}",
    "includes": [
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"coincontrol.h\"",
      "#include \"kernel.h\"",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"crypter.h\"",
      "#include \"walletdb.h\"",
      "#include \"wallet.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::runtime_error",
          "args": [
            "\"CWallet::GenerateNewKey() : AddKey failed\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddKey",
          "args": [
            "key"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "AddKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "58-69",
          "snippet": "bool CWallet::AddKey(const CKey& key)\n{\n    CPubKey pubkey = key.GetPubKey();\n\n    if (!CCryptoKeyStore::AddKey(key))\n        return false;\n    if (!fFileBacked)\n        return true;\n    if (!IsCrypted())\n        return CWalletDB(strWalletFile).WriteKey(pubkey, key.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::AddKey(const CKey& key)\n  {\n      CPubKey pubkey = key.GetPubKey();\n  \n      if (!CCryptoKeyStore::AddKey(key))\n          return false;\n      if (!fFileBacked)\n          return true;\n      if (!IsCrypted())\n          return CWalletDB(strWalletFile).WriteKey(pubkey, key.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CKeyMetadata",
          "args": [
            "nCreationTime"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyMetadata",
          "container": "CKeyMetadata",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "37-41",
          "snippet": "CKeyMetadata(int64_t nCreateTime_)\n    {\n        nVersion = CKeyMetadata::CURRENT_VERSION;\n        nCreateTime = nCreateTime_;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCKeyMetadata {\n  CKeyMetadata(int64_t nCreateTime_)\n      {\n          nVersion = CKeyMetadata::CURRENT_VERSION;\n          nCreateTime = nCreateTime_;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubkey.GetID",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetMinVersion",
          "args": [
            "FEATURE_COMPRPUBKEY"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.MakeNewKey",
          "args": [
            "fCompressed"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "MakeNewKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "177-184",
          "snippet": "void CKey::MakeNewKey(bool fCompressed)\n{\n    if (!EC_KEY_generate_key(pkey))\n        throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n    if (fCompressed)\n        SetCompressedPubKey();\n    fSet = true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::MakeNewKey(bool fCompressed)\n  {\n      if (!EC_KEY_generate_key(pkey))\n          throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n      if (fCompressed)\n          SetCompressedPubKey();\n      fSet = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandAddSeedPerfmon",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "RandAddSeedPerfmon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "146-171",
          "snippet": "void RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CanSupportFeature",
          "args": [
            "FEATURE_COMPRPUBKEY"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "CanSupportFeature",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "128-128",
          "snippet": "bool CanSupportFeature(enum WalletFeature wf) { return nWalletMaxVersion >= wf; }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  bool CanSupportFeature(enum WalletFeature wf) { return nWalletMaxVersion >= wf; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  CPubKey CWallet::GenerateNewKey()\n  {\n      bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n  \n      RandAddSeedPerfmon();\n      CKey key;\n      key.MakeNewKey(fCompressed);\n  \n      // Compressed public keys were introduced in version 0.6.0\n      if (fCompressed)\n          SetMinVersion(FEATURE_COMPRPUBKEY);\n  \n      CPubKey pubkey = key.GetPubKey();\n  \n      // Create new metadata\n      int64_t nCreationTime = GetTime();\n      mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n      if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n          nTimeFirstKey = nCreationTime;\n  \n      if (!AddKey(key))\n          throw std::runtime_error(\"CWallet::GenerateNewKey() : AddKey failed\");\n      return key.GetPubKey();\n  }\n}"
  }
]