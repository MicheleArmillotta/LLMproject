[
  {
    "function_name": "NewId",
    "container": "ShardedLRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "313-316",
    "snippet": "virtual uint64_t NewId() {\n    MutexLock l(&id_mutex_);\n    return ++(last_id_);\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual uint64_t NewId() {\n      MutexLock l(&id_mutex_);\n      return ++(last_id_);\n    }\n}"
  },
  {
    "function_name": "Erase",
    "container": "ShardedLRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "306-309",
    "snippet": "virtual void Erase(const Slice& key) {\n    const uint32_t hash = HashSlice(key);\n    shard_[Shard(hash)].Erase(key, hash);\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shard_[Shard",
          "args": [
            "key",
            "hash"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Shard",
          "args": [
            "hash"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "Erase",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "306-309",
          "snippet": "virtual void Erase(const Slice& key) {\n    const uint32_t hash = HashSlice(key);\n    shard_[Shard(hash)].Erase(key, hash);\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "HashSlice",
          "args": [
            "key"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual void Erase(const Slice& key) {\n      const uint32_t hash = HashSlice(key);\n      shard_[Shard(hash)].Erase(key, hash);\n    }\n}"
  },
  {
    "function_name": "Release",
    "container": "ShardedLRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "302-305",
    "snippet": "virtual void Release(Handle* handle) {\n    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n    shard_[Shard(h->hash)].Release(handle);\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shard_[Shard",
          "args": [
            "handle"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Shard",
          "args": [
            "h->hash"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "Erase",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "306-309",
          "snippet": "virtual void Erase(const Slice& key) {\n    const uint32_t hash = HashSlice(key);\n    shard_[Shard(hash)].Erase(key, hash);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual void Erase(const Slice& key) {\n      const uint32_t hash = HashSlice(key);\n      shard_[Shard(hash)].Erase(key, hash);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<LRUHandle*>",
          "args": [
            "handle"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual void Release(Handle* handle) {\n      LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n      shard_[Shard(h->hash)].Release(handle);\n    }\n}"
  },
  {
    "function_name": "ShardedLRUCache",
    "container": "ShardedLRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "285-291",
    "snippet": "explicit ShardedLRUCache(size_t capacity)\n      : last_id_(0) {\n    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;\n    for (int s = 0; s < kNumShards; s++) {\n      shard_[s].SetCapacity(per_shard);\n    }\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shard_[s].SetCapacity",
          "args": [
            "per_shard"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "SetCapacity",
          "container": "LRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "141-141",
          "snippet": "void SetCapacity(size_t capacity) { capacity_ = capacity; }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void SetCapacity(size_t capacity) { capacity_ = capacity; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  explicit ShardedLRUCache(size_t capacity)\n        : last_id_(0) {\n      const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;\n      for (int s = 0; s < kNumShards; s++) {\n        shard_[s].SetCapacity(per_shard);\n      }\n    }\n}"
  },
  {
    "function_name": "Shard",
    "container": "ShardedLRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "280-282",
    "snippet": "static uint32_t Shard(uint32_t hash) {\n    return hash >> (32 - kNumShardBits);\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static uint32_t Shard(uint32_t hash) {\n      return hash >> (32 - kNumShardBits);\n    }\n}"
  },
  {
    "function_name": "HashSlice",
    "container": "ShardedLRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "276-278",
    "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "s.data()",
            "s.size()",
            "0"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/hash.cc",
          "lines": "18-49",
          "snippet": "uint32_t Hash(const char* data, size_t n, uint32_t seed) {\n  // Similar to murmur hash\n  const uint32_t m = 0xc6a4a793;\n  const uint32_t r = 24;\n  const char* limit = data + n;\n  uint32_t h = seed ^ (n * m);\n\n  // Pick up four bytes at a time\n  while (data + 4 <= limit) {\n    uint32_t w = DecodeFixed32(data);\n    data += 4;\n    h += w;\n    h *= m;\n    h ^= (h >> 16);\n  }\n\n  // Pick up remaining bytes\n  switch (limit - data) {\n    case 3:\n      h += data[2] << 16;\n      FALLTHROUGH_INTENDED;\n    case 2:\n      h += data[1] << 8;\n      FALLTHROUGH_INTENDED;\n    case 1:\n      h += data[0];\n      h *= m;\n      h ^= (h >> r);\n      break;\n  }\n  return h;\n}",
          "includes": [
            "#include \"util/hash.h\"",
            "#include \"util/coding.h\"",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define FALLTHROUGH_INTENDED do { } while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/hash.h\"\n#include \"util/coding.h\"\n#include <string.h>\n\n#define FALLTHROUGH_INTENDED do { } while (0)\n\nuint32_t Hash(const char* data, size_t n, uint32_t seed) {\n  // Similar to murmur hash\n  const uint32_t m = 0xc6a4a793;\n  const uint32_t r = 24;\n  const char* limit = data + n;\n  uint32_t h = seed ^ (n * m);\n\n  // Pick up four bytes at a time\n  while (data + 4 <= limit) {\n    uint32_t w = DecodeFixed32(data);\n    data += 4;\n    h += w;\n    h *= m;\n    h ^= (h >> 16);\n  }\n\n  // Pick up remaining bytes\n  switch (limit - data) {\n    case 3:\n      h += data[2] << 16;\n      FALLTHROUGH_INTENDED;\n    case 2:\n      h += data[1] << 8;\n      FALLTHROUGH_INTENDED;\n    case 1:\n      h += data[0];\n      h *= m;\n      h ^= (h >> r);\n      break;\n  }\n  return h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.data",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
  },
  {
    "function_name": "Erase",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "258-265",
    "snippet": "void LRUCache::Erase(const Slice& key, uint32_t hash) {\n  MutexLock l(&mutex_);\n  LRUHandle* e = table_.Remove(key, hash);\n  if (e != NULL) {\n    LRU_Remove(e);\n    Unref(e);\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Unref",
          "args": [
            "e"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "LRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "186-194",
          "snippet": "void LRUCache::Unref(LRUHandle* e) {\n  assert(e->refs > 0);\n  e->refs--;\n  if (e->refs <= 0) {\n    usage_ -= e->charge;\n    (*e->deleter)(e->key(), e->value);\n    free(e);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::Unref(LRUHandle* e) {\n    assert(e->refs > 0);\n    e->refs--;\n    if (e->refs <= 0) {\n      usage_ -= e->charge;\n      (*e->deleter)(e->key(), e->value);\n      free(e);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LRU_Remove",
          "args": [
            "e"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "LRU_Remove",
          "container": "LRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "196-199",
          "snippet": "void LRUCache::LRU_Remove(LRUHandle* e) {\n  e->next->prev = e->prev;\n  e->prev->next = e->next;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::LRU_Remove(LRUHandle* e) {\n    e->next->prev = e->prev;\n    e->prev->next = e->next;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_.Remove",
          "args": [
            "key",
            "hash"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::Erase(const Slice& key, uint32_t hash) {\n    MutexLock l(&mutex_);\n    LRUHandle* e = table_.Remove(key, hash);\n    if (e != NULL) {\n      LRU_Remove(e);\n      Unref(e);\n    }\n  }\n}"
  },
  {
    "function_name": "Release",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "220-223",
    "snippet": "void LRUCache::Release(Cache::Handle* handle) {\n  MutexLock l(&mutex_);\n  Unref(reinterpret_cast<LRUHandle*>(handle));\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Unref",
          "args": [
            "reinterpret_cast<LRUHandle*>(handle)"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "LRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "186-194",
          "snippet": "void LRUCache::Unref(LRUHandle* e) {\n  assert(e->refs > 0);\n  e->refs--;\n  if (e->refs <= 0) {\n    usage_ -= e->charge;\n    (*e->deleter)(e->key(), e->value);\n    free(e);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::Unref(LRUHandle* e) {\n    assert(e->refs > 0);\n    e->refs--;\n    if (e->refs <= 0) {\n      usage_ -= e->charge;\n      (*e->deleter)(e->key(), e->value);\n      free(e);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<LRUHandle*>",
          "args": [
            "handle"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::Release(Cache::Handle* handle) {\n    MutexLock l(&mutex_);\n    Unref(reinterpret_cast<LRUHandle*>(handle));\n  }\n}"
  },
  {
    "function_name": "LRU_Append",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "201-207",
    "snippet": "void LRUCache::LRU_Append(LRUHandle* e) {\n  // Make \"e\" newest entry by inserting just before lru_\n  e->next = &lru_;\n  e->prev = lru_.prev;\n  e->prev->next = e;\n  e->next->prev = e;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::LRU_Append(LRUHandle* e) {\n    // Make \"e\" newest entry by inserting just before lru_\n    e->next = &lru_;\n    e->prev = lru_.prev;\n    e->prev->next = e;\n    e->next->prev = e;\n  }\n}"
  },
  {
    "function_name": "LRU_Remove",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "196-199",
    "snippet": "void LRUCache::LRU_Remove(LRUHandle* e) {\n  e->next->prev = e->prev;\n  e->prev->next = e->next;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::LRU_Remove(LRUHandle* e) {\n    e->next->prev = e->prev;\n    e->prev->next = e->next;\n  }\n}"
  },
  {
    "function_name": "Unref",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "186-194",
    "snippet": "void LRUCache::Unref(LRUHandle* e) {\n  assert(e->refs > 0);\n  e->refs--;\n  if (e->refs <= 0) {\n    usage_ -= e->charge;\n    (*e->deleter)(e->key(), e->value);\n    free(e);\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "e"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "zero_after_free_allocator",
          "container": "zero_after_free_allocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "241-241",
          "snippet": "zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a) {}",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nzero_after_free_allocator {\n  zero_after_free_allocator(const zero_after_free_allocator<U>& a) throw() : base(a) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "e->key()",
            "e->value"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->key",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "LRUHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "37-45",
          "snippet": "Slice key() const {\n    // For cheaper lookups, we allow a temporary Handle object\n    // to store a pointer to a key in \"value\".\n    if (next == this) {\n      return *(reinterpret_cast<Slice*>(value));\n    } else {\n      return Slice(key_data, key_length);\n    }\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUHandle {\n  Slice key() const {\n      // For cheaper lookups, we allow a temporary Handle object\n      // to store a pointer to a key in \"value\".\n      if (next == this) {\n        return *(reinterpret_cast<Slice*>(value));\n      } else {\n        return Slice(key_data, key_length);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "e->refs > 0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::Unref(LRUHandle* e) {\n    assert(e->refs > 0);\n    e->refs--;\n    if (e->refs <= 0) {\n      usage_ -= e->charge;\n      (*e->deleter)(e->key(), e->value);\n      free(e);\n    }\n  }\n}"
  },
  {
    "function_name": "~LRUCache",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "177-184",
    "snippet": "LRUCache::~LRUCache() {\n  for (LRUHandle* e = lru_.next; e != &lru_; ) {\n    LRUHandle* next = e->next;\n    assert(e->refs == 1);  // Error if caller has an unreleased handle\n    Unref(e);\n    e = next;\n  }\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Unref",
          "args": [
            "e"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "LRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "186-194",
          "snippet": "void LRUCache::Unref(LRUHandle* e) {\n  assert(e->refs > 0);\n  e->refs--;\n  if (e->refs <= 0) {\n    usage_ -= e->charge;\n    (*e->deleter)(e->key(), e->value);\n    free(e);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void LRUCache::Unref(LRUHandle* e) {\n    assert(e->refs > 0);\n    e->refs--;\n    if (e->refs <= 0) {\n      usage_ -= e->charge;\n      (*e->deleter)(e->key(), e->value);\n      free(e);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "e->refs == 1"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  LRUCache::~LRUCache() {\n    for (LRUHandle* e = lru_.next; e != &lru_; ) {\n      LRUHandle* next = e->next;\n      assert(e->refs == 1);  // Error if caller has an unreleased handle\n      Unref(e);\n      e = next;\n    }\n  }\n}"
  },
  {
    "function_name": "LRUCache",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "170-175",
    "snippet": "LRUCache::LRUCache()\n    : usage_(0) {\n  // Make empty circular linked list\n  lru_.next = &lru_;\n  lru_.prev = &lru_;\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  LRUCache::LRUCache()\n      : usage_(0) {\n    // Make empty circular linked list\n    lru_.next = &lru_;\n    lru_.prev = &lru_;\n  }\n}"
  },
  {
    "function_name": "SetCapacity",
    "container": "LRUCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "141-141",
    "snippet": "void SetCapacity(size_t capacity) { capacity_ = capacity; }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUCache {\n  void SetCapacity(size_t capacity) { capacity_ = capacity; }\n}"
  },
  {
    "function_name": "Resize",
    "container": "HandleTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "107-131",
    "snippet": "void Resize() {\n    uint32_t new_length = 4;\n    while (new_length < elems_) {\n      new_length *= 2;\n    }\n    LRUHandle** new_list = new LRUHandle*[new_length];\n    memset(new_list, 0, sizeof(new_list[0]) * new_length);\n    uint32_t count = 0;\n    for (uint32_t i = 0; i < length_; i++) {\n      LRUHandle* h = list_[i];\n      while (h != NULL) {\n        LRUHandle* next = h->next_hash;\n        uint32_t hash = h->hash;\n        LRUHandle** ptr = &new_list[hash & (new_length - 1)];\n        h->next_hash = *ptr;\n        *ptr = h;\n        h = next;\n        count++;\n      }\n    }\n    assert(elems_ == count);\n    delete[] list_;\n    list_ = new_list;\n    length_ = new_length;\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "elems_ == count"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_list",
            "0",
            "sizeof(new_list[0]) * new_length"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nHandleTable {\n  void Resize() {\n      uint32_t new_length = 4;\n      while (new_length < elems_) {\n        new_length *= 2;\n      }\n      LRUHandle** new_list = new LRUHandle*[new_length];\n      memset(new_list, 0, sizeof(new_list[0]) * new_length);\n      uint32_t count = 0;\n      for (uint32_t i = 0; i < length_; i++) {\n        LRUHandle* h = list_[i];\n        while (h != NULL) {\n          LRUHandle* next = h->next_hash;\n          uint32_t hash = h->hash;\n          LRUHandle** ptr = &new_list[hash & (new_length - 1)];\n          h->next_hash = *ptr;\n          *ptr = h;\n          h = next;\n          count++;\n        }\n      }\n      assert(elems_ == count);\n      delete[] list_;\n      list_ = new_list;\n      length_ = new_length;\n    }\n}"
  },
  {
    "function_name": "HandleTable",
    "container": "HandleTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "55-55",
    "snippet": "HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Resize",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "Resize",
          "container": "HandleTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "107-131",
          "snippet": "void Resize() {\n    uint32_t new_length = 4;\n    while (new_length < elems_) {\n      new_length *= 2;\n    }\n    LRUHandle** new_list = new LRUHandle*[new_length];\n    memset(new_list, 0, sizeof(new_list[0]) * new_length);\n    uint32_t count = 0;\n    for (uint32_t i = 0; i < length_; i++) {\n      LRUHandle* h = list_[i];\n      while (h != NULL) {\n        LRUHandle* next = h->next_hash;\n        uint32_t hash = h->hash;\n        LRUHandle** ptr = &new_list[hash & (new_length - 1)];\n        h->next_hash = *ptr;\n        *ptr = h;\n        h = next;\n        count++;\n      }\n    }\n    assert(elems_ == count);\n    delete[] list_;\n    list_ = new_list;\n    length_ = new_length;\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nHandleTable {\n  void Resize() {\n      uint32_t new_length = 4;\n      while (new_length < elems_) {\n        new_length *= 2;\n      }\n      LRUHandle** new_list = new LRUHandle*[new_length];\n      memset(new_list, 0, sizeof(new_list[0]) * new_length);\n      uint32_t count = 0;\n      for (uint32_t i = 0; i < length_; i++) {\n        LRUHandle* h = list_[i];\n        while (h != NULL) {\n          LRUHandle* next = h->next_hash;\n          uint32_t hash = h->hash;\n          LRUHandle** ptr = &new_list[hash & (new_length - 1)];\n          h->next_hash = *ptr;\n          *ptr = h;\n          h = next;\n          count++;\n        }\n      }\n      assert(elems_ == count);\n      delete[] list_;\n      list_ = new_list;\n      length_ = new_length;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nHandleTable {\n  HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }\n}"
  },
  {
    "function_name": "key",
    "container": "LRUHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "37-45",
    "snippet": "Slice key() const {\n    // For cheaper lookups, we allow a temporary Handle object\n    // to store a pointer to a key in \"value\".\n    if (next == this) {\n      return *(reinterpret_cast<Slice*>(value));\n    } else {\n      return Slice(key_data, key_length);\n    }\n  }",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "key_data",
            "key_length"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Slice*>",
          "args": [
            "value"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUHandle {\n  Slice key() const {\n      // For cheaper lookups, we allow a temporary Handle object\n      // to store a pointer to a key in \"value\".\n      if (next == this) {\n        return *(reinterpret_cast<Slice*>(value));\n      } else {\n        return Slice(key_data, key_length);\n      }\n    }\n}"
  },
  {
    "function_name": "~Cache",
    "container": "Cache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
    "lines": "16-17",
    "snippet": "Cache::~Cache() {\n}",
    "includes": [
      "#include \"util/mutexlock.h\"",
      "#include \"util/hash.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/cache.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nCache {\n  Cache::~Cache() {\n  }\n}"
  }
]