[
  {
    "function_name": "quotedPrintableDecode(",
    "container": "Codecs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
    "lines": "203-257",
    "snippet": "oid KCodecs::quotedPrintableDecode(const QByteArray& in, QByteArray& out)\n{\n  // clear out the output buffer\n  out.resize (0);\n  if (in.isEmpty())\n      return;\n\n  char *cursor;\n  const unsigned int length = in.size();\n\n  out.resize (length);\n  cursor = out.data();\n\n  for (unsigned int i = 0; i < length; i++)\n  {\n    char c(in[i]);\n\n    if ('=' == c)\n    {\n      if (i < length - 2)\n      {\n        char c1 = in[i + 1];\n        char c2 = in[i + 2];\n\n        if (('\\n' == c1) || ('\\r' == c1 && '\\n' == c2))\n        {\n          // Soft line break. No output.\n          if ('\\r' == c1)\n            i += 2;        // CRLF line breaks\n          else\n            i += 1;\n        }\n        else\n        {\n          // =XX encoded byte.\n\n          int hexChar0 = rikFindChar(hexChars, c1);\n          int hexChar1 = rikFindChar(hexChars, c2);\n\n          if (hexChar0 < 16 && hexChar1 < 16)\n          {\n            *cursor++ = char((hexChar0 * 16) | hexChar1);\n            i += 2;\n          }\n        }\n      }\n    }\n    else\n    {\n      *cursor++ = c;\n    }\n  }\n\n  out.truncate(cursor - out.data());\n}",
    "includes": [
      "include <QtCore/QIODevice>",
      "include <stdlib.h>",
      "include <string.h>",
      "include <stdio.h>\n#",
      "include \"kcodecs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut.truncate",
          "args": [
            "ursor - out.data())"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.data",
          "args": [],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "har",
          "args": [
            "hexChar0 * 16) | hexChar1)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "exValueOfChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "131-142",
          "snippet": "tatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ikFindChar(",
          "args": [
            "exChars,",
            "2)"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ikFindChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
          "lines": "57-70",
          "snippet": "tatic int rikFindChar(register const char * _s, const char c)\n{\n  register const char * s = _s;\n\n  while (true)\n  {\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n  }\n\n  return s - _s;\n}",
          "includes": [
            "include <QtCore/QIODevice>",
            "include <stdlib.h>",
            "include <string.h>",
            "include <stdio.h>\n#",
            "include \"kcodecs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\ntatic int rikFindChar(register const char * _s, const char c)\n{\n  register const char * s = _s;\n\n  while (true)\n  {\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n  }\n\n  return s - _s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ut.resize",
          "args": [
            "ength)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.size",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.isEmpty",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.resize",
          "args": [
            ")"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\nCodecs {\n  oid KCodecs::quotedPrintableDecode(const QByteArray& in, QByteArray& out)\n  {\n    // clear out the output buffer\n    out.resize (0);\n    if (in.isEmpty())\n        return;\n  \n    char *cursor;\n    const unsigned int length = in.size();\n  \n    out.resize (length);\n    cursor = out.data();\n  \n    for (unsigned int i = 0; i < length; i++)\n    {\n      char c(in[i]);\n  \n      if ('=' == c)\n      {\n        if (i < length - 2)\n        {\n          char c1 = in[i + 1];\n          char c2 = in[i + 2];\n  \n          if (('\\n' == c1) || ('\\r' == c1 && '\\n' == c2))\n          {\n            // Soft line break. No output.\n            if ('\\r' == c1)\n              i += 2;        // CRLF line breaks\n            else\n              i += 1;\n          }\n          else\n          {\n            // =XX encoded byte.\n  \n            int hexChar0 = rikFindChar(hexChars, c1);\n            int hexChar1 = rikFindChar(hexChars, c2);\n  \n            if (hexChar0 < 16 && hexChar1 < 16)\n            {\n              *cursor++ = char((hexChar0 * 16) | hexChar1);\n              i += 2;\n            }\n          }\n        }\n      }\n      else\n      {\n        *cursor++ = c;\n      }\n    }\n  \n    out.truncate(cursor - out.data());\n  }\n}"
  },
  {
    "function_name": "quotedPrintableDecode(",
    "container": "Codecs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
    "lines": "195-200",
    "snippet": "ByteArray KCodecs::quotedPrintableDecode(const QByteArray & in)\n{\n  QByteArray out;\n  quotedPrintableDecode (in, out);\n  return out;\n}",
    "includes": [
      "include <QtCore/QIODevice>",
      "include <stdlib.h>",
      "include <string.h>",
      "include <stdio.h>\n#",
      "include \"kcodecs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uotedPrintableDecode",
          "args": [
            "n,",
            "ut)"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "quotedPrintableDecode(",
          "container": "Codecs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
          "lines": "203-257",
          "snippet": "oid KCodecs::quotedPrintableDecode(const QByteArray& in, QByteArray& out)\n{\n  // clear out the output buffer\n  out.resize (0);\n  if (in.isEmpty())\n      return;\n\n  char *cursor;\n  const unsigned int length = in.size();\n\n  out.resize (length);\n  cursor = out.data();\n\n  for (unsigned int i = 0; i < length; i++)\n  {\n    char c(in[i]);\n\n    if ('=' == c)\n    {\n      if (i < length - 2)\n      {\n        char c1 = in[i + 1];\n        char c2 = in[i + 2];\n\n        if (('\\n' == c1) || ('\\r' == c1 && '\\n' == c2))\n        {\n          // Soft line break. No output.\n          if ('\\r' == c1)\n            i += 2;        // CRLF line breaks\n          else\n            i += 1;\n        }\n        else\n        {\n          // =XX encoded byte.\n\n          int hexChar0 = rikFindChar(hexChars, c1);\n          int hexChar1 = rikFindChar(hexChars, c2);\n\n          if (hexChar0 < 16 && hexChar1 < 16)\n          {\n            *cursor++ = char((hexChar0 * 16) | hexChar1);\n            i += 2;\n          }\n        }\n      }\n    }\n    else\n    {\n      *cursor++ = c;\n    }\n  }\n\n  out.truncate(cursor - out.data());\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\nCodecs {\n  ByteArray KCodecs::quotedPrintableDecode(const QByteArray & in)\n  {\n    QByteArray out;\n    quotedPrintableDecode (in, out);\n    return out;\n  }\n}"
  },
  {
    "function_name": "quotedPrintableEncode(",
    "container": "Codecs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
    "lines": "79-193",
    "snippet": "oid KCodecs::quotedPrintableEncode(const QByteArray& in, QByteArray& out, bool useCRLF)\n{\n  out.resize (0);\n  if (in.isEmpty())\n    return;\n\n  char *cursor;\n  const char *data;\n  unsigned int lineLength;\n  unsigned int pos;\n\n  const unsigned int length = in.size();\n  const unsigned int end = length - 1;\n\n\n  // Reasonable guess for output size when we're encoding\n  // mostly-ASCII data. It doesn't really matter, because\n  // the underlying allocation routines are quite efficient,\n  // but it's nice to have 0 allocations in many cases.\n  out.resize ((length*12)/10);\n  cursor = out.data();\n  data = in.data();\n  lineLength = 0;\n  pos = 0;\n\n  for (unsigned int i = 0; i < length; i++)\n  {\n    unsigned char c (data[i]);\n\n    // check if we have to enlarge the output buffer, use\n    // a safety margin of 16 byte\n    pos = cursor-out.data();\n    if (out.size()-pos < 16) {\n      out.resize(out.size()+4096);\n      cursor = out.data()+pos;\n    }\n\n    // Plain ASCII chars just go straight out.\n\n    if ((c >= 33) && (c <= 126) && ('=' != c))\n    {\n      *cursor++ = c;\n      ++lineLength;\n    }\n\n    // Spaces need some thought. We have to encode them at eol (or eof).\n\n    else if (' ' == c)\n    {\n      if\n        (\n         (i >= length)\n         ||\n         ((i < end) && ((useCRLF && ('\\r' == data[i + 1]) && ('\\n' == data[i + 2]))\n                        ||\n                        (!useCRLF && ('\\n' == data[i + 1]))))\n        )\n      {\n        *cursor++ = '=';\n        *cursor++ = '2';\n        *cursor++ = '0';\n\n        lineLength += 3;\n      }\n      else\n      {\n        *cursor++ = ' ';\n        ++lineLength;\n      }\n    }\n    // If we find a line break, just let it through.\n    else if ((useCRLF && ('\\r' == c) && (i < end) && ('\\n' == data[i + 1])) ||\n             (!useCRLF && ('\\n' == c)))\n    {\n      lineLength = 0;\n\n      if (useCRLF) {\n        *cursor++ = '\\r';\n        *cursor++ = '\\n';\n        ++i;\n      } else {\n        *cursor++ = '\\n';\n      }\n    }\n\n    // Anything else is converted to =XX.\n\n    else\n    {\n      *cursor++ = '=';\n      *cursor++ = hexChars[c / 16];\n      *cursor++ = hexChars[c % 16];\n\n      lineLength += 3;\n    }\n\n    // If we're approaching the maximum line length, do a soft line break.\n\n    if ((lineLength > maxQPLineLength) && (i < end))\n    {\n      if (useCRLF) {\n        *cursor++ = '=';\n        *cursor++ = '\\r';\n        *cursor++ = '\\n';\n      } else {\n        *cursor++ = '=';\n        *cursor++ = '\\n';\n      }\n\n      lineLength = 0;\n    }\n  }\n\n  out.truncate(cursor - out.data());\n}",
    "includes": [
      "include <QtCore/QIODevice>",
      "include <stdlib.h>",
      "include <string.h>",
      "include <stdio.h>\n#",
      "include \"kcodecs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut.truncate",
          "args": [
            "ursor - out.data())"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.data",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ut.resize",
          "args": [
            "ut.size()+4096)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.size",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "sizeHint",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "131-134",
          "snippet": "QSize FlowLayout::sizeHint() const\n{\n    return minimumSize();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  QSize FlowLayout::sizeHint() const\n  {\n      return minimumSize();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ut.resize",
          "args": [
            "length*12)/10)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.size",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.isEmpty",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.resize",
          "args": [
            ")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\nCodecs {\n  oid KCodecs::quotedPrintableEncode(const QByteArray& in, QByteArray& out, bool useCRLF)\n  {\n    out.resize (0);\n    if (in.isEmpty())\n      return;\n  \n    char *cursor;\n    const char *data;\n    unsigned int lineLength;\n    unsigned int pos;\n  \n    const unsigned int length = in.size();\n    const unsigned int end = length - 1;\n  \n  \n    // Reasonable guess for output size when we're encoding\n    // mostly-ASCII data. It doesn't really matter, because\n    // the underlying allocation routines are quite efficient,\n    // but it's nice to have 0 allocations in many cases.\n    out.resize ((length*12)/10);\n    cursor = out.data();\n    data = in.data();\n    lineLength = 0;\n    pos = 0;\n  \n    for (unsigned int i = 0; i < length; i++)\n    {\n      unsigned char c (data[i]);\n  \n      // check if we have to enlarge the output buffer, use\n      // a safety margin of 16 byte\n      pos = cursor-out.data();\n      if (out.size()-pos < 16) {\n        out.resize(out.size()+4096);\n        cursor = out.data()+pos;\n      }\n  \n      // Plain ASCII chars just go straight out.\n  \n      if ((c >= 33) && (c <= 126) && ('=' != c))\n      {\n        *cursor++ = c;\n        ++lineLength;\n      }\n  \n      // Spaces need some thought. We have to encode them at eol (or eof).\n  \n      else if (' ' == c)\n      {\n        if\n          (\n           (i >= length)\n           ||\n           ((i < end) && ((useCRLF && ('\\r' == data[i + 1]) && ('\\n' == data[i + 2]))\n                          ||\n                          (!useCRLF && ('\\n' == data[i + 1]))))\n          )\n        {\n          *cursor++ = '=';\n          *cursor++ = '2';\n          *cursor++ = '0';\n  \n          lineLength += 3;\n        }\n        else\n        {\n          *cursor++ = ' ';\n          ++lineLength;\n        }\n      }\n      // If we find a line break, just let it through.\n      else if ((useCRLF && ('\\r' == c) && (i < end) && ('\\n' == data[i + 1])) ||\n               (!useCRLF && ('\\n' == c)))\n      {\n        lineLength = 0;\n  \n        if (useCRLF) {\n          *cursor++ = '\\r';\n          *cursor++ = '\\n';\n          ++i;\n        } else {\n          *cursor++ = '\\n';\n        }\n      }\n  \n      // Anything else is converted to =XX.\n  \n      else\n      {\n        *cursor++ = '=';\n        *cursor++ = hexChars[c / 16];\n        *cursor++ = hexChars[c % 16];\n  \n        lineLength += 3;\n      }\n  \n      // If we're approaching the maximum line length, do a soft line break.\n  \n      if ((lineLength > maxQPLineLength) && (i < end))\n      {\n        if (useCRLF) {\n          *cursor++ = '=';\n          *cursor++ = '\\r';\n          *cursor++ = '\\n';\n        } else {\n          *cursor++ = '=';\n          *cursor++ = '\\n';\n        }\n  \n        lineLength = 0;\n      }\n    }\n  \n    out.truncate(cursor - out.data());\n  }\n}"
  },
  {
    "function_name": "quotedPrintableEncode(",
    "container": "Codecs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
    "lines": "72-77",
    "snippet": "ByteArray KCodecs::quotedPrintableEncode(const QByteArray& in, bool useCRLF)\n{\n  QByteArray out;\n  quotedPrintableEncode (in, out, useCRLF);\n  return out;\n}",
    "includes": [
      "include <QtCore/QIODevice>",
      "include <stdlib.h>",
      "include <string.h>",
      "include <stdio.h>\n#",
      "include \"kcodecs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uotedPrintableEncode",
          "args": [
            "n,",
            "ut,",
            "seCRLF)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "quotedPrintableEncode(",
          "container": "Codecs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
          "lines": "79-193",
          "snippet": "oid KCodecs::quotedPrintableEncode(const QByteArray& in, QByteArray& out, bool useCRLF)\n{\n  out.resize (0);\n  if (in.isEmpty())\n    return;\n\n  char *cursor;\n  const char *data;\n  unsigned int lineLength;\n  unsigned int pos;\n\n  const unsigned int length = in.size();\n  const unsigned int end = length - 1;\n\n\n  // Reasonable guess for output size when we're encoding\n  // mostly-ASCII data. It doesn't really matter, because\n  // the underlying allocation routines are quite efficient,\n  // but it's nice to have 0 allocations in many cases.\n  out.resize ((length*12)/10);\n  cursor = out.data();\n  data = in.data();\n  lineLength = 0;\n  pos = 0;\n\n  for (unsigned int i = 0; i < length; i++)\n  {\n    unsigned char c (data[i]);\n\n    // check if we have to enlarge the output buffer, use\n    // a safety margin of 16 byte\n    pos = cursor-out.data();\n    if (out.size()-pos < 16) {\n      out.resize(out.size()+4096);\n      cursor = out.data()+pos;\n    }\n\n    // Plain ASCII chars just go straight out.\n\n    if ((c >= 33) && (c <= 126) && ('=' != c))\n    {\n      *cursor++ = c;\n      ++lineLength;\n    }\n\n    // Spaces need some thought. We have to encode them at eol (or eof).\n\n    else if (' ' == c)\n    {\n      if\n        (\n         (i >= length)\n         ||\n         ((i < end) && ((useCRLF && ('\\r' == data[i + 1]) && ('\\n' == data[i + 2]))\n                        ||\n                        (!useCRLF && ('\\n' == data[i + 1]))))\n        )\n      {\n        *cursor++ = '=';\n        *cursor++ = '2';\n        *cursor++ = '0';\n\n        lineLength += 3;\n      }\n      else\n      {\n        *cursor++ = ' ';\n        ++lineLength;\n      }\n    }\n    // If we find a line break, just let it through.\n    else if ((useCRLF && ('\\r' == c) && (i < end) && ('\\n' == data[i + 1])) ||\n             (!useCRLF && ('\\n' == c)))\n    {\n      lineLength = 0;\n\n      if (useCRLF) {\n        *cursor++ = '\\r';\n        *cursor++ = '\\n';\n        ++i;\n      } else {\n        *cursor++ = '\\n';\n      }\n    }\n\n    // Anything else is converted to =XX.\n\n    else\n    {\n      *cursor++ = '=';\n      *cursor++ = hexChars[c / 16];\n      *cursor++ = hexChars[c % 16];\n\n      lineLength += 3;\n    }\n\n    // If we're approaching the maximum line length, do a soft line break.\n\n    if ((lineLength > maxQPLineLength) && (i < end))\n    {\n      if (useCRLF) {\n        *cursor++ = '=';\n        *cursor++ = '\\r';\n        *cursor++ = '\\n';\n      } else {\n        *cursor++ = '=';\n        *cursor++ = '\\n';\n      }\n\n      lineLength = 0;\n    }\n  }\n\n  out.truncate(cursor - out.data());\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\nCodecs {\n  ByteArray KCodecs::quotedPrintableEncode(const QByteArray& in, bool useCRLF)\n  {\n    QByteArray out;\n    quotedPrintableEncode (in, out, useCRLF);\n    return out;\n  }\n}"
  },
  {
    "function_name": "ikFindChar(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
    "lines": "57-70",
    "snippet": "tatic int rikFindChar(register const char * _s, const char c)\n{\n  register const char * s = _s;\n\n  while (true)\n  {\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n  }\n\n  return s - _s;\n}",
    "includes": [
      "include <QtCore/QIODevice>",
      "include <stdlib.h>",
      "include <string.h>",
      "include <stdio.h>\n#",
      "include \"kcodecs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\ntatic int rikFindChar(register const char * _s, const char c)\n{\n  register const char * s = _s;\n\n  while (true)\n  {\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n    if ((0 == *s) || (c == *s)) break; ++s;\n  }\n\n  return s - _s;\n}"
  }
]