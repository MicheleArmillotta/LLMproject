[
  {
    "function_name": "setEmulatePrepare",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "511-515",
    "snippet": "void XSqlQuery::setEmulatePrepare(bool emulate)\n{\n  if(_data)\n    _data->_emulatePrepare = emulate;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  void XSqlQuery::setEmulatePrepare(bool emulate)\n  {\n    if(_data)\n      _data->_emulatePrepare = emulate;\n  }\n}"
  },
  {
    "function_name": "emulatePrepare",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "504-509",
    "snippet": "bool XSqlQuery::emulatePrepare() const\n{\n  if(_data)\n    return _data->_emulatePrepare;\n  return false;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::emulatePrepare() const\n  {\n    if(_data)\n      return _data->_emulatePrepare;\n    return false;\n  }\n}"
  },
  {
    "function_name": "removeErrorListener",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "494-502",
    "snippet": "void XSqlQuery::removeErrorListener(XSqlQueryErrorListener* listener)\n{\n  int i = _errorListeners.indexOf(listener);\n  while(-1 != i)\n  {\n    _errorListeners.removeAt(i);\n    i = _errorListeners.indexOf(listener);\n  }\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [
      "static QList<XSqlQueryErrorListener*> _errorListeners;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_errorListeners.indexOf",
          "args": [
            "listener"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_errorListeners.removeAt",
          "args": [
            "i"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_errorListeners.indexOf",
          "args": [
            "listener"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QList<XSqlQueryErrorListener*> _errorListeners;\n\nXSqlQuery {\n  void XSqlQuery::removeErrorListener(XSqlQueryErrorListener* listener)\n  {\n    int i = _errorListeners.indexOf(listener);\n    while(-1 != i)\n    {\n      _errorListeners.removeAt(i);\n      i = _errorListeners.indexOf(listener);\n    }\n  }\n}"
  },
  {
    "function_name": "addErrorListener",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "488-492",
    "snippet": "void XSqlQuery::addErrorListener(XSqlQueryErrorListener* listener)\n{\n  if(!_errorListeners.contains(listener))\n    _errorListeners.append(listener);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [
      "static QList<XSqlQueryErrorListener*> _errorListeners;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_errorListeners.append",
          "args": [
            "listener"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_errorListeners.contains",
          "args": [
            "listener"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QList<XSqlQueryErrorListener*> _errorListeners;\n\nXSqlQuery {\n  void XSqlQuery::addErrorListener(XSqlQueryErrorListener* listener)\n  {\n    if(!_errorListeners.contains(listener))\n      _errorListeners.append(listener);\n  }\n}"
  },
  {
    "function_name": "findFirst",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "473-486",
    "snippet": "int XSqlQuery::findFirst(const QString &pField, const QString &pTarget)\n{\n  if (first())\n  {\n    do\n    {\n      if (value(pField).toString() == pTarget)\n        return at();\n    }\n    while (next());\n  }\n\n  return -1;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "at",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "emulatePrepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "504-509",
          "snippet": "bool XSqlQuery::emulatePrepare() const\n{\n  if(_data)\n    return _data->_emulatePrepare;\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::emulatePrepare() const\n  {\n    if(_data)\n      return _data->_emulatePrepare;\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "pField"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "first",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  int XSqlQuery::findFirst(const QString &pField, const QString &pTarget)\n  {\n    if (first())\n    {\n      do\n      {\n        if (value(pField).toString() == pTarget)\n          return at();\n      }\n      while (next());\n    }\n  \n    return -1;\n  }\n}"
  },
  {
    "function_name": "findFirst",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "458-471",
    "snippet": "int XSqlQuery::findFirst(const QString &pField, int pTarget)\n{\n  if (first())\n  {\n    do\n    {\n      if (value(pField).toInt() == pTarget)\n        return at();\n    }\n    while (next());\n  }\n\n  return -1;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "at",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "emulatePrepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "504-509",
          "snippet": "bool XSqlQuery::emulatePrepare() const\n{\n  if(_data)\n    return _data->_emulatePrepare;\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::emulatePrepare() const\n  {\n    if(_data)\n      return _data->_emulatePrepare;\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "pField"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "first",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  int XSqlQuery::findFirst(const QString &pField, int pTarget)\n  {\n    if (first())\n    {\n      do\n      {\n        if (value(pField).toInt() == pTarget)\n          return at();\n      }\n      while (next());\n    }\n  \n    return -1;\n  }\n}"
  },
  {
    "function_name": "findFirst",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "443-456",
    "snippet": "int XSqlQuery::findFirst(int pField, int pTarget)\n{\n  if (first())\n  {\n    do\n    {\n      if (value(pField).toInt() == pTarget)\n        return at();\n    }\n    while (next());\n  }\n\n  return -1;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "at",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "emulatePrepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "504-509",
          "snippet": "bool XSqlQuery::emulatePrepare() const\n{\n  if(_data)\n    return _data->_emulatePrepare;\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::emulatePrepare() const\n  {\n    if(_data)\n      return _data->_emulatePrepare;\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "pField"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "first",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  int XSqlQuery::findFirst(int pField, int pTarget)\n  {\n    if (first())\n    {\n      do\n      {\n        if (value(pField).toInt() == pTarget)\n          return at();\n      }\n      while (next());\n    }\n  \n    return -1;\n  }\n}"
  },
  {
    "function_name": "resetSubTotalsCurrent",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "429-441",
    "snippet": "void XSqlQuery::resetSubTotalsCurrent()\n{\n  if (_data)\n  {\n    // initial all our values to the absolute value of the current record\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n    }\n  }\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "mit.key()"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.next",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.hasNext",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  void XSqlQuery::resetSubTotalsCurrent()\n  {\n    if (_data)\n    {\n      // initial all our values to the absolute value of the current record\n      QMapIterator<QString,double> mit(_data->_fieldTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "resetSubTotals",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "415-427",
    "snippet": "void XSqlQuery::resetSubTotals()\n{\n  if (_data)\n  {\n    // initial all our values to 0.0\n    QMapIterator<QString,double> mit(_data->_fieldSubTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      _data->_fieldSubTotals[mit.key()] = 0.0;\n    }\n  }\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.next",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.hasNext",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  void XSqlQuery::resetSubTotals()\n  {\n    if (_data)\n    {\n      // initial all our values to 0.0\n      QMapIterator<QString,double> mit(_data->_fieldSubTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldSubTotals[mit.key()] = 0.0;\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "getFieldSubTotal",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "406-413",
    "snippet": "double XSqlQuery::getFieldSubTotal(QString & fld)\n{\n  if (_data)\n    if (_data->_fieldSubTotals.contains(fld))\n      return _data->_fieldSubTotals[fld];\n\n  return 0.0;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_data->_fieldSubTotals.contains",
          "args": [
            "fld"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  double XSqlQuery::getFieldSubTotal(QString & fld)\n  {\n    if (_data)\n      if (_data->_fieldSubTotals.contains(fld))\n        return _data->_fieldSubTotals[fld];\n  \n    return 0.0;\n  }\n}"
  },
  {
    "function_name": "getFieldTotal",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "396-404",
    "snippet": "double XSqlQuery::getFieldTotal(QString & fld)\n{\n  if (_data)\n  {\n    if (_data->_fieldTotals.contains(fld))\n      return _data->_fieldTotals[fld];\n  }\n  return 0.0;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_data->_fieldTotals.contains",
          "args": [
            "fld"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  double XSqlQuery::getFieldTotal(QString & fld)\n  {\n    if (_data)\n    {\n      if (_data->_fieldTotals.contains(fld))\n        return _data->_fieldTotals[fld];\n    }\n    return 0.0;\n  }\n}"
  },
  {
    "function_name": "trackFieldTotal",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "382-394",
    "snippet": "void XSqlQuery::trackFieldTotal(QString & fld)\n{\n  if (!_data)\n    _data = new XSqlQueryPrivate(this);\n\n  _data->_keepTotals = true;\n\n  if (!_data->_fieldTotals.contains(fld))\n      _data->_fieldTotals[fld] = 0.0;\n\n  if (!_data->_fieldSubTotals.contains(fld))\n      _data->_fieldSubTotals[fld] = 0.0;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_data->_fieldSubTotals.contains",
          "args": [
            "fld"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_data->_fieldTotals.contains",
          "args": [
            "fld"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  void XSqlQuery::trackFieldTotal(QString & fld)\n  {\n    if (!_data)\n      _data = new XSqlQueryPrivate(this);\n  \n    _data->_keepTotals = true;\n  \n    if (!_data->_fieldTotals.contains(fld))\n        _data->_fieldTotals[fld] = 0.0;\n  \n    if (!_data->_fieldSubTotals.contains(fld))\n        _data->_fieldSubTotals[fld] = 0.0;\n  }\n}"
  },
  {
    "function_name": "prev",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "377-380",
    "snippet": "bool XSqlQuery::prev()\n{\n  return previous();\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "previous",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "previous",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "342-375",
          "snippet": "bool XSqlQuery::previous()\n{\n  if (!_data)\n    return QSqlQuery::previous();\n\n  bool returnVal = false;\n\n  if (_data->_keepTotals && isValid())\n  {\n    QMap<QString,double> delta;\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      delta[mit.key()] = value(mit.key()).toDouble();\n    }\n    returnVal = QSqlQuery::previous();\n    if (returnVal)\n    {\n      mit = delta;\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldTotals[mit.key()] -= mit.value();\n        _data->_fieldSubTotals[mit.key()] -= mit.value();\n      }\n    }\n  }\n  else\n    returnVal = QSqlQuery::previous();\n\n  _data->_currRecord = record();\n  return returnVal;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::previous()\n  {\n    if (!_data)\n      return QSqlQuery::previous();\n  \n    bool returnVal = false;\n  \n    if (_data->_keepTotals && isValid())\n    {\n      QMap<QString,double> delta;\n      QMapIterator<QString,double> mit(_data->_fieldTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        delta[mit.key()] = value(mit.key()).toDouble();\n      }\n      returnVal = QSqlQuery::previous();\n      if (returnVal)\n      {\n        mit = delta;\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] -= mit.value();\n          _data->_fieldSubTotals[mit.key()] -= mit.value();\n        }\n      }\n    }\n    else\n      returnVal = QSqlQuery::previous();\n  \n    _data->_currRecord = record();\n    return returnVal;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::prev()\n  {\n    return previous();\n  }\n}"
  },
  {
    "function_name": "previous",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "342-375",
    "snippet": "bool XSqlQuery::previous()\n{\n  if (!_data)\n    return QSqlQuery::previous();\n\n  bool returnVal = false;\n\n  if (_data->_keepTotals && isValid())\n  {\n    QMap<QString,double> delta;\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      delta[mit.key()] = value(mit.key()).toDouble();\n    }\n    returnVal = QSqlQuery::previous();\n    if (returnVal)\n    {\n      mit = delta;\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldTotals[mit.key()] -= mit.value();\n        _data->_fieldSubTotals[mit.key()] -= mit.value();\n      }\n    }\n  }\n  else\n    returnVal = QSqlQuery::previous();\n\n  _data->_currRecord = record();\n  return returnVal;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "record",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QSqlQuery::previous",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "previous",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "342-375",
          "snippet": "bool XSqlQuery::previous()\n{\n  if (!_data)\n    return QSqlQuery::previous();\n\n  bool returnVal = false;\n\n  if (_data->_keepTotals && isValid())\n  {\n    QMap<QString,double> delta;\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      delta[mit.key()] = value(mit.key()).toDouble();\n    }\n    returnVal = QSqlQuery::previous();\n    if (returnVal)\n    {\n      mit = delta;\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldTotals[mit.key()] -= mit.value();\n        _data->_fieldSubTotals[mit.key()] -= mit.value();\n      }\n    }\n  }\n  else\n    returnVal = QSqlQuery::previous();\n\n  _data->_currRecord = record();\n  return returnVal;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mit.value",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.next",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.hasNext",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "mit.key()"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.hasNext",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isValid",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "isValid(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "125-131",
          "snippet": "ool Sequence::isValid() const\n{\n    if (kind == DISTINCT && list.isEmpty())\n        return false;\n    else\n        return true;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ool Sequence::isValid() const\n  {\n      if (kind == DISTINCT && list.isEmpty())\n          return false;\n      else\n          return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::previous()\n  {\n    if (!_data)\n      return QSqlQuery::previous();\n  \n    bool returnVal = false;\n  \n    if (_data->_keepTotals && isValid())\n    {\n      QMap<QString,double> delta;\n      QMapIterator<QString,double> mit(_data->_fieldTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        delta[mit.key()] = value(mit.key()).toDouble();\n      }\n      returnVal = QSqlQuery::previous();\n      if (returnVal)\n      {\n        mit = delta;\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] -= mit.value();\n          _data->_fieldSubTotals[mit.key()] -= mit.value();\n        }\n      }\n    }\n    else\n      returnVal = QSqlQuery::previous();\n  \n    _data->_currRecord = record();\n    return returnVal;\n  }\n}"
  },
  {
    "function_name": "next",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "318-340",
    "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "record",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "mit.key()"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.next",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mit.hasNext",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
  },
  {
    "function_name": "first",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "293-316",
    "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "record",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "mit.key()"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.key",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit.next",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mit.hasNext",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resetSubTotals",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "resetSubTotalsCurrent",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "429-441",
          "snippet": "void XSqlQuery::resetSubTotalsCurrent()\n{\n  if (_data)\n  {\n    // initial all our values to the absolute value of the current record\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n    }\n  }\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  void XSqlQuery::resetSubTotalsCurrent()\n  {\n    if (_data)\n    {\n      // initial all our values to the absolute value of the current record\n      QMapIterator<QString,double> mit(_data->_fieldTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSqlQuery::first",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
  },
  {
    "function_name": "prepare",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "257-291",
    "snippet": "bool XSqlQuery::prepare(const QString &pSql)\n{\n  bool ret;\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    ((XSqlResultHelper*)result())->setActive(false);\n    ((XSqlResultHelper*)result())->setLastError(QSqlError());\n    ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n    if (!driver()) {\n      qWarning(\"XSqlQuery::prepare: no driver\");\n      return false;\n    }\n    if (!driver()->isOpen() || driver()->isOpenError()) {\n      qWarning(\"XSqlQuery::prepare: database not open\");\n      return false;\n    }\n    if (pSql.isEmpty()) {\n      qWarning(\"XSqlQuery::prepare: empty query\");\n      return false;\n    }\n#ifdef QT_DEBUG_SQL\n    qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n#endif\n    ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n  }\n  else\n    ret = QSqlQuery::prepare(pSql);\n  if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n    bindValue(\":firstnullfix\", QVariant());\n  return ret;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bindValue",
          "args": [
            "\":firstnullfix\"",
            "QVariant()"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QVariant",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [
            "QSqlDriver::PreparedQueries"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QSqlQuery::prepare",
          "args": [
            "pSql"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "prepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "257-291",
          "snippet": "bool XSqlQuery::prepare(const QString &pSql)\n{\n  bool ret;\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    ((XSqlResultHelper*)result())->setActive(false);\n    ((XSqlResultHelper*)result())->setLastError(QSqlError());\n    ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n    if (!driver()) {\n      qWarning(\"XSqlQuery::prepare: no driver\");\n      return false;\n    }\n    if (!driver()->isOpen() || driver()->isOpenError()) {\n      qWarning(\"XSqlQuery::prepare: database not open\");\n      return false;\n    }\n    if (pSql.isEmpty()) {\n      qWarning(\"XSqlQuery::prepare: empty query\");\n      return false;\n    }\n#ifdef QT_DEBUG_SQL\n    qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n#endif\n    ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n  }\n  else\n    ret = QSqlQuery::prepare(pSql);\n  if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n    bindValue(\":firstnullfix\", QVariant());\n  return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pSql"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qDebug",
          "args": [
            "\"\\n XSqlQuery::prepare: %s\"",
            "query.toLocal8Bit().constData()"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "query.toLocal8Bit",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "query.toLocal8Bit",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [
            "\"XSqlQuery::prepare: empty query\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pSql.isEmpty",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [
            "\"XSqlQuery::prepare: database not open\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [
            "\"XSqlQuery::prepare: no driver\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "QSql::BeforeFirstRow"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "QSqlError()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QSqlError",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "false"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::prepare(const QString &pSql)\n  {\n    bool ret;\n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      ((XSqlResultHelper*)result())->setActive(false);\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n      ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n      if (!driver()) {\n        qWarning(\"XSqlQuery::prepare: no driver\");\n        return false;\n      }\n      if (!driver()->isOpen() || driver()->isOpenError()) {\n        qWarning(\"XSqlQuery::prepare: database not open\");\n        return false;\n      }\n      if (pSql.isEmpty()) {\n        qWarning(\"XSqlQuery::prepare: empty query\");\n        return false;\n      }\n  #ifdef QT_DEBUG_SQL\n      qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n  #endif\n      ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n    }\n    else\n      ret = QSqlQuery::prepare(pSql);\n    if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n      bindValue(\":firstnullfix\", QVariant());\n    return ret;\n  }\n}"
  },
  {
    "function_name": "exec",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "244-255",
    "snippet": "bool XSqlQuery::exec(const QString &pSql)\n{\n  bool returnValue = QSqlQuery::exec(pSql);\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifyErrorListeners",
          "args": [
            "this"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "notifyErrorListeners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "86-98",
          "snippet": "static void notifyErrorListeners(XSqlQuery * source)\n{\n  if(!source)\n    return;\n\n  XSqlQueryErrorListener * listener = 0;\n  for(int i = 0; i < _errorListeners.size(); i++)\n  {\n    listener = _errorListeners.at(i);\n    if(listener)\n      listener->error(source->executedQuery(), source->lastError());\n  }\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QList<XSqlQueryErrorListener*> _errorListeners;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QList<XSqlQueryErrorListener*> _errorListeners;\n\nstatic void notifyErrorListeners(XSqlQuery * source)\n{\n  if(!source)\n    return;\n\n  XSqlQueryErrorListener * listener = 0;\n  for(int i = 0; i < _errorListeners.size(); i++)\n  {\n    listener = _errorListeners.at(i);\n    if(listener)\n      listener->error(source->executedQuery(), source->lastError());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "record",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QSqlQuery::exec",
          "args": [
            "pSql"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "244-255",
          "snippet": "bool XSqlQuery::exec(const QString &pSql)\n{\n  bool returnValue = QSqlQuery::exec(pSql);\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec(const QString &pSql)\n  {\n    bool returnValue = QSqlQuery::exec(pSql);\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
  },
  {
    "function_name": "exec",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "217-242",
    "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifyErrorListeners",
          "args": [
            "this"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "notifyErrorListeners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "86-98",
          "snippet": "static void notifyErrorListeners(XSqlQuery * source)\n{\n  if(!source)\n    return;\n\n  XSqlQueryErrorListener * listener = 0;\n  for(int i = 0; i < _errorListeners.size(); i++)\n  {\n    listener = _errorListeners.at(i);\n    if(listener)\n      listener->error(source->executedQuery(), source->lastError());\n  }\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QList<XSqlQueryErrorListener*> _errorListeners;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QList<XSqlQueryErrorListener*> _errorListeners;\n\nstatic void notifyErrorListeners(XSqlQuery * source)\n{\n  if(!source)\n    return;\n\n  XSqlQueryErrorListener * listener = 0;\n  for(int i = 0; i < _errorListeners.size(); i++)\n  {\n    listener = _errorListeners.at(i);\n    if(listener)\n      listener->error(source->executedQuery(), source->lastError());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "record",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QSqlQuery::exec",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "QSqlError()"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QSqlError",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lastError",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lastError",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
  },
  {
    "function_name": "count",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "207-215",
    "snippet": "int XSqlQuery::count()\n{\n  QSqlRecord rec = record();\n\n  if (!rec.isEmpty())\n    return rec.count();\n  else\n    return 0;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rec.count",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "207-215",
          "snippet": "int XSqlQuery::count()\n{\n  QSqlRecord rec = record();\n\n  if (!rec.isEmpty())\n    return rec.count();\n  else\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rec.isEmpty",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  int XSqlQuery::count()\n  {\n    QSqlRecord rec = record();\n  \n    if (!rec.isEmpty())\n      return rec.count();\n    else\n      return 0;\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "187-205",
    "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [
      "static QString _nameErrorValue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "QVariant",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value",
          "args": [
            "_data->_currRecord.indexOf(name)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_data->_currRecord.indexOf",
          "args": [
            "name"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QVariant",
          "args": [
            "_nameErrorValue"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [
            "\"%s\"",
            "err.toLocal8Bit().constData()"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err.toLocal8Bit",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err.toLocal8Bit",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_data->_currRecord.indexOf",
          "args": [
            "name"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_data->_currRecord.isEmpty",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QVariant",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.isEmpty",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
  },
  {
    "function_name": "value",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "182-185",
    "snippet": "QVariant XSqlQuery::value(int i) const\n{\n  return QSqlQuery::value(i);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSqlQuery::value",
          "args": [
            "i"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  QVariant XSqlQuery::value(int i) const\n  {\n    return QSqlQuery::value(i);\n  }\n}"
  },
  {
    "function_name": "~XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "155-160",
    "snippet": "XSqlQuery::~XSqlQuery()\n{\n  if (_data)\n    delete _data;\n  _data = 0;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::~XSqlQuery()\n  {\n    if (_data)\n      delete _data;\n    _data = 0;\n  }\n}"
  },
  {
    "function_name": "XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "147-153",
    "snippet": "XSqlQuery::XSqlQuery(const XSqlQuery & other) :\n  QSqlQuery(other)\n{\n  _data = new XSqlQueryPrivate(this);\n  if (other._data)\n    _data = new XSqlQueryPrivate(*other._data);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::XSqlQuery(const XSqlQuery & other) :\n    QSqlQuery(other)\n  {\n    _data = new XSqlQueryPrivate(this);\n    if (other._data)\n      _data = new XSqlQueryPrivate(*other._data);\n  }\n}"
  },
  {
    "function_name": "XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "141-145",
    "snippet": "XSqlQuery::XSqlQuery(const QSqlQuery & other) :\n  QSqlQuery(other)\n{\n  _data = new XSqlQueryPrivate(this);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::XSqlQuery(const QSqlQuery & other) :\n    QSqlQuery(other)\n  {\n    _data = new XSqlQueryPrivate(this);\n  }\n}"
  },
  {
    "function_name": "XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "134-139",
    "snippet": "XSqlQuery::XSqlQuery(const QString &pSql, QSqlDatabase db) :\n  QSqlQuery(QString(), db)\n{\n  _data = new XSqlQueryPrivate(this);\n  exec(pSql.toAscii().data());\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exec",
          "args": [
            "pSql.toAscii().data()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "244-255",
          "snippet": "bool XSqlQuery::exec(const QString &pSql)\n{\n  bool returnValue = QSqlQuery::exec(pSql);\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec(const QString &pSql)\n  {\n    bool returnValue = QSqlQuery::exec(pSql);\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pSql.toAscii",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pSql.toAscii",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::XSqlQuery(const QString &pSql, QSqlDatabase db) :\n    QSqlQuery(QString(), db)\n  {\n    _data = new XSqlQueryPrivate(this);\n    exec(pSql.toAscii().data());\n  }\n}"
  },
  {
    "function_name": "XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "128-132",
    "snippet": "XSqlQuery::XSqlQuery(QSqlResult * r) :\n  QSqlQuery(r)\n{\n  _data = new XSqlQueryPrivate(this);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::XSqlQuery(QSqlResult * r) :\n    QSqlQuery(r)\n  {\n    _data = new XSqlQueryPrivate(this);\n  }\n}"
  },
  {
    "function_name": "XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "122-126",
    "snippet": "XSqlQuery::XSqlQuery(QSqlDatabase db) :\n  QSqlQuery(db)\n{\n  _data = new XSqlQueryPrivate(this);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::XSqlQuery(QSqlDatabase db) :\n    QSqlQuery(db)\n  {\n    _data = new XSqlQueryPrivate(this);\n  }\n}"
  },
  {
    "function_name": "XSqlQuery",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "116-120",
    "snippet": "XSqlQuery::XSqlQuery() :\n  QSqlQuery()\n{\n  _data = new XSqlQueryPrivate(this);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  XSqlQuery::XSqlQuery() :\n    QSqlQuery()\n  {\n    _data = new XSqlQueryPrivate(this);\n  }\n}"
  },
  {
    "function_name": "setNameErrorValue",
    "container": "XSqlQuery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "110-113",
    "snippet": "void XSqlQuery::setNameErrorValue(QString v)\n{\n    _nameErrorValue = v;\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [
      "static QString _nameErrorValue;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  void XSqlQuery::setNameErrorValue(QString v)\n  {\n      _nameErrorValue = v;\n  }\n}"
  },
  {
    "function_name": "~XSqlQueryErrorListener",
    "container": "XSqlQueryErrorListener",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "102-105",
    "snippet": "XSqlQueryErrorListener::~XSqlQueryErrorListener()\n{\n  XSqlQuery::removeErrorListener(this);\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSqlQuery::removeErrorListener",
          "args": [
            "this"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "removeErrorListener",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "494-502",
          "snippet": "void XSqlQuery::removeErrorListener(XSqlQueryErrorListener* listener)\n{\n  int i = _errorListeners.indexOf(listener);\n  while(-1 != i)\n  {\n    _errorListeners.removeAt(i);\n    i = _errorListeners.indexOf(listener);\n  }\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QList<XSqlQueryErrorListener*> _errorListeners;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QList<XSqlQueryErrorListener*> _errorListeners;\n\nXSqlQuery {\n  void XSqlQuery::removeErrorListener(XSqlQueryErrorListener* listener)\n  {\n    int i = _errorListeners.indexOf(listener);\n    while(-1 != i)\n    {\n      _errorListeners.removeAt(i);\n      i = _errorListeners.indexOf(listener);\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQueryErrorListener {\n  XSqlQueryErrorListener::~XSqlQueryErrorListener()\n  {\n    XSqlQuery::removeErrorListener(this);\n  }\n}"
  },
  {
    "function_name": "XSqlQueryErrorListener",
    "container": "XSqlQueryErrorListener",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "101-101",
    "snippet": "XSqlQueryErrorListener::XSqlQueryErrorListener() {}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQueryErrorListener {\n  XSqlQueryErrorListener::XSqlQueryErrorListener() {}\n}"
  },
  {
    "function_name": "notifyErrorListeners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "86-98",
    "snippet": "static void notifyErrorListeners(XSqlQuery * source)\n{\n  if(!source)\n    return;\n\n  XSqlQueryErrorListener * listener = 0;\n  for(int i = 0; i < _errorListeners.size(); i++)\n  {\n    listener = _errorListeners.at(i);\n    if(listener)\n      listener->error(source->executedQuery(), source->lastError());\n  }\n}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [
      "static QList<XSqlQueryErrorListener*> _errorListeners;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "listener->error",
          "args": [
            "source->executedQuery()",
            "source->lastError()"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source->lastError",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source->executedQuery",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_errorListeners.at",
          "args": [
            "i"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_errorListeners.size",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QList<XSqlQueryErrorListener*> _errorListeners;\n\nstatic void notifyErrorListeners(XSqlQuery * source)\n{\n  if(!source)\n    return;\n\n  XSqlQueryErrorListener * listener = 0;\n  for(int i = 0; i < _errorListeners.size(); i++)\n  {\n    listener = _errorListeners.at(i);\n    if(listener)\n      listener->error(source->executedQuery(), source->lastError());\n  }\n}"
  },
  {
    "function_name": "XSqlQueryPrivate",
    "container": "XSqlQueryPrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "59-62",
    "snippet": "XSqlQueryPrivate(const XSqlQueryPrivate & p)\n  {\n    *this = p;\n  }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQueryPrivate {\n  XSqlQueryPrivate(const XSqlQueryPrivate & p)\n    {\n      *this = p;\n    }\n}"
  },
  {
    "function_name": "XSqlQueryPrivate",
    "container": "XSqlQueryPrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "48-58",
    "snippet": "XSqlQueryPrivate(XSqlQuery * parent)\n  {\n    _emulatePrepare = false;\n    if(parent->driver())\n    {\n      QVariant v = parent->driver()->handle();\n      if(qstrcmp(v.typeName(), \"PGconn*\")==0)\n        _emulatePrepare = true;\n    }\n    _keepTotals = false;\n  }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qstrcmp",
          "args": [
            "v.typeName()",
            "\"PGconn*\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.typeName",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->driver",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->driver",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->driver",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQueryPrivate {\n  XSqlQueryPrivate(XSqlQuery * parent)\n    {\n      _emulatePrepare = false;\n      if(parent->driver())\n      {\n        QVariant v = parent->driver()->handle();\n        if(qstrcmp(v.typeName(), \"PGconn*\")==0)\n          _emulatePrepare = true;\n      }\n      _keepTotals = false;\n    }\n}"
  },
  {
    "function_name": "savePrepare",
    "container": "XSqlResultHelper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "43-43",
    "snippet": "bool savePrepare(const QString& sqlquery) { clear(); return QSqlResult::prepare(sqlquery); }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSqlResult::prepare",
          "args": [
            "sqlquery"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "prepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "257-291",
          "snippet": "bool XSqlQuery::prepare(const QString &pSql)\n{\n  bool ret;\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    ((XSqlResultHelper*)result())->setActive(false);\n    ((XSqlResultHelper*)result())->setLastError(QSqlError());\n    ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n    if (!driver()) {\n      qWarning(\"XSqlQuery::prepare: no driver\");\n      return false;\n    }\n    if (!driver()->isOpen() || driver()->isOpenError()) {\n      qWarning(\"XSqlQuery::prepare: database not open\");\n      return false;\n    }\n    if (pSql.isEmpty()) {\n      qWarning(\"XSqlQuery::prepare: empty query\");\n      return false;\n    }\n#ifdef QT_DEBUG_SQL\n    qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n#endif\n    ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n  }\n  else\n    ret = QSqlQuery::prepare(pSql);\n  if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n    bindValue(\":firstnullfix\", QVariant());\n  return ret;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::prepare(const QString &pSql)\n  {\n    bool ret;\n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      ((XSqlResultHelper*)result())->setActive(false);\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n      ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n      if (!driver()) {\n        qWarning(\"XSqlQuery::prepare: no driver\");\n        return false;\n      }\n      if (!driver()->isOpen() || driver()->isOpenError()) {\n        qWarning(\"XSqlQuery::prepare: database not open\");\n        return false;\n      }\n      if (pSql.isEmpty()) {\n        qWarning(\"XSqlQuery::prepare: empty query\");\n        return false;\n      }\n  #ifdef QT_DEBUG_SQL\n      qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n  #endif\n      ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n    }\n    else\n      ret = QSqlQuery::prepare(pSql);\n    if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n      bindValue(\":firstnullfix\", QVariant());\n    return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "clearLogDisplay(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "115-130",
          "snippet": "oid ProtocolLoggerWidget::clearLogDisplay()\n{\n    // These will be freed from the GUI\n    loggerWidgets.clear();\n\n    // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n    // so it's much better to clean up the GUI at first and only after that purge the underlying data\n    while (tabs->count()) {\n        QWidget *w = tabs->widget(0);\n        Q_ASSERT(w);\n        tabs->removeTab(0);\n        w->deleteLater();\n    }\n\n    buffers.clear();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::clearLogDisplay()\n  {\n      // These will be freed from the GUI\n      loggerWidgets.clear();\n  \n      // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n      // so it's much better to clean up the GUI at first and only after that purge the underlying data\n      while (tabs->count()) {\n          QWidget *w = tabs->widget(0);\n          Q_ASSERT(w);\n          tabs->removeTab(0);\n          w->deleteLater();\n      }\n  \n      buffers.clear();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlResultHelper {\n  bool savePrepare(const QString& sqlquery) { clear(); return QSqlResult::prepare(sqlquery); }\n}"
  },
  {
    "function_name": "setAt",
    "container": "XSqlResultHelper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "42-42",
    "snippet": "void setAt(int at) { QSqlResult::setAt(at); }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSqlResult::setAt",
          "args": [
            "at"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "setAt",
          "container": "XSqlResultHelper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "42-42",
          "snippet": "void setAt(int at) { QSqlResult::setAt(at); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlResultHelper {\n  void setAt(int at) { QSqlResult::setAt(at); }\n}"
  },
  {
    "function_name": "setActive",
    "container": "XSqlResultHelper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "41-41",
    "snippet": "void setActive(bool a) { QSqlResult::setActive(a); }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSqlResult::setActive",
          "args": [
            "a"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "setActive",
          "container": "XSqlResultHelper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "41-41",
          "snippet": "void setActive(bool a) { QSqlResult::setActive(a); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlResultHelper {\n  void setActive(bool a) { QSqlResult::setActive(a); }\n}"
  },
  {
    "function_name": "exec",
    "container": "XSqlResultHelper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "40-40",
    "snippet": "bool exec() { return QSqlResult::exec(); }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSqlResult::exec",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlResultHelper {\n  bool exec() { return QSqlResult::exec(); }\n}"
  },
  {
    "function_name": "setLastError",
    "container": "XSqlResultHelper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "39-39",
    "snippet": "void setLastError(const QSqlError& e) { QSqlResult::setLastError(e); }",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSqlResult::setLastError",
          "args": [
            "e"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "setLastError",
          "container": "XSqlResultHelper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "39-39",
          "snippet": "void setLastError(const QSqlError& e) { QSqlResult::setLastError(e); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlResultHelper {\n  void setLastError(const QSqlError& e) { QSqlResult::setLastError(e); }\n}"
  },
  {
    "function_name": "XSqlResultHelper",
    "container": "XSqlResultHelper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
    "lines": "37-37",
    "snippet": "XSqlResultHelper(const QSqlDriver * db) : QSqlResult(db) {}",
    "includes": [
      "#include \"xsqlquery.h\"",
      "#include <QMap>",
      "#include <QCursor>",
      "#include <QSqlResult>",
      "#include <QSqlDriver>",
      "#include <QVariant>",
      "#include <QSqlError>",
      "#include <QSqlQuery>",
      "#include <QSqlRecord>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlResultHelper {\n  XSqlResultHelper(const QSqlDriver * db) : QSqlResult(db) {}\n}"
  }
]