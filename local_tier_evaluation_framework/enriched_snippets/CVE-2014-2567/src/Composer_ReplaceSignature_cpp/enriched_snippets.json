[
  {
    "function_name": "eplaceSignature(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ReplaceSignature.cpp",
    "lines": "31-76",
    "snippet": "oid replaceSignature(QTextDocument *document, const QString &newSignature)\n{\n    // The QTextEdit is set up in such a way as to treat a fully terminated line as a standalone text block,\n    // hence no newlines in the signature separator\n    const QLatin1String signatureSeperator(\"-- \");\n\n    QTextBlock block = document->lastBlock();\n    while (block.isValid() && block.blockNumber() > 0) {\n        if (block.text() == signatureSeperator) {\n            // So this block holds the last signature separator -- great!\n            break;\n        }\n        block = block.previous();\n    }\n\n    QTextCursor cursor(block);\n    if (block.text() == signatureSeperator) {\n        // Remove everything till the end of the document since the end of the previous block\n        if (block.previous().isValid()) {\n            // Prevent adding newlines when switching signatures\n            block = block.previous();\n            cursor = QTextCursor(block);\n            cursor.movePosition(QTextCursor::EndOfBlock);\n        }\n        cursor.beginEditBlock();\n        cursor.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);\n        cursor.removeSelectedText();\n        cursor.endEditBlock();\n    } else {\n        // We have not removed anything, so we have to \"fake\" an edit action so that we're adding the signature to a correct place\n        block = document->lastBlock();\n        cursor = QTextCursor(block);\n        cursor.movePosition(QTextCursor::EndOfBlock);\n        cursor.beginEditBlock();\n        cursor.endEditBlock();\n    }\n\n    if (!newSignature.isEmpty()) {\n        cursor.joinPreviousEditBlock();\n        cursor.insertBlock();\n        cursor.insertText(signatureSeperator);\n        cursor.insertBlock();\n        cursor.insertText(newSignature);\n        cursor.endEditBlock();\n    }\n}",
    "includes": [
      "include <QTextDocument>",
      "include <QTextCursor>\n#",
      "include <QTextBlock>\n#",
      "include \"ReplaceSignature.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ursor.endEditBlock",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.insertText",
          "args": [
            "ewSignature)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.insertBlock",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.insertText",
          "args": [
            "ignatureSeperator)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.insertBlock",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.joinPreviousEditBlock",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewSignature.isEmpty",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.endEditBlock",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.beginEditBlock",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.movePosition",
          "args": [
            "TextCursor::EndOfBlock)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextCursor(",
          "args": [
            "lock)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocument->lastBlock",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.endEditBlock",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.removeSelectedText",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.movePosition",
          "args": [
            "TextCursor::End,",
            "TextCursor::KeepAnchor)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.beginEditBlock",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ursor.movePosition",
          "args": [
            "TextCursor::EndOfBlock)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextCursor(",
          "args": [
            "lock)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.previous",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "previous",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "342-375",
          "snippet": "bool XSqlQuery::previous()\n{\n  if (!_data)\n    return QSqlQuery::previous();\n\n  bool returnVal = false;\n\n  if (_data->_keepTotals && isValid())\n  {\n    QMap<QString,double> delta;\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      delta[mit.key()] = value(mit.key()).toDouble();\n    }\n    returnVal = QSqlQuery::previous();\n    if (returnVal)\n    {\n      mit = delta;\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldTotals[mit.key()] -= mit.value();\n        _data->_fieldSubTotals[mit.key()] -= mit.value();\n      }\n    }\n  }\n  else\n    returnVal = QSqlQuery::previous();\n\n  _data->_currRecord = record();\n  return returnVal;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::previous()\n  {\n    if (!_data)\n      return QSqlQuery::previous();\n  \n    bool returnVal = false;\n  \n    if (_data->_keepTotals && isValid())\n    {\n      QMap<QString,double> delta;\n      QMapIterator<QString,double> mit(_data->_fieldTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        delta[mit.key()] = value(mit.key()).toDouble();\n      }\n      returnVal = QSqlQuery::previous();\n      if (returnVal)\n      {\n        mit = delta;\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] -= mit.value();\n          _data->_fieldSubTotals[mit.key()] -= mit.value();\n        }\n      }\n    }\n    else\n      returnVal = QSqlQuery::previous();\n  \n    _data->_currRecord = record();\n    return returnVal;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock.text",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.text",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.blockNumber",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.isValid",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocument->lastBlock",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <QTextDocument>\ninclude <QTextCursor>\n#\ninclude <QTextBlock>\n#\ninclude \"ReplaceSignature.h\"\n#\n\noid replaceSignature(QTextDocument *document, const QString &newSignature)\n{\n    // The QTextEdit is set up in such a way as to treat a fully terminated line as a standalone text block,\n    // hence no newlines in the signature separator\n    const QLatin1String signatureSeperator(\"-- \");\n\n    QTextBlock block = document->lastBlock();\n    while (block.isValid() && block.blockNumber() > 0) {\n        if (block.text() == signatureSeperator) {\n            // So this block holds the last signature separator -- great!\n            break;\n        }\n        block = block.previous();\n    }\n\n    QTextCursor cursor(block);\n    if (block.text() == signatureSeperator) {\n        // Remove everything till the end of the document since the end of the previous block\n        if (block.previous().isValid()) {\n            // Prevent adding newlines when switching signatures\n            block = block.previous();\n            cursor = QTextCursor(block);\n            cursor.movePosition(QTextCursor::EndOfBlock);\n        }\n        cursor.beginEditBlock();\n        cursor.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);\n        cursor.removeSelectedText();\n        cursor.endEditBlock();\n    } else {\n        // We have not removed anything, so we have to \"fake\" an edit action so that we're adding the signature to a correct place\n        block = document->lastBlock();\n        cursor = QTextCursor(block);\n        cursor.movePosition(QTextCursor::EndOfBlock);\n        cursor.beginEditBlock();\n        cursor.endEditBlock();\n    }\n\n    if (!newSignature.isEmpty()) {\n        cursor.joinPreviousEditBlock();\n        cursor.insertBlock();\n        cursor.insertText(signatureSeperator);\n        cursor.insertBlock();\n        cursor.insertText(newSignature);\n        cursor.endEditBlock();\n    }\n}"
  }
]