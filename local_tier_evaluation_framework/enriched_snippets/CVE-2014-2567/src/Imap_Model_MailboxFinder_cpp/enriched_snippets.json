[
  {
    "function_name": "slotRowsInserted(",
    "container": "ailboxFinder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
    "lines": "97-104",
    "snippet": "oid MailboxFinder::slotRowsInserted( const QModelIndex &parent, int start, int end )\n{\n    // \"something got inserted\". It's enough to simply trigger the finder in checkArrivals().\n    Q_UNUSED(parent);\n    Q_UNUSED(start);\n    Q_UNUSED(end);\n    checkArrivals();\n}",
    "includes": [
      "include \"ItemRoles.h\"",
      "include \"Model.h\"\n#",
      "include \"MailboxFinder.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heckArrivals(",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "checkArrivals(",
          "container": "ailboxFinder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
          "lines": "54-95",
          "snippet": "oid MailboxFinder::checkArrivals()\n{\n    Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n        QModelIndex root;\n        bool cont = false;\n\n        // Simply use the MVC API to find an interesting object\n        do {\n            cont = false;\n            int rowCount = m_model->rowCount( root );\n            if ( rowCount < 2 ) {\n                // remember, the first one is list of messages!\n                break;\n            }\n            // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n            for ( int i = 1; i < rowCount; ++i ) {\n                const QModelIndex index = m_model->index( i, 0, root );\n                const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n\n                if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                    // This shoudln't really happen\n                    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                      QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                    continue;\n                }\n\n                if ( possibleName == mailbox ) {\n                    // found it\n                    m_watchedNames.removeAll( mailbox );\n                    emit mailboxFound( mailbox, index );\n                    break;\n                } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                    // we know where to go\n                    root = index;\n                    cont = true;\n                    break;\n                }\n            }\n        } while ( cont );\n    }\n}",
          "includes": [
            "include \"ItemRoles.h\"",
            "include \"Model.h\"\n#",
            "include \"MailboxFinder.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  oid MailboxFinder::checkArrivals()\n  {\n      Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n          QModelIndex root;\n          bool cont = false;\n  \n          // Simply use the MVC API to find an interesting object\n          do {\n              cont = false;\n              int rowCount = m_model->rowCount( root );\n              if ( rowCount < 2 ) {\n                  // remember, the first one is list of messages!\n                  break;\n              }\n              // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n              for ( int i = 1; i < rowCount; ++i ) {\n                  const QModelIndex index = m_model->index( i, 0, root );\n                  const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                  const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n  \n                  if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                      // This shoudln't really happen\n                      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                        QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                      continue;\n                  }\n  \n                  if ( possibleName == mailbox ) {\n                      // found it\n                      m_watchedNames.removeAll( mailbox );\n                      emit mailboxFound( mailbox, index );\n                      break;\n                  } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                      // we know where to go\n                      root = index;\n                      cont = true;\n                      break;\n                  }\n              }\n          } while ( cont );\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "nd)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "tart)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "arent)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  oid MailboxFinder::slotRowsInserted( const QModelIndex &parent, int start, int end )\n  {\n      // \"something got inserted\". It's enough to simply trigger the finder in checkArrivals().\n      Q_UNUSED(parent);\n      Q_UNUSED(start);\n      Q_UNUSED(end);\n      checkArrivals();\n  }\n}"
  },
  {
    "function_name": "checkArrivals(",
    "container": "ailboxFinder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
    "lines": "54-95",
    "snippet": "oid MailboxFinder::checkArrivals()\n{\n    Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n        QModelIndex root;\n        bool cont = false;\n\n        // Simply use the MVC API to find an interesting object\n        do {\n            cont = false;\n            int rowCount = m_model->rowCount( root );\n            if ( rowCount < 2 ) {\n                // remember, the first one is list of messages!\n                break;\n            }\n            // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n            for ( int i = 1; i < rowCount; ++i ) {\n                const QModelIndex index = m_model->index( i, 0, root );\n                const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n\n                if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                    // This shoudln't really happen\n                    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                      QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                    continue;\n                }\n\n                if ( possibleName == mailbox ) {\n                    // found it\n                    m_watchedNames.removeAll( mailbox );\n                    emit mailboxFound( mailbox, index );\n                    break;\n                } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                    // we know where to go\n                    root = index;\n                    cont = true;\n                    break;\n                }\n            }\n        } while ( cont );\n    }\n}",
    "includes": [
      "include \"ItemRoles.h\"",
      "include \"Model.h\"\n#",
      "include \"MailboxFinder.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailbox.startsWith",
          "args": [
            "ossibleName + separator"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_watchedNames.removeAll",
          "args": [
            "ailbox"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->logTrace",
          "args": [
            ",",
            "ommon::LOG_OTHER,",
            "Latin1String(\"MailboxFinder\"),",
            "Latin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"))"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Weird, there's a mailbox with no name and no separator. Avoiding!\")"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "MailboxFinder\")"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eparator.isEmpty",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ossibleName.isEmpty",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->data",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_model->data",
          "args": [
            "ndex,",
            "map::Mailbox::RoleMailboxSeparator"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->data",
          "args": [
            "ndex,",
            "map::Mailbox::RoleMailboxName"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->index",
          "args": [
            ",",
            ",",
            "oot"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->rowCount",
          "args": [
            "oot"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  oid MailboxFinder::checkArrivals()\n  {\n      Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n          QModelIndex root;\n          bool cont = false;\n  \n          // Simply use the MVC API to find an interesting object\n          do {\n              cont = false;\n              int rowCount = m_model->rowCount( root );\n              if ( rowCount < 2 ) {\n                  // remember, the first one is list of messages!\n                  break;\n              }\n              // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n              for ( int i = 1; i < rowCount; ++i ) {\n                  const QModelIndex index = m_model->index( i, 0, root );\n                  const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                  const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n  \n                  if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                      // This shoudln't really happen\n                      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                        QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                      continue;\n                  }\n  \n                  if ( possibleName == mailbox ) {\n                      // found it\n                      m_watchedNames.removeAll( mailbox );\n                      emit mailboxFound( mailbox, index );\n                      break;\n                  } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                      // we know where to go\n                      root = index;\n                      cont = true;\n                      break;\n                  }\n              }\n          } while ( cont );\n      }\n  }\n}"
  },
  {
    "function_name": "addMailbox(",
    "container": "ailboxFinder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
    "lines": "48-52",
    "snippet": "oid MailboxFinder::addMailbox( const QString &mailbox )\n{\n    m_watchedNames.append(mailbox);\n    QTimer::singleShot(0, this, SLOT(checkArrivals()));\n}",
    "includes": [
      "include \"ItemRoles.h\"",
      "include \"Model.h\"\n#",
      "include \"MailboxFinder.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(checkArrivals()))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "heckArrivals())"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heckArrivals(",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "checkArrivals(",
          "container": "ailboxFinder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
          "lines": "54-95",
          "snippet": "oid MailboxFinder::checkArrivals()\n{\n    Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n        QModelIndex root;\n        bool cont = false;\n\n        // Simply use the MVC API to find an interesting object\n        do {\n            cont = false;\n            int rowCount = m_model->rowCount( root );\n            if ( rowCount < 2 ) {\n                // remember, the first one is list of messages!\n                break;\n            }\n            // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n            for ( int i = 1; i < rowCount; ++i ) {\n                const QModelIndex index = m_model->index( i, 0, root );\n                const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n\n                if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                    // This shoudln't really happen\n                    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                      QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                    continue;\n                }\n\n                if ( possibleName == mailbox ) {\n                    // found it\n                    m_watchedNames.removeAll( mailbox );\n                    emit mailboxFound( mailbox, index );\n                    break;\n                } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                    // we know where to go\n                    root = index;\n                    cont = true;\n                    break;\n                }\n            }\n        } while ( cont );\n    }\n}",
          "includes": [
            "include \"ItemRoles.h\"",
            "include \"Model.h\"\n#",
            "include \"MailboxFinder.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  oid MailboxFinder::checkArrivals()\n  {\n      Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n          QModelIndex root;\n          bool cont = false;\n  \n          // Simply use the MVC API to find an interesting object\n          do {\n              cont = false;\n              int rowCount = m_model->rowCount( root );\n              if ( rowCount < 2 ) {\n                  // remember, the first one is list of messages!\n                  break;\n              }\n              // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n              for ( int i = 1; i < rowCount; ++i ) {\n                  const QModelIndex index = m_model->index( i, 0, root );\n                  const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                  const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n  \n                  if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                      // This shoudln't really happen\n                      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                        QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                      continue;\n                  }\n  \n                  if ( possibleName == mailbox ) {\n                      // found it\n                      m_watchedNames.removeAll( mailbox );\n                      emit mailboxFound( mailbox, index );\n                      break;\n                  } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                      // we know where to go\n                      root = index;\n                      cont = true;\n                      break;\n                  }\n              }\n          } while ( cont );\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_watchedNames.append",
          "args": [
            "ailbox)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  oid MailboxFinder::addMailbox( const QString &mailbox )\n  {\n      m_watchedNames.append(mailbox);\n      QTimer::singleShot(0, this, SLOT(checkArrivals()));\n  }\n}"
  },
  {
    "function_name": "MailboxFinder(",
    "container": "ailboxFinder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
    "lines": "40-46",
    "snippet": "ailboxFinder::MailboxFinder( QObject *parent, Imap::Mailbox::Model *model ) :\n    QObject(parent), m_model(model)\n{\n    Q_ASSERT(m_model);\n    connect( m_model, SIGNAL(layoutChanged()), this, SLOT(checkArrivals()) );\n    connect( m_model, SIGNAL(rowsInserted(QModelIndex,int,int)), this, SLOT(slotRowsInserted(QModelIndex,int,int)) );\n}",
    "includes": [
      "include \"ItemRoles.h\"",
      "include \"Model.h\"\n#",
      "include \"MailboxFinder.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(layoutChanged()),",
            "his,",
            "LOT(checkArrivals())"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "heckArrivals())"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heckArrivals(",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "checkArrivals(",
          "container": "ailboxFinder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxFinder.cpp",
          "lines": "54-95",
          "snippet": "oid MailboxFinder::checkArrivals()\n{\n    Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n        QModelIndex root;\n        bool cont = false;\n\n        // Simply use the MVC API to find an interesting object\n        do {\n            cont = false;\n            int rowCount = m_model->rowCount( root );\n            if ( rowCount < 2 ) {\n                // remember, the first one is list of messages!\n                break;\n            }\n            // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n            for ( int i = 1; i < rowCount; ++i ) {\n                const QModelIndex index = m_model->index( i, 0, root );\n                const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n\n                if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                    // This shoudln't really happen\n                    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                      QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                    continue;\n                }\n\n                if ( possibleName == mailbox ) {\n                    // found it\n                    m_watchedNames.removeAll( mailbox );\n                    emit mailboxFound( mailbox, index );\n                    break;\n                } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                    // we know where to go\n                    root = index;\n                    cont = true;\n                    break;\n                }\n            }\n        } while ( cont );\n    }\n}",
          "includes": [
            "include \"ItemRoles.h\"",
            "include \"Model.h\"\n#",
            "include \"MailboxFinder.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  oid MailboxFinder::checkArrivals()\n  {\n      Q_FOREACH( const QString &mailbox, m_watchedNames ) {\n          QModelIndex root;\n          bool cont = false;\n  \n          // Simply use the MVC API to find an interesting object\n          do {\n              cont = false;\n              int rowCount = m_model->rowCount( root );\n              if ( rowCount < 2 ) {\n                  // remember, the first one is list of messages!\n                  break;\n              }\n              // ...so the iteration really starts at 1. We go over all mailboxes which are children of current root.\n              for ( int i = 1; i < rowCount; ++i ) {\n                  const QModelIndex index = m_model->index( i, 0, root );\n                  const QString possibleName = m_model->data( index, Imap::Mailbox::RoleMailboxName ).toString();\n                  const QString separator = m_model->data( index, Imap::Mailbox::RoleMailboxSeparator ).toString();\n  \n                  if ( possibleName.isEmpty() && separator.isEmpty() ) {\n                      // This shoudln't really happen\n                      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MailboxFinder\"),\n                                        QLatin1String(\"Weird, there's a mailbox with no name and no separator. Avoiding!\"));\n                      continue;\n                  }\n  \n                  if ( possibleName == mailbox ) {\n                      // found it\n                      m_watchedNames.removeAll( mailbox );\n                      emit mailboxFound( mailbox, index );\n                      break;\n                  } else if ( mailbox.startsWith( possibleName + separator ) ) {\n                      // we know where to go\n                      root = index;\n                      cont = true;\n                      break;\n                  }\n              }\n          } while ( cont );\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ayoutChanged())"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ayoutChanged(",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "layoutChanged(",
          "container": "odelWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelWatcher.cpp",
          "lines": "94-97",
          "snippet": "oid ModelWatcher::layoutChanged()\n{\n    qDebug() << sender()->objectName() << \"layoutChanged()\";\n}",
          "includes": [
            "include \"ModelWatcher.h\"",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ModelWatcher.h\"\ninclude <QDebug>\n#\n\nodelWatcher {\n  oid ModelWatcher::layoutChanged()\n  {\n      qDebug() << sender()->objectName() << \"layoutChanged()\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_model)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"ItemRoles.h\"\ninclude \"Model.h\"\n#\ninclude \"MailboxFinder.h\"\n#\n\nailboxFinder {\n  ailboxFinder::MailboxFinder( QObject *parent, Imap::Mailbox::Model *model ) :\n      QObject(parent), m_model(model)\n  {\n      Q_ASSERT(m_model);\n      connect( m_model, SIGNAL(layoutChanged()), this, SLOT(checkArrivals()) );\n      connect( m_model, SIGNAL(rowsInserted(QModelIndex,int,int)), this, SLOT(slotRowsInserted(QModelIndex,int,int)) );\n  }\n}"
  }
]