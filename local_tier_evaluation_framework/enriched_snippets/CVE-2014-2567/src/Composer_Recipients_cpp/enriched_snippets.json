[
  {
    "function_name": "xtractEmailAddresses(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "406-412",
    "snippet": "List<Imap::Message::MailAddress> extractEmailAddresses(const RecipientList &list)\n{\n    QList<Imap::Message::MailAddress> addresses;\n    std::transform(list.constBegin(), list.constEnd(), std::back_inserter(addresses),\n                   ExtractSecond<RecipientList::value_type>());\n    return addresses;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "td::transform(",
          "args": [
            "ist.constBegin(),",
            "ist.constEnd(),",
            "td::back_inserter(addresses),",
            "xtractSecond<RecipientList::value_type>())"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtractSecond<RecipientList::value_type>",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::back_inserter(",
          "args": [
            "ddresses)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.constEnd",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.constBegin",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nList<Imap::Message::MailAddress> extractEmailAddresses(const RecipientList &list)\n{\n    QList<Imap::Message::MailAddress> addresses;\n    std::transform(list.constBegin(), list.constEnd(), std::back_inserter(addresses),\n                   ExtractSecond<RecipientList::value_type>());\n    return addresses;\n}"
  },
  {
    "function_name": "hooseSenderIdentityForReply(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "399-403",
    "snippet": "ool chooseSenderIdentityForReply(const SenderIdentitiesModel *senderIdetitiesModel,\n                                  const QModelIndex &message, int &row)\n{\n    return chooseSenderIdentity(senderIdetitiesModel, extractEmailAddresses(extractListOfRecipients(message)), row);\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hooseSenderIdentity(",
          "args": [
            "enderIdetitiesModel,",
            "xtractEmailAddresses(extractListOfRecipients(message)),",
            "ow)"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "hooseSenderIdentity(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "354-396",
          "snippet": "ool chooseSenderIdentity(const SenderIdentitiesModel *senderIdetitiesModel, const QList<Imap::Message::MailAddress> &addresses, int &row)\n{\n    using namespace Imap::Message;\n    QList<MailAddress> identities = extractEmailAddresses(senderIdetitiesModel);\n\n    // I want to stop this madness. I want C++11.\n\n    // First of all, look for a full match of the sender among the addresses\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByMail(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found an exact match of one of our identities in the recipients -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Then look for the matching domain\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomain(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Check for situations where the identity's domain is the suffix of some address\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomainSuffix(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain suffix matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // No other heuristic is there for now -> give up\n    return false;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool chooseSenderIdentity(const SenderIdentitiesModel *senderIdetitiesModel, const QList<Imap::Message::MailAddress> &addresses, int &row)\n{\n    using namespace Imap::Message;\n    QList<MailAddress> identities = extractEmailAddresses(senderIdetitiesModel);\n\n    // I want to stop this madness. I want C++11.\n\n    // First of all, look for a full match of the sender among the addresses\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByMail(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found an exact match of one of our identities in the recipients -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Then look for the matching domain\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomain(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Check for situations where the identity's domain is the suffix of some address\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomainSuffix(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain suffix matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // No other heuristic is there for now -> give up\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtractEmailAddresses(",
          "args": [
            "xtractListOfRecipients(message))"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xtractEmailAddresses(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "406-412",
          "snippet": "List<Imap::Message::MailAddress> extractEmailAddresses(const RecipientList &list)\n{\n    QList<Imap::Message::MailAddress> addresses;\n    std::transform(list.constBegin(), list.constEnd(), std::back_inserter(addresses),\n                   ExtractSecond<RecipientList::value_type>());\n    return addresses;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nList<Imap::Message::MailAddress> extractEmailAddresses(const RecipientList &list)\n{\n    QList<Imap::Message::MailAddress> addresses;\n    std::transform(list.constBegin(), list.constEnd(), std::back_inserter(addresses),\n                   ExtractSecond<RecipientList::value_type>());\n    return addresses;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtractListOfRecipients(",
          "args": [
            "essage)"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xtractListOfRecipients(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "239-267",
          "snippet": "ecipientList extractListOfRecipients(const QModelIndex &message)\n{\n    Composer::RecipientList originalRecipients;\n    if (!message.isValid())\n        return originalRecipients;\n\n    using namespace Imap::Mailbox;\n    using namespace Imap::Message;\n    Model *model = dynamic_cast<Model *>(const_cast<QAbstractItemModel *>(message.model()));\n    TreeItemMessage *messagePtr = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(message.internalPointer()));\n    Q_ASSERT(messagePtr);\n    Envelope envelope = messagePtr->envelope(model);\n\n    // Prepare the list of recipients\n    Q_FOREACH(const MailAddress &addr, envelope.from)\n        originalRecipients << qMakePair(Composer::ADDRESS_FROM, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.to)\n        originalRecipients << qMakePair(Composer::ADDRESS_TO, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.cc)\n        originalRecipients << qMakePair(Composer::ADDRESS_CC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.bcc)\n        originalRecipients << qMakePair(Composer::ADDRESS_BCC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.sender)\n        originalRecipients << qMakePair(Composer::ADDRESS_SENDER, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.replyTo)\n        originalRecipients << qMakePair(Composer::ADDRESS_REPLY_TO, addr);\n\n    return originalRecipients;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList extractListOfRecipients(const QModelIndex &message)\n{\n    Composer::RecipientList originalRecipients;\n    if (!message.isValid())\n        return originalRecipients;\n\n    using namespace Imap::Mailbox;\n    using namespace Imap::Message;\n    Model *model = dynamic_cast<Model *>(const_cast<QAbstractItemModel *>(message.model()));\n    TreeItemMessage *messagePtr = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(message.internalPointer()));\n    Q_ASSERT(messagePtr);\n    Envelope envelope = messagePtr->envelope(model);\n\n    // Prepare the list of recipients\n    Q_FOREACH(const MailAddress &addr, envelope.from)\n        originalRecipients << qMakePair(Composer::ADDRESS_FROM, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.to)\n        originalRecipients << qMakePair(Composer::ADDRESS_TO, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.cc)\n        originalRecipients << qMakePair(Composer::ADDRESS_CC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.bcc)\n        originalRecipients << qMakePair(Composer::ADDRESS_BCC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.sender)\n        originalRecipients << qMakePair(Composer::ADDRESS_SENDER, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.replyTo)\n        originalRecipients << qMakePair(Composer::ADDRESS_REPLY_TO, addr);\n\n    return originalRecipients;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool chooseSenderIdentityForReply(const SenderIdentitiesModel *senderIdetitiesModel,\n                                  const QModelIndex &message, int &row)\n{\n    return chooseSenderIdentity(senderIdetitiesModel, extractEmailAddresses(extractListOfRecipients(message)), row);\n}"
  },
  {
    "function_name": "hooseSenderIdentity(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "354-396",
    "snippet": "ool chooseSenderIdentity(const SenderIdentitiesModel *senderIdetitiesModel, const QList<Imap::Message::MailAddress> &addresses, int &row)\n{\n    using namespace Imap::Message;\n    QList<MailAddress> identities = extractEmailAddresses(senderIdetitiesModel);\n\n    // I want to stop this madness. I want C++11.\n\n    // First of all, look for a full match of the sender among the addresses\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByMail(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found an exact match of one of our identities in the recipients -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Then look for the matching domain\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomain(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Check for situations where the identity's domain is the suffix of some address\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomainSuffix(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain suffix matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // No other heuristic is there for now -> give up\n    return false;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ddresses.constEnd",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "ddresses.constBegin(),",
            "ddresses.constEnd(),",
            "td::bind2nd(Imap::Message::MailAddressesEqualByDomainSuffix(), identities[i]))"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::bind2nd(",
          "args": [
            "map::Message::MailAddressesEqualByDomainSuffix(),",
            "dentities[i])"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddressesEqualByDomainSuffix(",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constEnd",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constBegin",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentities.size",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constEnd",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "ddresses.constBegin(),",
            "ddresses.constEnd(),",
            "td::bind2nd(Imap::Message::MailAddressesEqualByDomain(), identities[i]))"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::bind2nd(",
          "args": [
            "map::Message::MailAddressesEqualByDomain(),",
            "dentities[i])"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddressesEqualByDomain(",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constEnd",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constBegin",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentities.size",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constEnd",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "ddresses.constBegin(),",
            "ddresses.constEnd(),",
            "td::bind2nd(Imap::Message::MailAddressesEqualByMail(), identities[i]))"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::bind2nd(",
          "args": [
            "map::Message::MailAddressesEqualByMail(),",
            "dentities[i])"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddressesEqualByMail(",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constEnd",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.constBegin",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentities.size",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtractEmailAddresses(",
          "args": [
            "enderIdetitiesModel)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "xtractEmailAddresses(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "406-412",
          "snippet": "List<Imap::Message::MailAddress> extractEmailAddresses(const RecipientList &list)\n{\n    QList<Imap::Message::MailAddress> addresses;\n    std::transform(list.constBegin(), list.constEnd(), std::back_inserter(addresses),\n                   ExtractSecond<RecipientList::value_type>());\n    return addresses;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nList<Imap::Message::MailAddress> extractEmailAddresses(const RecipientList &list)\n{\n    QList<Imap::Message::MailAddress> addresses;\n    std::transform(list.constBegin(), list.constEnd(), std::back_inserter(addresses),\n                   ExtractSecond<RecipientList::value_type>());\n    return addresses;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool chooseSenderIdentity(const SenderIdentitiesModel *senderIdetitiesModel, const QList<Imap::Message::MailAddress> &addresses, int &row)\n{\n    using namespace Imap::Message;\n    QList<MailAddress> identities = extractEmailAddresses(senderIdetitiesModel);\n\n    // I want to stop this madness. I want C++11.\n\n    // First of all, look for a full match of the sender among the addresses\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByMail(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found an exact match of one of our identities in the recipients -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Then look for the matching domain\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomain(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // Check for situations where the identity's domain is the suffix of some address\n    for (int i = 0; i < identities.size(); ++i) {\n        auto it = std::find_if(addresses.constBegin(), addresses.constEnd(),\n                               std::bind2nd(Imap::Message::MailAddressesEqualByDomainSuffix(), identities[i]));\n        if (it != addresses.constEnd()) {\n            // Found a match because the domain suffix matches -> return that\n            row = i;\n            return true;\n        }\n    }\n\n    // No other heuristic is there for now -> give up\n    return false;\n}"
  },
  {
    "function_name": "xtractEmailAddresses(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "339-351",
    "snippet": "List<Imap::Message::MailAddress> extractEmailAddresses(const SenderIdentitiesModel *senderIdetitiesModel)\n{\n    using namespace Imap::Message;\n    // What identities do we have?\n    QList<MailAddress> identities;\n    for (int i = 0; i < senderIdetitiesModel->rowCount(); ++i) {\n        MailAddress addr;\n        MailAddress::fromPrettyString(addr,\n                senderIdetitiesModel->data(senderIdetitiesModel->index(i, Composer::SenderIdentitiesModel::COLUMN_EMAIL)).toString());\n        identities << addr;\n    }\n    return identities;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailAddress::fromPrettyString(",
          "args": [
            "ddr,",
            "enderIdetitiesModel->data(senderIdetitiesModel->index(i, Composer::SenderIdentitiesModel::COLUMN_EMAIL)).toString())"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "fromPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "41-52",
          "snippet": "ool MailAddress::fromPrettyString(MailAddress &into, const QString &address)\n{\n    int offset = 0;\n\n    if (!parseOneAddress(into, address, offset))\n        return false;\n\n    if (offset < address.size())\n        return false;\n\n    return true;\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ool MailAddress::fromPrettyString(MailAddress &into, const QString &address)\n  {\n      int offset = 0;\n  \n      if (!parseOneAddress(into, address, offset))\n          return false;\n  \n      if (offset < address.size())\n          return false;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "enderIdetitiesModel->data",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "enderIdetitiesModel->data",
          "args": [
            "enderIdetitiesModel->index(i, Composer::SenderIdentitiesModel::COLUMN_EMAIL))"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enderIdetitiesModel->index",
          "args": [
            ",",
            "omposer::SenderIdentitiesModel::COLUMN_EMAIL)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enderIdetitiesModel->rowCount",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "133-153",
          "snippet": "void ModelTest::rowCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    int rows = model->rowCount(topIndex);\n    Q_ASSERT(rows >= 0);\n    if (rows > 0)\n        Q_ASSERT(model->hasChildren(topIndex) == true);\n\n    QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n    if (secondLevelIndex.isValid()) { // not the top level\n        // check a row count where parent is valid\n        rows = model->rowCount(secondLevelIndex);\n        Q_ASSERT(rows >= 0);\n        if (rows > 0)\n            Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n    }\n\n    // The models rowCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::rowCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      int rows = model->rowCount(topIndex);\n      Q_ASSERT(rows >= 0);\n      if (rows > 0)\n          Q_ASSERT(model->hasChildren(topIndex) == true);\n  \n      QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n      if (secondLevelIndex.isValid()) { // not the top level\n          // check a row count where parent is valid\n          rows = model->rowCount(secondLevelIndex);\n          Q_ASSERT(rows >= 0);\n          if (rows > 0)\n              Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n      }\n  \n      // The models rowCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nList<Imap::Message::MailAddress> extractEmailAddresses(const SenderIdentitiesModel *senderIdetitiesModel)\n{\n    using namespace Imap::Message;\n    // What identities do we have?\n    QList<MailAddress> identities;\n    for (int i = 0; i < senderIdetitiesModel->rowCount(); ++i) {\n        MailAddress addr;\n        MailAddress::fromPrettyString(addr,\n                senderIdetitiesModel->data(senderIdetitiesModel->index(i, Composer::SenderIdentitiesModel::COLUMN_EMAIL)).toString());\n        identities << addr;\n    }\n    return identities;\n}"
  },
  {
    "function_name": "eplyRecipientList(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "321-337",
    "snippet": "ool replyRecipientList(const ReplyMode mode, const SenderIdentitiesModel *senderIdetitiesModel,\n                        const QModelIndex &message, RecipientList &output)\n{\n    if (!message.isValid())\n        return false;\n\n    // Prepare the list of recipients\n    RecipientList originalRecipients = extractListOfRecipients(message);\n\n    // The List-Post header\n    QList<QUrl> headerListPost;\n    Q_FOREACH(const QVariant &item, message.data(Imap::Mailbox::RoleMessageHeaderListPost).toList())\n        headerListPost << item.toUrl();\n\n    return replyRecipientList(mode, senderIdetitiesModel, originalRecipients, headerListPost,\n                              message.data(Imap::Mailbox::RoleMessageHeaderListPostNo).toBool(), output);\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eplyRecipientList(",
          "args": [
            "ode,",
            "enderIdetitiesModel,",
            "riginalRecipients,",
            "eaderListPost,",
            "essage.data(Imap::Mailbox::RoleMessageHeaderListPostNo).toBool(),",
            "utput)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "eplyRecipientList(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "276-318",
          "snippet": "ool replyRecipientList(const ReplyMode mode, const SenderIdentitiesModel *senderIdetitiesModel,\n                        const RecipientList &originalRecipients,\n                        const QList<QUrl> &headerListPost, const bool headerListPostNo,\n                        RecipientList &output)\n{\n    switch (mode) {\n    case REPLY_ALL:\n        return prepareReplyAll(originalRecipients, output);\n    case REPLY_ALL_BUT_ME:\n    {\n        RecipientList res = output;\n        bool ok = prepareReplyAll(originalRecipients, res);\n        if (!ok)\n            return false;\n        Q_FOREACH(const Imap::Message::MailAddress &addr, extractEmailAddresses(senderIdetitiesModel)) {\n            RecipientList::iterator it = res.begin();\n            while (it != res.end()) {\n                if (Imap::Message::MailAddressesEqualByMail()(it->second, addr)) {\n                    // this is our own address\n                    it = res.erase(it);\n                } else {\n                    ++it;\n                }\n            }\n        }\n        // We might have deleted something, let's repeat the Cc -> To (...) promotion\n        res = deduplicatedAndJustToCcBcc(res);\n        if (res.size()) {\n            output = res;\n            return true;\n        } else {\n            return false;\n        }\n    }\n    case REPLY_PRIVATE:\n        return prepareReplySenderOnly(originalRecipients, headerListPost, output);\n    case REPLY_LIST:\n        return prepareReplyList(headerListPost, headerListPostNo, output);\n    }\n\n    Q_ASSERT(false);\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageHeaderListPostNo)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem.toUrl",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtractListOfRecipients(",
          "args": [
            "essage)"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "xtractListOfRecipients(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "239-267",
          "snippet": "ecipientList extractListOfRecipients(const QModelIndex &message)\n{\n    Composer::RecipientList originalRecipients;\n    if (!message.isValid())\n        return originalRecipients;\n\n    using namespace Imap::Mailbox;\n    using namespace Imap::Message;\n    Model *model = dynamic_cast<Model *>(const_cast<QAbstractItemModel *>(message.model()));\n    TreeItemMessage *messagePtr = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(message.internalPointer()));\n    Q_ASSERT(messagePtr);\n    Envelope envelope = messagePtr->envelope(model);\n\n    // Prepare the list of recipients\n    Q_FOREACH(const MailAddress &addr, envelope.from)\n        originalRecipients << qMakePair(Composer::ADDRESS_FROM, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.to)\n        originalRecipients << qMakePair(Composer::ADDRESS_TO, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.cc)\n        originalRecipients << qMakePair(Composer::ADDRESS_CC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.bcc)\n        originalRecipients << qMakePair(Composer::ADDRESS_BCC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.sender)\n        originalRecipients << qMakePair(Composer::ADDRESS_SENDER, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.replyTo)\n        originalRecipients << qMakePair(Composer::ADDRESS_REPLY_TO, addr);\n\n    return originalRecipients;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList extractListOfRecipients(const QModelIndex &message)\n{\n    Composer::RecipientList originalRecipients;\n    if (!message.isValid())\n        return originalRecipients;\n\n    using namespace Imap::Mailbox;\n    using namespace Imap::Message;\n    Model *model = dynamic_cast<Model *>(const_cast<QAbstractItemModel *>(message.model()));\n    TreeItemMessage *messagePtr = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(message.internalPointer()));\n    Q_ASSERT(messagePtr);\n    Envelope envelope = messagePtr->envelope(model);\n\n    // Prepare the list of recipients\n    Q_FOREACH(const MailAddress &addr, envelope.from)\n        originalRecipients << qMakePair(Composer::ADDRESS_FROM, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.to)\n        originalRecipients << qMakePair(Composer::ADDRESS_TO, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.cc)\n        originalRecipients << qMakePair(Composer::ADDRESS_CC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.bcc)\n        originalRecipients << qMakePair(Composer::ADDRESS_BCC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.sender)\n        originalRecipients << qMakePair(Composer::ADDRESS_SENDER, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.replyTo)\n        originalRecipients << qMakePair(Composer::ADDRESS_REPLY_TO, addr);\n\n    return originalRecipients;\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.isValid",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool replyRecipientList(const ReplyMode mode, const SenderIdentitiesModel *senderIdetitiesModel,\n                        const QModelIndex &message, RecipientList &output)\n{\n    if (!message.isValid())\n        return false;\n\n    // Prepare the list of recipients\n    RecipientList originalRecipients = extractListOfRecipients(message);\n\n    // The List-Post header\n    QList<QUrl> headerListPost;\n    Q_FOREACH(const QVariant &item, message.data(Imap::Mailbox::RoleMessageHeaderListPost).toList())\n        headerListPost << item.toUrl();\n\n    return replyRecipientList(mode, senderIdetitiesModel, originalRecipients, headerListPost,\n                              message.data(Imap::Mailbox::RoleMessageHeaderListPostNo).toBool(), output);\n}"
  },
  {
    "function_name": "eplyRecipientList(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "276-318",
    "snippet": "ool replyRecipientList(const ReplyMode mode, const SenderIdentitiesModel *senderIdetitiesModel,\n                        const RecipientList &originalRecipients,\n                        const QList<QUrl> &headerListPost, const bool headerListPostNo,\n                        RecipientList &output)\n{\n    switch (mode) {\n    case REPLY_ALL:\n        return prepareReplyAll(originalRecipients, output);\n    case REPLY_ALL_BUT_ME:\n    {\n        RecipientList res = output;\n        bool ok = prepareReplyAll(originalRecipients, res);\n        if (!ok)\n            return false;\n        Q_FOREACH(const Imap::Message::MailAddress &addr, extractEmailAddresses(senderIdetitiesModel)) {\n            RecipientList::iterator it = res.begin();\n            while (it != res.end()) {\n                if (Imap::Message::MailAddressesEqualByMail()(it->second, addr)) {\n                    // this is our own address\n                    it = res.erase(it);\n                } else {\n                    ++it;\n                }\n            }\n        }\n        // We might have deleted something, let's repeat the Cc -> To (...) promotion\n        res = deduplicatedAndJustToCcBcc(res);\n        if (res.size()) {\n            output = res;\n            return true;\n        } else {\n            return false;\n        }\n    }\n    case REPLY_PRIVATE:\n        return prepareReplySenderOnly(originalRecipients, headerListPost, output);\n    case REPLY_LIST:\n        return prepareReplyList(headerListPost, headerListPostNo, output);\n    }\n\n    Q_ASSERT(false);\n    return false;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repareReplyList(",
          "args": [
            "eaderListPost,",
            "eaderListPostNo,",
            "utput)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "repareReplyList(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "195-218",
          "snippet": "ool prepareReplyList(const QList<QUrl> &headerListPost, const bool headerListPostNo, RecipientList &output)\n{\n    if (headerListPostNo)\n        return false;\n\n    RecipientList res;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\"))\n            continue;\n\n        QStringList mail = url.path().split(QLatin1Char('@'));\n        if (mail.size() != 2)\n            continue;\n\n        res << qMakePair(Composer::ADDRESS_TO, Imap::Message::MailAddress(QString(), QString(), mail[0], mail[1]));\n    }\n\n    if (!res.isEmpty()) {\n        output = deduplicatedAndJustToCcBcc(res);\n        return true;\n    }\n\n    return false;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool prepareReplyList(const QList<QUrl> &headerListPost, const bool headerListPostNo, RecipientList &output)\n{\n    if (headerListPostNo)\n        return false;\n\n    RecipientList res;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\"))\n            continue;\n\n        QStringList mail = url.path().split(QLatin1Char('@'));\n        if (mail.size() != 2)\n            continue;\n\n        res << qMakePair(Composer::ADDRESS_TO, Imap::Message::MailAddress(QString(), QString(), mail[0], mail[1]));\n    }\n\n    if (!res.isEmpty()) {\n        output = deduplicatedAndJustToCcBcc(res);\n        return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repareReplySenderOnly(",
          "args": [
            "riginalRecipients,",
            "eaderListPost,",
            "utput)"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "repareReplySenderOnly(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "136-192",
          "snippet": "ool prepareReplySenderOnly(const RecipientList &originalRecipients, const QList<QUrl> &headerListPost, RecipientList &output)\n{\n    // Create a blacklist for the Reply-To filtering. This is needed to work with nasty mailing lists (hey, I run quite\n    // a few like that) which do the reply-to munging.\n    QList<QPair<QString, QString> > blacklist;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\")) {\n            // non-mail links are not relevant in this situation; they don't mean that we have to give up\n            continue;\n        }\n\n        QStringList list = url.path().split(QLatin1Char('@'));\n        if (list.size() != 2) {\n            // Malformed mailto: link, maybe it relies on some fancy routing? Either way, play it safe and refuse to work on that\n            return false;\n        }\n\n        // FIXME: we actually don't catch the routing!like!this#or#like#this (I don't remember which one is used).\n        // The routing shall definitely be checked.\n\n        // FIXME: URL decoding? UTF-8 denormalization?\n        blacklist << qMakePair(list[0].toLower(), list[1].toLower());\n    }\n\n    // Now gather all addresses from the From and Reply-To headers, taking care to skip munged Reply-To from ML software\n    RecipientList originalFrom, originalReplyTo;\n    Q_FOREACH(const RecipientList::value_type &recipient, originalRecipients) {\n        switch (recipient.first) {\n        case ADDRESS_FROM:\n            originalFrom << qMakePair(ADDRESS_TO, recipient.second);\n            break;\n        case ADDRESS_REPLY_TO:\n            if (blacklist.contains(qMakePair(recipient.second.mailbox.toLower(), recipient.second.host.toLower()))) {\n                // This is the safe situation, this item in the Reply-To is set to a recognized mailing list address.\n                // We can safely ignore that.\n            } else {\n                originalReplyTo << qMakePair(ADDRESS_TO, recipient.second);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (!originalReplyTo.isEmpty()) {\n        // Prefer replying to the (ML-demunged) Reply-To addresses\n        output = originalReplyTo;\n        return true;\n    } else if (!originalFrom.isEmpty()) {\n        // If no usable thing is in the Reply-To, fall back to anything in From\n        output = originalFrom;\n        return true;\n    } else {\n        // No recognized addresses -> bail out\n        return false;\n    }\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool prepareReplySenderOnly(const RecipientList &originalRecipients, const QList<QUrl> &headerListPost, RecipientList &output)\n{\n    // Create a blacklist for the Reply-To filtering. This is needed to work with nasty mailing lists (hey, I run quite\n    // a few like that) which do the reply-to munging.\n    QList<QPair<QString, QString> > blacklist;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\")) {\n            // non-mail links are not relevant in this situation; they don't mean that we have to give up\n            continue;\n        }\n\n        QStringList list = url.path().split(QLatin1Char('@'));\n        if (list.size() != 2) {\n            // Malformed mailto: link, maybe it relies on some fancy routing? Either way, play it safe and refuse to work on that\n            return false;\n        }\n\n        // FIXME: we actually don't catch the routing!like!this#or#like#this (I don't remember which one is used).\n        // The routing shall definitely be checked.\n\n        // FIXME: URL decoding? UTF-8 denormalization?\n        blacklist << qMakePair(list[0].toLower(), list[1].toLower());\n    }\n\n    // Now gather all addresses from the From and Reply-To headers, taking care to skip munged Reply-To from ML software\n    RecipientList originalFrom, originalReplyTo;\n    Q_FOREACH(const RecipientList::value_type &recipient, originalRecipients) {\n        switch (recipient.first) {\n        case ADDRESS_FROM:\n            originalFrom << qMakePair(ADDRESS_TO, recipient.second);\n            break;\n        case ADDRESS_REPLY_TO:\n            if (blacklist.contains(qMakePair(recipient.second.mailbox.toLower(), recipient.second.host.toLower()))) {\n                // This is the safe situation, this item in the Reply-To is set to a recognized mailing list address.\n                // We can safely ignore that.\n            } else {\n                originalReplyTo << qMakePair(ADDRESS_TO, recipient.second);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (!originalReplyTo.isEmpty()) {\n        // Prefer replying to the (ML-demunged) Reply-To addresses\n        output = originalReplyTo;\n        return true;\n    } else if (!originalFrom.isEmpty()) {\n        // If no usable thing is in the Reply-To, fall back to anything in From\n        output = originalFrom;\n        return true;\n    } else {\n        // No recognized addresses -> bail out\n        return false;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "es.size",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eduplicatedAndJustToCcBcc(",
          "args": [
            "es)"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "eduplicatedAndJustToCcBcc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "38-91",
          "snippet": "ecipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "es.erase",
          "args": [
            "t)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddressesEqualByMail",
          "args": [
            "t->second,",
            "ddr)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddressesEqualByMail(",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.end",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.begin",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repareReplyAll(",
          "args": [
            "riginalRecipients,",
            "es)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "repareReplyAll(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "118-133",
          "snippet": "ool prepareReplyAll(const RecipientList &originalRecipients, RecipientList &output)\n{\n    QMap<RecipientKind, RecipientKind> mapping;\n    mapping[ADDRESS_FROM] = ADDRESS_TO;\n    mapping[ADDRESS_REPLY_TO] = ADDRESS_CC;\n    mapping[ADDRESS_TO] = ADDRESS_CC;\n    mapping[ADDRESS_CC] = ADDRESS_CC;\n    mapping[ADDRESS_BCC] = ADDRESS_BCC;\n    RecipientList res = deduplicatedAndJustToCcBcc(mapRecipients(originalRecipients, mapping));\n    if (res.isEmpty()) {\n        return false;\n    } else {\n        output = res;\n        return true;\n    }\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool prepareReplyAll(const RecipientList &originalRecipients, RecipientList &output)\n{\n    QMap<RecipientKind, RecipientKind> mapping;\n    mapping[ADDRESS_FROM] = ADDRESS_TO;\n    mapping[ADDRESS_REPLY_TO] = ADDRESS_CC;\n    mapping[ADDRESS_TO] = ADDRESS_CC;\n    mapping[ADDRESS_CC] = ADDRESS_CC;\n    mapping[ADDRESS_BCC] = ADDRESS_BCC;\n    RecipientList res = deduplicatedAndJustToCcBcc(mapRecipients(originalRecipients, mapping));\n    if (res.isEmpty()) {\n        return false;\n    } else {\n        output = res;\n        return true;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool replyRecipientList(const ReplyMode mode, const SenderIdentitiesModel *senderIdetitiesModel,\n                        const RecipientList &originalRecipients,\n                        const QList<QUrl> &headerListPost, const bool headerListPostNo,\n                        RecipientList &output)\n{\n    switch (mode) {\n    case REPLY_ALL:\n        return prepareReplyAll(originalRecipients, output);\n    case REPLY_ALL_BUT_ME:\n    {\n        RecipientList res = output;\n        bool ok = prepareReplyAll(originalRecipients, res);\n        if (!ok)\n            return false;\n        Q_FOREACH(const Imap::Message::MailAddress &addr, extractEmailAddresses(senderIdetitiesModel)) {\n            RecipientList::iterator it = res.begin();\n            while (it != res.end()) {\n                if (Imap::Message::MailAddressesEqualByMail()(it->second, addr)) {\n                    // this is our own address\n                    it = res.erase(it);\n                } else {\n                    ++it;\n                }\n            }\n        }\n        // We might have deleted something, let's repeat the Cc -> To (...) promotion\n        res = deduplicatedAndJustToCcBcc(res);\n        if (res.size()) {\n            output = res;\n            return true;\n        } else {\n            return false;\n        }\n    }\n    case REPLY_PRIVATE:\n        return prepareReplySenderOnly(originalRecipients, headerListPost, output);\n    case REPLY_LIST:\n        return prepareReplyList(headerListPost, headerListPostNo, output);\n    }\n\n    Q_ASSERT(false);\n    return false;\n}"
  },
  {
    "function_name": "xtractListOfRecipients(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "239-267",
    "snippet": "ecipientList extractListOfRecipients(const QModelIndex &message)\n{\n    Composer::RecipientList originalRecipients;\n    if (!message.isValid())\n        return originalRecipients;\n\n    using namespace Imap::Mailbox;\n    using namespace Imap::Message;\n    Model *model = dynamic_cast<Model *>(const_cast<QAbstractItemModel *>(message.model()));\n    TreeItemMessage *messagePtr = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(message.internalPointer()));\n    Q_ASSERT(messagePtr);\n    Envelope envelope = messagePtr->envelope(model);\n\n    // Prepare the list of recipients\n    Q_FOREACH(const MailAddress &addr, envelope.from)\n        originalRecipients << qMakePair(Composer::ADDRESS_FROM, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.to)\n        originalRecipients << qMakePair(Composer::ADDRESS_TO, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.cc)\n        originalRecipients << qMakePair(Composer::ADDRESS_CC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.bcc)\n        originalRecipients << qMakePair(Composer::ADDRESS_BCC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.sender)\n        originalRecipients << qMakePair(Composer::ADDRESS_SENDER, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.replyTo)\n        originalRecipients << qMakePair(Composer::ADDRESS_REPLY_TO, addr);\n\n    return originalRecipients;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_REPLY_TO,",
            "ddr)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_SENDER,",
            "ddr)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_BCC,",
            "ddr)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_CC,",
            "ddr)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_TO,",
            "ddr)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_FROM,",
            "ddr)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essagePtr->envelope",
          "args": [
            "odel)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essagePtr)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage *>",
          "args": [
            "tatic_cast<TreeItem *>(message.internalPointer()))"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "essage.internalPointer())"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.internalPointer",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<Model *>",
          "args": [
            "onst_cast<QAbstractItemModel *>(message.model()))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<QAbstractItemModel *>",
          "args": [
            "essage.model())"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.model",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.isValid",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList extractListOfRecipients(const QModelIndex &message)\n{\n    Composer::RecipientList originalRecipients;\n    if (!message.isValid())\n        return originalRecipients;\n\n    using namespace Imap::Mailbox;\n    using namespace Imap::Message;\n    Model *model = dynamic_cast<Model *>(const_cast<QAbstractItemModel *>(message.model()));\n    TreeItemMessage *messagePtr = dynamic_cast<TreeItemMessage *>(static_cast<TreeItem *>(message.internalPointer()));\n    Q_ASSERT(messagePtr);\n    Envelope envelope = messagePtr->envelope(model);\n\n    // Prepare the list of recipients\n    Q_FOREACH(const MailAddress &addr, envelope.from)\n        originalRecipients << qMakePair(Composer::ADDRESS_FROM, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.to)\n        originalRecipients << qMakePair(Composer::ADDRESS_TO, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.cc)\n        originalRecipients << qMakePair(Composer::ADDRESS_CC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.bcc)\n        originalRecipients << qMakePair(Composer::ADDRESS_BCC, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.sender)\n        originalRecipients << qMakePair(Composer::ADDRESS_SENDER, addr);\n    Q_FOREACH(const MailAddress &addr, envelope.replyTo)\n        originalRecipients << qMakePair(Composer::ADDRESS_REPLY_TO, addr);\n\n    return originalRecipients;\n}"
  },
  {
    "function_name": "repareReplyList(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "195-218",
    "snippet": "ool prepareReplyList(const QList<QUrl> &headerListPost, const bool headerListPostNo, RecipientList &output)\n{\n    if (headerListPostNo)\n        return false;\n\n    RecipientList res;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\"))\n            continue;\n\n        QStringList mail = url.path().split(QLatin1Char('@'));\n        if (mail.size() != 2)\n            continue;\n\n        res << qMakePair(Composer::ADDRESS_TO, Imap::Message::MailAddress(QString(), QString(), mail[0], mail[1]));\n    }\n\n    if (!res.isEmpty()) {\n        output = deduplicatedAndJustToCcBcc(res);\n        return true;\n    }\n\n    return false;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eduplicatedAndJustToCcBcc(",
          "args": [
            "es)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "eduplicatedAndJustToCcBcc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "38-91",
          "snippet": "ecipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "es.isEmpty",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_TO,",
            "map::Message::MailAddress(QString(), QString(), mail[0], mail[1]))"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Message::MailAddress(",
          "args": [
            "String(),",
            "String(),",
            "ail[0],",
            "ail[1])"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ail.size",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [
            "Latin1Char('@'))"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "@')"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mailto\")"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool prepareReplyList(const QList<QUrl> &headerListPost, const bool headerListPostNo, RecipientList &output)\n{\n    if (headerListPostNo)\n        return false;\n\n    RecipientList res;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\"))\n            continue;\n\n        QStringList mail = url.path().split(QLatin1Char('@'));\n        if (mail.size() != 2)\n            continue;\n\n        res << qMakePair(Composer::ADDRESS_TO, Imap::Message::MailAddress(QString(), QString(), mail[0], mail[1]));\n    }\n\n    if (!res.isEmpty()) {\n        output = deduplicatedAndJustToCcBcc(res);\n        return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "repareReplySenderOnly(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "136-192",
    "snippet": "ool prepareReplySenderOnly(const RecipientList &originalRecipients, const QList<QUrl> &headerListPost, RecipientList &output)\n{\n    // Create a blacklist for the Reply-To filtering. This is needed to work with nasty mailing lists (hey, I run quite\n    // a few like that) which do the reply-to munging.\n    QList<QPair<QString, QString> > blacklist;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\")) {\n            // non-mail links are not relevant in this situation; they don't mean that we have to give up\n            continue;\n        }\n\n        QStringList list = url.path().split(QLatin1Char('@'));\n        if (list.size() != 2) {\n            // Malformed mailto: link, maybe it relies on some fancy routing? Either way, play it safe and refuse to work on that\n            return false;\n        }\n\n        // FIXME: we actually don't catch the routing!like!this#or#like#this (I don't remember which one is used).\n        // The routing shall definitely be checked.\n\n        // FIXME: URL decoding? UTF-8 denormalization?\n        blacklist << qMakePair(list[0].toLower(), list[1].toLower());\n    }\n\n    // Now gather all addresses from the From and Reply-To headers, taking care to skip munged Reply-To from ML software\n    RecipientList originalFrom, originalReplyTo;\n    Q_FOREACH(const RecipientList::value_type &recipient, originalRecipients) {\n        switch (recipient.first) {\n        case ADDRESS_FROM:\n            originalFrom << qMakePair(ADDRESS_TO, recipient.second);\n            break;\n        case ADDRESS_REPLY_TO:\n            if (blacklist.contains(qMakePair(recipient.second.mailbox.toLower(), recipient.second.host.toLower()))) {\n                // This is the safe situation, this item in the Reply-To is set to a recognized mailing list address.\n                // We can safely ignore that.\n            } else {\n                originalReplyTo << qMakePair(ADDRESS_TO, recipient.second);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (!originalReplyTo.isEmpty()) {\n        // Prefer replying to the (ML-demunged) Reply-To addresses\n        output = originalReplyTo;\n        return true;\n    } else if (!originalFrom.isEmpty()) {\n        // If no usable thing is in the Reply-To, fall back to anything in From\n        output = originalFrom;\n        return true;\n    } else {\n        // No recognized addresses -> bail out\n        return false;\n    }\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "riginalFrom.isEmpty",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riginalReplyTo.isEmpty",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "DDRESS_TO,",
            "ecipient.second)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lacklist.contains",
          "args": [
            "MakePair(recipient.second.mailbox.toLower(), recipient.second.host.toLower()))"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ecipient.second.mailbox.toLower(),",
            "ecipient.second.host.toLower())"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecipient.second.host.toLower",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecipient.second.mailbox.toLower",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "DDRESS_TO,",
            "ecipient.second)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ist[0].toLower(),",
            "ist[1].toLower())"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[1].toLower",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist[0].toLower",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.size",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [
            "Latin1Char('@'))"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "@')"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mailto\")"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool prepareReplySenderOnly(const RecipientList &originalRecipients, const QList<QUrl> &headerListPost, RecipientList &output)\n{\n    // Create a blacklist for the Reply-To filtering. This is needed to work with nasty mailing lists (hey, I run quite\n    // a few like that) which do the reply-to munging.\n    QList<QPair<QString, QString> > blacklist;\n    Q_FOREACH(const QUrl &url, headerListPost) {\n        if (url.scheme().toLower() != QLatin1String(\"mailto\")) {\n            // non-mail links are not relevant in this situation; they don't mean that we have to give up\n            continue;\n        }\n\n        QStringList list = url.path().split(QLatin1Char('@'));\n        if (list.size() != 2) {\n            // Malformed mailto: link, maybe it relies on some fancy routing? Either way, play it safe and refuse to work on that\n            return false;\n        }\n\n        // FIXME: we actually don't catch the routing!like!this#or#like#this (I don't remember which one is used).\n        // The routing shall definitely be checked.\n\n        // FIXME: URL decoding? UTF-8 denormalization?\n        blacklist << qMakePair(list[0].toLower(), list[1].toLower());\n    }\n\n    // Now gather all addresses from the From and Reply-To headers, taking care to skip munged Reply-To from ML software\n    RecipientList originalFrom, originalReplyTo;\n    Q_FOREACH(const RecipientList::value_type &recipient, originalRecipients) {\n        switch (recipient.first) {\n        case ADDRESS_FROM:\n            originalFrom << qMakePair(ADDRESS_TO, recipient.second);\n            break;\n        case ADDRESS_REPLY_TO:\n            if (blacklist.contains(qMakePair(recipient.second.mailbox.toLower(), recipient.second.host.toLower()))) {\n                // This is the safe situation, this item in the Reply-To is set to a recognized mailing list address.\n                // We can safely ignore that.\n            } else {\n                originalReplyTo << qMakePair(ADDRESS_TO, recipient.second);\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (!originalReplyTo.isEmpty()) {\n        // Prefer replying to the (ML-demunged) Reply-To addresses\n        output = originalReplyTo;\n        return true;\n    } else if (!originalFrom.isEmpty()) {\n        // If no usable thing is in the Reply-To, fall back to anything in From\n        output = originalFrom;\n        return true;\n    } else {\n        // No recognized addresses -> bail out\n        return false;\n    }\n}"
  },
  {
    "function_name": "repareReplyAll(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "118-133",
    "snippet": "ool prepareReplyAll(const RecipientList &originalRecipients, RecipientList &output)\n{\n    QMap<RecipientKind, RecipientKind> mapping;\n    mapping[ADDRESS_FROM] = ADDRESS_TO;\n    mapping[ADDRESS_REPLY_TO] = ADDRESS_CC;\n    mapping[ADDRESS_TO] = ADDRESS_CC;\n    mapping[ADDRESS_CC] = ADDRESS_CC;\n    mapping[ADDRESS_BCC] = ADDRESS_BCC;\n    RecipientList res = deduplicatedAndJustToCcBcc(mapRecipients(originalRecipients, mapping));\n    if (res.isEmpty()) {\n        return false;\n    } else {\n        output = res;\n        return true;\n    }\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "es.isEmpty",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eduplicatedAndJustToCcBcc(",
          "args": [
            "apRecipients(originalRecipients, mapping))"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "eduplicatedAndJustToCcBcc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "38-91",
          "snippet": "ecipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apRecipients(",
          "args": [
            "riginalRecipients,",
            "apping)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "apRecipients(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
          "lines": "99-115",
          "snippet": "ecipientList mapRecipients(RecipientList input, const QMap<RecipientKind, RecipientKind>& mapping)\n{\n    RecipientList::iterator recipient = input.begin();\n    while (recipient != input.end()) {\n        QMap<RecipientKind, RecipientKind>::const_iterator operation = mapping.constFind(recipient->first);\n        if (operation == mapping.constEnd()) {\n            recipient = input.erase(recipient);\n        } else if (*operation != recipient->first) {\n            recipient->first = *operation;\n            ++recipient;\n        } else {\n            // don't modify items which don't need modification\n            ++recipient;\n        }\n    }\n    return input;\n}",
          "includes": [
            "include \"Imap/Model/Model.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"SenderIdentitiesModel.h\"\n#",
            "include \"Recipients.h\"\n#",
            "include <QUrl>\n#",
            "include <QStringList>\n#",
            "include <QSet>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList mapRecipients(RecipientList input, const QMap<RecipientKind, RecipientKind>& mapping)\n{\n    RecipientList::iterator recipient = input.begin();\n    while (recipient != input.end()) {\n        QMap<RecipientKind, RecipientKind>::const_iterator operation = mapping.constFind(recipient->first);\n        if (operation == mapping.constEnd()) {\n            recipient = input.erase(recipient);\n        } else if (*operation != recipient->first) {\n            recipient->first = *operation;\n            ++recipient;\n        } else {\n            // don't modify items which don't need modification\n            ++recipient;\n        }\n    }\n    return input;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\nool prepareReplyAll(const RecipientList &originalRecipients, RecipientList &output)\n{\n    QMap<RecipientKind, RecipientKind> mapping;\n    mapping[ADDRESS_FROM] = ADDRESS_TO;\n    mapping[ADDRESS_REPLY_TO] = ADDRESS_CC;\n    mapping[ADDRESS_TO] = ADDRESS_CC;\n    mapping[ADDRESS_CC] = ADDRESS_CC;\n    mapping[ADDRESS_BCC] = ADDRESS_BCC;\n    RecipientList res = deduplicatedAndJustToCcBcc(mapRecipients(originalRecipients, mapping));\n    if (res.isEmpty()) {\n        return false;\n    } else {\n        output = res;\n        return true;\n    }\n}"
  },
  {
    "function_name": "apRecipients(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "99-115",
    "snippet": "ecipientList mapRecipients(RecipientList input, const QMap<RecipientKind, RecipientKind>& mapping)\n{\n    RecipientList::iterator recipient = input.begin();\n    while (recipient != input.end()) {\n        QMap<RecipientKind, RecipientKind>::const_iterator operation = mapping.constFind(recipient->first);\n        if (operation == mapping.constEnd()) {\n            recipient = input.erase(recipient);\n        } else if (*operation != recipient->first) {\n            recipient->first = *operation;\n            ++recipient;\n        } else {\n            // don't modify items which don't need modification\n            ++recipient;\n        }\n    }\n    return input;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nput.erase",
          "args": [
            "ecipient)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apping.constEnd",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apping.constFind",
          "args": [
            "ecipient->first)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.end",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.begin",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList mapRecipients(RecipientList input, const QMap<RecipientKind, RecipientKind>& mapping)\n{\n    RecipientList::iterator recipient = input.begin();\n    while (recipient != input.end()) {\n        QMap<RecipientKind, RecipientKind>::const_iterator operation = mapping.constFind(recipient->first);\n        if (operation == mapping.constEnd()) {\n            recipient = input.erase(recipient);\n        } else if (*operation != recipient->first) {\n            recipient->first = *operation;\n            ++recipient;\n        } else {\n            // don't modify items which don't need modification\n            ++recipient;\n        }\n    }\n    return input;\n}"
  },
  {
    "function_name": "eduplicatedAndJustToCcBcc(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Recipients.cpp",
    "lines": "38-91",
    "snippet": "ecipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}",
    "includes": [
      "include \"Imap/Model/Model.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"SenderIdentitiesModel.h\"\n#",
      "include \"Recipients.h\"\n#",
      "include <QUrl>\n#",
      "include <QStringList>\n#",
      "include <QSet>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lreadySeen.insert",
          "args": [
            "tem)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_BCC,",
            "ddr)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lreadySeen.contains",
          "args": [
            "tem)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ddr.mailbox,",
            "ddr.host)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lreadySeen.insert",
          "args": [
            "tem)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "esult.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC,",
            "ddr)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esult.isEmpty",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lreadySeen.contains",
          "args": [
            "tem)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ddr.mailbox,",
            "ddr.host)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lreadySeen.insert",
          "args": [
            "tem)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "omposer::ADDRESS_TO,",
            "ddr)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lreadySeen.contains",
          "args": [
            "tem)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ddr.mailbox,",
            "ddr.host)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Model.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"SenderIdentitiesModel.h\"\n#\ninclude \"Recipients.h\"\n#\ninclude <QUrl>\n#\ninclude <QStringList>\n#\ninclude <QSet>\n#\ninclude <algorithm>\n#\n\necipientList deduplicatedAndJustToCcBcc(RecipientList input)\n{\n    QList<Imap::Message::MailAddress> to, cc, bcc;\n\n    Q_FOREACH(const RecipientList::value_type &recipient, input) {\n        switch (recipient.first) {\n        case Composer::ADDRESS_TO:\n            to << recipient.second;\n            break;\n        case Composer::ADDRESS_CC:\n            cc << recipient.second;\n            break;\n        case Composer::ADDRESS_BCC:\n            bcc << recipient.second;\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // that's right, ignore these\n            break;\n        }\n    }\n\n    // Keep processing the To, Cc and Bcc fields, making sure that no duplicates (where comparing just the addresses) are present\n    // in any of them and also making sure that an address is present in at most one of the (To, Cc, Bcc) groups.\n    RecipientList result;\n    QSet<QPair<QString, QString> > alreadySeen;\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, to) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_TO, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, cc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(result.isEmpty() ? Composer::ADDRESS_TO : Composer::ADDRESS_CC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    Q_FOREACH(const Imap::Message::MailAddress &addr, bcc) {\n        QPair<QString, QString> item = qMakePair(addr.mailbox, addr.host);\n        if (!alreadySeen.contains(item)) {\n            result << qMakePair(Composer::ADDRESS_BCC, addr);\n            alreadySeen.insert(item);\n        }\n    }\n\n    return result;\n}"
  }
]