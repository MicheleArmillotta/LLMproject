[
  {
    "function_name": "umpModelContents(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "281-292",
    "snippet": "oid dumpModelContents(QAbstractItemModel *model, QModelIndex index, int offset)\n{\n    qDebug() << QByteArray().fill(' ', offset) << index.data(Qt::DisplayRole).toString();\n    for (int i=0; i < model->rowCount(index); ++i) {\n        QModelIndex child = model->index(i, 0, index);\n        if (!child.isValid()) {\n            qDebug() << \"FAIL: \" << index << child << i << model->rowCount(index);\n        }\n        Q_ASSERT(child.isValid());\n        dumpModelContents(model, child, offset + 1);\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umpModelContents(",
          "args": [
            "odel,",
            "hild,",
            "ffset + 1)"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "umpModelContents(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "281-292",
          "snippet": "oid dumpModelContents(QAbstractItemModel *model, QModelIndex index, int offset)\n{\n    qDebug() << QByteArray().fill(' ', offset) << index.data(Qt::DisplayRole).toString();\n    for (int i=0; i < model->rowCount(index); ++i) {\n        QModelIndex child = model->index(i, 0, index);\n        if (!child.isValid()) {\n            qDebug() << \"FAIL: \" << index << child << i << model->rowCount(index);\n        }\n        Q_ASSERT(child.isValid());\n        dumpModelContents(model, child, offset + 1);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hild.isValid())"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hild.isValid",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->rowCount",
          "args": [
            "ndex)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "134-153",
          "snippet": "nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        // This is where it starts to get complicated -- we're somewhere inside the tree\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // A child of the top level item, ie. a ParserState object\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            return parserState.activeTasks.size();\n        } else {\n            // It's a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            return task->dependentTasks.size();\n        }\n    } else {\n        // The top-level stuff children represent the list of active connections\n        return m_model->m_parsers.size();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          // This is where it starts to get complicated -- we're somewhere inside the tree\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // A child of the top level item, ie. a ParserState object\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              return parserState.activeTasks.size();\n          } else {\n              // It's a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              return task->dependentTasks.size();\n          }\n      } else {\n          // The top-level stuff children represent the list of active connections\n          return m_model->m_parsers.size();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->index",
          "args": [
            ",",
            ",",
            "ndex)"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "index(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "51-87",
          "snippet": "ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n{\n    if (column != 0)\n        return QModelIndex();\n    if (row < 0)\n        return QModelIndex();\n\n    if (parent.isValid()) {\n        // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // The parent is a ParserState\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            if (row >= parserState.activeTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, parserState.activeTasks.at(row));\n            }\n        } else {\n            // The parent is a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            if (row >= task->dependentTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, task->dependentTasks.at(row));\n            }\n        }\n    } else {\n        // So this is about a ParserState -- fair enough\n        if (row >= m_model->m_parsers.size()) {\n            return QModelIndex();\n        } else {\n            return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n  {\n      if (column != 0)\n          return QModelIndex();\n      if (row < 0)\n          return QModelIndex();\n  \n      if (parent.isValid()) {\n          // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // The parent is a ParserState\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              if (row >= parserState.activeTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, parserState.activeTasks.at(row));\n              }\n          } else {\n              // The parent is a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              if (row >= task->dependentTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, task->dependentTasks.at(row));\n              }\n          }\n      } else {\n          // So this is about a ParserState -- fair enough\n          if (row >= m_model->m_parsers.size()) {\n              return QModelIndex();\n          } else {\n              return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "t::DisplayRole)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray",
          "args": [
            "',",
            "ffset)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "334-340",
          "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\noid dumpModelContents(QAbstractItemModel *model, QModelIndex index, int offset)\n{\n    qDebug() << QByteArray().fill(' ', offset) << index.data(Qt::DisplayRole).toString();\n    for (int i=0; i < model->rowCount(index); ++i) {\n        QModelIndex child = model->index(i, 0, index);\n        if (!child.isValid()) {\n            qDebug() << \"FAIL: \" << index << child << i << model->rowCount(index);\n        }\n        Q_ASSERT(child.isValid());\n        dumpModelContents(model, child, offset + 1);\n    }\n}"
  },
  {
    "function_name": "slotTaskMighHaveChanged(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "264-279",
    "snippet": "oid TaskPresentationModel::slotTaskMighHaveChanged(ImapTask *task)\n{\n    CHECK_TASK_TREE\n    if (task->isFinished()) {\n        // finished tasks are not located in our tree, so indexForTask would assert on them\n        return;\n    }\n    if (KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(task)) {\n        if (keepTask->isReadyToTerminate()) {\n            // this one could be missing from the mapping, too\n            return;\n        }\n    }\n    QModelIndex index = indexForTask(task);\n    emit dataChanged(index, index);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndexForTask(",
          "args": [
            "ask)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "indexForTask(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "111-132",
          "snippet": "ModelIndex TaskPresentationModel::indexForTask(ImapTask *const task) const\n{\n    Q_ASSERT(task);\n    if (task->parentTask) {\n        // The target task is a child of another task\n        int index = task->parentTask->dependentTasks.indexOf(task);\n        Q_ASSERT(index != -1);\n        return createIndex(index, 0, task);\n    } else {\n        // The child has no parent task, so the child is apparently the top-level task for a given parser,\n        Q_ASSERT(task->parser);\n        int index = m_model->accessParser(task->parser).activeTasks.indexOf(task);\n        if (index == -1) {\n#ifdef TROJITA_DEBUG_TASK_TREE\n            m_model->checkTaskTreeConsistency();\n            Q_ASSERT(index != -1);\n#endif\n            return QModelIndex();\n        }\n        return createIndex(index, 0, task);\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::indexForTask(ImapTask *const task) const\n  {\n      Q_ASSERT(task);\n      if (task->parentTask) {\n          // The target task is a child of another task\n          int index = task->parentTask->dependentTasks.indexOf(task);\n          Q_ASSERT(index != -1);\n          return createIndex(index, 0, task);\n      } else {\n          // The child has no parent task, so the child is apparently the top-level task for a given parser,\n          Q_ASSERT(task->parser);\n          int index = m_model->accessParser(task->parser).activeTasks.indexOf(task);\n          if (index == -1) {\n  #ifdef TROJITA_DEBUG_TASK_TREE\n              m_model->checkTaskTreeConsistency();\n              Q_ASSERT(index != -1);\n  #endif\n              return QModelIndex();\n          }\n          return createIndex(index, 0, task);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eepTask->isReadyToTerminate",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<KeepMailboxOpenTask*>",
          "args": [
            "ask)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->isFinished",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotTaskMighHaveChanged(ImapTask *task)\n  {\n      CHECK_TASK_TREE\n      if (task->isFinished()) {\n          // finished tasks are not located in our tree, so indexForTask would assert on them\n          return;\n      }\n      if (KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(task)) {\n          if (keepTask->isReadyToTerminate()) {\n              // this one could be missing from the mapping, too\n              return;\n          }\n      }\n      QModelIndex index = indexForTask(task);\n      emit dataChanged(index, index);\n  }\n}"
  },
  {
    "function_name": "slotTaskGotReparented(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "255-261",
    "snippet": "oid TaskPresentationModel::slotTaskGotReparented(const ImapTask *const task)\n{\n    Q_UNUSED(task);\n    CHECK_TASK_TREE\n    RESET_MODEL;\n    CHECK_TASK_TREE\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ask)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotTaskGotReparented(const ImapTask *const task)\n  {\n      Q_UNUSED(task);\n      CHECK_TASK_TREE\n      RESET_MODEL;\n      CHECK_TASK_TREE\n  }\n}"
  },
  {
    "function_name": "slotParserDeleted(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "243-249",
    "snippet": "oid TaskPresentationModel::slotParserDeleted(Parser *parser)\n{\n    Q_UNUSED(parser);\n    CHECK_TASK_TREE\n    RESET_MODEL;\n    CHECK_TASK_TREE\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "arser)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotParserDeleted(Parser *parser)\n  {\n      Q_UNUSED(parser);\n      CHECK_TASK_TREE\n      RESET_MODEL;\n      CHECK_TASK_TREE\n  }\n}"
  },
  {
    "function_name": "slotParserCreated(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "231-237",
    "snippet": "oid TaskPresentationModel::slotParserCreated(Parser *parser)\n{\n    Q_UNUSED(parser);\n    CHECK_TASK_TREE\n    RESET_MODEL;\n    CHECK_TASK_TREE\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "arser)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotParserCreated(Parser *parser)\n  {\n      Q_UNUSED(parser);\n      CHECK_TASK_TREE\n      RESET_MODEL;\n      CHECK_TASK_TREE\n  }\n}"
  },
  {
    "function_name": "slotTaskDestroyed(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "219-225",
    "snippet": "oid TaskPresentationModel::slotTaskDestroyed(const ImapTask *const task)\n{\n    Q_UNUSED(task);\n    CHECK_TASK_TREE\n    RESET_MODEL;\n    CHECK_TASK_TREE\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ask)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotTaskDestroyed(const ImapTask *const task)\n  {\n      Q_UNUSED(task);\n      CHECK_TASK_TREE\n      RESET_MODEL;\n      CHECK_TASK_TREE\n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "160-212",
    "snippet": "Variant TaskPresentationModel::data(const QModelIndex &index, int role) const\n{\n    if (!index.isValid()) {\n        return QVariant();\n    }\n\n    bool isParserState = m_model->m_parsers.find(static_cast<Imap::Parser *>(index.internalPointer())) != m_model->m_parsers.end();\n\n    switch (role) {\n    case RoleTaskIsParserState:\n        return isParserState;\n    case RoleTaskIsVisible:\n    {\n        if (isParserState) {\n            // That's not a task at all\n            return false;\n        }\n\n        ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n        if (dynamic_cast<KeepMailboxOpenTask *>(task) || dynamic_cast<GetAnyConnectionTask *>(task) ||\n            dynamic_cast<UnSelectTask *>(task)) {\n            // Internal, auxiliary tasks\n            // FIXME: revisit this for the KeepMailboxOpenTask; it *can* perform a certain activity after all\n            return false;\n        } else if (dynamic_cast<SortTask *>(task) && dynamic_cast<SortTask *>(task)->isJustUpdatingNow()) {\n            // This is a persistent task responsible for further maintenance of the sort order\n            return false;\n        } else {\n            return true;\n        }\n    }\n    case Qt::DisplayRole:\n        if (isParserState) {\n            Imap::Parser *parser = static_cast<Imap::Parser *>(index.internalPointer());\n            return tr(\"Parser %1\").arg(QString::number(parser->parserId()));\n        } else {\n            ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n            QString className = QLatin1String(task->metaObject()->className());\n            className.remove(QLatin1String(\"Imap::Mailbox::\"));\n            return tr(\"%1: %2\").arg(className, task->debugIdentification());\n        }\n    case RoleTaskCompactName: {\n        if (isParserState) {\n            return QVariant();\n        } else {\n            ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n            return task->taskData(RoleTaskCompactName);\n        }\n    }\n    default:\n        return QVariant();\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->taskData",
          "args": [
            "oleTaskCompactName)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "taskData(",
          "container": "xpungeMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ExpungeMessagesTask.cpp",
          "lines": "103-106",
          "snippet": "Variant ExpungeMessagesTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Removing some of the deleted messages\")) : QVariant();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ExpungeMessagesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ExpungeMessagesTask.h\"\n#\n\nxpungeMessagesTask {\n  Variant ExpungeMessagesTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Removing some of the deleted messages\")) : QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "lassName,",
            "ask->debugIdentification())"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "data(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "160-212",
          "snippet": "Variant TaskPresentationModel::data(const QModelIndex &index, int role) const\n{\n    if (!index.isValid()) {\n        return QVariant();\n    }\n\n    bool isParserState = m_model->m_parsers.find(static_cast<Imap::Parser *>(index.internalPointer())) != m_model->m_parsers.end();\n\n    switch (role) {\n    case RoleTaskIsParserState:\n        return isParserState;\n    case RoleTaskIsVisible:\n    {\n        if (isParserState) {\n            // That's not a task at all\n            return false;\n        }\n\n        ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n        if (dynamic_cast<KeepMailboxOpenTask *>(task) || dynamic_cast<GetAnyConnectionTask *>(task) ||\n            dynamic_cast<UnSelectTask *>(task)) {\n            // Internal, auxiliary tasks\n            // FIXME: revisit this for the KeepMailboxOpenTask; it *can* perform a certain activity after all\n            return false;\n        } else if (dynamic_cast<SortTask *>(task) && dynamic_cast<SortTask *>(task)->isJustUpdatingNow()) {\n            // This is a persistent task responsible for further maintenance of the sort order\n            return false;\n        } else {\n            return true;\n        }\n    }\n    case Qt::DisplayRole:\n        if (isParserState) {\n            Imap::Parser *parser = static_cast<Imap::Parser *>(index.internalPointer());\n            return tr(\"Parser %1\").arg(QString::number(parser->parserId()));\n        } else {\n            ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n            QString className = QLatin1String(task->metaObject()->className());\n            className.remove(QLatin1String(\"Imap::Mailbox::\"));\n            return tr(\"%1: %2\").arg(className, task->debugIdentification());\n        }\n    case RoleTaskCompactName: {\n        if (isParserState) {\n            return QVariant();\n        } else {\n            ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n            return task->taskData(RoleTaskCompactName);\n        }\n    }\n    default:\n        return QVariant();\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ask->debugIdentification",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "debugIdentification(",
          "container": "umberOfMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/NumberOfMessagesTask.cpp",
          "lines": "87-95",
          "snippet": "String NumberOfMessagesTask::debugIdentification() const\n{\n    if (! mailboxIndex.isValid())\n        return QLatin1String(\"[invalid mailboxIndex]\");\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    return QString::fromUtf8(\"attached to %1\").arg(mailbox->mailbox());\n}",
          "includes": [
            "include \"GetAnyConnectionTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"NumberOfMessagesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"NumberOfMessagesTask.h\"\n#\n\numberOfMessagesTask {\n  String NumberOfMessagesTask::debugIdentification() const\n  {\n      if (! mailboxIndex.isValid())\n          return QLatin1String(\"[invalid mailboxIndex]\");\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      return QString::fromUtf8(\"attached to %1\").arg(mailbox->mailbox());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "%1: %2\")"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lassName.remove",
          "args": [
            "Latin1String(\"Imap::Mailbox::\"))"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Imap::Mailbox::\")"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ask->metaObject()->className())"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->metaObject",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->metaObject",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "String::number(parser->parserId()))"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "slotTaskMighHaveChanged(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "264-279",
          "snippet": "oid TaskPresentationModel::slotTaskMighHaveChanged(ImapTask *task)\n{\n    CHECK_TASK_TREE\n    if (task->isFinished()) {\n        // finished tasks are not located in our tree, so indexForTask would assert on them\n        return;\n    }\n    if (KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(task)) {\n        if (keepTask->isReadyToTerminate()) {\n            // this one could be missing from the mapping, too\n            return;\n        }\n    }\n    QModelIndex index = indexForTask(task);\n    emit dataChanged(index, index);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotTaskMighHaveChanged(ImapTask *task)\n  {\n      CHECK_TASK_TREE\n      if (task->isFinished()) {\n          // finished tasks are not located in our tree, so indexForTask would assert on them\n          return;\n      }\n      if (KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(task)) {\n          if (keepTask->isReadyToTerminate()) {\n              // this one could be missing from the mapping, too\n              return;\n          }\n      }\n      QModelIndex index = indexForTask(task);\n      emit dataChanged(index, index);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "arser->parserId())"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->parserId",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "parserId(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1152-1155",
          "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<Imap::Parser *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<SortTask *>",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<SortTask *>",
          "args": [
            "ask)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<SortTask *>",
          "args": [
            "ask)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<UnSelectTask *>",
          "args": [
            "ask)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<GetAnyConnectionTask *>",
          "args": [
            "ask)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<KeepMailboxOpenTask *>",
          "args": [
            "ask)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.end",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.find",
          "args": [
            "tatic_cast<Imap::Parser *>(index.internalPointer()))"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<Imap::Parser *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  Variant TaskPresentationModel::data(const QModelIndex &index, int role) const\n  {\n      if (!index.isValid()) {\n          return QVariant();\n      }\n  \n      bool isParserState = m_model->m_parsers.find(static_cast<Imap::Parser *>(index.internalPointer())) != m_model->m_parsers.end();\n  \n      switch (role) {\n      case RoleTaskIsParserState:\n          return isParserState;\n      case RoleTaskIsVisible:\n      {\n          if (isParserState) {\n              // That's not a task at all\n              return false;\n          }\n  \n          ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n          if (dynamic_cast<KeepMailboxOpenTask *>(task) || dynamic_cast<GetAnyConnectionTask *>(task) ||\n              dynamic_cast<UnSelectTask *>(task)) {\n              // Internal, auxiliary tasks\n              // FIXME: revisit this for the KeepMailboxOpenTask; it *can* perform a certain activity after all\n              return false;\n          } else if (dynamic_cast<SortTask *>(task) && dynamic_cast<SortTask *>(task)->isJustUpdatingNow()) {\n              // This is a persistent task responsible for further maintenance of the sort order\n              return false;\n          } else {\n              return true;\n          }\n      }\n      case Qt::DisplayRole:\n          if (isParserState) {\n              Imap::Parser *parser = static_cast<Imap::Parser *>(index.internalPointer());\n              return tr(\"Parser %1\").arg(QString::number(parser->parserId()));\n          } else {\n              ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n              QString className = QLatin1String(task->metaObject()->className());\n              className.remove(QLatin1String(\"Imap::Mailbox::\"));\n              return tr(\"%1: %2\").arg(className, task->debugIdentification());\n          }\n      case RoleTaskCompactName: {\n          if (isParserState) {\n              return QVariant();\n          } else {\n              ImapTask *task = static_cast<ImapTask *>(index.internalPointer());\n              return task->taskData(RoleTaskCompactName);\n          }\n      }\n      default:\n          return QVariant();\n      }\n  }\n}"
  },
  {
    "function_name": "columnCount(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "155-158",
    "snippet": "nt TaskPresentationModel::columnCount(const QModelIndex &parent) const\n{\n    return (rowCount(parent) > 0) ? 1 : 0;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "owCount(",
          "args": [
            "arent)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "134-153",
          "snippet": "nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        // This is where it starts to get complicated -- we're somewhere inside the tree\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // A child of the top level item, ie. a ParserState object\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            return parserState.activeTasks.size();\n        } else {\n            // It's a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            return task->dependentTasks.size();\n        }\n    } else {\n        // The top-level stuff children represent the list of active connections\n        return m_model->m_parsers.size();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          // This is where it starts to get complicated -- we're somewhere inside the tree\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // A child of the top level item, ie. a ParserState object\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              return parserState.activeTasks.size();\n          } else {\n              // It's a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              return task->dependentTasks.size();\n          }\n      } else {\n          // The top-level stuff children represent the list of active connections\n          return m_model->m_parsers.size();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::columnCount(const QModelIndex &parent) const\n  {\n      return (rowCount(parent) > 0) ? 1 : 0;\n  }\n}"
  },
  {
    "function_name": "rowCount(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "134-153",
    "snippet": "nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        // This is where it starts to get complicated -- we're somewhere inside the tree\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // A child of the top level item, ie. a ParserState object\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            return parserState.activeTasks.size();\n        } else {\n            // It's a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            return task->dependentTasks.size();\n        }\n    } else {\n        // The top-level stuff children represent the list of active connections\n        return m_model->m_parsers.size();\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_model->m_parsers.size",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->dependentTasks.size",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ask)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "arent.internalPointer())"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.internalPointer",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arserState.activeTasks.size",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->accessParser",
          "args": [
            "arser)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<Imap::Parser *>",
          "args": [
            "arent.internalPointer())"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.internalPointer",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.data",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arent.data",
          "args": [
            "oleTaskIsParserState)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          // This is where it starts to get complicated -- we're somewhere inside the tree\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // A child of the top level item, ie. a ParserState object\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              return parserState.activeTasks.size();\n          } else {\n              // It's a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              return task->dependentTasks.size();\n          }\n      } else {\n          // The top-level stuff children represent the list of active connections\n          return m_model->m_parsers.size();\n      }\n  }\n}"
  },
  {
    "function_name": "indexForTask(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "111-132",
    "snippet": "ModelIndex TaskPresentationModel::indexForTask(ImapTask *const task) const\n{\n    Q_ASSERT(task);\n    if (task->parentTask) {\n        // The target task is a child of another task\n        int index = task->parentTask->dependentTasks.indexOf(task);\n        Q_ASSERT(index != -1);\n        return createIndex(index, 0, task);\n    } else {\n        // The child has no parent task, so the child is apparently the top-level task for a given parser,\n        Q_ASSERT(task->parser);\n        int index = m_model->accessParser(task->parser).activeTasks.indexOf(task);\n        if (index == -1) {\n#ifdef TROJITA_DEBUG_TASK_TREE\n            m_model->checkTaskTreeConsistency();\n            Q_ASSERT(index != -1);\n#endif\n            return QModelIndex();\n        }\n        return createIndex(index, 0, task);\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ndex,",
            ",",
            "ask)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex != -1)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->checkTaskTreeConsistency",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->accessParser",
          "args": [
            "ask)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->accessParser",
          "args": [
            "ask->parser)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ask->parser)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ndex,",
            ",",
            "ask)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex != -1)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->parentTask->dependentTasks.indexOf",
          "args": [
            "ask)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ask)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::indexForTask(ImapTask *const task) const\n  {\n      Q_ASSERT(task);\n      if (task->parentTask) {\n          // The target task is a child of another task\n          int index = task->parentTask->dependentTasks.indexOf(task);\n          Q_ASSERT(index != -1);\n          return createIndex(index, 0, task);\n      } else {\n          // The child has no parent task, so the child is apparently the top-level task for a given parser,\n          Q_ASSERT(task->parser);\n          int index = m_model->accessParser(task->parser).activeTasks.indexOf(task);\n          if (index == -1) {\n  #ifdef TROJITA_DEBUG_TASK_TREE\n              m_model->checkTaskTreeConsistency();\n              Q_ASSERT(index != -1);\n  #endif\n              return QModelIndex();\n          }\n          return createIndex(index, 0, task);\n      }\n  }\n}"
  },
  {
    "function_name": "parent(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "89-108",
    "snippet": "ModelIndex TaskPresentationModel::parent(const QModelIndex &child) const\n{\n    if (!child.isValid())\n        return QModelIndex();\n\n    if (child.data(RoleTaskIsParserState).toBool()) {\n        // A parent of the parser state is always the root item\n        return QModelIndex();\n    }\n    // The child is definitely an ImapTask; let's find what the parent is\n    ImapTask *task = static_cast<ImapTask *>(child.internalPointer());\n    if (task->parentTask) {\n        return indexForTask(task->parentTask);\n    } else {\n        Q_ASSERT(task->parser);\n        int index = m_model->m_parsers.keys().indexOf(task->parser);\n        Q_ASSERT(index != -1);\n        return createIndex(index, 0, task->parser);\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ndex,",
            ",",
            "ask->parser)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex != -1)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.keys",
          "args": [
            "ask->parser)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.keys",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ask->parser)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndexForTask(",
          "args": [
            "ask->parentTask)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "indexForTask(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "111-132",
          "snippet": "ModelIndex TaskPresentationModel::indexForTask(ImapTask *const task) const\n{\n    Q_ASSERT(task);\n    if (task->parentTask) {\n        // The target task is a child of another task\n        int index = task->parentTask->dependentTasks.indexOf(task);\n        Q_ASSERT(index != -1);\n        return createIndex(index, 0, task);\n    } else {\n        // The child has no parent task, so the child is apparently the top-level task for a given parser,\n        Q_ASSERT(task->parser);\n        int index = m_model->accessParser(task->parser).activeTasks.indexOf(task);\n        if (index == -1) {\n#ifdef TROJITA_DEBUG_TASK_TREE\n            m_model->checkTaskTreeConsistency();\n            Q_ASSERT(index != -1);\n#endif\n            return QModelIndex();\n        }\n        return createIndex(index, 0, task);\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::indexForTask(ImapTask *const task) const\n  {\n      Q_ASSERT(task);\n      if (task->parentTask) {\n          // The target task is a child of another task\n          int index = task->parentTask->dependentTasks.indexOf(task);\n          Q_ASSERT(index != -1);\n          return createIndex(index, 0, task);\n      } else {\n          // The child has no parent task, so the child is apparently the top-level task for a given parser,\n          Q_ASSERT(task->parser);\n          int index = m_model->accessParser(task->parser).activeTasks.indexOf(task);\n          if (index == -1) {\n  #ifdef TROJITA_DEBUG_TASK_TREE\n              m_model->checkTaskTreeConsistency();\n              Q_ASSERT(index != -1);\n  #endif\n              return QModelIndex();\n          }\n          return createIndex(index, 0, task);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "hild.internalPointer())"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hild.internalPointer",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hild.data",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hild.data",
          "args": [
            "oleTaskIsParserState)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hild.isValid",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::parent(const QModelIndex &child) const\n  {\n      if (!child.isValid())\n          return QModelIndex();\n  \n      if (child.data(RoleTaskIsParserState).toBool()) {\n          // A parent of the parser state is always the root item\n          return QModelIndex();\n      }\n      // The child is definitely an ImapTask; let's find what the parent is\n      ImapTask *task = static_cast<ImapTask *>(child.internalPointer());\n      if (task->parentTask) {\n          return indexForTask(task->parentTask);\n      } else {\n          Q_ASSERT(task->parser);\n          int index = m_model->m_parsers.keys().indexOf(task->parser);\n          Q_ASSERT(index != -1);\n          return createIndex(index, 0, task->parser);\n      }\n  }\n}"
  },
  {
    "function_name": "index(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "51-87",
    "snippet": "ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n{\n    if (column != 0)\n        return QModelIndex();\n    if (row < 0)\n        return QModelIndex();\n\n    if (parent.isValid()) {\n        // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // The parent is a ParserState\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            if (row >= parserState.activeTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, parserState.activeTasks.at(row));\n            }\n        } else {\n            // The parent is a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            if (row >= task->dependentTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, task->dependentTasks.at(row));\n            }\n        }\n    } else {\n        // So this is about a ParserState -- fair enough\n        if (row >= m_model->m_parsers.size()) {\n            return QModelIndex();\n        } else {\n            return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n        }\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ow,",
            ",",
            "_model->m_parsers.keys().at(row))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.keys",
          "args": [
            "ow)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.keys",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->m_parsers.size",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ow,",
            ",",
            "ask->dependentTasks.at(row))"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->dependentTasks.at",
          "args": [
            "ow)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->dependentTasks.size",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ask)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "arent.internalPointer())"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.internalPointer",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ow,",
            ",",
            "arserState.activeTasks.at(row))"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arserState.activeTasks.at",
          "args": [
            "ow)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arserState.activeTasks.size",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->accessParser",
          "args": [
            "arser)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<Imap::Parser *>",
          "args": [
            "arent.internalPointer())"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.internalPointer",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.data",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arent.data",
          "args": [
            "oleTaskIsParserState)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n  {\n      if (column != 0)\n          return QModelIndex();\n      if (row < 0)\n          return QModelIndex();\n  \n      if (parent.isValid()) {\n          // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // The parent is a ParserState\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              if (row >= parserState.activeTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, parserState.activeTasks.at(row));\n              }\n          } else {\n              // The parent is a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              if (row >= task->dependentTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, task->dependentTasks.at(row));\n              }\n          }\n      } else {\n          // So this is about a ParserState -- fair enough\n          if (row >= m_model->m_parsers.size()) {\n              return QModelIndex();\n          } else {\n              return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "TaskPresentationModel(",
    "container": "askPresentationModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
    "lines": "46-49",
    "snippet": "askPresentationModel::TaskPresentationModel(Model *model) :\n    QAbstractItemModel(model), m_model(model)\n{\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"Model.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/UnSelectTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
      "include \"Imap/Tasks/NoopTask.h\"\n#",
      "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
      "include \"TaskPresentationModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  askPresentationModel::TaskPresentationModel(Model *model) :\n      QAbstractItemModel(model), m_model(model)\n  {\n  }\n}"
  }
]