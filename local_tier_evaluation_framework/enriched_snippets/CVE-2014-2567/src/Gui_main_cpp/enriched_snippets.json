[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/main.cpp",
    "lines": "35-87",
    "snippet": "nt main(int argc, char **argv)\n{\n    Common::registerMetaTypes();\n\n    QApplication app(argc, argv);\n    Q_INIT_RESOURCE(icons);\n    Q_INIT_RESOURCE(license);\n\n    QTranslator qtTranslator;\n    qtTranslator.load(QLatin1String(\"qt_\") + QLocale::system().name(),\n                      QLibraryInfo::location(QLibraryInfo::TranslationsPath));\n    app.installTranslator(&qtTranslator);\n\n    QLatin1String localeSuffix(\"/locale\");\n    QString localeName(QLatin1String(\"trojita_common_\") + QLocale::system().name());\n\n    // The \"installed to system\" localization\n    QTranslator appSystemTranslator;\n    if (!Gui::Util::pkgDataDir().isEmpty()) {\n        appSystemTranslator.load(localeName, Gui::Util::pkgDataDir() + localeSuffix);\n        app.installTranslator(&appSystemTranslator);\n    }\n\n    // The \"in the directory with the binary\" localization\n    QTranslator appDirectoryTranslator;\n    appDirectoryTranslator.load(localeName, app.applicationDirPath() + localeSuffix);\n    app.installTranslator(&appDirectoryTranslator);\n\n    AppVersion::setGitVersion();\n    AppVersion::setCoreApplicationData();\n    app.setWindowIcon(QIcon(QLatin1String(\":/icons/trojita.png\")));\n\n    // Hack: support multiple \"profiles\"\n    QString profileName;\n    if (argc == 3 && argv[1] == QByteArray(\"--profile\")) {\n        profileName = QString::fromLocal8Bit(argv[2]);\n        // We are abusing the env vars here. Yes, it's a hidden global. Yes, it's ugly.\n        // Take it or leave it, this is a time-limited hack.\n        // The env var is also in UTF-8. I like UTF-8.\n        qputenv(\"TROJITA_PROFILE\", profileName.toUtf8());\n    } else {\n#ifndef Q_OS_WIN32\n        unsetenv(\"TROJITA_PROFILE\");\n#else\n        putenv(\"TROJITA_PROFILE=\");\n#endif\n    }\n    QSettings settings(Common::Application::organization,\n                       profileName.isEmpty() ? Common::Application::name : Common::Application::name + QLatin1Char('-') + profileName);\n    Gui::MainWindow win(&settings);\n    win.show();\n    return app.exec();\n}",
    "includes": [
      "include \"static_plugins.h\"",
      "include \"Gui/Window.h\"",
      "include \"Gui/Util.h\"\n#",
      "include \"Common/MetaTypes.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include \"AppVersion/SetCoreApplication.h\"\n#",
      "include <QTranslator>",
      "include <QSettings>\n#",
      "include <QLibraryInfo>\n#",
      "include <QApplication>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pp.exec",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.show",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "-')"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rofileName.isEmpty",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utenv(",
          "args": [
            "TROJITA_PROFILE=\")"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsetenv(",
          "args": [
            "TROJITA_PROFILE\")"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putenv(",
          "args": [
            "TROJITA_PROFILE\",",
            "rofileName.toUtf8())"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rofileName.toUtf8",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromLocal8Bit(",
          "args": [
            "rgv[2])"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "--profile\")"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pp.setWindowIcon",
          "args": [
            "Icon(QLatin1String(\":/icons/trojita.png\")))"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Icon(",
          "args": [
            "Latin1String(\":/icons/trojita.png\"))"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "adIcon(c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/IconLoader.h",
          "lines": "42-55",
          "snippet": "line QIcon loadIcon(const QString &name)\n{\n    // A QIcon(QString) constructor creates non-null QIcons, even though the resulting icon will\n    // not ever return a valid and usable pixmap. This means that we have to actually look at the\n    // icon's pixmap to find out what to return.\n    // If we do not do that, the GUI shows empty pixmaps instead of a text fallback, which is\n    // clearly suboptimal.\n    QIcon res = QIcon::fromTheme(name, QIcon(QString::fromUtf8(\":/icons/%1\").arg(name)));\n    if (res.pixmap(QSize(16, 16)).isNull()) {\n        return QIcon();\n    } else {\n        return res;\n    }\n}",
          "includes": [
            "include <QIcon>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QIcon>\n\nline QIcon loadIcon(const QString &name)\n{\n    // A QIcon(QString) constructor creates non-null QIcons, even though the resulting icon will\n    // not ever return a valid and usable pixmap. This means that we have to actually look at the\n    // icon's pixmap to find out what to return.\n    // If we do not do that, the GUI shows empty pixmaps instead of a text fallback, which is\n    // clearly suboptimal.\n    QIcon res = QIcon::fromTheme(name, QIcon(QString::fromUtf8(\":/icons/%1\").arg(name)));\n    if (res.pixmap(QSize(16, 16)).isNull()) {\n        return QIcon();\n    } else {\n        return res;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ":/icons/trojita.png\")"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppVersion::setCoreApplicationData(",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppVersion::setGitVersion(",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pp.installTranslator",
          "args": [
            "appDirectoryTranslator)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppDirectoryTranslator.load",
          "args": [
            "ocaleName,",
            "pp.applicationDirPath() + localeSuffix)"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "load",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "768-784",
          "snippet": "bool QMimeXMLProvider::load(const QString &fileName, QString *errorMessage)\n{\n    m_loaded = true;\n\n    QFile file(fileName);\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        if (errorMessage)\n            *errorMessage = QString::fromLatin1(\"Cannot open %1: %2\").arg(fileName, file.errorString());\n        return false;\n    }\n\n    if (errorMessage)\n        errorMessage->clear();\n\n    QMimeTypeParser parser(*this);\n    return parser.parse(&file, fileName, errorMessage);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::load(const QString &fileName, QString *errorMessage)\n  {\n      m_loaded = true;\n  \n      QFile file(fileName);\n      if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n          if (errorMessage)\n              *errorMessage = QString::fromLatin1(\"Cannot open %1: %2\").arg(fileName, file.errorString());\n          return false;\n      }\n  \n      if (errorMessage)\n          errorMessage->clear();\n  \n      QMimeTypeParser parser(*this);\n      return parser.parse(&file, fileName, errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pp.applicationDirPath",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pp.installTranslator",
          "args": [
            "appSystemTranslator)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::Util::pkgDataDir(",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::Util::pkgDataDir",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::Util::pkgDataDir(",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Locale::system",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Locale::system(",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "trojita_common_\")"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pp.installTranslator",
          "args": [
            "qtTranslator)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LibraryInfo::location(",
          "args": [
            "LibraryInfo::TranslationsPath)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Locale::system",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Locale::system(",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "qt_\")"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_INIT_RESOURCE(",
          "args": [
            "icense)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_INIT_RESOURCE(",
          "args": [
            "cons)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommon::registerMetaTypes(",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"static_plugins.h\"\ninclude \"Gui/Window.h\"\ninclude \"Gui/Util.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude \"AppVersion/SetCoreApplication.h\"\n#\ninclude <QTranslator>\ninclude <QSettings>\n#\ninclude <QLibraryInfo>\n#\ninclude <QApplication>\n#\n\nnt main(int argc, char **argv)\n{\n    Common::registerMetaTypes();\n\n    QApplication app(argc, argv);\n    Q_INIT_RESOURCE(icons);\n    Q_INIT_RESOURCE(license);\n\n    QTranslator qtTranslator;\n    qtTranslator.load(QLatin1String(\"qt_\") + QLocale::system().name(),\n                      QLibraryInfo::location(QLibraryInfo::TranslationsPath));\n    app.installTranslator(&qtTranslator);\n\n    QLatin1String localeSuffix(\"/locale\");\n    QString localeName(QLatin1String(\"trojita_common_\") + QLocale::system().name());\n\n    // The \"installed to system\" localization\n    QTranslator appSystemTranslator;\n    if (!Gui::Util::pkgDataDir().isEmpty()) {\n        appSystemTranslator.load(localeName, Gui::Util::pkgDataDir() + localeSuffix);\n        app.installTranslator(&appSystemTranslator);\n    }\n\n    // The \"in the directory with the binary\" localization\n    QTranslator appDirectoryTranslator;\n    appDirectoryTranslator.load(localeName, app.applicationDirPath() + localeSuffix);\n    app.installTranslator(&appDirectoryTranslator);\n\n    AppVersion::setGitVersion();\n    AppVersion::setCoreApplicationData();\n    app.setWindowIcon(QIcon(QLatin1String(\":/icons/trojita.png\")));\n\n    // Hack: support multiple \"profiles\"\n    QString profileName;\n    if (argc == 3 && argv[1] == QByteArray(\"--profile\")) {\n        profileName = QString::fromLocal8Bit(argv[2]);\n        // We are abusing the env vars here. Yes, it's a hidden global. Yes, it's ugly.\n        // Take it or leave it, this is a time-limited hack.\n        // The env var is also in UTF-8. I like UTF-8.\n        qputenv(\"TROJITA_PROFILE\", profileName.toUtf8());\n    } else {\n#ifndef Q_OS_WIN32\n        unsetenv(\"TROJITA_PROFILE\");\n#else\n        putenv(\"TROJITA_PROFILE=\");\n#endif\n    }\n    QSettings settings(Common::Application::organization,\n                       profileName.isEmpty() ? Common::Application::name : Common::Application::name + QLatin1Char('-') + profileName);\n    Gui::MainWindow win(&settings);\n    win.show();\n    return app.exec();\n}"
  }
]