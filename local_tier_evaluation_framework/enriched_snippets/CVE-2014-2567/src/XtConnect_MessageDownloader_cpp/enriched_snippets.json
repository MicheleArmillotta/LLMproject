[
  {
    "function_name": "slotFetchQueuedMessages(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "309-317",
    "snippet": "oid MessageDownloader::slotFetchQueuedMessages()\n{\n    for (int i = 0; i < BATCH_SIZE; ++i) {\n        if (m_queuedEnvelopes.isEmpty())\n            return;\n        QPersistentModelIndex message = m_queuedEnvelopes.dequeue();\n        reallyRequestDownload(message);\n    }\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eallyRequestDownload(",
          "args": [
            "essage)"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "reallyRequestDownload(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "77-92",
          "snippet": "oid MessageDownloader::reallyRequestDownload(const QModelIndex &message)\n{\n    MessageMetadata metaData;\n\n    // Now request loading of the message metadata. We are especially interested in the message envelope, the part which will\n    // enable us to request the main part in future.\n    metaData.hasMessage = message.data( Imap::Mailbox::RoleMessageMessageId ).isValid();\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n    m_parts[ uid ] = metaData;\n\n    if (metaData.hasMessage) {\n        requestDataDownload(message);\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::reallyRequestDownload(const QModelIndex &message)\n  {\n      MessageMetadata metaData;\n  \n      // Now request loading of the message metadata. We are especially interested in the message envelope, the part which will\n      // enable us to request the main part in future.\n      metaData.hasMessage = message.data( Imap::Mailbox::RoleMessageMessageId ).isValid();\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n      m_parts[ uid ] = metaData;\n  \n      if (metaData.hasMessage) {\n          requestDataDownload(message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_queuedEnvelopes.dequeue",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_queuedEnvelopes.isEmpty",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotFetchQueuedMessages()\n  {\n      for (int i = 0; i < BATCH_SIZE; ++i) {\n          if (m_queuedEnvelopes.isEmpty())\n              return;\n          QPersistentModelIndex message = m_queuedEnvelopes.dequeue();\n          reallyRequestDownload(message);\n      }\n  }\n}"
  },
  {
    "function_name": "slotFreeProcessedMessages(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "291-307",
    "snippet": "oid MessageDownloader::slotFreeProcessedMessages()\n{\n    Q_FOREACH(const QPersistentModelIndex &index, m_messagesToBeFreed) {\n        if (!index.isValid())\n            continue;\n        // The const_cast should be safe here -- this action is certainly not going to invalidate the index,\n        // and even the releaseMessageData() won't (directly) touch its members anyway...\n        Imap::Mailbox::Model *model = qobject_cast<Imap::Mailbox::Model*>(const_cast<QAbstractItemModel*>(index.model()));\n        Q_ASSERT(model);\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Freeing memory for\" << index.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() <<\n                    \"UID\" << index.data(Imap::Mailbox::RoleMessageUid).toUInt();\n#endif\n        model->releaseMessageData(index);\n    }\n    m_messagesToBeFreed.clear();\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_messagesToBeFreed.clear",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->releaseMessageData",
          "args": [
            "ndex)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "map::Mailbox::RoleMessageUid)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.parent",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.parent",
          "args": [
            "map::Mailbox::RoleMailboxName)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<Imap::Mailbox::Model*>",
          "args": [
            "onst_cast<QAbstractItemModel*>(index.model()))"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<QAbstractItemModel*>",
          "args": [
            "ndex.model())"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotFreeProcessedMessages()\n  {\n      Q_FOREACH(const QPersistentModelIndex &index, m_messagesToBeFreed) {\n          if (!index.isValid())\n              continue;\n          // The const_cast should be safe here -- this action is certainly not going to invalidate the index,\n          // and even the releaseMessageData() won't (directly) touch its members anyway...\n          Imap::Mailbox::Model *model = qobject_cast<Imap::Mailbox::Model*>(const_cast<QAbstractItemModel*>(index.model()));\n          Q_ASSERT(model);\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Freeing memory for\" << index.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() <<\n                      \"UID\" << index.data(Imap::Mailbox::RoleMessageUid).toUInt();\n  #endif\n          model->releaseMessageData(index);\n      }\n      m_messagesToBeFreed.clear();\n  }\n}"
  },
  {
    "function_name": "pendingMessages(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "285-288",
    "snippet": "nt MessageDownloader::pendingMessages() const\n{\n    return m_queuedEnvelopes.size();\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_queuedEnvelopes.size",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  nt MessageDownloader::pendingMessages() const\n  {\n      return m_queuedEnvelopes.size();\n  }\n}"
  },
  {
    "function_name": "activeMessages(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "280-283",
    "snippet": "nt MessageDownloader::activeMessages() const\n{\n    return m_parts.size();\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_parts.size",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  nt MessageDownloader::activeMessages() const\n  {\n      return m_parts.size();\n  }\n}"
  },
  {
    "function_name": "slotDataChanged(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "152-278",
    "snippet": "oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n{\n    if ( ! a.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( a != b ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n#endif\n        return;\n    }\n\n    QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n    if ( ! message.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                    message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n#endif\n        return;\n    }\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n    if ( it == m_parts.end() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"We are not interested in message with UID\" << uid;\n#endif\n        return;\n    }\n\n    const QAbstractItemModel *model = message.model();\n\n    // Find out whether the data is available already\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n\n    if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasHeader = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got header for\" << uid;\n#endif\n    }\n\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasBody = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got body for\" << uid;\n#endif\n    }\n\n    if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n            it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasMainPart = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got main part for\" << uid;\n#endif\n    }\n\n    if (a == message && !it->hasMessage) {\n\n        if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n            qDebug() << \"  Not loaded yet\";\n#endif\n            return;\n        }\n\n        it->hasMessage = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got message for\" << uid;\n#endif\n        requestDataDownload(message);\n\n    }\n\n    if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n        // Check message metadata\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n\n        // Check the main part\n        QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n        QString mainPart;\n        if (it->mainPartFailed) {\n            mainPart = it->partMessage;\n        } else {\n            Q_ASSERT(mainPartData.isValid());\n            mainPart = mainPartData.toString();\n        }\n\n        // The rest of the bulk data\n        QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(headerData.isValid());\n        QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(bodyData.isValid());\n\n        log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n        emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n        m_parts.erase(it);\n\n        m_messagesToBeFreed << message;\n        if (!m_releasingTimer->isActive())\n            m_releasingTimer->start();\n\n        if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n            m_queuedTimer->start();\n\n    } else {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n#endif\n    }\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_queuedTimer->start",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parts.size",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_queuedTimer->isActive",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_releasingTimer->start",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_releasingTimer->isActive",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parts.erase",
          "args": [
            "t)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyData.toByteArray",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderData.toByteArray",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "String::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)))"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(uid))"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "id)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Downloaded message %1\")"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odyData.isValid())"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyData.isValid",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext.data",
          "args": [
            "map::Mailbox::RolePartData)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "eaderData.isValid())"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eader.data",
          "args": [
            "map::Mailbox::RolePartData)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ainPartData.toString",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ainPartData.isValid())"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->mainPart.data",
          "args": [
            "map::Mailbox::RolePartData)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essage.data(Imap::Mailbox::RoleMessageDate).isValid())"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageDate)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essage.data(Imap::Mailbox::RoleMessageSubject).isValid())"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageSubject)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essage.data(Imap::Mailbox::RoleMessageMessageId).isValid())"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageMessageId)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestDataDownload(",
          "args": [
            "essage)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "requestDataDownload(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "95-150",
          "snippet": "oid MessageDownloader::requestDataDownload(const QModelIndex &message)\n{\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find(uid);\n    Q_ASSERT(it != m_parts.end());\n    Q_ASSERT(it->hasMessage);\n\n    // Let's see if we can find out what the \"main part\" is.\n    // The \"main part\" cannot be determined prior to the message's metadata becoming available.\n\n    QModelIndex mainPart;\n    Imap::Mailbox::FindInterestingPart::MainPartReturnCode status =\n            Imap::Mailbox::FindInterestingPart::findMainPartOfMessage(message, mainPart, it->partMessage, 0);\n    it->mainPart = mainPart;\n    switch (status) {\n    case Imap::Mailbox::FindInterestingPart::MAINPART_FOUND:\n    case Imap::Mailbox::FindInterestingPart::MAINPART_PART_LOADING:\n        // The MAINPART_PART_LOADING is a confusing name -- as we're calling findMainPartOfMessage with the last parameter being\n        // nullptr, the function will not attempt to actually fetch the data, and therefore the exit status cannot be\n        // MAINPART_FOUND, so it will be MAINPART_PART_LOADING. Yep, confusing.\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Requesting data for \" << uid;\n#endif\n        // Ask for the data.\n        Q_ASSERT(mainPart.isValid());\n        mainPart.data(Imap::Mailbox::RolePartData);\n        break;\n\n    case Imap::Mailbox::FindInterestingPart::MAINPART_MESSAGE_NOT_LOADED:\n        Q_ASSERT(false);\n        break;\n\n    case Imap::Mailbox::FindInterestingPart::MAINPART_PART_CANNOT_DETERMINE:\n        it->hasMainPart = true;\n        it->mainPartFailed = true;\n        log(QString::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)));\n        break;\n    }\n\n    // Now request the rest of the data\n    const QAbstractItemModel *model = message.model();\n    Q_ASSERT(model);\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n    header.data(Imap::Mailbox::RolePartData);\n    it->hasHeader = header.data(Imap::Mailbox::RoleIsFetched).toBool();\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    text.data(Imap::Mailbox::RolePartData);\n    it->hasBody = text.data(Imap::Mailbox::RoleIsFetched).toBool();\n\n    if (it->hasMainPart && it->hasHeader && it->hasBody) {\n        // We have everything what we need at this point\n        slotDataChanged(message, message);\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::requestDataDownload(const QModelIndex &message)\n  {\n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find(uid);\n      Q_ASSERT(it != m_parts.end());\n      Q_ASSERT(it->hasMessage);\n  \n      // Let's see if we can find out what the \"main part\" is.\n      // The \"main part\" cannot be determined prior to the message's metadata becoming available.\n  \n      QModelIndex mainPart;\n      Imap::Mailbox::FindInterestingPart::MainPartReturnCode status =\n              Imap::Mailbox::FindInterestingPart::findMainPartOfMessage(message, mainPart, it->partMessage, 0);\n      it->mainPart = mainPart;\n      switch (status) {\n      case Imap::Mailbox::FindInterestingPart::MAINPART_FOUND:\n      case Imap::Mailbox::FindInterestingPart::MAINPART_PART_LOADING:\n          // The MAINPART_PART_LOADING is a confusing name -- as we're calling findMainPartOfMessage with the last parameter being\n          // nullptr, the function will not attempt to actually fetch the data, and therefore the exit status cannot be\n          // MAINPART_FOUND, so it will be MAINPART_PART_LOADING. Yep, confusing.\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Requesting data for \" << uid;\n  #endif\n          // Ask for the data.\n          Q_ASSERT(mainPart.isValid());\n          mainPart.data(Imap::Mailbox::RolePartData);\n          break;\n  \n      case Imap::Mailbox::FindInterestingPart::MAINPART_MESSAGE_NOT_LOADED:\n          Q_ASSERT(false);\n          break;\n  \n      case Imap::Mailbox::FindInterestingPart::MAINPART_PART_CANNOT_DETERMINE:\n          it->hasMainPart = true;\n          it->mainPartFailed = true;\n          log(QString::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)));\n          break;\n      }\n  \n      // Now request the rest of the data\n      const QAbstractItemModel *model = message.model();\n      Q_ASSERT(model);\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n      header.data(Imap::Mailbox::RolePartData);\n      it->hasHeader = header.data(Imap::Mailbox::RoleIsFetched).toBool();\n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      text.data(Imap::Mailbox::RolePartData);\n      it->hasBody = text.data(Imap::Mailbox::RoleIsFetched).toBool();\n  \n      if (it->hasMainPart && it->hasHeader && it->hasBody) {\n          // We have everything what we need at this point\n          slotDataChanged(message, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleIsFetched)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->mainPart.data",
          "args": [
            "map::Mailbox::RoleIsFetched)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.data",
          "args": [
            "map::Mailbox::RoleIsFetched)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->index",
          "args": [
            ",",
            "map::Mailbox::TreeItem::OFFSET_TEXT,",
            "essage)"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "index(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "51-87",
          "snippet": "ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n{\n    if (column != 0)\n        return QModelIndex();\n    if (row < 0)\n        return QModelIndex();\n\n    if (parent.isValid()) {\n        // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // The parent is a ParserState\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            if (row >= parserState.activeTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, parserState.activeTasks.at(row));\n            }\n        } else {\n            // The parent is a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            if (row >= task->dependentTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, task->dependentTasks.at(row));\n            }\n        }\n    } else {\n        // So this is about a ParserState -- fair enough\n        if (row >= m_model->m_parsers.size()) {\n            return QModelIndex();\n        } else {\n            return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n  {\n      if (column != 0)\n          return QModelIndex();\n      if (row < 0)\n          return QModelIndex();\n  \n      if (parent.isValid()) {\n          // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // The parent is a ParserState\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              if (row >= parserState.activeTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, parserState.activeTasks.at(row));\n              }\n          } else {\n              // The parent is a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              if (row >= task->dependentTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, task->dependentTasks.at(row));\n              }\n          }\n      } else {\n          // So this is about a ParserState -- fair enough\n          if (row >= m_model->m_parsers.size()) {\n              return QModelIndex();\n          } else {\n              return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eader.data",
          "args": [
            "map::Mailbox::RoleIsFetched)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.model",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parts.end",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parts.find",
          "args": [
            "id"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "id)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.parent",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.parent",
          "args": [
            "map::Mailbox::RoleMailboxName)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.parent",
          "args": [
            "map::Mailbox::RoleMailboxName"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Mailbox::Model::findMessageForItem(",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isValid",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "isValid(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "125-131",
          "snippet": "ool Sequence::isValid() const\n{\n    if (kind == DISTINCT && list.isEmpty())\n        return false;\n    else\n        return true;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ool Sequence::isValid() const\n  {\n      if (kind == DISTINCT && list.isEmpty())\n          return false;\n      else\n          return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n  {\n      if ( ! a.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( a != b ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n  #endif\n          return;\n      }\n  \n      QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n      if ( ! message.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                      message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n  #endif\n          return;\n      }\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n      if ( it == m_parts.end() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"We are not interested in message with UID\" << uid;\n  #endif\n          return;\n      }\n  \n      const QAbstractItemModel *model = message.model();\n  \n      // Find out whether the data is available already\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n  \n      if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasHeader = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got header for\" << uid;\n  #endif\n      }\n  \n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasBody = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got body for\" << uid;\n  #endif\n      }\n  \n      if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n              it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasMainPart = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got main part for\" << uid;\n  #endif\n      }\n  \n      if (a == message && !it->hasMessage) {\n  \n          if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n              qDebug() << \"  Not loaded yet\";\n  #endif\n              return;\n          }\n  \n          it->hasMessage = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got message for\" << uid;\n  #endif\n          requestDataDownload(message);\n  \n      }\n  \n      if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n          // Check message metadata\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n  \n          // Check the main part\n          QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n          QString mainPart;\n          if (it->mainPartFailed) {\n              mainPart = it->partMessage;\n          } else {\n              Q_ASSERT(mainPartData.isValid());\n              mainPart = mainPartData.toString();\n          }\n  \n          // The rest of the bulk data\n          QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(headerData.isValid());\n          QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(bodyData.isValid());\n  \n          log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n          emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n          m_parts.erase(it);\n  \n          m_messagesToBeFreed << message;\n          if (!m_releasingTimer->isActive())\n              m_releasingTimer->start();\n  \n          if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n              m_queuedTimer->start();\n  \n      } else {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n  #endif\n      }\n  }\n}"
  },
  {
    "function_name": "requestDataDownload(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "95-150",
    "snippet": "oid MessageDownloader::requestDataDownload(const QModelIndex &message)\n{\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find(uid);\n    Q_ASSERT(it != m_parts.end());\n    Q_ASSERT(it->hasMessage);\n\n    // Let's see if we can find out what the \"main part\" is.\n    // The \"main part\" cannot be determined prior to the message's metadata becoming available.\n\n    QModelIndex mainPart;\n    Imap::Mailbox::FindInterestingPart::MainPartReturnCode status =\n            Imap::Mailbox::FindInterestingPart::findMainPartOfMessage(message, mainPart, it->partMessage, 0);\n    it->mainPart = mainPart;\n    switch (status) {\n    case Imap::Mailbox::FindInterestingPart::MAINPART_FOUND:\n    case Imap::Mailbox::FindInterestingPart::MAINPART_PART_LOADING:\n        // The MAINPART_PART_LOADING is a confusing name -- as we're calling findMainPartOfMessage with the last parameter being\n        // nullptr, the function will not attempt to actually fetch the data, and therefore the exit status cannot be\n        // MAINPART_FOUND, so it will be MAINPART_PART_LOADING. Yep, confusing.\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Requesting data for \" << uid;\n#endif\n        // Ask for the data.\n        Q_ASSERT(mainPart.isValid());\n        mainPart.data(Imap::Mailbox::RolePartData);\n        break;\n\n    case Imap::Mailbox::FindInterestingPart::MAINPART_MESSAGE_NOT_LOADED:\n        Q_ASSERT(false);\n        break;\n\n    case Imap::Mailbox::FindInterestingPart::MAINPART_PART_CANNOT_DETERMINE:\n        it->hasMainPart = true;\n        it->mainPartFailed = true;\n        log(QString::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)));\n        break;\n    }\n\n    // Now request the rest of the data\n    const QAbstractItemModel *model = message.model();\n    Q_ASSERT(model);\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n    header.data(Imap::Mailbox::RolePartData);\n    it->hasHeader = header.data(Imap::Mailbox::RoleIsFetched).toBool();\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    text.data(Imap::Mailbox::RolePartData);\n    it->hasBody = text.data(Imap::Mailbox::RoleIsFetched).toBool();\n\n    if (it->hasMainPart && it->hasHeader && it->hasBody) {\n        // We have everything what we need at this point\n        slotDataChanged(message, message);\n    }\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lotDataChanged(",
          "args": [
            "essage,",
            "essage)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "slotDataChanged(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "152-278",
          "snippet": "oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n{\n    if ( ! a.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( a != b ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n#endif\n        return;\n    }\n\n    QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n    if ( ! message.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                    message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n#endif\n        return;\n    }\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n    if ( it == m_parts.end() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"We are not interested in message with UID\" << uid;\n#endif\n        return;\n    }\n\n    const QAbstractItemModel *model = message.model();\n\n    // Find out whether the data is available already\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n\n    if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasHeader = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got header for\" << uid;\n#endif\n    }\n\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasBody = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got body for\" << uid;\n#endif\n    }\n\n    if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n            it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasMainPart = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got main part for\" << uid;\n#endif\n    }\n\n    if (a == message && !it->hasMessage) {\n\n        if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n            qDebug() << \"  Not loaded yet\";\n#endif\n            return;\n        }\n\n        it->hasMessage = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got message for\" << uid;\n#endif\n        requestDataDownload(message);\n\n    }\n\n    if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n        // Check message metadata\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n\n        // Check the main part\n        QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n        QString mainPart;\n        if (it->mainPartFailed) {\n            mainPart = it->partMessage;\n        } else {\n            Q_ASSERT(mainPartData.isValid());\n            mainPart = mainPartData.toString();\n        }\n\n        // The rest of the bulk data\n        QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(headerData.isValid());\n        QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(bodyData.isValid());\n\n        log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n        emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n        m_parts.erase(it);\n\n        m_messagesToBeFreed << message;\n        if (!m_releasingTimer->isActive())\n            m_releasingTimer->start();\n\n        if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n            m_queuedTimer->start();\n\n    } else {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n#endif\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n  {\n      if ( ! a.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( a != b ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n  #endif\n          return;\n      }\n  \n      QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n      if ( ! message.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                      message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n  #endif\n          return;\n      }\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n      if ( it == m_parts.end() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"We are not interested in message with UID\" << uid;\n  #endif\n          return;\n      }\n  \n      const QAbstractItemModel *model = message.model();\n  \n      // Find out whether the data is available already\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n  \n      if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasHeader = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got header for\" << uid;\n  #endif\n      }\n  \n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasBody = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got body for\" << uid;\n  #endif\n      }\n  \n      if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n              it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasMainPart = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got main part for\" << uid;\n  #endif\n      }\n  \n      if (a == message && !it->hasMessage) {\n  \n          if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n              qDebug() << \"  Not loaded yet\";\n  #endif\n              return;\n          }\n  \n          it->hasMessage = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got message for\" << uid;\n  #endif\n          requestDataDownload(message);\n  \n      }\n  \n      if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n          // Check message metadata\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n  \n          // Check the main part\n          QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n          QString mainPart;\n          if (it->mainPartFailed) {\n              mainPart = it->partMessage;\n          } else {\n              Q_ASSERT(mainPartData.isValid());\n              mainPart = mainPartData.toString();\n          }\n  \n          // The rest of the bulk data\n          QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(headerData.isValid());\n          QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(bodyData.isValid());\n  \n          log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n          emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n          m_parts.erase(it);\n  \n          m_messagesToBeFreed << message;\n          if (!m_releasingTimer->isActive())\n              m_releasingTimer->start();\n  \n          if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n              m_queuedTimer->start();\n  \n      } else {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n  #endif\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext.data",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext.data",
          "args": [
            "map::Mailbox::RoleIsFetched)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.data",
          "args": [
            "map::Mailbox::RolePartData)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->index",
          "args": [
            ",",
            "map::Mailbox::TreeItem::OFFSET_TEXT,",
            "essage)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "index(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "51-87",
          "snippet": "ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n{\n    if (column != 0)\n        return QModelIndex();\n    if (row < 0)\n        return QModelIndex();\n\n    if (parent.isValid()) {\n        // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // The parent is a ParserState\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            if (row >= parserState.activeTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, parserState.activeTasks.at(row));\n            }\n        } else {\n            // The parent is a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            if (row >= task->dependentTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, task->dependentTasks.at(row));\n            }\n        }\n    } else {\n        // So this is about a ParserState -- fair enough\n        if (row >= m_model->m_parsers.size()) {\n            return QModelIndex();\n        } else {\n            return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n  {\n      if (column != 0)\n          return QModelIndex();\n      if (row < 0)\n          return QModelIndex();\n  \n      if (parent.isValid()) {\n          // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // The parent is a ParserState\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              if (row >= parserState.activeTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, parserState.activeTasks.at(row));\n              }\n          } else {\n              // The parent is a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              if (row >= task->dependentTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, task->dependentTasks.at(row));\n              }\n          }\n      } else {\n          // So this is about a ParserState -- fair enough\n          if (row >= m_model->m_parsers.size()) {\n              return QModelIndex();\n          } else {\n              return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eader.data",
          "args": [
            "map::Mailbox::RoleIsFetched)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eader.data",
          "args": [
            "map::Mailbox::RolePartData)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.model",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "String::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)))"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(uid))"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "id)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Cannot find the main part for %1\")"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ainPart.data",
          "args": [
            "map::Mailbox::RolePartData)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ainPart.isValid())"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ainPart.isValid",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Mailbox::FindInterestingPart::findMainPartOfMessage(",
          "args": [
            "essage,",
            "ainPart,",
            "t->partMessage,",
            ")"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "findMainPartOfMessage(",
          "container": "indInterestingPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FindInterestingPart.cpp",
          "lines": "87-111",
          "snippet": "indInterestingPart::MainPartReturnCode FindInterestingPart::findMainPartOfMessage(\n        const QModelIndex &message, QModelIndex &mainPartIndex, QString &partMessage, QString *partData)\n{\n    mainPartIndex = message.child( 0, 0 );\n    if ( ! mainPartIndex.isValid() ) {\n        return MAINPART_MESSAGE_NOT_LOADED;\n    }\n\n    partMessage = findMainPart( mainPartIndex );\n    if ( ! mainPartIndex.isValid() ) {\n        return MAINPART_PART_CANNOT_DETERMINE;\n    }\n\n    if (partData) {\n        QVariant data = mainPartIndex.data( Imap::Mailbox::RolePartData );\n        if ( ! data.isValid() ) {\n            return MAINPART_PART_LOADING;\n        }\n\n        *partData = data.toString();\n        return MAINPART_FOUND;\n    } else {\n        return mainPartIndex.data(Imap::Mailbox::RoleIsFetched).toBool() ? MAINPART_FOUND : MAINPART_PART_LOADING;\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"FindInterestingPart.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FindInterestingPart.h\"\n#\n\nindInterestingPart {\n  indInterestingPart::MainPartReturnCode FindInterestingPart::findMainPartOfMessage(\n          const QModelIndex &message, QModelIndex &mainPartIndex, QString &partMessage, QString *partData)\n  {\n      mainPartIndex = message.child( 0, 0 );\n      if ( ! mainPartIndex.isValid() ) {\n          return MAINPART_MESSAGE_NOT_LOADED;\n      }\n  \n      partMessage = findMainPart( mainPartIndex );\n      if ( ! mainPartIndex.isValid() ) {\n          return MAINPART_PART_CANNOT_DETERMINE;\n      }\n  \n      if (partData) {\n          QVariant data = mainPartIndex.data( Imap::Mailbox::RolePartData );\n          if ( ! data.isValid() ) {\n              return MAINPART_PART_LOADING;\n          }\n  \n          *partData = data.toString();\n          return MAINPART_FOUND;\n      } else {\n          return mainPartIndex.data(Imap::Mailbox::RoleIsFetched).toBool() ? MAINPART_FOUND : MAINPART_PART_LOADING;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t->hasMessage)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != m_parts.end())"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parts.end",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_parts.find",
          "args": [
            "id)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "id)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::requestDataDownload(const QModelIndex &message)\n  {\n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find(uid);\n      Q_ASSERT(it != m_parts.end());\n      Q_ASSERT(it->hasMessage);\n  \n      // Let's see if we can find out what the \"main part\" is.\n      // The \"main part\" cannot be determined prior to the message's metadata becoming available.\n  \n      QModelIndex mainPart;\n      Imap::Mailbox::FindInterestingPart::MainPartReturnCode status =\n              Imap::Mailbox::FindInterestingPart::findMainPartOfMessage(message, mainPart, it->partMessage, 0);\n      it->mainPart = mainPart;\n      switch (status) {\n      case Imap::Mailbox::FindInterestingPart::MAINPART_FOUND:\n      case Imap::Mailbox::FindInterestingPart::MAINPART_PART_LOADING:\n          // The MAINPART_PART_LOADING is a confusing name -- as we're calling findMainPartOfMessage with the last parameter being\n          // nullptr, the function will not attempt to actually fetch the data, and therefore the exit status cannot be\n          // MAINPART_FOUND, so it will be MAINPART_PART_LOADING. Yep, confusing.\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Requesting data for \" << uid;\n  #endif\n          // Ask for the data.\n          Q_ASSERT(mainPart.isValid());\n          mainPart.data(Imap::Mailbox::RolePartData);\n          break;\n  \n      case Imap::Mailbox::FindInterestingPart::MAINPART_MESSAGE_NOT_LOADED:\n          Q_ASSERT(false);\n          break;\n  \n      case Imap::Mailbox::FindInterestingPart::MAINPART_PART_CANNOT_DETERMINE:\n          it->hasMainPart = true;\n          it->mainPartFailed = true;\n          log(QString::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)));\n          break;\n      }\n  \n      // Now request the rest of the data\n      const QAbstractItemModel *model = message.model();\n      Q_ASSERT(model);\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n      header.data(Imap::Mailbox::RolePartData);\n      it->hasHeader = header.data(Imap::Mailbox::RoleIsFetched).toBool();\n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      text.data(Imap::Mailbox::RolePartData);\n      it->hasBody = text.data(Imap::Mailbox::RoleIsFetched).toBool();\n  \n      if (it->hasMainPart && it->hasHeader && it->hasBody) {\n          // We have everything what we need at this point\n          slotDataChanged(message, message);\n      }\n  }\n}"
  },
  {
    "function_name": "reallyRequestDownload(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "77-92",
    "snippet": "oid MessageDownloader::reallyRequestDownload(const QModelIndex &message)\n{\n    MessageMetadata metaData;\n\n    // Now request loading of the message metadata. We are especially interested in the message envelope, the part which will\n    // enable us to request the main part in future.\n    metaData.hasMessage = message.data( Imap::Mailbox::RoleMessageMessageId ).isValid();\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n    m_parts[ uid ] = metaData;\n\n    if (metaData.hasMessage) {\n        requestDataDownload(message);\n    }\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "equestDataDownload(",
          "args": [
            "essage)"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "requestDataDownload(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "95-150",
          "snippet": "oid MessageDownloader::requestDataDownload(const QModelIndex &message)\n{\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find(uid);\n    Q_ASSERT(it != m_parts.end());\n    Q_ASSERT(it->hasMessage);\n\n    // Let's see if we can find out what the \"main part\" is.\n    // The \"main part\" cannot be determined prior to the message's metadata becoming available.\n\n    QModelIndex mainPart;\n    Imap::Mailbox::FindInterestingPart::MainPartReturnCode status =\n            Imap::Mailbox::FindInterestingPart::findMainPartOfMessage(message, mainPart, it->partMessage, 0);\n    it->mainPart = mainPart;\n    switch (status) {\n    case Imap::Mailbox::FindInterestingPart::MAINPART_FOUND:\n    case Imap::Mailbox::FindInterestingPart::MAINPART_PART_LOADING:\n        // The MAINPART_PART_LOADING is a confusing name -- as we're calling findMainPartOfMessage with the last parameter being\n        // nullptr, the function will not attempt to actually fetch the data, and therefore the exit status cannot be\n        // MAINPART_FOUND, so it will be MAINPART_PART_LOADING. Yep, confusing.\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Requesting data for \" << uid;\n#endif\n        // Ask for the data.\n        Q_ASSERT(mainPart.isValid());\n        mainPart.data(Imap::Mailbox::RolePartData);\n        break;\n\n    case Imap::Mailbox::FindInterestingPart::MAINPART_MESSAGE_NOT_LOADED:\n        Q_ASSERT(false);\n        break;\n\n    case Imap::Mailbox::FindInterestingPart::MAINPART_PART_CANNOT_DETERMINE:\n        it->hasMainPart = true;\n        it->mainPartFailed = true;\n        log(QString::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)));\n        break;\n    }\n\n    // Now request the rest of the data\n    const QAbstractItemModel *model = message.model();\n    Q_ASSERT(model);\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n    header.data(Imap::Mailbox::RolePartData);\n    it->hasHeader = header.data(Imap::Mailbox::RoleIsFetched).toBool();\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    text.data(Imap::Mailbox::RolePartData);\n    it->hasBody = text.data(Imap::Mailbox::RoleIsFetched).toBool();\n\n    if (it->hasMainPart && it->hasHeader && it->hasBody) {\n        // We have everything what we need at this point\n        slotDataChanged(message, message);\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::requestDataDownload(const QModelIndex &message)\n  {\n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find(uid);\n      Q_ASSERT(it != m_parts.end());\n      Q_ASSERT(it->hasMessage);\n  \n      // Let's see if we can find out what the \"main part\" is.\n      // The \"main part\" cannot be determined prior to the message's metadata becoming available.\n  \n      QModelIndex mainPart;\n      Imap::Mailbox::FindInterestingPart::MainPartReturnCode status =\n              Imap::Mailbox::FindInterestingPart::findMainPartOfMessage(message, mainPart, it->partMessage, 0);\n      it->mainPart = mainPart;\n      switch (status) {\n      case Imap::Mailbox::FindInterestingPart::MAINPART_FOUND:\n      case Imap::Mailbox::FindInterestingPart::MAINPART_PART_LOADING:\n          // The MAINPART_PART_LOADING is a confusing name -- as we're calling findMainPartOfMessage with the last parameter being\n          // nullptr, the function will not attempt to actually fetch the data, and therefore the exit status cannot be\n          // MAINPART_FOUND, so it will be MAINPART_PART_LOADING. Yep, confusing.\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Requesting data for \" << uid;\n  #endif\n          // Ask for the data.\n          Q_ASSERT(mainPart.isValid());\n          mainPart.data(Imap::Mailbox::RolePartData);\n          break;\n  \n      case Imap::Mailbox::FindInterestingPart::MAINPART_MESSAGE_NOT_LOADED:\n          Q_ASSERT(false);\n          break;\n  \n      case Imap::Mailbox::FindInterestingPart::MAINPART_PART_CANNOT_DETERMINE:\n          it->hasMainPart = true;\n          it->mainPartFailed = true;\n          log(QString::fromUtf8(\"Cannot find the main part for %1\").arg(QString::number(uid)));\n          break;\n      }\n  \n      // Now request the rest of the data\n      const QAbstractItemModel *model = message.model();\n      Q_ASSERT(model);\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n      header.data(Imap::Mailbox::RolePartData);\n      it->hasHeader = header.data(Imap::Mailbox::RoleIsFetched).toBool();\n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      text.data(Imap::Mailbox::RolePartData);\n      it->hasBody = text.data(Imap::Mailbox::RoleIsFetched).toBool();\n  \n      if (it->hasMainPart && it->hasHeader && it->hasBody) {\n          // We have everything what we need at this point\n          slotDataChanged(message, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "id)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageMessageId"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::reallyRequestDownload(const QModelIndex &message)\n  {\n      MessageMetadata metaData;\n  \n      // Now request loading of the message metadata. We are especially interested in the message envelope, the part which will\n      // enable us to request the main part in future.\n      metaData.hasMessage = message.data( Imap::Mailbox::RoleMessageMessageId ).isValid();\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n      m_parts[ uid ] = metaData;\n  \n      if (metaData.hasMessage) {\n          requestDataDownload(message);\n      }\n  }\n}"
  },
  {
    "function_name": "requestDownload(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "62-75",
    "snippet": "oid MessageDownloader::requestDownload( const QModelIndex &message )\n{\n    Q_ASSERT(m_model == message.model());\n    Q_ASSERT( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() == registeredMailbox );\n\n    log(QString::fromUtf8(\"Requesting download of UID %1 from mailbox %2\").arg(\n            message.data(Imap::Mailbox::RoleMessageUid).toString(), registeredMailbox));\n\n    if (m_parts.size() >= BATCH_SIZE) {\n        m_queuedEnvelopes << message;\n    } else {\n        reallyRequestDownload(message);\n    }\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eallyRequestDownload(",
          "args": [
            "essage)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "reallyRequestDownload(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "77-92",
          "snippet": "oid MessageDownloader::reallyRequestDownload(const QModelIndex &message)\n{\n    MessageMetadata metaData;\n\n    // Now request loading of the message metadata. We are especially interested in the message envelope, the part which will\n    // enable us to request the main part in future.\n    metaData.hasMessage = message.data( Imap::Mailbox::RoleMessageMessageId ).isValid();\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n    m_parts[ uid ] = metaData;\n\n    if (metaData.hasMessage) {\n        requestDataDownload(message);\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::reallyRequestDownload(const QModelIndex &message)\n  {\n      MessageMetadata metaData;\n  \n      // Now request loading of the message metadata. We are especially interested in the message envelope, the part which will\n      // enable us to request the main part in future.\n      metaData.hasMessage = message.data( Imap::Mailbox::RoleMessageMessageId ).isValid();\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n      m_parts[ uid ] = metaData;\n  \n      if (metaData.hasMessage) {\n          requestDataDownload(message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_parts.size",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "String::fromUtf8(\"Requesting download of UID %1 from mailbox %2\").arg(\n            message.data(Imap::Mailbox::RoleMessageUid).toString(), registeredMailbox))"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "essage.data(Imap::Mailbox::RoleMessageUid).toString(),",
            "egisteredMailbox)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Requesting download of UID %1 from mailbox %2\")"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essage.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() == registeredMailbox"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.parent",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.parent",
          "args": [
            "map::Mailbox::RoleMailboxName"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_model == message.model())"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.model",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::requestDownload( const QModelIndex &message )\n  {\n      Q_ASSERT(m_model == message.model());\n      Q_ASSERT( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() == registeredMailbox );\n  \n      log(QString::fromUtf8(\"Requesting download of UID %1 from mailbox %2\").arg(\n              message.data(Imap::Mailbox::RoleMessageUid).toString(), registeredMailbox));\n  \n      if (m_parts.size() >= BATCH_SIZE) {\n          m_queuedEnvelopes << message;\n      } else {\n          reallyRequestDownload(message);\n      }\n  }\n}"
  },
  {
    "function_name": "log(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "57-60",
    "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_model->logTrace",
          "args": [
            ",",
            "ommon::LOG_OTHER,",
            "Latin1String(\"MessageDownloader\"),",
            "essage)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "MessageDownloader\")"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
  },
  {
    "function_name": "MessageDownloader(",
    "container": "essageDownloader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
    "lines": "42-55",
    "snippet": "essageDownloader::MessageDownloader(QObject *parent, Imap::Mailbox::Model *model, const QString &mailboxName):\n    QObject(parent), m_model(model), registeredMailbox(mailboxName)\n{\n    m_releasingTimer = new QTimer(this);\n    m_releasingTimer->setSingleShot(true);\n    connect(m_releasingTimer, SIGNAL(timeout()), this, SLOT(slotFreeProcessedMessages()));\n\n    m_queuedTimer = new QTimer(this);\n    m_queuedTimer->setSingleShot(true);\n    connect(m_queuedTimer, SIGNAL(timeout()), this, SLOT(slotFetchQueuedMessages()));\n\n    Q_ASSERT(m_model);\n    connect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FindInterestingPart.h\"\n#",
      "include \"MessageDownloader.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(dataChanged(QModelIndex,QModelIndex)),",
            "his,",
            "LOT(slotDataChanged(QModelIndex,QModelIndex)))"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotDataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotDataChanged(",
          "args": [
            "ModelIndex,",
            "ModelIndex)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "slotDataChanged(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "152-278",
          "snippet": "oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n{\n    if ( ! a.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( a != b ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n#endif\n        return;\n    }\n\n    QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n    if ( ! message.isValid() ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n#endif\n        return;\n    }\n\n    if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n        qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                    message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n#endif\n        return;\n    }\n\n    const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n    Q_ASSERT(uid);\n\n    QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n    if ( it == m_parts.end() ) {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"We are not interested in message with UID\" << uid;\n#endif\n        return;\n    }\n\n    const QAbstractItemModel *model = message.model();\n\n    // Find out whether the data is available already\n    QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n\n    if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasHeader = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got header for\" << uid;\n#endif\n    }\n\n    QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n    if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasBody = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got body for\" << uid;\n#endif\n    }\n\n    if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n            it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n        it->hasMainPart = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got main part for\" << uid;\n#endif\n    }\n\n    if (a == message && !it->hasMessage) {\n\n        if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n#ifdef DEBUG_PENDING_MESSAGES_2\n            qDebug() << \"  Not loaded yet\";\n#endif\n            return;\n        }\n\n        it->hasMessage = true;\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"  Got message for\" << uid;\n#endif\n        requestDataDownload(message);\n\n    }\n\n    if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n        // Check message metadata\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n        Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n\n        // Check the main part\n        QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n        QString mainPart;\n        if (it->mainPartFailed) {\n            mainPart = it->partMessage;\n        } else {\n            Q_ASSERT(mainPartData.isValid());\n            mainPart = mainPartData.toString();\n        }\n\n        // The rest of the bulk data\n        QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(headerData.isValid());\n        QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n        Q_ASSERT(bodyData.isValid());\n\n        log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n        emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n        m_parts.erase(it);\n\n        m_messagesToBeFreed << message;\n        if (!m_releasingTimer->isActive())\n            m_releasingTimer->start();\n\n        if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n            m_queuedTimer->start();\n\n    } else {\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n#endif\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotDataChanged( const QModelIndex &a, const QModelIndex &b )\n  {\n      if ( ! a.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( a != b ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"MessageDownloader::slotDataChanged: a != b\" << a;\n  #endif\n          return;\n      }\n  \n      QModelIndex message = Imap::Mailbox::Model::findMessageForItem( a );\n      if ( ! message.isValid() ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: message not valid\" << a;\n  #endif\n          return;\n      }\n  \n      if ( message.parent().parent().data( Imap::Mailbox::RoleMailboxName ).toString() != registeredMailbox ) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n          qDebug() << \"MessageDownloader::slotDataChanged: not this mailbox\" << a <<\n                      message.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() << registeredMailbox;\n  #endif\n          return;\n      }\n  \n      const uint uid = message.data( Imap::Mailbox::RoleMessageUid ).toUInt();\n      Q_ASSERT(uid);\n  \n      QMap<uint,MessageMetadata>::iterator it = m_parts.find( uid );\n      if ( it == m_parts.end() ) {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"We are not interested in message with UID\" << uid;\n  #endif\n          return;\n      }\n  \n      const QAbstractItemModel *model = message.model();\n  \n      // Find out whether the data is available already\n      QModelIndex header = model->index(0, Imap::Mailbox::TreeItem::OFFSET_HEADER, message);\n  \n      if (!it->hasHeader && header.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasHeader = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got header for\" << uid;\n  #endif\n      }\n  \n      QModelIndex text = model->index(0, Imap::Mailbox::TreeItem::OFFSET_TEXT, message);\n      if (!it->hasBody && text.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasBody = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got body for\" << uid;\n  #endif\n      }\n  \n      if (!it->hasMainPart && !it->mainPartFailed && it->mainPart.isValid() && a == it->mainPart &&\n              it->mainPart.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n          it->hasMainPart = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got main part for\" << uid;\n  #endif\n      }\n  \n      if (a == message && !it->hasMessage) {\n  \n          if (!message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n  #ifdef DEBUG_PENDING_MESSAGES_2\n              qDebug() << \"  Not loaded yet\";\n  #endif\n              return;\n          }\n  \n          it->hasMessage = true;\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"  Got message for\" << uid;\n  #endif\n          requestDataDownload(message);\n  \n      }\n  \n      if ( it->hasHeader && it->hasBody && it->hasMessage && it->hasMainPart ) {\n          // Check message metadata\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageMessageId).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageSubject).isValid());\n          Q_ASSERT(message.data(Imap::Mailbox::RoleMessageDate).isValid());\n  \n          // Check the main part\n          QVariant mainPartData = it->mainPart.data(Imap::Mailbox::RolePartData);\n          QString mainPart;\n          if (it->mainPartFailed) {\n              mainPart = it->partMessage;\n          } else {\n              Q_ASSERT(mainPartData.isValid());\n              mainPart = mainPartData.toString();\n          }\n  \n          // The rest of the bulk data\n          QVariant headerData = header.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(headerData.isValid());\n          QVariant bodyData = text.data(Imap::Mailbox::RolePartData);\n          Q_ASSERT(bodyData.isValid());\n  \n          log(QString::fromUtf8(\"Downloaded message %1\").arg(QString::number(uid)));\n          emit messageDownloaded( message, headerData.toByteArray(), bodyData.toByteArray(), mainPart );\n          m_parts.erase(it);\n  \n          m_messagesToBeFreed << message;\n          if (!m_releasingTimer->isActive())\n              m_releasingTimer->start();\n  \n          if (!m_queuedTimer->isActive() && m_parts.size() <= BATCH_SIZE / 10)\n              m_queuedTimer->start();\n  \n      } else {\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Something is missing for\" << uid << it->hasHeader << it->hasBody << it->hasMessage << it->hasMainPart;\n  #endif\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_model)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_queuedTimer,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotFetchQueuedMessages()))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotFetchQueuedMessages())"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotFetchQueuedMessages(",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchQueuedMessages(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "309-317",
          "snippet": "oid MessageDownloader::slotFetchQueuedMessages()\n{\n    for (int i = 0; i < BATCH_SIZE; ++i) {\n        if (m_queuedEnvelopes.isEmpty())\n            return;\n        QPersistentModelIndex message = m_queuedEnvelopes.dequeue();\n        reallyRequestDownload(message);\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotFetchQueuedMessages()\n  {\n      for (int i = 0; i < BATCH_SIZE; ++i) {\n          if (m_queuedEnvelopes.isEmpty())\n              return;\n          QPersistentModelIndex message = m_queuedEnvelopes.dequeue();\n          reallyRequestDownload(message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_queuedTimer->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_releasingTimer,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotFreeProcessedMessages()))"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotFreeProcessedMessages())"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotFreeProcessedMessages(",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "slotFreeProcessedMessages(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "291-307",
          "snippet": "oid MessageDownloader::slotFreeProcessedMessages()\n{\n    Q_FOREACH(const QPersistentModelIndex &index, m_messagesToBeFreed) {\n        if (!index.isValid())\n            continue;\n        // The const_cast should be safe here -- this action is certainly not going to invalidate the index,\n        // and even the releaseMessageData() won't (directly) touch its members anyway...\n        Imap::Mailbox::Model *model = qobject_cast<Imap::Mailbox::Model*>(const_cast<QAbstractItemModel*>(index.model()));\n        Q_ASSERT(model);\n#ifdef DEBUG_PENDING_MESSAGES\n        qDebug() << \"Freeing memory for\" << index.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() <<\n                    \"UID\" << index.data(Imap::Mailbox::RoleMessageUid).toUInt();\n#endif\n        model->releaseMessageData(index);\n    }\n    m_messagesToBeFreed.clear();\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::slotFreeProcessedMessages()\n  {\n      Q_FOREACH(const QPersistentModelIndex &index, m_messagesToBeFreed) {\n          if (!index.isValid())\n              continue;\n          // The const_cast should be safe here -- this action is certainly not going to invalidate the index,\n          // and even the releaseMessageData() won't (directly) touch its members anyway...\n          Imap::Mailbox::Model *model = qobject_cast<Imap::Mailbox::Model*>(const_cast<QAbstractItemModel*>(index.model()));\n          Q_ASSERT(model);\n  #ifdef DEBUG_PENDING_MESSAGES\n          qDebug() << \"Freeing memory for\" << index.parent().parent().data(Imap::Mailbox::RoleMailboxName).toString() <<\n                      \"UID\" << index.data(Imap::Mailbox::RoleMessageUid).toUInt();\n  #endif\n          model->releaseMessageData(index);\n      }\n      m_messagesToBeFreed.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_releasingTimer->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  essageDownloader::MessageDownloader(QObject *parent, Imap::Mailbox::Model *model, const QString &mailboxName):\n      QObject(parent), m_model(model), registeredMailbox(mailboxName)\n  {\n      m_releasingTimer = new QTimer(this);\n      m_releasingTimer->setSingleShot(true);\n      connect(m_releasingTimer, SIGNAL(timeout()), this, SLOT(slotFreeProcessedMessages()));\n  \n      m_queuedTimer = new QTimer(this);\n      m_queuedTimer->setSingleShot(true);\n      connect(m_queuedTimer, SIGNAL(timeout()), this, SLOT(slotFetchQueuedMessages()));\n  \n      Q_ASSERT(m_model);\n      connect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n  }\n}"
  }
]