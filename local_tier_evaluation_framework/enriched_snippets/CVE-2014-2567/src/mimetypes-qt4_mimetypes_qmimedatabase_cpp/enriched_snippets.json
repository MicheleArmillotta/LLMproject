[
  {
    "function_name": "allMimeTypes",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "586-591",
    "snippet": "QList<QMimeType> QMimeDatabase::allMimeTypes() const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->allMimeTypes();\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->allMimeTypes",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "allMimeTypes",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "586-591",
          "snippet": "QList<QMimeType> QMimeDatabase::allMimeTypes() const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->allMimeTypes();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QList<QMimeType> QMimeDatabase::allMimeTypes() const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->allMimeTypes();\n  }\n}"
  },
  {
    "function_name": "mimeTypeForFileNameAndData",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "571-577",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForFileNameAndData(const QString &fileName, const QByteArray &data) const\n{\n    QBuffer buffer(const_cast<QByteArray *>(&data));\n    buffer.open(QIODevice::ReadOnly);\n    int accuracy = 0;\n    return d->mimeTypeForFileNameAndData(fileName, &buffer, &accuracy);\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->mimeTypeForFileNameAndData",
          "args": [
            "fileName",
            "&buffer",
            "&accuracy"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForFileNameAndData",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "160-216",
          "snippet": "QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n{\n    // First, glob patterns are evaluated. If there is a match with max weight,\n    // this one is selected and we are done. Otherwise, the file contents are\n    // evaluated and the match with the highest value (either a magic priority or\n    // a glob pattern weight) is selected. Matching starts from max level (most\n    // specific) in both cases, even when there is already a suffix matching candidate.\n    *accuracyPtr = 0;\n\n    // Pass 1) Try to match on the file name\n    QStringList candidatesByName = mimeTypeForFileName(fileName);\n    if (candidatesByName.count() == 1) {\n        *accuracyPtr = 100;\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n        candidatesByName.clear();\n    }\n\n    // Extension is unknown, or matches multiple mimetypes.\n    // Pass 2) Match on content, if we can read the data\n    if (device->isOpen()) {\n\n        // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n        // This is much faster than seeking back and forth into QIODevice.\n        const QByteArray data = device->peek(16384);\n\n        int magicAccuracy = 0;\n        QMimeType candidateByData(findByData(data, &magicAccuracy));\n\n        // Disambiguate conflicting extensions (if magic matching found something)\n        if (candidateByData.isValid() && magicAccuracy > 0) {\n            // \"for glob_match in glob_matches:\"\n            // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n            const QString sniffedMime = candidateByData.name();\n            foreach (const QString &m, candidatesByName) {\n                if (inherits(m, sniffedMime)) {\n                    // We have magic + pattern pointing to this, so it's a pretty good match\n                    *accuracyPtr = 100;\n                    return mimeTypeForName(m);\n                }\n            }\n            *accuracyPtr = magicAccuracy;\n            return candidateByData;\n        }\n    }\n\n    if (candidatesByName.count() > 1) {\n        *accuracyPtr = 20;\n        candidatesByName.sort(); // to make it deterministic\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n  {\n      // First, glob patterns are evaluated. If there is a match with max weight,\n      // this one is selected and we are done. Otherwise, the file contents are\n      // evaluated and the match with the highest value (either a magic priority or\n      // a glob pattern weight) is selected. Matching starts from max level (most\n      // specific) in both cases, even when there is already a suffix matching candidate.\n      *accuracyPtr = 0;\n  \n      // Pass 1) Try to match on the file name\n      QStringList candidatesByName = mimeTypeForFileName(fileName);\n      if (candidatesByName.count() == 1) {\n          *accuracyPtr = 100;\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n          candidatesByName.clear();\n      }\n  \n      // Extension is unknown, or matches multiple mimetypes.\n      // Pass 2) Match on content, if we can read the data\n      if (device->isOpen()) {\n  \n          // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n          // This is much faster than seeking back and forth into QIODevice.\n          const QByteArray data = device->peek(16384);\n  \n          int magicAccuracy = 0;\n          QMimeType candidateByData(findByData(data, &magicAccuracy));\n  \n          // Disambiguate conflicting extensions (if magic matching found something)\n          if (candidateByData.isValid() && magicAccuracy > 0) {\n              // \"for glob_match in glob_matches:\"\n              // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n              const QString sniffedMime = candidateByData.name();\n              foreach (const QString &m, candidatesByName) {\n                  if (inherits(m, sniffedMime)) {\n                      // We have magic + pattern pointing to this, so it's a pretty good match\n                      *accuracyPtr = 100;\n                      return mimeTypeForName(m);\n                  }\n              }\n              *accuracyPtr = magicAccuracy;\n              return candidateByData;\n          }\n      }\n  \n      if (candidatesByName.count() > 1) {\n          *accuracyPtr = 20;\n          candidatesByName.sort(); // to make it deterministic\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<QByteArray *>",
          "args": [
            "&data"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForFileNameAndData(const QString &fileName, const QByteArray &data) const\n  {\n      QBuffer buffer(const_cast<QByteArray *>(&data));\n      buffer.open(QIODevice::ReadOnly);\n      int accuracy = 0;\n      return d->mimeTypeForFileNameAndData(fileName, &buffer, &accuracy);\n  }\n}"
  },
  {
    "function_name": "mimeTypeForFileNameAndData",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "545-553",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device) const\n{\n    int accuracy = 0;\n    const bool openedByUs = !device->isOpen() && device->open(QIODevice::ReadOnly);\n    const QMimeType result = d->mimeTypeForFileNameAndData(fileName, device, &accuracy);\n    if (openedByUs)\n        device->close();\n    return result;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device->close",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mimeTypeForFileNameAndData",
          "args": [
            "fileName",
            "device",
            "&accuracy"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForFileNameAndData",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "160-216",
          "snippet": "QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n{\n    // First, glob patterns are evaluated. If there is a match with max weight,\n    // this one is selected and we are done. Otherwise, the file contents are\n    // evaluated and the match with the highest value (either a magic priority or\n    // a glob pattern weight) is selected. Matching starts from max level (most\n    // specific) in both cases, even when there is already a suffix matching candidate.\n    *accuracyPtr = 0;\n\n    // Pass 1) Try to match on the file name\n    QStringList candidatesByName = mimeTypeForFileName(fileName);\n    if (candidatesByName.count() == 1) {\n        *accuracyPtr = 100;\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n        candidatesByName.clear();\n    }\n\n    // Extension is unknown, or matches multiple mimetypes.\n    // Pass 2) Match on content, if we can read the data\n    if (device->isOpen()) {\n\n        // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n        // This is much faster than seeking back and forth into QIODevice.\n        const QByteArray data = device->peek(16384);\n\n        int magicAccuracy = 0;\n        QMimeType candidateByData(findByData(data, &magicAccuracy));\n\n        // Disambiguate conflicting extensions (if magic matching found something)\n        if (candidateByData.isValid() && magicAccuracy > 0) {\n            // \"for glob_match in glob_matches:\"\n            // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n            const QString sniffedMime = candidateByData.name();\n            foreach (const QString &m, candidatesByName) {\n                if (inherits(m, sniffedMime)) {\n                    // We have magic + pattern pointing to this, so it's a pretty good match\n                    *accuracyPtr = 100;\n                    return mimeTypeForName(m);\n                }\n            }\n            *accuracyPtr = magicAccuracy;\n            return candidateByData;\n        }\n    }\n\n    if (candidatesByName.count() > 1) {\n        *accuracyPtr = 20;\n        candidatesByName.sort(); // to make it deterministic\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n  {\n      // First, glob patterns are evaluated. If there is a match with max weight,\n      // this one is selected and we are done. Otherwise, the file contents are\n      // evaluated and the match with the highest value (either a magic priority or\n      // a glob pattern weight) is selected. Matching starts from max level (most\n      // specific) in both cases, even when there is already a suffix matching candidate.\n      *accuracyPtr = 0;\n  \n      // Pass 1) Try to match on the file name\n      QStringList candidatesByName = mimeTypeForFileName(fileName);\n      if (candidatesByName.count() == 1) {\n          *accuracyPtr = 100;\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n          candidatesByName.clear();\n      }\n  \n      // Extension is unknown, or matches multiple mimetypes.\n      // Pass 2) Match on content, if we can read the data\n      if (device->isOpen()) {\n  \n          // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n          // This is much faster than seeking back and forth into QIODevice.\n          const QByteArray data = device->peek(16384);\n  \n          int magicAccuracy = 0;\n          QMimeType candidateByData(findByData(data, &magicAccuracy));\n  \n          // Disambiguate conflicting extensions (if magic matching found something)\n          if (candidateByData.isValid() && magicAccuracy > 0) {\n              // \"for glob_match in glob_matches:\"\n              // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n              const QString sniffedMime = candidateByData.name();\n              foreach (const QString &m, candidatesByName) {\n                  if (inherits(m, sniffedMime)) {\n                      // We have magic + pattern pointing to this, so it's a pretty good match\n                      *accuracyPtr = 100;\n                      return mimeTypeForName(m);\n                  }\n              }\n              *accuracyPtr = magicAccuracy;\n              return candidateByData;\n          }\n      }\n  \n      if (candidatesByName.count() > 1) {\n          *accuracyPtr = 20;\n          candidatesByName.sort(); // to make it deterministic\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "device->open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device->isOpen",
          "args": [],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device) const\n  {\n      int accuracy = 0;\n      const bool openedByUs = !device->isOpen() && device->open(QIODevice::ReadOnly);\n      const QMimeType result = d->mimeTypeForFileNameAndData(fileName, device, &accuracy);\n      if (openedByUs)\n          device->close();\n      return result;\n  }\n}"
  },
  {
    "function_name": "mimeTypeForUrl",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "510-524",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForUrl(const QUrl &url) const\n{\n#if QT_VERSION >= 0x040800\n    if (url.isLocalFile())\n#else\n    if (url.scheme().isEmpty())\n#endif\n        return mimeTypeForFile(url.toLocalFile());\n\n    const QString scheme = url.scheme();\n    if (scheme.startsWith(QLatin1String(\"http\")))\n        return mimeTypeForName(d->defaultMimeType());\n\n    return mimeTypeForFile(url.path());\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimeTypeForFile",
          "args": [
            "url.path()"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.path",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeForName",
          "args": [
            "d->defaultMimeType()"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->defaultMimeType",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "defaultMimeType",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase_p.h",
          "lines": "70-70",
          "snippet": "inline QString defaultMimeType() const { return m_defaultMimeType; }",
          "includes": [
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\"",
            "#include <qmutex.h>",
            "#include <qhash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeglobpattern_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n#include <qmutex.h>\n#include <qhash.h>\n\nQMimeDatabasePrivate {\n  inline QString defaultMimeType() const { return m_defaultMimeType; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scheme.startsWith",
          "args": [
            "QLatin1String(\"http\")"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"http\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.scheme",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeForFile",
          "args": [
            "url.toLocalFile()"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.toLocalFile",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.scheme",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.scheme",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "url.isLocalFile",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForUrl(const QUrl &url) const\n  {\n  #if QT_VERSION >= 0x040800\n      if (url.isLocalFile())\n  #else\n      if (url.scheme().isEmpty())\n  #endif\n          return mimeTypeForFile(url.toLocalFile());\n  \n      const QString scheme = url.scheme();\n      if (scheme.startsWith(QLatin1String(\"http\")))\n          return mimeTypeForName(d->defaultMimeType());\n  \n      return mimeTypeForFile(url.path());\n  }\n}"
  },
  {
    "function_name": "mimeTypeForData",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "478-494",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForData(QIODevice *device) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    int accuracy = 0;\n    const bool openedByUs = !device->isOpen() && device->open(QIODevice::ReadOnly);\n    if (device->isOpen()) {\n        // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n        // This is much faster than seeking back and forth into QIODevice.\n        const QByteArray data = device->peek(16384);\n        const QMimeType result = d->findByData(data, &accuracy);\n        if (openedByUs)\n            device->close();\n        return result;\n    }\n    return d->mimeTypeForName(d->defaultMimeType());\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->mimeTypeForName",
          "args": [
            "d->defaultMimeType()"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->defaultMimeType",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "defaultMimeType",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase_p.h",
          "lines": "70-70",
          "snippet": "inline QString defaultMimeType() const { return m_defaultMimeType; }",
          "includes": [
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\"",
            "#include <qmutex.h>",
            "#include <qhash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeglobpattern_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n#include <qmutex.h>\n#include <qhash.h>\n\nQMimeDatabasePrivate {\n  inline QString defaultMimeType() const { return m_defaultMimeType; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "device->close",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->findByData",
          "args": [
            "data",
            "&accuracy"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "findByData",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "139-158",
          "snippet": "QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n{\n    if (data.isEmpty()) {\n        *accuracyPtr = 100;\n        return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n    }\n\n    *accuracyPtr = 0;\n    QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n\n    if (candidate.isValid())\n        return candidate;\n\n    if (isTextFile(data)) {\n        *accuracyPtr = 5;\n        return mimeTypeForName(QLatin1String(\"text/plain\"));\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n  {\n      if (data.isEmpty()) {\n          *accuracyPtr = 100;\n          return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n      }\n  \n      *accuracyPtr = 0;\n      QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n  \n      if (candidate.isValid())\n          return candidate;\n  \n      if (isTextFile(data)) {\n          *accuracyPtr = 5;\n          return mimeTypeForName(QLatin1String(\"text/plain\"));\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "device->peek",
          "args": [
            "16384"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device->isOpen",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device->open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device->isOpen",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForData(QIODevice *device) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      int accuracy = 0;\n      const bool openedByUs = !device->isOpen() && device->open(QIODevice::ReadOnly);\n      if (device->isOpen()) {\n          // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n          // This is much faster than seeking back and forth into QIODevice.\n          const QByteArray data = device->peek(16384);\n          const QMimeType result = d->findByData(data, &accuracy);\n          if (openedByUs)\n              device->close();\n          return result;\n      }\n      return d->mimeTypeForName(d->defaultMimeType());\n  }\n}"
  },
  {
    "function_name": "mimeTypeForData",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "463-469",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForData(const QByteArray &data) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    int accuracy = 0;\n    return d->findByData(data, &accuracy);\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->findByData",
          "args": [
            "data",
            "&accuracy"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "findByData",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "139-158",
          "snippet": "QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n{\n    if (data.isEmpty()) {\n        *accuracyPtr = 100;\n        return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n    }\n\n    *accuracyPtr = 0;\n    QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n\n    if (candidate.isValid())\n        return candidate;\n\n    if (isTextFile(data)) {\n        *accuracyPtr = 5;\n        return mimeTypeForName(QLatin1String(\"text/plain\"));\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n  {\n      if (data.isEmpty()) {\n          *accuracyPtr = 100;\n          return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n      }\n  \n      *accuracyPtr = 0;\n      QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n  \n      if (candidate.isValid())\n          return candidate;\n  \n      if (isTextFile(data)) {\n          *accuracyPtr = 5;\n          return mimeTypeForName(QLatin1String(\"text/plain\"));\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForData(const QByteArray &data) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      int accuracy = 0;\n      return d->findByData(data, &accuracy);\n  }\n}"
  },
  {
    "function_name": "suffixForFileName",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "448-454",
    "snippet": "QString QMimeDatabase::suffixForFileName(const QString &fileName) const\n{\n    QMutexLocker locker(&d->mutex);\n    QString foundSuffix;\n    d->mimeTypeForFileName(fileName, &foundSuffix);\n    return foundSuffix;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->mimeTypeForFileName",
          "args": [
            "fileName",
            "&foundSuffix"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForFileName",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "111-118",
          "snippet": "QStringList QMimeDatabasePrivate::mimeTypeForFileName(const QString &fileName, QString *foundSuffix)\n{\n    if (fileName.endsWith(QLatin1Char('/')))\n        return QStringList() << QLatin1String(\"inode/directory\");\n\n    const QStringList matchingMimeTypes = provider()->findByFileName(QFileInfo(fileName).fileName(), foundSuffix);\n    return matchingMimeTypes;\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QStringList QMimeDatabasePrivate::mimeTypeForFileName(const QString &fileName, QString *foundSuffix)\n  {\n      if (fileName.endsWith(QLatin1Char('/')))\n          return QStringList() << QLatin1String(\"inode/directory\");\n  \n      const QStringList matchingMimeTypes = provider()->findByFileName(QFileInfo(fileName).fileName(), foundSuffix);\n      return matchingMimeTypes;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QString QMimeDatabase::suffixForFileName(const QString &fileName) const\n  {\n      QMutexLocker locker(&d->mutex);\n      QString foundSuffix;\n      d->mimeTypeForFileName(fileName, &foundSuffix);\n      return foundSuffix;\n  }\n}"
  },
  {
    "function_name": "mimeTypesForFileName",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "431-441",
    "snippet": "QList<QMimeType> QMimeDatabase::mimeTypesForFileName(const QString &fileName) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    QStringList matches = d->mimeTypeForFileName(fileName);\n    QList<QMimeType> mimes;\n    matches.sort(); // Make it deterministic\n    foreach (const QString &mime, matches)\n        mimes.append(d->mimeTypeForName(mime));\n    return mimes;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimes.append",
          "args": [
            "d->mimeTypeForName(mime)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mimeTypeForName",
          "args": [
            "mime"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "matches.sort",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mimeTypeForFileName",
          "args": [
            "fileName"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QList<QMimeType> QMimeDatabase::mimeTypesForFileName(const QString &fileName) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      QStringList matches = d->mimeTypeForFileName(fileName);\n      QList<QMimeType> mimes;\n      matches.sort(); // Make it deterministic\n      foreach (const QString &mime, matches)\n          mimes.append(d->mimeTypeForName(mime));\n      return mimes;\n  }\n}"
  },
  {
    "function_name": "mimeTypeForFile",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "397-417",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForFile(const QString &fileName, MatchMode mode) const\n{\n    if (mode == MatchExtension) {\n        QMutexLocker locker(&d->mutex);\n        QStringList matches = d->mimeTypeForFileName(fileName);\n        const int matchCount = matches.count();\n        if (matchCount == 0) {\n            return d->mimeTypeForName(d->defaultMimeType());\n        } else if (matchCount == 1) {\n            return d->mimeTypeForName(matches.first());\n        } else {\n            // We have to pick one.\n            matches.sort(); // Make it deterministic\n            return d->mimeTypeForName(matches.first());\n        }\n    } else {\n        // Implemented as a wrapper around mimeTypeForFile(QFileInfo), so no mutex.\n        QFileInfo fileInfo(fileName);\n        return mimeTypeForFile(fileInfo);\n    }\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimeTypeForFile",
          "args": [
            "fileInfo"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mimeTypeForName",
          "args": [
            "matches.first()"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "matches.first",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "matches.sort",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->defaultMimeType",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "defaultMimeType",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase_p.h",
          "lines": "70-70",
          "snippet": "inline QString defaultMimeType() const { return m_defaultMimeType; }",
          "includes": [
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\"",
            "#include <qmutex.h>",
            "#include <qhash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeglobpattern_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n#include <qmutex.h>\n#include <qhash.h>\n\nQMimeDatabasePrivate {\n  inline QString defaultMimeType() const { return m_defaultMimeType; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "matches.count",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->mimeTypeForFileName",
          "args": [
            "fileName"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForFile(const QString &fileName, MatchMode mode) const\n  {\n      if (mode == MatchExtension) {\n          QMutexLocker locker(&d->mutex);\n          QStringList matches = d->mimeTypeForFileName(fileName);\n          const int matchCount = matches.count();\n          if (matchCount == 0) {\n              return d->mimeTypeForName(d->defaultMimeType());\n          } else if (matchCount == 1) {\n              return d->mimeTypeForName(matches.first());\n          } else {\n              // We have to pick one.\n              matches.sort(); // Make it deterministic\n              return d->mimeTypeForName(matches.first());\n          }\n      } else {\n          // Implemented as a wrapper around mimeTypeForFile(QFileInfo), so no mutex.\n          QFileInfo fileInfo(fileName);\n          return mimeTypeForFile(fileInfo);\n      }\n  }\n}"
  },
  {
    "function_name": "mimeTypeForFile",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "346-390",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForFile(const QFileInfo &fileInfo, MatchMode mode) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    if (fileInfo.isDir())\n        return d->mimeTypeForName(QLatin1String(\"inode/directory\"));\n\n    QFile file(fileInfo.absoluteFilePath());\n\n#ifdef Q_OS_UNIX\n    // Cannot access statBuf.st_mode from the filesystem engine, so we have to stat again.\n    const QByteArray nativeFilePath = QFile::encodeName(file.fileName());\n    QT_STATBUF statBuffer;\n    if (QT_LSTAT(nativeFilePath.constData(), &statBuffer) == 0) {\n        if (S_ISCHR(statBuffer.st_mode))\n            return d->mimeTypeForName(QLatin1String(\"inode/chardevice\"));\n        if (S_ISBLK(statBuffer.st_mode))\n            return d->mimeTypeForName(QLatin1String(\"inode/blockdevice\"));\n        if (S_ISFIFO(statBuffer.st_mode))\n            return d->mimeTypeForName(QLatin1String(\"inode/fifo\"));\n        if (S_ISSOCK(statBuffer.st_mode))\n            return d->mimeTypeForName(QLatin1String(\"inode/socket\"));\n    }\n#endif\n\n    int priority = 0;\n    switch (mode) {\n    case MatchDefault:\n        file.open(QIODevice::ReadOnly); // isOpen() will be tested by method below\n        return d->mimeTypeForFileNameAndData(fileInfo.absoluteFilePath(), &file, &priority);\n    case MatchExtension:\n        locker.unlock();\n        return mimeTypeForFile(fileInfo.absoluteFilePath(), mode);\n    case MatchContent:\n        if (file.open(QIODevice::ReadOnly)) {\n            locker.unlock();\n            return mimeTypeForData(&file);\n        } else {\n            return d->mimeTypeForName(d->defaultMimeType());\n        }\n    default:\n        Q_ASSERT(false);\n    }\n    return d->mimeTypeForName(d->defaultMimeType());\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->mimeTypeForName",
          "args": [
            "d->defaultMimeType()"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->defaultMimeType",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "defaultMimeType",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase_p.h",
          "lines": "70-70",
          "snippet": "inline QString defaultMimeType() const { return m_defaultMimeType; }",
          "includes": [
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\"",
            "#include <qmutex.h>",
            "#include <qhash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeglobpattern_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n#include <qmutex.h>\n#include <qhash.h>\n\nQMimeDatabasePrivate {\n  inline QString defaultMimeType() const { return m_defaultMimeType; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "false"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeForData",
          "args": [
            "&file"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForData",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "478-494",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForData(QIODevice *device) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    int accuracy = 0;\n    const bool openedByUs = !device->isOpen() && device->open(QIODevice::ReadOnly);\n    if (device->isOpen()) {\n        // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n        // This is much faster than seeking back and forth into QIODevice.\n        const QByteArray data = device->peek(16384);\n        const QMimeType result = d->findByData(data, &accuracy);\n        if (openedByUs)\n            device->close();\n        return result;\n    }\n    return d->mimeTypeForName(d->defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForData(QIODevice *device) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      int accuracy = 0;\n      const bool openedByUs = !device->isOpen() && device->open(QIODevice::ReadOnly);\n      if (device->isOpen()) {\n          // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n          // This is much faster than seeking back and forth into QIODevice.\n          const QByteArray data = device->peek(16384);\n          const QMimeType result = d->findByData(data, &accuracy);\n          if (openedByUs)\n              device->close();\n          return result;\n      }\n      return d->mimeTypeForName(d->defaultMimeType());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "locker.unlock",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeForFile",
          "args": [
            "fileInfo.absoluteFilePath()",
            "mode"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForFileNameAndData",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "571-577",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForFileNameAndData(const QString &fileName, const QByteArray &data) const\n{\n    QBuffer buffer(const_cast<QByteArray *>(&data));\n    buffer.open(QIODevice::ReadOnly);\n    int accuracy = 0;\n    return d->mimeTypeForFileNameAndData(fileName, &buffer, &accuracy);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForFileNameAndData(const QString &fileName, const QByteArray &data) const\n  {\n      QBuffer buffer(const_cast<QByteArray *>(&data));\n      buffer.open(QIODevice::ReadOnly);\n      int accuracy = 0;\n      return d->mimeTypeForFileNameAndData(fileName, &buffer, &accuracy);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileInfo.absoluteFilePath",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locker.unlock",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->mimeTypeForFileNameAndData",
          "args": [
            "fileInfo.absoluteFilePath()",
            "&file",
            "&priority"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForFileNameAndData",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "160-216",
          "snippet": "QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n{\n    // First, glob patterns are evaluated. If there is a match with max weight,\n    // this one is selected and we are done. Otherwise, the file contents are\n    // evaluated and the match with the highest value (either a magic priority or\n    // a glob pattern weight) is selected. Matching starts from max level (most\n    // specific) in both cases, even when there is already a suffix matching candidate.\n    *accuracyPtr = 0;\n\n    // Pass 1) Try to match on the file name\n    QStringList candidatesByName = mimeTypeForFileName(fileName);\n    if (candidatesByName.count() == 1) {\n        *accuracyPtr = 100;\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n        candidatesByName.clear();\n    }\n\n    // Extension is unknown, or matches multiple mimetypes.\n    // Pass 2) Match on content, if we can read the data\n    if (device->isOpen()) {\n\n        // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n        // This is much faster than seeking back and forth into QIODevice.\n        const QByteArray data = device->peek(16384);\n\n        int magicAccuracy = 0;\n        QMimeType candidateByData(findByData(data, &magicAccuracy));\n\n        // Disambiguate conflicting extensions (if magic matching found something)\n        if (candidateByData.isValid() && magicAccuracy > 0) {\n            // \"for glob_match in glob_matches:\"\n            // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n            const QString sniffedMime = candidateByData.name();\n            foreach (const QString &m, candidatesByName) {\n                if (inherits(m, sniffedMime)) {\n                    // We have magic + pattern pointing to this, so it's a pretty good match\n                    *accuracyPtr = 100;\n                    return mimeTypeForName(m);\n                }\n            }\n            *accuracyPtr = magicAccuracy;\n            return candidateByData;\n        }\n    }\n\n    if (candidatesByName.count() > 1) {\n        *accuracyPtr = 20;\n        candidatesByName.sort(); // to make it deterministic\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n  {\n      // First, glob patterns are evaluated. If there is a match with max weight,\n      // this one is selected and we are done. Otherwise, the file contents are\n      // evaluated and the match with the highest value (either a magic priority or\n      // a glob pattern weight) is selected. Matching starts from max level (most\n      // specific) in both cases, even when there is already a suffix matching candidate.\n      *accuracyPtr = 0;\n  \n      // Pass 1) Try to match on the file name\n      QStringList candidatesByName = mimeTypeForFileName(fileName);\n      if (candidatesByName.count() == 1) {\n          *accuracyPtr = 100;\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n          candidatesByName.clear();\n      }\n  \n      // Extension is unknown, or matches multiple mimetypes.\n      // Pass 2) Match on content, if we can read the data\n      if (device->isOpen()) {\n  \n          // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n          // This is much faster than seeking back and forth into QIODevice.\n          const QByteArray data = device->peek(16384);\n  \n          int magicAccuracy = 0;\n          QMimeType candidateByData(findByData(data, &magicAccuracy));\n  \n          // Disambiguate conflicting extensions (if magic matching found something)\n          if (candidateByData.isValid() && magicAccuracy > 0) {\n              // \"for glob_match in glob_matches:\"\n              // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n              const QString sniffedMime = candidateByData.name();\n              foreach (const QString &m, candidatesByName) {\n                  if (inherits(m, sniffedMime)) {\n                      // We have magic + pattern pointing to this, so it's a pretty good match\n                      *accuracyPtr = 100;\n                      return mimeTypeForName(m);\n                  }\n              }\n              *accuracyPtr = magicAccuracy;\n              return candidateByData;\n          }\n      }\n  \n      if (candidatesByName.count() > 1) {\n          *accuracyPtr = 20;\n          candidatesByName.sort(); // to make it deterministic\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileInfo.absoluteFilePath",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode/socket\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "statBuffer.st_mode"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode/fifo\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "statBuffer.st_mode"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode/blockdevice\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "statBuffer.st_mode"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode/chardevice\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "statBuffer.st_mode"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QT_LSTAT",
          "args": [
            "nativeFilePath.constData()",
            "&statBuffer"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nativeFilePath.constData",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFile::encodeName",
          "args": [
            "file.fileName()"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.fileName",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileInfo.absoluteFilePath",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode/directory\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileInfo.isDir",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForFile(const QFileInfo &fileInfo, MatchMode mode) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      if (fileInfo.isDir())\n          return d->mimeTypeForName(QLatin1String(\"inode/directory\"));\n  \n      QFile file(fileInfo.absoluteFilePath());\n  \n  #ifdef Q_OS_UNIX\n      // Cannot access statBuf.st_mode from the filesystem engine, so we have to stat again.\n      const QByteArray nativeFilePath = QFile::encodeName(file.fileName());\n      QT_STATBUF statBuffer;\n      if (QT_LSTAT(nativeFilePath.constData(), &statBuffer) == 0) {\n          if (S_ISCHR(statBuffer.st_mode))\n              return d->mimeTypeForName(QLatin1String(\"inode/chardevice\"));\n          if (S_ISBLK(statBuffer.st_mode))\n              return d->mimeTypeForName(QLatin1String(\"inode/blockdevice\"));\n          if (S_ISFIFO(statBuffer.st_mode))\n              return d->mimeTypeForName(QLatin1String(\"inode/fifo\"));\n          if (S_ISSOCK(statBuffer.st_mode))\n              return d->mimeTypeForName(QLatin1String(\"inode/socket\"));\n      }\n  #endif\n  \n      int priority = 0;\n      switch (mode) {\n      case MatchDefault:\n          file.open(QIODevice::ReadOnly); // isOpen() will be tested by method below\n          return d->mimeTypeForFileNameAndData(fileInfo.absoluteFilePath(), &file, &priority);\n      case MatchExtension:\n          locker.unlock();\n          return mimeTypeForFile(fileInfo.absoluteFilePath(), mode);\n      case MatchContent:\n          if (file.open(QIODevice::ReadOnly)) {\n              locker.unlock();\n              return mimeTypeForData(&file);\n          } else {\n              return d->mimeTypeForName(d->defaultMimeType());\n          }\n      default:\n          Q_ASSERT(false);\n      }\n      return d->mimeTypeForName(d->defaultMimeType());\n  }\n}"
  },
  {
    "function_name": "mimeTypeForName",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "311-316",
    "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->mimeTypeForName",
          "args": [
            "nameOrAlias"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
  },
  {
    "function_name": "~QMimeDatabase",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "302-305",
    "snippet": "QMimeDatabase::~QMimeDatabase()\n{\n    d = 0;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeDatabase::~QMimeDatabase()\n  {\n      d = 0;\n  }\n}"
  },
  {
    "function_name": "QMimeDatabase",
    "container": "QMimeDatabase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "293-296",
    "snippet": "QMimeDatabase::QMimeDatabase() :\n        d(staticQMimeDatabase())\n{\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [
      "QT_BEGIN_NAMESPACE\n\nQ_GLOBAL_STATIC(QMimeDatabasePrivate, staticQMimeDatabase)"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "staticQMimeDatabase",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQT_BEGIN_NAMESPACE\n\nQ_GLOBAL_STATIC(QMimeDatabasePrivate, staticQMimeDatabase);\n\nQMimeDatabase {\n  QMimeDatabase::QMimeDatabase() :\n          d(staticQMimeDatabase())\n  {\n  }\n}"
  },
  {
    "function_name": "inherits",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "223-237",
    "snippet": "bool QMimeDatabasePrivate::inherits(const QString &mime, const QString &parent)\n{\n    const QString resolvedParent = provider()->resolveAlias(parent);\n    //Q_ASSERT(provider()->resolveAlias(mime) == mime);\n    QStack<QString> toCheck;\n    toCheck.push(mime);\n    while (!toCheck.isEmpty()) {\n        const QString current = toCheck.pop();\n        if (current == resolvedParent)\n            return true;\n        foreach (const QString &par, provider()->parents(current))\n            toCheck.push(par);\n    }\n    return false;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "toCheck.push",
          "args": [
            "par"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toCheck.pop",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toCheck.isEmpty",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toCheck.push",
          "args": [
            "mime"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [
            "parent"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  bool QMimeDatabasePrivate::inherits(const QString &mime, const QString &parent)\n  {\n      const QString resolvedParent = provider()->resolveAlias(parent);\n      //Q_ASSERT(provider()->resolveAlias(mime) == mime);\n      QStack<QString> toCheck;\n      toCheck.push(mime);\n      while (!toCheck.isEmpty()) {\n          const QString current = toCheck.pop();\n          if (current == resolvedParent)\n              return true;\n          foreach (const QString &par, provider()->parents(current))\n              toCheck.push(par);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "allMimeTypes",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "218-221",
    "snippet": "QList<QMimeType> QMimeDatabasePrivate::allMimeTypes()\n{\n    return provider()->allMimeTypes();\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QList<QMimeType> QMimeDatabasePrivate::allMimeTypes()\n  {\n      return provider()->allMimeTypes();\n  }\n}"
  },
  {
    "function_name": "mimeTypeForFileNameAndData",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "160-216",
    "snippet": "QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n{\n    // First, glob patterns are evaluated. If there is a match with max weight,\n    // this one is selected and we are done. Otherwise, the file contents are\n    // evaluated and the match with the highest value (either a magic priority or\n    // a glob pattern weight) is selected. Matching starts from max level (most\n    // specific) in both cases, even when there is already a suffix matching candidate.\n    *accuracyPtr = 0;\n\n    // Pass 1) Try to match on the file name\n    QStringList candidatesByName = mimeTypeForFileName(fileName);\n    if (candidatesByName.count() == 1) {\n        *accuracyPtr = 100;\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n        candidatesByName.clear();\n    }\n\n    // Extension is unknown, or matches multiple mimetypes.\n    // Pass 2) Match on content, if we can read the data\n    if (device->isOpen()) {\n\n        // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n        // This is much faster than seeking back and forth into QIODevice.\n        const QByteArray data = device->peek(16384);\n\n        int magicAccuracy = 0;\n        QMimeType candidateByData(findByData(data, &magicAccuracy));\n\n        // Disambiguate conflicting extensions (if magic matching found something)\n        if (candidateByData.isValid() && magicAccuracy > 0) {\n            // \"for glob_match in glob_matches:\"\n            // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n            const QString sniffedMime = candidateByData.name();\n            foreach (const QString &m, candidatesByName) {\n                if (inherits(m, sniffedMime)) {\n                    // We have magic + pattern pointing to this, so it's a pretty good match\n                    *accuracyPtr = 100;\n                    return mimeTypeForName(m);\n                }\n            }\n            *accuracyPtr = magicAccuracy;\n            return candidateByData;\n        }\n    }\n\n    if (candidatesByName.count() > 1) {\n        *accuracyPtr = 20;\n        candidatesByName.sort(); // to make it deterministic\n        const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n        if (mime.isValid())\n            return mime;\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimeTypeForName",
          "args": [
            "defaultMimeType()"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "defaultMimeType",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "defaultMimeType",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase_p.h",
          "lines": "70-70",
          "snippet": "inline QString defaultMimeType() const { return m_defaultMimeType; }",
          "includes": [
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\"",
            "#include <qmutex.h>",
            "#include <qhash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeglobpattern_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n#include <qmutex.h>\n#include <qhash.h>\n\nQMimeDatabasePrivate {\n  inline QString defaultMimeType() const { return m_defaultMimeType; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mime.isValid",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "candidatesByName.at",
          "args": [
            "0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "candidatesByName.sort",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "candidatesByName.count",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inherits",
          "args": [
            "m",
            "sniffedMime"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "inherits",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "223-237",
          "snippet": "bool QMimeDatabasePrivate::inherits(const QString &mime, const QString &parent)\n{\n    const QString resolvedParent = provider()->resolveAlias(parent);\n    //Q_ASSERT(provider()->resolveAlias(mime) == mime);\n    QStack<QString> toCheck;\n    toCheck.push(mime);\n    while (!toCheck.isEmpty()) {\n        const QString current = toCheck.pop();\n        if (current == resolvedParent)\n            return true;\n        foreach (const QString &par, provider()->parents(current))\n            toCheck.push(par);\n    }\n    return false;\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  bool QMimeDatabasePrivate::inherits(const QString &mime, const QString &parent)\n  {\n      const QString resolvedParent = provider()->resolveAlias(parent);\n      //Q_ASSERT(provider()->resolveAlias(mime) == mime);\n      QStack<QString> toCheck;\n      toCheck.push(mime);\n      while (!toCheck.isEmpty()) {\n          const QString current = toCheck.pop();\n          if (current == resolvedParent)\n              return true;\n          foreach (const QString &par, provider()->parents(current))\n              toCheck.push(par);\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "candidateByData.name",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "208-211",
          "snippet": "QString QMimeType::name() const\n{\n    return d->name;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::name() const\n  {\n      return d->name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "findByData",
          "args": [
            "data",
            "&magicAccuracy"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "findByData",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "139-158",
          "snippet": "QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n{\n    if (data.isEmpty()) {\n        *accuracyPtr = 100;\n        return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n    }\n\n    *accuracyPtr = 0;\n    QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n\n    if (candidate.isValid())\n        return candidate;\n\n    if (isTextFile(data)) {\n        *accuracyPtr = 5;\n        return mimeTypeForName(QLatin1String(\"text/plain\"));\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n  {\n      if (data.isEmpty()) {\n          *accuracyPtr = 100;\n          return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n      }\n  \n      *accuracyPtr = 0;\n      QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n  \n      if (candidate.isValid())\n          return candidate;\n  \n      if (isTextFile(data)) {\n          *accuracyPtr = 5;\n          return mimeTypeForName(QLatin1String(\"text/plain\"));\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "device->peek",
          "args": [
            "16384"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device->isOpen",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "candidatesByName.clear",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "candidatesByName.at",
          "args": [
            "0"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeForFileName",
          "args": [
            "fileName"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device, int *accuracyPtr)\n  {\n      // First, glob patterns are evaluated. If there is a match with max weight,\n      // this one is selected and we are done. Otherwise, the file contents are\n      // evaluated and the match with the highest value (either a magic priority or\n      // a glob pattern weight) is selected. Matching starts from max level (most\n      // specific) in both cases, even when there is already a suffix matching candidate.\n      *accuracyPtr = 0;\n  \n      // Pass 1) Try to match on the file name\n      QStringList candidatesByName = mimeTypeForFileName(fileName);\n      if (candidatesByName.count() == 1) {\n          *accuracyPtr = 100;\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n          candidatesByName.clear();\n      }\n  \n      // Extension is unknown, or matches multiple mimetypes.\n      // Pass 2) Match on content, if we can read the data\n      if (device->isOpen()) {\n  \n          // Read 16K in one go (QIODEVICE_BUFFERSIZE in qiodevice_p.h).\n          // This is much faster than seeking back and forth into QIODevice.\n          const QByteArray data = device->peek(16384);\n  \n          int magicAccuracy = 0;\n          QMimeType candidateByData(findByData(data, &magicAccuracy));\n  \n          // Disambiguate conflicting extensions (if magic matching found something)\n          if (candidateByData.isValid() && magicAccuracy > 0) {\n              // \"for glob_match in glob_matches:\"\n              // \"if glob_match is subclass or equal to sniffed_type, use glob_match\"\n              const QString sniffedMime = candidateByData.name();\n              foreach (const QString &m, candidatesByName) {\n                  if (inherits(m, sniffedMime)) {\n                      // We have magic + pattern pointing to this, so it's a pretty good match\n                      *accuracyPtr = 100;\n                      return mimeTypeForName(m);\n                  }\n              }\n              *accuracyPtr = magicAccuracy;\n              return candidateByData;\n          }\n      }\n  \n      if (candidatesByName.count() > 1) {\n          *accuracyPtr = 20;\n          candidatesByName.sort(); // to make it deterministic\n          const QMimeType mime = mimeTypeForName(candidatesByName.at(0));\n          if (mime.isValid())\n              return mime;\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
  },
  {
    "function_name": "findByData",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "139-158",
    "snippet": "QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n{\n    if (data.isEmpty()) {\n        *accuracyPtr = 100;\n        return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n    }\n\n    *accuracyPtr = 0;\n    QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n\n    if (candidate.isValid())\n        return candidate;\n\n    if (isTextFile(data)) {\n        *accuracyPtr = 5;\n        return mimeTypeForName(QLatin1String(\"text/plain\"));\n    }\n\n    return mimeTypeForName(defaultMimeType());\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimeTypeForName",
          "args": [
            "defaultMimeType()"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "311-316",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n{\n    QMutexLocker locker(&d->mutex);\n\n    return d->mimeTypeForName(nameOrAlias);\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForName(const QString &nameOrAlias) const\n  {\n      QMutexLocker locker(&d->mutex);\n  \n      return d->mimeTypeForName(nameOrAlias);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "defaultMimeType",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "defaultMimeType",
          "container": "QMimeDatabasePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase_p.h",
          "lines": "70-70",
          "snippet": "inline QString defaultMimeType() const { return m_defaultMimeType; }",
          "includes": [
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\"",
            "#include <qmutex.h>",
            "#include <qhash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeglobpattern_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n#include <qmutex.h>\n#include <qhash.h>\n\nQMimeDatabasePrivate {\n  inline QString defaultMimeType() const { return m_defaultMimeType; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"text/plain\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isTextFile",
          "args": [
            "data"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "isTextFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "120-137",
          "snippet": "static inline bool isTextFile(const QByteArray &data)\n{\n    // UTF16 byte order marks\n    static const char bigEndianBOM[] = \"\\xFE\\xFF\";\n    static const char littleEndianBOM[] = \"\\xFF\\xFE\";\n    if (data.startsWith(bigEndianBOM) || data.startsWith(littleEndianBOM))\n        return true;\n\n    // Check the first 32 bytes (see shared-mime spec)\n    const char *p = data.constData();\n    const char *e = p + qMin(32, data.size());\n    for ( ; p < e; ++p) {\n        if ((unsigned char)(*p) < 32 && *p != 9 && *p !=10 && *p != 13)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nstatic inline bool isTextFile(const QByteArray &data)\n{\n    // UTF16 byte order marks\n    static const char bigEndianBOM[] = \"\\xFE\\xFF\";\n    static const char littleEndianBOM[] = \"\\xFF\\xFE\";\n    if (data.startsWith(bigEndianBOM) || data.startsWith(littleEndianBOM))\n        return true;\n\n    // Check the first 32 bytes (see shared-mime spec)\n    const char *p = data.constData();\n    const char *e = p + qMin(32, data.size());\n    for ( ; p < e; ++p) {\n        if ((unsigned char)(*p) < 32 && *p != 9 && *p !=10 && *p != 13)\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "candidate.isValid",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [
            "data",
            "accuracyPtr"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"application/x-zerosize\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.isEmpty",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::findByData(const QByteArray &data, int *accuracyPtr)\n  {\n      if (data.isEmpty()) {\n          *accuracyPtr = 100;\n          return mimeTypeForName(QLatin1String(\"application/x-zerosize\"));\n      }\n  \n      *accuracyPtr = 0;\n      QMimeType candidate = provider()->findByMagic(data, accuracyPtr);\n  \n      if (candidate.isValid())\n          return candidate;\n  \n      if (isTextFile(data)) {\n          *accuracyPtr = 5;\n          return mimeTypeForName(QLatin1String(\"text/plain\"));\n      }\n  \n      return mimeTypeForName(defaultMimeType());\n  }\n}"
  },
  {
    "function_name": "isTextFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "120-137",
    "snippet": "static inline bool isTextFile(const QByteArray &data)\n{\n    // UTF16 byte order marks\n    static const char bigEndianBOM[] = \"\\xFE\\xFF\";\n    static const char littleEndianBOM[] = \"\\xFF\\xFE\";\n    if (data.startsWith(bigEndianBOM) || data.startsWith(littleEndianBOM))\n        return true;\n\n    // Check the first 32 bytes (see shared-mime spec)\n    const char *p = data.constData();\n    const char *e = p + qMin(32, data.size());\n    for ( ; p < e; ++p) {\n        if ((unsigned char)(*p) < 32 && *p != 9 && *p !=10 && *p != 13)\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qMin",
          "args": [
            "32",
            "data.size()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.constData",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.startsWith",
          "args": [
            "littleEndianBOM"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.startsWith",
          "args": [
            "bigEndianBOM"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nstatic inline bool isTextFile(const QByteArray &data)\n{\n    // UTF16 byte order marks\n    static const char bigEndianBOM[] = \"\\xFE\\xFF\";\n    static const char littleEndianBOM[] = \"\\xFF\\xFE\";\n    if (data.startsWith(bigEndianBOM) || data.startsWith(littleEndianBOM))\n        return true;\n\n    // Check the first 32 bytes (see shared-mime spec)\n    const char *p = data.constData();\n    const char *e = p + qMin(32, data.size());\n    for ( ; p < e; ++p) {\n        if ((unsigned char)(*p) < 32 && *p != 9 && *p !=10 && *p != 13)\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "mimeTypeForFileName",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "111-118",
    "snippet": "QStringList QMimeDatabasePrivate::mimeTypeForFileName(const QString &fileName, QString *foundSuffix)\n{\n    if (fileName.endsWith(QLatin1Char('/')))\n        return QStringList() << QLatin1String(\"inode/directory\");\n\n    const QStringList matchingMimeTypes = provider()->findByFileName(QFileInfo(fileName).fileName(), foundSuffix);\n    return matchingMimeTypes;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "provider",
          "args": [
            "QFileInfo(fileName).fileName()",
            "foundSuffix"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFileInfo",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFileInfo",
          "args": [
            "fileName"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode/directory\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringList",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileName.endsWith",
          "args": [
            "QLatin1Char('/')"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'/'"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QStringList QMimeDatabasePrivate::mimeTypeForFileName(const QString &fileName, QString *foundSuffix)\n  {\n      if (fileName.endsWith(QLatin1Char('/')))\n          return QStringList() << QLatin1String(\"inode/directory\");\n  \n      const QStringList matchingMimeTypes = provider()->findByFileName(QFileInfo(fileName).fileName(), foundSuffix);\n      return matchingMimeTypes;\n  }\n}"
  },
  {
    "function_name": "mimeTypeForName",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "106-109",
    "snippet": "QMimeType QMimeDatabasePrivate::mimeTypeForName(const QString &nameOrAlias)\n{\n    return provider()->mimeTypeForName(provider()->resolveAlias(nameOrAlias));\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "provider",
          "args": [
            "provider()->resolveAlias(nameOrAlias)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [
            "nameOrAlias"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "provider",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeType QMimeDatabasePrivate::mimeTypeForName(const QString &nameOrAlias)\n  {\n      return provider()->mimeTypeForName(provider()->resolveAlias(nameOrAlias));\n  }\n}"
  },
  {
    "function_name": "setProvider",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "96-100",
    "snippet": "void QMimeDatabasePrivate::setProvider(QMimeProviderBase *theProvider)\n{\n    delete m_provider;\n    m_provider = theProvider;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  void QMimeDatabasePrivate::setProvider(QMimeProviderBase *theProvider)\n  {\n      delete m_provider;\n      m_provider = theProvider;\n  }\n}"
  },
  {
    "function_name": "~QMimeDatabasePrivate",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "76-80",
    "snippet": "QMimeDatabasePrivate::~QMimeDatabasePrivate()\n{\n    delete m_provider;\n    m_provider = 0;\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeDatabasePrivate::~QMimeDatabasePrivate()\n  {\n      delete m_provider;\n      m_provider = 0;\n  }\n}"
  },
  {
    "function_name": "QMimeDatabasePrivate",
    "container": "QMimeDatabasePrivate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
    "lines": "71-74",
    "snippet": "QMimeDatabasePrivate::QMimeDatabasePrivate()\n    : m_provider(0), m_defaultMimeType(QLatin1String(\"application/octet-stream\"))\n{\n}",
    "includes": [
      "#include <functional>",
      "#include <algorithm>",
      "#include <QDebug>",
      "#include <QStack>",
      "#include <QUrl>",
      "#include <QBuffer>",
      "#include <QSet>",
      "#include <QFileInfo>",
      "#include <QFile>",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimeprovider_p.h\"",
      "#include \"qmimedatabase_p.h\"",
      "#include \"qmimedatabase.h\"",
      "#include <qplatformdefs.h> // always first"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"application/octet-stream\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabasePrivate {\n  QMimeDatabasePrivate::QMimeDatabasePrivate()\n      : m_provider(0), m_defaultMimeType(QLatin1String(\"application/octet-stream\"))\n  {\n  }\n}"
  }
]