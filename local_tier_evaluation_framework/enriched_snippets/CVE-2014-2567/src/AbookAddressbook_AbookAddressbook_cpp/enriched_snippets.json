[
  {
    "function_name": "prettyNamesForAddress(c",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "296-305",
    "snippet": "tringList AbookAddressbook::prettyNamesForAddress(const QString &mail) const\n{\n    QStringList res;\n    for (int i = 0; i < m_contacts->rowCount(); ++i) {\n        QStandardItem *item = m_contacts->item(i);\n        if (QString::compare(item->data(Mail).toString(), mail, Qt::CaseInsensitive) == 0)\n            res << item->data(Name).toString();\n    }\n    return res;\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "em->data",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "me)."
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::compare(i",
          "args": [
            "em->data(Mail).toString(),",
            "il,",
            "::CaseInsensitive)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "il)."
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->item",
          "args": [
            ";"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->rowCount",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "133-153",
          "snippet": "void ModelTest::rowCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    int rows = model->rowCount(topIndex);\n    Q_ASSERT(rows >= 0);\n    if (rows > 0)\n        Q_ASSERT(model->hasChildren(topIndex) == true);\n\n    QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n    if (secondLevelIndex.isValid()) { // not the top level\n        // check a row count where parent is valid\n        rows = model->rowCount(secondLevelIndex);\n        Q_ASSERT(rows >= 0);\n        if (rows > 0)\n            Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n    }\n\n    // The models rowCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::rowCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      int rows = model->rowCount(topIndex);\n      Q_ASSERT(rows >= 0);\n      if (rows > 0)\n          Q_ASSERT(model->hasChildren(topIndex) == true);\n  \n      QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n      if (secondLevelIndex.isValid()) { // not the top level\n          // check a row count where parent is valid\n          rows = model->rowCount(secondLevelIndex);\n          Q_ASSERT(rows >= 0);\n          if (rows > 0)\n              Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n      }\n  \n      // The models rowCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  tringList AbookAddressbook::prettyNamesForAddress(const QString &mail) const\n  {\n      QStringList res;\n      for (int i = 0; i < m_contacts->rowCount(); ++i) {\n          QStandardItem *item = m_contacts->item(i);\n          if (QString::compare(item->data(Mail).toString(), mail, Qt::CaseInsensitive) == 0)\n              res << item->data(Name).toString();\n      }\n      return res;\n  }\n}"
  },
  {
    "function_name": "formatAddress(c",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "288-294",
    "snippet": "tring AbookAddressbook::formatAddress(const QString &contactName, const QString &mail)\n{\n    if (contactName.isEmpty() || contactName == mail)\n        return mail;\n    else\n        return contactName % QLatin1String(\" <\") % mail % QLatin1String(\">\");\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "\");"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "<\")"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntactName.isEmpty",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  tring AbookAddressbook::formatAddress(const QString &contactName, const QString &mail)\n  {\n      if (contactName.isEmpty() || contactName == mail)\n          return mail;\n      else\n          return contactName % QLatin1String(\" <\") % mail % QLatin1String(\">\");\n  }\n}"
  },
  {
    "function_name": "complete(c",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "248-286",
    "snippet": "tringList AbookAddressbook::complete(const QString &string, const QStringList &ignores, int max) const\n{\n    if (string.isEmpty())\n        return QStringList();\n    QStringList list;\n    // In e-mail addresses, dot, dash, _ and @ shall be treated as delimiters\n    QRegExp mailMatch = QRegExp(QString::fromUtf8(\"[\\\\.\\\\-_@]%1\").arg(QRegExp::escape(string)), Qt::CaseInsensitive);\n    // In human readable names, match on word boundaries\n    QRegExp nameMatch = QRegExp(QString::fromUtf8(\"\\\\b%1\").arg(QRegExp::escape(string)), Qt::CaseInsensitive);\n    // These REs are still not perfect, they won't match on e.g. \".net\" or \"-project\", but screw these I say\n    for (int i = 0; i < m_contacts->rowCount(); ++i) {\n        QStandardItem *item = m_contacts->item(i);\n        QString contactName = item->data(Name).toString();\n        // several mail addresses per contact are stored newline delimited\n        QStringList contactMails(item->data(Mail).toString().split(QLatin1Char('\\n'), QString::SkipEmptyParts));\n        if (contactName.contains(nameMatch)) {\n            Q_FOREACH (const QString &mail, contactMails) {\n                if (ignore(mail, ignores))\n                    continue;\n                list << formatAddress(contactName, mail);\n                if (list.count() == max)\n                    return list;\n            }\n            continue;\n        }\n        Q_FOREACH (const QString &mail, contactMails) {\n            if (mail.startsWith(string, Qt::CaseInsensitive) ||\n                    // don't match on the TLD\n                    mail.section(QLatin1Char('.'), 0, -2).contains(mailMatch)) {\n                if (ignore(mail, ignores))\n                    continue;\n                list << formatAddress(contactName, mail);\n                if (list.count() == max)\n                    return list;\n            }\n        }\n    }\n    return list;\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "st.count",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmatAddress(c",
          "args": [
            "ntactName,",
            "il);"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "formatAddress(c",
          "container": "ookAddressbook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
          "lines": "288-294",
          "snippet": "tring AbookAddressbook::formatAddress(const QString &contactName, const QString &mail)\n{\n    if (contactName.isEmpty() || contactName == mail)\n        return mail;\n    else\n        return contactName % QLatin1String(\" <\") % mail % QLatin1String(\">\");\n}",
          "includes": [
            "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
            "nclude <QTimer>\n#i",
            "nclude <QStringBuilder>\n#i",
            "nclude <QStandardItemModel>\n#i",
            "nclude <QSettings>\n#i",
            "nclude <QFileSystemWatcher>\n#i",
            "nclude <QDir>\n#i",
            "nclude \"AbookAddressbook.h\"\n\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  tring AbookAddressbook::formatAddress(const QString &contactName, const QString &mail)\n  {\n      if (contactName.isEmpty() || contactName == mail)\n          return mail;\n      else\n          return contactName % QLatin1String(\" <\") % mail % QLatin1String(\">\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nore(m",
          "args": [
            "il,",
            "nores))"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "il.section",
          "args": [
            "ilMatch))"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "il.section",
          "args": [
            "atin1Char('.'),",
            ")."
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "'),"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "il.startsWith",
          "args": [
            "ring,",
            "::CaseInsensitive)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nore(m",
          "args": [
            "il,",
            "nores))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntactName.contains",
          "args": [
            "meMatch))"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "atin1Char('\\n'),",
            "tring::SkipEmptyParts))"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "n'),"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "il)."
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "me)."
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->item",
          "args": [
            ";"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->rowCount",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "133-153",
          "snippet": "void ModelTest::rowCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    int rows = model->rowCount(topIndex);\n    Q_ASSERT(rows >= 0);\n    if (rows > 0)\n        Q_ASSERT(model->hasChildren(topIndex) == true);\n\n    QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n    if (secondLevelIndex.isValid()) { // not the top level\n        // check a row count where parent is valid\n        rows = model->rowCount(secondLevelIndex);\n        Q_ASSERT(rows >= 0);\n        if (rows > 0)\n            Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n    }\n\n    // The models rowCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::rowCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      int rows = model->rowCount(topIndex);\n      Q_ASSERT(rows >= 0);\n      if (rows > 0)\n          Q_ASSERT(model->hasChildren(topIndex) == true);\n  \n      QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n      if (secondLevelIndex.isValid()) { // not the top level\n          // check a row count where parent is valid\n          rows = model->rowCount(secondLevelIndex);\n          Q_ASSERT(rows >= 0);\n          if (rows > 0)\n              Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n      }\n  \n      // The models rowCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "egExp(Q",
          "args": [
            "tring::fromUtf8(\"\\\\b%1\").arg(QRegExp::escape(string)),",
            "::CaseInsensitive);"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "egExp::escape(string)),"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egExp::escape(s",
          "args": [
            "ring))"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "\\b%1\")."
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egExp(Q",
          "args": [
            "tring::fromUtf8(\"[\\\\.\\\\-_@]%1\").arg(QRegExp::escape(string)),",
            "::CaseInsensitive);"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "egExp::escape(string)),"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egExp::escape(s",
          "args": [
            "ring))"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "\\\\.\\\\-_@]%1\")."
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tringList()",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring.isEmpty",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  tringList AbookAddressbook::complete(const QString &string, const QStringList &ignores, int max) const\n  {\n      if (string.isEmpty())\n          return QStringList();\n      QStringList list;\n      // In e-mail addresses, dot, dash, _ and @ shall be treated as delimiters\n      QRegExp mailMatch = QRegExp(QString::fromUtf8(\"[\\\\.\\\\-_@]%1\").arg(QRegExp::escape(string)), Qt::CaseInsensitive);\n      // In human readable names, match on word boundaries\n      QRegExp nameMatch = QRegExp(QString::fromUtf8(\"\\\\b%1\").arg(QRegExp::escape(string)), Qt::CaseInsensitive);\n      // These REs are still not perfect, they won't match on e.g. \".net\" or \"-project\", but screw these I say\n      for (int i = 0; i < m_contacts->rowCount(); ++i) {\n          QStandardItem *item = m_contacts->item(i);\n          QString contactName = item->data(Name).toString();\n          // several mail addresses per contact are stored newline delimited\n          QStringList contactMails(item->data(Mail).toString().split(QLatin1Char('\\n'), QString::SkipEmptyParts));\n          if (contactName.contains(nameMatch)) {\n              Q_FOREACH (const QString &mail, contactMails) {\n                  if (ignore(mail, ignores))\n                      continue;\n                  list << formatAddress(contactName, mail);\n                  if (list.count() == max)\n                      return list;\n              }\n              continue;\n          }\n          Q_FOREACH (const QString &mail, contactMails) {\n              if (mail.startsWith(string, Qt::CaseInsensitive) ||\n                      // don't match on the TLD\n                      mail.section(QLatin1Char('.'), 0, -2).contains(mailMatch)) {\n                  if (ignore(mail, ignores))\n                      continue;\n                  list << formatAddress(contactName, mail);\n                  if (list.count() == max)\n                      return list;\n              }\n          }\n      }\n      return list;\n  }\n}"
  },
  {
    "function_name": "nore(c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "239-246",
    "snippet": "atic inline bool ignore(const QString &string, const QStringList &ignores)\n{\n    Q_FOREACH (const QString &ignore, ignores) {\n        if (ignore.contains(string, Qt::CaseInsensitive))\n            return true;\n    }\n    return false;\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nore.contains",
          "args": [
            "ring,",
            "::CaseInsensitive))"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\natic inline bool ignore(const QString &string, const QStringList &ignores)\n{\n    Q_FOREACH (const QString &ignore, ignores) {\n        if (ignore.contains(string, Qt::CaseInsensitive))\n            return true;\n    }\n    return false;\n}"
  },
  {
    "function_name": "saveContacts()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "210-237",
    "snippet": "id AbookAddressbook::saveContacts()\n{\n    m_filesystemWatcher->blockSignals(true);\n    QSettings abook(QDir::homePath() + \"/.abook/addressbook\", QSettings::IniFormat);\n    abook.setIniCodec(\"UTF-8\");\n    abook.clear();\n    for (int i = 0; i < m_contacts->rowCount(); ++i) {\n        Common::SettingsCategoryGuard guard(&abook, QString::number(i));\n        QStandardItem *item = m_contacts->item(i);\n        for (QList<QPair<Type,QString> >::const_iterator   it = m_fields.constBegin(),\n                                            end = m_fields.constEnd(); it != end; ++it) {\n            if (it->first == Mail)\n                abook.setValue(\"email\", item->data(Mail).toString().split('\\n'));\n            else {\n                const QVariant v = item->data(it->first);\n                if (!v.toString().isEmpty())\n                    abook.setValue(it->second, v);\n            }\n        }\n        QMap<QString,QVariant> unknownKeys = item->data( UnknownKeys ).toMap();\n        for (QMap<QString,QVariant>::const_iterator it = unknownKeys.constBegin(),\n                                                    end = unknownKeys.constEnd(); it != end; ++it) {\n            abook.setValue(it.key(), it.value());\n        }\n    }\n    abook.sync();\n    m_filesystemWatcher->blockSignals(false);\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filesystemWatcher->blockSignals",
          "args": [
            "lse);"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.sync",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.setValue",
          "args": [
            ".key(),",
            ".value());"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".value",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".key",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "knownKeys.constEnd",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "knownKeys.constBegin",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "knownKeys )"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.setValue",
          "args": [
            "->second,",
            ";"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "->first);"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.setValue",
          "args": [
            "mail\",",
            "em->data(Mail).toString().split('\\n'));"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "n'))"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "il)."
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fields.constEnd",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fields.constBegin",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->item",
          "args": [
            ";"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::number(i",
          "args": [
            ")"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->rowCount",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "133-153",
          "snippet": "void ModelTest::rowCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    int rows = model->rowCount(topIndex);\n    Q_ASSERT(rows >= 0);\n    if (rows > 0)\n        Q_ASSERT(model->hasChildren(topIndex) == true);\n\n    QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n    if (secondLevelIndex.isValid()) { // not the top level\n        // check a row count where parent is valid\n        rows = model->rowCount(secondLevelIndex);\n        Q_ASSERT(rows >= 0);\n        if (rows > 0)\n            Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n    }\n\n    // The models rowCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::rowCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      int rows = model->rowCount(topIndex);\n      Q_ASSERT(rows >= 0);\n      if (rows > 0)\n          Q_ASSERT(model->hasChildren(topIndex) == true);\n  \n      QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n      if (secondLevelIndex.isValid()) { // not the top level\n          // check a row count where parent is valid\n          rows = model->rowCount(secondLevelIndex);\n          Q_ASSERT(rows >= 0);\n          if (rows > 0)\n              Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n      }\n  \n      // The models rowCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ook.clear",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ook.setIniCodec",
          "args": [
            "TF-8\");"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystemWatcher->blockSignals",
          "args": [
            "ue);"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::saveContacts()\n  {\n      m_filesystemWatcher->blockSignals(true);\n      QSettings abook(QDir::homePath() + \"/.abook/addressbook\", QSettings::IniFormat);\n      abook.setIniCodec(\"UTF-8\");\n      abook.clear();\n      for (int i = 0; i < m_contacts->rowCount(); ++i) {\n          Common::SettingsCategoryGuard guard(&abook, QString::number(i));\n          QStandardItem *item = m_contacts->item(i);\n          for (QList<QPair<Type,QString> >::const_iterator   it = m_fields.constBegin(),\n                                              end = m_fields.constEnd(); it != end; ++it) {\n              if (it->first == Mail)\n                  abook.setValue(\"email\", item->data(Mail).toString().split('\\n'));\n              else {\n                  const QVariant v = item->data(it->first);\n                  if (!v.toString().isEmpty())\n                      abook.setValue(it->second, v);\n              }\n          }\n          QMap<QString,QVariant> unknownKeys = item->data( UnknownKeys ).toMap();\n          for (QMap<QString,QVariant>::const_iterator it = unknownKeys.constBegin(),\n                                                      end = unknownKeys.constEnd(); it != end; ++it) {\n              abook.setValue(it.key(), it.value());\n          }\n      }\n      abook.sync();\n      m_filesystemWatcher->blockSignals(false);\n  }\n}"
  },
  {
    "function_name": "readAbook(b",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "138-208",
    "snippet": "id AbookAddressbook::readAbook(bool update)\n{\n//     QElapsedTimer profile;\n//     profile.start();\n    QSettings abook(QDir::homePath() + \"/.abook/addressbook\", QSettings::IniFormat);\n    abook.setIniCodec(\"UTF-8\");\n    QStringList contacts = abook.childGroups();\n    foreach (const QString &contact, contacts) {\n        Common::SettingsCategoryGuard guard(&abook, contact);\n        QStandardItem *item = 0;\n        QStringList mails;\n        if (update) {\n            QList<QStandardItem*> list = m_contacts->findItems(abook.value(\"name\").toString());\n            if (list.count() == 1)\n                item = list.at(0);\n            else if (list.count() > 1) {\n                mails = abook.value(\"email\", QString()).toStringList();\n                const QString mailString = mails.join(\"\\n\");\n                foreach (QStandardItem *it, list) {\n                    if (it->data(Mail).toString() == mailString) {\n                        item = it;\n                        break;\n                    }\n                }\n            }\n            if (item && item->data(Dirty).toBool()) {\n                continue;\n            }\n        }\n        bool add = !item;\n        if (add)\n            item = new QStandardItem;\n\n        QMap<QString,QVariant> unknownKeys;\n\n        foreach (const QString &key, abook.allKeys()) {\n            QList<QPair<Type,QString> >::const_iterator field = m_fields.constBegin();\n            while (field != m_fields.constEnd()) {\n                if (field->second == key)\n                    break;\n                ++field;\n            }\n            if (field == m_fields.constEnd())\n                unknownKeys.insert(key, abook.value(key));\n            else if (field->first == Mail) {\n                if (mails.isEmpty())\n                    mails = abook.value(field->second, QString()).toStringList(); // to fix the name field\n                item->setData( mails.join(\"\\n\"), Mail );\n            }\n            else\n                item->setData( abook.value(field->second, QString()), field->first );\n        }\n\n        // attempt to fix the name field\n        if (item->data(Name).toString().isEmpty()) {\n            if (!mails.isEmpty())\n                item->setData( mails.at(0), Name );\n        }\n        if (item->data(Name).toString().isEmpty()) {\n            delete item;\n            continue; // junk or format spec entry\n        }\n\n        item->setData( unknownKeys, UnknownKeys );\n\n        if (add)\n            m_contacts->appendRow( item );\n    }\n//     const qint64 elapsed = profile.elapsed();\n//     qDebug() << \"reading too\" << elapsed << \"ms\";\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "contacts->appendRow",
          "args": [
            "em )"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->setData",
          "args": [
            "knownKeys,",
            "knownKeys )"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "me)."
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->setData",
          "args": [
            "ils.at(0),",
            "me )"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ils.at",
          "args": [
            ","
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ils.isEmpty",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "me)."
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->setData",
          "args": [
            "ook.value(field->second, QString()),",
            "eld->first )"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.value",
          "args": [
            "eld->second,",
            "tring()),"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->setData",
          "args": [
            "ils.join(\"\\n\"),",
            "il )"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ils.join",
          "args": [
            "n\"),"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.value",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ook.value",
          "args": [
            "eld->second,",
            "tring())."
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ils.isEmpty",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "knownKeys.insert",
          "args": [
            "y,",
            "ook.value(key));"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.value",
          "args": [
            "y))"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fields.constEnd",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fields.constEnd",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fields.constBegin",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "em->data",
          "args": [
            "rty)."
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->data",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "debugIdentification(",
          "container": "etchMsgMetadataTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgMetadataTask.cpp",
          "lines": "90-98",
          "snippet": "String FetchMsgMetadataTask::debugIdentification() const\n{\n    if (!mailbox.isValid())\n        return QLatin1String(\"[invalid mailbox]\");\n\n    Q_ASSERT(!uids.isEmpty());\n    return QString::fromUtf8(\"%1: UIDs %2\").arg(mailbox.data(RoleMailboxName).toString(),\n                                                QString::fromUtf8(Sequence::fromList(uids).toByteArray()));\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\n\netchMsgMetadataTask {\n  String FetchMsgMetadataTask::debugIdentification() const\n  {\n      if (!mailbox.isValid())\n          return QLatin1String(\"[invalid mailbox]\");\n  \n      Q_ASSERT(!uids.isEmpty());\n      return QString::fromUtf8(\"%1: UIDs %2\").arg(mailbox.data(RoleMailboxName).toString(),\n                                                  QString::fromUtf8(Sequence::fromList(uids).toByteArray()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->data",
          "args": [
            "il)."
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "taskData(",
          "container": "etchMsgMetadataTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgMetadataTask.cpp",
          "lines": "100-103",
          "snippet": "Variant FetchMsgMetadataTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Downloading headers\")) : QVariant();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\n\netchMsgMetadataTask {\n  Variant FetchMsgMetadataTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Downloading headers\")) : QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ils.join",
          "args": [
            "n\");"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.value",
          "args": [
            "mail\",",
            "tring())."
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st.count",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "st.at",
          "args": [
            ";"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contacts->findItems",
          "args": [
            "ook.value(\"name\").toString());"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.childGroups",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.setIniCodec",
          "args": [
            "TF-8\");"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::readAbook(bool update)\n  {\n  //     QElapsedTimer profile;\n  //     profile.start();\n      QSettings abook(QDir::homePath() + \"/.abook/addressbook\", QSettings::IniFormat);\n      abook.setIniCodec(\"UTF-8\");\n      QStringList contacts = abook.childGroups();\n      foreach (const QString &contact, contacts) {\n          Common::SettingsCategoryGuard guard(&abook, contact);\n          QStandardItem *item = 0;\n          QStringList mails;\n          if (update) {\n              QList<QStandardItem*> list = m_contacts->findItems(abook.value(\"name\").toString());\n              if (list.count() == 1)\n                  item = list.at(0);\n              else if (list.count() > 1) {\n                  mails = abook.value(\"email\", QString()).toStringList();\n                  const QString mailString = mails.join(\"\\n\");\n                  foreach (QStandardItem *it, list) {\n                      if (it->data(Mail).toString() == mailString) {\n                          item = it;\n                          break;\n                      }\n                  }\n              }\n              if (item && item->data(Dirty).toBool()) {\n                  continue;\n              }\n          }\n          bool add = !item;\n          if (add)\n              item = new QStandardItem;\n  \n          QMap<QString,QVariant> unknownKeys;\n  \n          foreach (const QString &key, abook.allKeys()) {\n              QList<QPair<Type,QString> >::const_iterator field = m_fields.constBegin();\n              while (field != m_fields.constEnd()) {\n                  if (field->second == key)\n                      break;\n                  ++field;\n              }\n              if (field == m_fields.constEnd())\n                  unknownKeys.insert(key, abook.value(key));\n              else if (field->first == Mail) {\n                  if (mails.isEmpty())\n                      mails = abook.value(field->second, QString()).toStringList(); // to fix the name field\n                  item->setData( mails.join(\"\\n\"), Mail );\n              }\n              else\n                  item->setData( abook.value(field->second, QString()), field->first );\n          }\n  \n          // attempt to fix the name field\n          if (item->data(Name).toString().isEmpty()) {\n              if (!mails.isEmpty())\n                  item->setData( mails.at(0), Name );\n          }\n          if (item->data(Name).toString().isEmpty()) {\n              delete item;\n              continue; // junk or format spec entry\n          }\n  \n          item->setData( unknownKeys, UnknownKeys );\n  \n          if (add)\n              m_contacts->appendRow( item );\n      }\n  //     const qint64 elapsed = profile.elapsed();\n  //     qDebug() << \"reading too\" << elapsed << \"ms\";\n  }\n}"
  },
  {
    "function_name": "updateAbook()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "131-136",
    "snippet": "id AbookAddressbook::updateAbook()\n{\n    readAbook(true);\n    // QFileSystemWatcher will usually unhook from the file when it's re/written - the entire watcher ain't so great :-(\n    m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filesystemWatcher->addPath",
          "args": [
            "ir::homePath() + \"/.abook/addressbook\");"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adAbook(t",
          "args": [
            "ue);"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::updateAbook()\n  {\n      readAbook(true);\n      // QFileSystemWatcher will usually unhook from the file when it's re/written - the entire watcher ain't so great :-(\n      m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n  }\n}"
  },
  {
    "function_name": "scheduleAbookUpdate()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "120-129",
    "snippet": "id AbookAddressbook::scheduleAbookUpdate()\n{\n    // we need to schedule this because the filesystemwatcher usually fires while the file is re/written\n    if (!m_updateTimer) {\n        m_updateTimer = new QTimer(this);\n        m_updateTimer->setSingleShot(true);\n        connect (m_updateTimer, SIGNAL(timeout()), SLOT(updateAbook()));\n    }\n    m_updateTimer->start(500);\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateTimer->start",
          "args": [
            "0);"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnect (",
          "args": [
            "updateTimer,",
            "GNAL(timeout()),",
            "OT(updateAbook()));"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OT(u",
          "args": [
            "dateAbook()))"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dateAbook()",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "updateAbook()",
          "container": "ookAddressbook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
          "lines": "131-136",
          "snippet": "id AbookAddressbook::updateAbook()\n{\n    readAbook(true);\n    // QFileSystemWatcher will usually unhook from the file when it's re/written - the entire watcher ain't so great :-(\n    m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n}",
          "includes": [
            "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
            "nclude <QTimer>\n#i",
            "nclude <QStringBuilder>\n#i",
            "nclude <QStandardItemModel>\n#i",
            "nclude <QSettings>\n#i",
            "nclude <QFileSystemWatcher>\n#i",
            "nclude <QDir>\n#i",
            "nclude \"AbookAddressbook.h\"\n\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::updateAbook()\n  {\n      readAbook(true);\n      // QFileSystemWatcher will usually unhook from the file when it's re/written - the entire watcher ain't so great :-(\n      m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GNAL(t",
          "args": [
            "meout()),"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meout()",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "updateTimer->setSingleShot",
          "args": [
            "ue);"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::scheduleAbookUpdate()\n  {\n      // we need to schedule this because the filesystemwatcher usually fires while the file is re/written\n      if (!m_updateTimer) {\n          m_updateTimer = new QTimer(this);\n          m_updateTimer->setSingleShot(true);\n          connect (m_updateTimer, SIGNAL(timeout()), SLOT(updateAbook()));\n      }\n      m_updateTimer->start(500);\n  }\n}"
  },
  {
    "function_name": "ensureAbookPath()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "84-118",
    "snippet": "id AbookAddressbook::ensureAbookPath()\n{\n    if (!QDir::home().exists(\".abook\")) {\n        QDir::home().mkdir(\".abook\");\n    }\n    QDir abook(QDir::homePath() + \"/.abook/\");\n    QStringList abookrc;\n    QFile file(QDir::homePath() + \"/.abook/abookrc\");\n    if (file.exists() && file.open(QIODevice::ReadWrite|QIODevice::Text)) {\n        abookrc = QString::fromLocal8Bit(file.readAll()).split('\\n');\n        bool havePhoto = false;\n        for (QStringList::iterator it = abookrc.begin(), end = abookrc.end(); it != end; ++it) {\n            if (it->contains(\"preserve_fields\"))\n                *it = \"set preserve_fields=all\";\n            else if (it->contains(\"photo\") && it->contains(\"field\"))\n                havePhoto = true;\n        }\n        if (!havePhoto)\n            abookrc << \"field photo = Photo\";\n    } else {\n        abookrc << \"field photo = Photo\" << \"set preserve_fields=all\";\n        file.open(QIODevice::WriteOnly|QIODevice::Text);\n    }\n    if (file.isOpen()) {\n        if (file.isWritable()) {\n            file.seek(0);\n            file.write(abookrc.join(\"\\n\").toLocal8Bit());\n        }\n        file.close();\n    }\n    QFile abookFile(abook.filePath(QLatin1String(\"addressbook\")));\n    if (!abookFile.exists()) {\n        abookFile.open(QIODevice::WriteOnly);\n    }\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ookFile.open",
          "args": [
            "ODevice::WriteOnly);"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookFile.exists",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ook.filePath",
          "args": [
            "atin1String(\"addressbook\")))"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "ddressbook\"))"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.close",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.write",
          "args": [
            "ookrc.join(\"\\n\").toLocal8Bit());"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookrc.join",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookrc.join",
          "args": [
            "n\")."
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.seek",
          "args": [
            ";"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.isWritable",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.isOpen",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.open",
          "args": [
            "ODevice::WriteOnly|QIODevice::Text);"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->contains",
          "args": [
            "ield\"))"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->contains",
          "args": [
            "hoto\")"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->contains",
          "args": [
            "reserve_fields\"))"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookrc.end",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookrc.begin",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromLocal8Bit",
          "args": [
            "n');"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromLocal8Bit(f",
          "args": [
            "le.readAll())."
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.readAll",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.open",
          "args": [
            "ODevice::ReadWrite|QIODevice::Text))"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le.exists",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::home",
          "args": [
            "abook\");"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::home()",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::home",
          "args": [
            "abook\"))"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::home()",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::ensureAbookPath()\n  {\n      if (!QDir::home().exists(\".abook\")) {\n          QDir::home().mkdir(\".abook\");\n      }\n      QDir abook(QDir::homePath() + \"/.abook/\");\n      QStringList abookrc;\n      QFile file(QDir::homePath() + \"/.abook/abookrc\");\n      if (file.exists() && file.open(QIODevice::ReadWrite|QIODevice::Text)) {\n          abookrc = QString::fromLocal8Bit(file.readAll()).split('\\n');\n          bool havePhoto = false;\n          for (QStringList::iterator it = abookrc.begin(), end = abookrc.end(); it != end; ++it) {\n              if (it->contains(\"preserve_fields\"))\n                  *it = \"set preserve_fields=all\";\n              else if (it->contains(\"photo\") && it->contains(\"field\"))\n                  havePhoto = true;\n          }\n          if (!havePhoto)\n              abookrc << \"field photo = Photo\";\n      } else {\n          abookrc << \"field photo = Photo\" << \"set preserve_fields=all\";\n          file.open(QIODevice::WriteOnly|QIODevice::Text);\n      }\n      if (file.isOpen()) {\n          if (file.isWritable()) {\n              file.seek(0);\n              file.write(abookrc.join(\"\\n\").toLocal8Bit());\n          }\n          file.close();\n      }\n      QFile abookFile(abook.filePath(QLatin1String(\"addressbook\")));\n      if (!abookFile.exists()) {\n          abookFile.open(QIODevice::WriteOnly);\n      }\n  }\n}"
  },
  {
    "function_name": "remonitorAdressbook()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "79-82",
    "snippet": "id AbookAddressbook::remonitorAdressbook()\n{\n    m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filesystemWatcher->addPath",
          "args": [
            "ir::homePath() + \"/.abook/addressbook\");"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::remonitorAdressbook()\n  {\n      m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n  }\n}"
  },
  {
    "function_name": "~AbookAddressbook()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "70-72",
    "snippet": "ookAddressbook::~AbookAddressbook()\n{\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  ookAddressbook::~AbookAddressbook()\n  {\n  }\n}"
  },
  {
    "function_name": "AbookAddressbook()",
    "container": "ookAddressbook",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
    "lines": "37-68",
    "snippet": "ookAddressbook::AbookAddressbook(): m_updateTimer(0)\n{\n#define ADD(TYPE, KEY) \\\n    m_fields << qMakePair<Type,QString>(TYPE, QLatin1String(KEY))\n    ADD(Name, \"name\");\n    ADD(Mail, \"email\");\n    ADD(Address, \"address\");\n    ADD(City, \"city\");\n    ADD(State, \"state\");\n    ADD(ZIP, \"zip\");\n    ADD(Country, \"country\");\n    ADD(Phone, \"phone\");\n    ADD(Workphone, \"workphone\");\n    ADD(Fax, \"fax\");\n    ADD(Mobile, \"mobile\");\n    ADD(Nick, \"nick\");\n    ADD(URL, \"url\");\n    ADD(Anniversary, \"anniversary\");\n    ADD(Photo, \"photo\");\n#undef ADD\n\n    m_contacts = new QStandardItemModel(this);\n\n    ensureAbookPath();\n\n    // read abook\n    readAbook(false);\n\n    m_filesystemWatcher = new QFileSystemWatcher(this);\n    m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n    connect (m_filesystemWatcher, SIGNAL(fileChanged(QString)), SLOT(scheduleAbookUpdate()));\n}",
    "includes": [
      "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
      "nclude <QTimer>\n#i",
      "nclude <QStringBuilder>\n#i",
      "nclude <QStandardItemModel>\n#i",
      "nclude <QSettings>\n#i",
      "nclude <QFileSystemWatcher>\n#i",
      "nclude <QDir>\n#i",
      "nclude \"AbookAddressbook.h\"\n\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnect (",
          "args": [
            "filesystemWatcher,",
            "GNAL(fileChanged(QString)),",
            "OT(scheduleAbookUpdate()));"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OT(s",
          "args": [
            "heduleAbookUpdate()))"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heduleAbookUpdate()",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "scheduleAbookUpdate()",
          "container": "ookAddressbook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
          "lines": "120-129",
          "snippet": "id AbookAddressbook::scheduleAbookUpdate()\n{\n    // we need to schedule this because the filesystemwatcher usually fires while the file is re/written\n    if (!m_updateTimer) {\n        m_updateTimer = new QTimer(this);\n        m_updateTimer->setSingleShot(true);\n        connect (m_updateTimer, SIGNAL(timeout()), SLOT(updateAbook()));\n    }\n    m_updateTimer->start(500);\n}",
          "includes": [
            "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
            "nclude <QTimer>\n#i",
            "nclude <QStringBuilder>\n#i",
            "nclude <QStandardItemModel>\n#i",
            "nclude <QSettings>\n#i",
            "nclude <QFileSystemWatcher>\n#i",
            "nclude <QDir>\n#i",
            "nclude \"AbookAddressbook.h\"\n\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::scheduleAbookUpdate()\n  {\n      // we need to schedule this because the filesystemwatcher usually fires while the file is re/written\n      if (!m_updateTimer) {\n          m_updateTimer = new QTimer(this);\n          m_updateTimer->setSingleShot(true);\n          connect (m_updateTimer, SIGNAL(timeout()), SLOT(updateAbook()));\n      }\n      m_updateTimer->start(500);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GNAL(f",
          "args": [
            "leChanged(QString)),"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leChanged(Q",
          "args": [
            "tring))"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystemWatcher->addPath",
          "args": [
            "ir::homePath() + \"/.abook/addressbook\");"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir::homePath()",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adAbook(f",
          "args": [
            "lse);"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sureAbookPath()",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ensureAbookPath()",
          "container": "ookAddressbook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/AbookAddressbook/AbookAddressbook.cpp",
          "lines": "84-118",
          "snippet": "id AbookAddressbook::ensureAbookPath()\n{\n    if (!QDir::home().exists(\".abook\")) {\n        QDir::home().mkdir(\".abook\");\n    }\n    QDir abook(QDir::homePath() + \"/.abook/\");\n    QStringList abookrc;\n    QFile file(QDir::homePath() + \"/.abook/abookrc\");\n    if (file.exists() && file.open(QIODevice::ReadWrite|QIODevice::Text)) {\n        abookrc = QString::fromLocal8Bit(file.readAll()).split('\\n');\n        bool havePhoto = false;\n        for (QStringList::iterator it = abookrc.begin(), end = abookrc.end(); it != end; ++it) {\n            if (it->contains(\"preserve_fields\"))\n                *it = \"set preserve_fields=all\";\n            else if (it->contains(\"photo\") && it->contains(\"field\"))\n                havePhoto = true;\n        }\n        if (!havePhoto)\n            abookrc << \"field photo = Photo\";\n    } else {\n        abookrc << \"field photo = Photo\" << \"set preserve_fields=all\";\n        file.open(QIODevice::WriteOnly|QIODevice::Text);\n    }\n    if (file.isOpen()) {\n        if (file.isWritable()) {\n            file.seek(0);\n            file.write(abookrc.join(\"\\n\").toLocal8Bit());\n        }\n        file.close();\n    }\n    QFile abookFile(abook.filePath(QLatin1String(\"addressbook\")));\n    if (!abookFile.exists()) {\n        abookFile.open(QIODevice::WriteOnly);\n    }\n}",
          "includes": [
            "nclude \"Common/SettingsCategoryGuard.h\"\n\nu",
            "nclude <QTimer>\n#i",
            "nclude <QStringBuilder>\n#i",
            "nclude <QStandardItemModel>\n#i",
            "nclude <QSettings>\n#i",
            "nclude <QFileSystemWatcher>\n#i",
            "nclude <QDir>\n#i",
            "nclude \"AbookAddressbook.h\"\n\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  id AbookAddressbook::ensureAbookPath()\n  {\n      if (!QDir::home().exists(\".abook\")) {\n          QDir::home().mkdir(\".abook\");\n      }\n      QDir abook(QDir::homePath() + \"/.abook/\");\n      QStringList abookrc;\n      QFile file(QDir::homePath() + \"/.abook/abookrc\");\n      if (file.exists() && file.open(QIODevice::ReadWrite|QIODevice::Text)) {\n          abookrc = QString::fromLocal8Bit(file.readAll()).split('\\n');\n          bool havePhoto = false;\n          for (QStringList::iterator it = abookrc.begin(), end = abookrc.end(); it != end; ++it) {\n              if (it->contains(\"preserve_fields\"))\n                  *it = \"set preserve_fields=all\";\n              else if (it->contains(\"photo\") && it->contains(\"field\"))\n                  havePhoto = true;\n          }\n          if (!havePhoto)\n              abookrc << \"field photo = Photo\";\n      } else {\n          abookrc << \"field photo = Photo\" << \"set preserve_fields=all\";\n          file.open(QIODevice::WriteOnly|QIODevice::Text);\n      }\n      if (file.isOpen()) {\n          if (file.isWritable()) {\n              file.seek(0);\n              file.write(abookrc.join(\"\\n\").toLocal8Bit());\n          }\n          file.close();\n      }\n      QFile abookFile(abook.filePath(QLatin1String(\"addressbook\")));\n      if (!abookFile.exists()) {\n          abookFile.open(QIODevice::WriteOnly);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "D(P",
          "args": [
            "oto,",
            "hoto\");"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(A",
          "args": [
            "niversary,",
            "nniversary\");"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(U",
          "args": [
            "L,",
            "rl\");"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(N",
          "args": [
            "ck,",
            "ick\");"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(M",
          "args": [
            "bile,",
            "obile\");"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(F",
          "args": [
            "x,",
            "ax\");"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(W",
          "args": [
            "rkphone,",
            "orkphone\");"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(P",
          "args": [
            "one,",
            "hone\");"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(C",
          "args": [
            "untry,",
            "ountry\");"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(Z",
          "args": [
            "P,",
            "ip\");"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(S",
          "args": [
            "ate,",
            "tate\");"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(C",
          "args": [
            "ty,",
            "ity\");"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(A",
          "args": [
            "dress,",
            "ddress\");"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(M",
          "args": [
            "il,",
            "mail\");"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D(N",
          "args": [
            "me,",
            "ame\");"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"Common/SettingsCategoryGuard.h\"\n\nu\nnclude <QTimer>\n#i\nnclude <QStringBuilder>\n#i\nnclude <QStandardItemModel>\n#i\nnclude <QSettings>\n#i\nnclude <QFileSystemWatcher>\n#i\nnclude <QDir>\n#i\nnclude \"AbookAddressbook.h\"\n\n#\n\nookAddressbook {\n  ookAddressbook::AbookAddressbook(): m_updateTimer(0)\n  {\n  #define ADD(TYPE, KEY) \\\n      m_fields << qMakePair<Type,QString>(TYPE, QLatin1String(KEY))\n      ADD(Name, \"name\");\n      ADD(Mail, \"email\");\n      ADD(Address, \"address\");\n      ADD(City, \"city\");\n      ADD(State, \"state\");\n      ADD(ZIP, \"zip\");\n      ADD(Country, \"country\");\n      ADD(Phone, \"phone\");\n      ADD(Workphone, \"workphone\");\n      ADD(Fax, \"fax\");\n      ADD(Mobile, \"mobile\");\n      ADD(Nick, \"nick\");\n      ADD(URL, \"url\");\n      ADD(Anniversary, \"anniversary\");\n      ADD(Photo, \"photo\");\n  #undef ADD\n  \n      m_contacts = new QStandardItemModel(this);\n  \n      ensureAbookPath();\n  \n      // read abook\n      readAbook(false);\n  \n      m_filesystemWatcher = new QFileSystemWatcher(this);\n      m_filesystemWatcher->addPath(QDir::homePath() + \"/.abook/addressbook\");\n      connect (m_filesystemWatcher, SIGNAL(fileChanged(QString)), SLOT(scheduleAbookUpdate()));\n  }\n}"
  }
]