[
  {
    "function_name": "eplySubject(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/SubjectMangling.cpp",
    "lines": "33-72",
    "snippet": "String replySubject(const QString &subject)\n{\n    // These operations should *not* check for internationalized variants of \"Re\"; these are evil.\n\n#define RE_PREFIX_RE \"(?:(?:Re:\\\\s*)*)\"\n#define RE_PREFIX_ML \"(?:(\\\\[[^\\\\]]+\\\\]\\\\s*)?)\"\n\n    static QRegExp rePrefixMatcher(QLatin1String(\"^\"\n                                                 RE_PREFIX_RE // a sequence of \"Re: \" prefixes\n                                                 RE_PREFIX_ML // something like a mailing list prefix\n                                                 RE_PREFIX_RE // a sequence of \"Re: \" prefixes\n                                                 ), Qt::CaseInsensitive);\n    rePrefixMatcher.setPatternSyntax(QRegExp::RegExp2);\n    QLatin1String correctedPrefix(\"Re: \");\n\n    if (rePrefixMatcher.indexIn(subject) == -1) {\n        // Our regular expression has failed, so better play it safe and blindly prepend \"Re: \"\n        return correctedPrefix + subject;\n    } else {\n        QStringList listPrefixes;\n        int pos = 0;\n        int oldPos = 0;\n        while ((pos = rePrefixMatcher.indexIn(subject, pos, QRegExp::CaretAtOffset)) != -1) {\n            if (rePrefixMatcher.matchedLength() == 0)\n                break;\n            pos += rePrefixMatcher.matchedLength();\n            if (!listPrefixes.contains(rePrefixMatcher.cap(1)))\n                listPrefixes << rePrefixMatcher.cap(1);\n            oldPos = pos;\n        }\n\n        QString mlPrefix = listPrefixes.join(QString()).trimmed();\n        QString baseSubject = subject.mid(oldPos + qMax(0, rePrefixMatcher.matchedLength()));\n\n        if (!mlPrefix.isEmpty() && !baseSubject.isEmpty())\n            mlPrefix += QLatin1Char(' ');\n\n        return correctedPrefix + mlPrefix + baseSubject;\n    }\n}",
    "includes": [
      "include \"SubjectMangling.h\"",
      "include <QStringList>",
      "include <QRegExp>\n#",
      "include <QObject>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aseSubject.isEmpty",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lPrefix.isEmpty",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubject.mid",
          "args": [
            "ldPos + qMax(0, rePrefixMatcher.matchedLength()))"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            ",",
            "ePrefixMatcher.matchedLength())"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.matchedLength",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istPrefixes.join",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istPrefixes.join",
          "args": [
            "String())"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.cap",
          "args": [
            ")"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istPrefixes.contains",
          "args": [
            "ePrefixMatcher.cap(1))"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.cap",
          "args": [
            ")"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.matchedLength",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.matchedLength",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.indexIn",
          "args": [
            "ubject,",
            "os,",
            "RegExp::CaretAtOffset)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.indexIn",
          "args": [
            "ubject)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ePrefixMatcher.setPatternSyntax",
          "args": [
            "RegExp::RegExp2)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "^\"\n                                                 RE_PREFIX_RE / a sequence of \"Re: \" prefixes\nE_PREFIX_ML // something like a mailing list prefix\n                                                 RE_PREFIX_RE / a sequence of \"Re: \" prefixes"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"SubjectMangling.h\"\ninclude <QStringList>\ninclude <QRegExp>\n#\ninclude <QObject>\n#\n\nString replySubject(const QString &subject)\n{\n    // These operations should *not* check for internationalized variants of \"Re\"; these are evil.\n\n#define RE_PREFIX_RE \"(?:(?:Re:\\\\s*)*)\"\n#define RE_PREFIX_ML \"(?:(\\\\[[^\\\\]]+\\\\]\\\\s*)?)\"\n\n    static QRegExp rePrefixMatcher(QLatin1String(\"^\"\n                                                 RE_PREFIX_RE // a sequence of \"Re: \" prefixes\n                                                 RE_PREFIX_ML // something like a mailing list prefix\n                                                 RE_PREFIX_RE // a sequence of \"Re: \" prefixes\n                                                 ), Qt::CaseInsensitive);\n    rePrefixMatcher.setPatternSyntax(QRegExp::RegExp2);\n    QLatin1String correctedPrefix(\"Re: \");\n\n    if (rePrefixMatcher.indexIn(subject) == -1) {\n        // Our regular expression has failed, so better play it safe and blindly prepend \"Re: \"\n        return correctedPrefix + subject;\n    } else {\n        QStringList listPrefixes;\n        int pos = 0;\n        int oldPos = 0;\n        while ((pos = rePrefixMatcher.indexIn(subject, pos, QRegExp::CaretAtOffset)) != -1) {\n            if (rePrefixMatcher.matchedLength() == 0)\n                break;\n            pos += rePrefixMatcher.matchedLength();\n            if (!listPrefixes.contains(rePrefixMatcher.cap(1)))\n                listPrefixes << rePrefixMatcher.cap(1);\n            oldPos = pos;\n        }\n\n        QString mlPrefix = listPrefixes.join(QString()).trimmed();\n        QString baseSubject = subject.mid(oldPos + qMax(0, rePrefixMatcher.matchedLength()));\n\n        if (!mlPrefix.isEmpty() && !baseSubject.isEmpty())\n            mlPrefix += QLatin1Char(' ');\n\n        return correctedPrefix + mlPrefix + baseSubject;\n    }\n}"
  }
]