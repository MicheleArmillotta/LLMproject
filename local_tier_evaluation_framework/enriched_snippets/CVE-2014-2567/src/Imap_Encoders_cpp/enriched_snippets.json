[
  {
    "function_name": "ecodeContentTransferEncoding(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "655-668",
    "snippet": "oid decodeContentTransferEncoding(const QByteArray &rawData, const QByteArray &encoding, QByteArray *outputData)\n{\n    Q_ASSERT(outputData);\n    if (encoding == \"quoted-printable\") {\n        *outputData = quotedPrintableDecode(rawData);\n    } else if (encoding == \"base64\") {\n        *outputData = QByteArray::fromBase64(rawData);\n    } else if (encoding.isEmpty() || encoding == \"7bit\" || encoding == \"8bit\" || encoding == \"binary\") {\n        *outputData = rawData;\n    } else {\n        qDebug() << \"Warning: unknown encoding\" << encoding;\n        *outputData = rawData;\n    }\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncoding.isEmpty",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::fromBase64(",
          "args": [
            "awData)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uotedPrintableDecode(",
          "args": [
            "awData)"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "uotedPrintableDecode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "387-390",
          "snippet": "ByteArray quotedPrintableDecode( const QByteArray& raw )\n{\n    return KCodecs::quotedPrintableDecode( raw );\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray quotedPrintableDecode( const QByteArray& raw )\n{\n    return KCodecs::quotedPrintableDecode( raw );\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "utputData)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\noid decodeContentTransferEncoding(const QByteArray &rawData, const QByteArray &encoding, QByteArray *outputData)\n{\n    Q_ASSERT(outputData);\n    if (encoding == \"quoted-printable\") {\n        *outputData = quotedPrintableDecode(rawData);\n    } else if (encoding == \"base64\") {\n        *outputData = QByteArray::fromBase64(rawData);\n    } else if (encoding.isEmpty() || encoding == \"7bit\" || encoding == \"8bit\" || encoding == \"binary\") {\n        *outputData = rawData;\n    } else {\n        qDebug() << \"Warning: unknown encoding\" << encoding;\n        *outputData = rawData;\n    }\n}"
  },
  {
    "function_name": "rapFormatFlowed(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "580-653",
    "snippet": "String wrapFormatFlowed(const QString &input)\n{\n    QRegExp justQuotationAndSpaces(QLatin1String(\"[> ]\"));\n\n    // Determining a proper cutoff is not easy. The Q-P allows for at most 76 chars per line, not counting the trailing CR LF.\n    // Suppose there's exactly one multibyte character which gets decoded into two bytes in UTF-8. After these two bytes are\n    // encoded via quoted-printable, they will take up six bytes together (each byte is converted to hex and prepended by \"=\").\n    // This means that such a line could contain only 70 ASCII characters and one non-ASCII one (assuming it gets encoded as a\n    // two-byte sequence in UTF-8) and it will still fit into a single line in Q-P.\n    //\n    // However, the only points for making this guess right are:\n    // a) to fit the SHOULD requirement in RFC 3676 [1] which says that line lengths should be <= 78 characters,\n    // b) to avoid Q-P doing excessive line wrapping later on\n    //\n    // If the text contain non-ASCII characters, these are not going to be readable without a proper Q-P decoder. As such, the\n    // argument for not triggering \"useless\" breaks at the QP time has much lower weight in such situations -- the aesthetics of\n    // the raw, QP-encoded form are not terribly relevant IMHO.\n    //\n    // The b) leads us to 76 characters, while yet another sentence in RFC 3676 suggests wrapping at 72, and even speaks about\n    // 66 as aestheticaly pleasing.\n    //\n    // Finally, because these \"76 characters\" have to include the trailing space, we're now at 75.\n    //\n    // [1] http://tools.ietf.org/html/rfc3676#section-4.2\n    const int defaultCutof = 75;\n\n    QStringList res;\n    Q_FOREACH(QString line, input.split(QLatin1Char('\\n'), QString::KeepEmptyParts)) {\n        line.remove(QLatin1Char('\\r'));\n        if (line.isEmpty()) {\n            res << line;\n            continue;\n        }\n\n        int previousBreak = 0;\n        while (previousBreak < line.size()) {\n            // Find a place to insert the line break\n            int size = defaultCutof;\n            if (line.size() <= previousBreak + size) {\n                // We can safely use this chunk\n            } else if (line.at(previousBreak + size) == QLatin1Char(' ')) {\n                // We've found our space -- let's just use it and be done here\n            } else {\n                // OK, let's find a place to break the words at. At first, go back and try to find any possibility of reusing\n                // an existing space.\n                while (size > 0 && line.at(previousBreak + size) != QLatin1Char(' ')) {\n                    --size;\n                    if (justQuotationAndSpaces.exactMatch(line.left(size))) {\n                        // Too bad; there is nothing but quotation at the beginning of this line. We cannot break the line here!\n                        // Doing so would create line which look like this:\n                        //   >[space]\n                        //   quoted text goes here\n                        size = 0;\n                    }\n                }\n                if (size == 0) {\n                    size = defaultCutof;\n                    while (previousBreak + size < line.size() && line.at(previousBreak + size) != QLatin1Char(' ')) {\n                        ++size;\n                    }\n                }\n            }\n\n            Q_ASSERT(previousBreak + size >= line.size() || line.at(previousBreak + size) == QLatin1Char(' '));\n\n            // Now we want to insert the newline *after* the space\n            ++size;\n\n            res << line.mid(previousBreak, size);\n            previousBreak += size;\n        }\n    }\n    return res.join(QLatin1String(\"\\r\\n\"));\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "es.join",
          "args": [
            "Latin1String(\"\\r\\n\"))"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\\r\\n\")"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "reviousBreak,",
            "ize)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "reviousBreak + size >= line.size() || line.at(previousBreak + size) == QLatin1Char(' '))"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.at",
          "args": [
            "reviousBreak + size)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.at",
          "args": [
            "reviousBreak + size)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ustQuotationAndSpaces.exactMatch",
          "args": [
            "ine.left(size))"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.left",
          "args": [
            "ize)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.at",
          "args": [
            "reviousBreak + size)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.at",
          "args": [
            "reviousBreak + size)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.isEmpty",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.remove",
          "args": [
            "Latin1Char('\\r'))"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "\\r')"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "[> ]\")"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString wrapFormatFlowed(const QString &input)\n{\n    QRegExp justQuotationAndSpaces(QLatin1String(\"[> ]\"));\n\n    // Determining a proper cutoff is not easy. The Q-P allows for at most 76 chars per line, not counting the trailing CR LF.\n    // Suppose there's exactly one multibyte character which gets decoded into two bytes in UTF-8. After these two bytes are\n    // encoded via quoted-printable, they will take up six bytes together (each byte is converted to hex and prepended by \"=\").\n    // This means that such a line could contain only 70 ASCII characters and one non-ASCII one (assuming it gets encoded as a\n    // two-byte sequence in UTF-8) and it will still fit into a single line in Q-P.\n    //\n    // However, the only points for making this guess right are:\n    // a) to fit the SHOULD requirement in RFC 3676 [1] which says that line lengths should be <= 78 characters,\n    // b) to avoid Q-P doing excessive line wrapping later on\n    //\n    // If the text contain non-ASCII characters, these are not going to be readable without a proper Q-P decoder. As such, the\n    // argument for not triggering \"useless\" breaks at the QP time has much lower weight in such situations -- the aesthetics of\n    // the raw, QP-encoded form are not terribly relevant IMHO.\n    //\n    // The b) leads us to 76 characters, while yet another sentence in RFC 3676 suggests wrapping at 72, and even speaks about\n    // 66 as aestheticaly pleasing.\n    //\n    // Finally, because these \"76 characters\" have to include the trailing space, we're now at 75.\n    //\n    // [1] http://tools.ietf.org/html/rfc3676#section-4.2\n    const int defaultCutof = 75;\n\n    QStringList res;\n    Q_FOREACH(QString line, input.split(QLatin1Char('\\n'), QString::KeepEmptyParts)) {\n        line.remove(QLatin1Char('\\r'));\n        if (line.isEmpty()) {\n            res << line;\n            continue;\n        }\n\n        int previousBreak = 0;\n        while (previousBreak < line.size()) {\n            // Find a place to insert the line break\n            int size = defaultCutof;\n            if (line.size() <= previousBreak + size) {\n                // We can safely use this chunk\n            } else if (line.at(previousBreak + size) == QLatin1Char(' ')) {\n                // We've found our space -- let's just use it and be done here\n            } else {\n                // OK, let's find a place to break the words at. At first, go back and try to find any possibility of reusing\n                // an existing space.\n                while (size > 0 && line.at(previousBreak + size) != QLatin1Char(' ')) {\n                    --size;\n                    if (justQuotationAndSpaces.exactMatch(line.left(size))) {\n                        // Too bad; there is nothing but quotation at the beginning of this line. We cannot break the line here!\n                        // Doing so would create line which look like this:\n                        //   >[space]\n                        //   quoted text goes here\n                        size = 0;\n                    }\n                }\n                if (size == 0) {\n                    size = defaultCutof;\n                    while (previousBreak + size < line.size() && line.at(previousBreak + size) != QLatin1Char(' ')) {\n                        ++size;\n                    }\n                }\n            }\n\n            Q_ASSERT(previousBreak + size >= line.size() || line.at(previousBreak + size) == QLatin1Char(' '));\n\n            // Now we want to insert the newline *after* the space\n            ++size;\n\n            res << line.mid(previousBreak, size);\n            previousBreak += size;\n        }\n    }\n    return res.join(QLatin1String(\"\\r\\n\"));\n}"
  },
  {
    "function_name": "ncodeRfc2231Parameter(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "537-565",
    "snippet": "ByteArray encodeRfc2231Parameter(const QByteArray &key, const QString &value)\n{\n    if (value.isEmpty())\n        return key + \"=\\\"\\\"\";\n\n    bool safeAscii = true;\n\n    // Find \"dangerous\" characters\n    for (int i = 0; i < value.size(); ++i) {\n        if (rfc2311NeedsEscaping(value[i].unicode())) {\n            safeAscii = false;\n            break;\n        }\n    }\n\n    if (safeAscii)\n        return key + '=' + value.toUtf8();\n\n    QByteArray res = key + \"*=\\\"utf-8''\";\n    QByteArray encoded = value.toUtf8();\n    for (int i = 0; i < encoded.size(); ++i) {\n        char unicode = encoded[i];\n        if (rfc2311NeedsEscaping(unicode))\n            res += toHexChar(unicode, '%');\n        else\n            res += unicode;\n    }\n    return res + '\"';\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oHexChar(",
          "args": [
            "nicode,",
            "%')"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "oHexChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "252-256",
          "snippet": "ByteArray toHexChar(const ushort unicode, char prefix)\n    {\n        const char hexChars[] = \"0123456789ABCDEF\";\n        return QByteArray() + prefix + hexChars[(unicode >> 4) & 0xf] + hexChars[unicode & 0xf];\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray toHexChar(const ushort unicode, char prefix)\n    {\n        const char hexChars[] = \"0123456789ABCDEF\";\n        return QByteArray() + prefix + hexChars[(unicode >> 4) & 0xf] + hexChars[unicode & 0xf];\n    }"
        }
      },
      {
        "call_info": {
          "callee": "fc2311NeedsEscaping(",
          "args": [
            "nicode)"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "fc2311NeedsEscaping(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "78-99",
          "snippet": "tatic inline bool rfc2311NeedsEscaping(const int unicode)\n    {\n        const unsigned char Ascii_Zero = 0x30;\n        const unsigned char Ascii_Nine = 0x39;\n        const unsigned char Ascii_A = 0x41;\n        const unsigned char Ascii_Z = 0x5a;\n        const unsigned char Ascii_a = 0x61;\n        const unsigned char Ascii_z = 0x7a;\n        const unsigned char Ascii_Minus = 0x2d;\n        const unsigned char Ascii_Dot = 0x2e;\n        const unsigned char Ascii_Underscore = 0x5f;\n\n        if (unicode == Ascii_Minus || unicode == Ascii_Dot || unicode == Ascii_Underscore)\n            return false;\n        if (unicode >= Ascii_Zero && unicode <= Ascii_Nine)\n            return false;\n        if (unicode >= Ascii_A && unicode <= Ascii_Z)\n            return false;\n        if (unicode >= Ascii_a && unicode <= Ascii_z)\n            return false;\n        return true;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline bool rfc2311NeedsEscaping(const int unicode)\n    {\n        const unsigned char Ascii_Zero = 0x30;\n        const unsigned char Ascii_Nine = 0x39;\n        const unsigned char Ascii_A = 0x41;\n        const unsigned char Ascii_Z = 0x5a;\n        const unsigned char Ascii_a = 0x61;\n        const unsigned char Ascii_z = 0x7a;\n        const unsigned char Ascii_Minus = 0x2d;\n        const unsigned char Ascii_Dot = 0x2e;\n        const unsigned char Ascii_Underscore = 0x5f;\n\n        if (unicode == Ascii_Minus || unicode == Ascii_Dot || unicode == Ascii_Underscore)\n            return false;\n        if (unicode >= Ascii_Zero && unicode <= Ascii_Nine)\n            return false;\n        if (unicode >= Ascii_A && unicode <= Ascii_Z)\n            return false;\n        if (unicode >= Ascii_a && unicode <= Ascii_z)\n            return false;\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ncoded.size",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.toUtf8",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.toUtf8",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue[i].unicode",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.size",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.isEmpty",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeRfc2231Parameter(const QByteArray &key, const QString &value)\n{\n    if (value.isEmpty())\n        return key + \"=\\\"\\\"\";\n\n    bool safeAscii = true;\n\n    // Find \"dangerous\" characters\n    for (int i = 0; i < value.size(); ++i) {\n        if (rfc2311NeedsEscaping(value[i].unicode())) {\n            safeAscii = false;\n            break;\n        }\n    }\n\n    if (safeAscii)\n        return key + '=' + value.toUtf8();\n\n    QByteArray res = key + \"*=\\\"utf-8''\";\n    QByteArray encoded = value.toUtf8();\n    for (int i = 0; i < encoded.size(); ++i) {\n        char unicode = encoded[i];\n        if (rfc2311NeedsEscaping(unicode))\n            res += toHexChar(unicode, '%');\n        else\n            res += unicode;\n    }\n    return res + '\"';\n}"
  },
  {
    "function_name": "xtractRfc2231Param(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "488-534",
    "snippet": "String extractRfc2231Param(const QMap<QByteArray, QByteArray> &parameters, const QByteArray &key)\n{\n    QMap<QByteArray, QByteArray>::const_iterator it = parameters.constFind(key);\n    if (it != parameters.constEnd()) {\n        // This parameter is not using the RFC 2231 syntax for extended parameters.\n        // I have no idea whether this is correct, but I *guess* that trying to use RFC2047 is not going to hurt.\n        return decodeRFC2047String(*it);\n    }\n\n    if (parameters.constFind(key + \"*0\") != parameters.constEnd()) {\n        // There's a 2231-style continuation *without* the language/charset extension\n        QByteArray raw;\n        int num = 0;\n        while ((it = parameters.constFind(key + '*' + QByteArray::number(num++))) != parameters.constEnd()) {\n            raw += *it;\n        }\n        return decodeRFC2047String(raw);\n    }\n\n    QByteArray raw;\n    if ((it = parameters.constFind(key + '*')) != parameters.constEnd()) {\n        // No continuation, but language/charset is present\n        raw = *it;\n    } else if (parameters.constFind(key + \"*0*\") != parameters.constEnd()) {\n        // Both continuation *and* the lang/charset extension are in there\n        int num = 0;\n        // The funny thing is that the other values might or might not end with the trailing star,\n        // at least according to the example in the RFC\n        do {\n            if ((it = parameters.constFind(key + '*' + QByteArray::number(num))) != parameters.constEnd())\n                raw += *it;\n            else if ((it = parameters.constFind(key + '*' + QByteArray::number(num) + '*')) != parameters.constEnd())\n                raw += *it;\n            ++num;\n        } while (it != parameters.constEnd());\n    }\n\n    // Process 2231-style language/charset continuation, if present\n    int pos1 = raw.indexOf('\\'', 0);\n    int pos2 = raw.indexOf('\\'', qMax(1, pos1 + 1));\n    if (pos1 != -1 && pos2 != -1) {\n        return decodeByteArray(translatePercentToBin(raw.mid(pos2 + 1)), raw.left(pos1));\n    }\n\n    // Fallback: it could be empty, or otherwise malformed. Just treat it as UTF-8 for compatibility\n    return QString::fromUtf8(raw);\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "aw)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecodeByteArray(",
          "args": [
            "ranslatePercentToBin(raw.mid(pos2 + 1)),",
            "aw.left(pos1))"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "334-340",
          "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "aw.left",
          "args": [
            "os1)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslatePercentToBin(",
          "args": [
            "aw.mid(pos2 + 1))"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ranslatePercentToBin(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "175-192",
          "snippet": "tatic inline QByteArray translatePercentToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '%' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline QByteArray translatePercentToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '%' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "aw.mid",
          "args": [
            "os2 + 1)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aw.indexOf",
          "args": [
            "\\'',",
            "Max(1, pos1 + 1))"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            ",",
            "os1 + 1)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aw.indexOf",
          "args": [
            "\\'',",
            ")"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey + '*' + QByteArray::number(num) + '*')"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "um)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey + '*' + QByteArray::number(num))"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "um)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey + \"*0*\")"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey + '*')"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecodeRFC2047String(",
          "args": [
            "aw)"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeRFC2047String(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "372-375",
          "snippet": "String decodeRFC2047String( const QByteArray& raw )\n{\n    return ::decodeWordSequence( raw );\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeRFC2047String( const QByteArray& raw )\n{\n    return ::decodeWordSequence( raw );\n}"
        }
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey + '*' + QByteArray::number(num++))"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "um++)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey + \"*0\")"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constEnd",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arameters.constFind",
          "args": [
            "ey)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString extractRfc2231Param(const QMap<QByteArray, QByteArray> &parameters, const QByteArray &key)\n{\n    QMap<QByteArray, QByteArray>::const_iterator it = parameters.constFind(key);\n    if (it != parameters.constEnd()) {\n        // This parameter is not using the RFC 2231 syntax for extended parameters.\n        // I have no idea whether this is correct, but I *guess* that trying to use RFC2047 is not going to hurt.\n        return decodeRFC2047String(*it);\n    }\n\n    if (parameters.constFind(key + \"*0\") != parameters.constEnd()) {\n        // There's a 2231-style continuation *without* the language/charset extension\n        QByteArray raw;\n        int num = 0;\n        while ((it = parameters.constFind(key + '*' + QByteArray::number(num++))) != parameters.constEnd()) {\n            raw += *it;\n        }\n        return decodeRFC2047String(raw);\n    }\n\n    QByteArray raw;\n    if ((it = parameters.constFind(key + '*')) != parameters.constEnd()) {\n        // No continuation, but language/charset is present\n        raw = *it;\n    } else if (parameters.constFind(key + \"*0*\") != parameters.constEnd()) {\n        // Both continuation *and* the lang/charset extension are in there\n        int num = 0;\n        // The funny thing is that the other values might or might not end with the trailing star,\n        // at least according to the example in the RFC\n        do {\n            if ((it = parameters.constFind(key + '*' + QByteArray::number(num))) != parameters.constEnd())\n                raw += *it;\n            else if ((it = parameters.constFind(key + '*' + QByteArray::number(num) + '*')) != parameters.constEnd())\n                raw += *it;\n            ++num;\n        } while (it != parameters.constEnd());\n    }\n\n    // Process 2231-style language/charset continuation, if present\n    int pos1 = raw.indexOf('\\'', 0);\n    int pos2 = raw.indexOf('\\'', qMax(1, pos1 + 1));\n    if (pos1 != -1 && pos2 != -1) {\n        return decodeByteArray(translatePercentToBin(raw.mid(pos2 + 1)), raw.left(pos1));\n    }\n\n    // Fallback: it could be empty, or otherwise malformed. Just treat it as UTF-8 for compatibility\n    return QString::fromUtf8(raw);\n}"
  },
  {
    "function_name": "ncodeRFC2047Phrase(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "448-485",
    "snippet": "ByteArray encodeRFC2047Phrase( const QString &text )\n{\n    /* We want to know if we can encode as ASCII. But bizarrely, Qt\n       (on my system at least) doesn't have an ASCII codec. So we use\n       the ISO-8859-1 superset, and check for any non-ASCII characters\n       in the result. */\n    QTextCodec *latin1 = QTextCodec::codecForMib(4);\n\n    if (latin1->canEncode(text)) {\n        /* Attempt to represent it as an RFC2822 'phrase' --- either a\n           sequence of atoms or as a quoted-string. */\n        \n        if (atomPhraseRx.exactMatch(text)) {\n            /* Simplest case: a sequence of atoms (not dot-atoms) */\n            return latin1->fromUnicode(text);\n        } else {\n            /* Next-simplest representation: a quoted-string */\n            QByteArray unquoted = latin1->fromUnicode(text);\n            \n            /* Check for non-ASCII characters. */\n            for(int i = 0; i < unquoted.size(); i++) {\n                char ch = unquoted[i];\n                if (ch < 1 || ch >= 127) {\n                    /* This string contains non-ASCII characters, so the\n                       only way to represent it in a mail header is as an\n                       RFC2047 encoded-word. */\n                    return encodeRFC2047String(text, RFC2047_STRING_LATIN);\n                }\n            }\n\n            return quotedString(unquoted);\n        }\n    }\n\n    /* If the text has characters outside of the basic ASCII set, then\n       it has to be encoded using the RFC2047 encoded-word syntax. */\n    return encodeRFC2047String(text, RFC2047_STRING_UTF8);\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncodeRFC2047String(",
          "args": [
            "ext,",
            "FC2047_STRING_UTF8)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeRFC2047String(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "262-331",
          "snippet": "ByteArray encodeRFC2047String(const QString &text, const Rfc2047StringCharacterSetType charset)\n{\n    // We can't allow more than 75 chars per encoded-word, including the boiler plate (7 chars and the size of the encoding spec)\n    // -- this is defined by RFC2047.\n    int maximumEncoded = 75 - 7;\n    QByteArray encoding;\n    if (charset == RFC2047_STRING_UTF8)\n        encoding = \"utf-8\";\n    else\n        encoding = \"iso-8859-1\";\n    maximumEncoded -= encoding.size();\n\n    // If this is an encodedWord, we need to include any whitespace that we don't want to lose\n    if (charset == RFC2047_STRING_UTF8) {\n        QByteArray res;\n        int start = 0;\n\n        while (start < text.size()) {\n            // as long as we have something to work on...\n            int size = maximumEncoded;\n            QByteArray candidate;\n\n            // Find the character boundary at which we have to split the input.\n            // Remember that we're iterating on Unicode codepoints now, not on raw bytes.\n            while (true) {\n                candidate = text.mid(start, size).toUtf8();\n                int utf8Size = candidate.size();\n                int base64Size = utf8Size * 4 / 3 + utf8Size % 3;\n                if (base64Size <= maximumEncoded) {\n                    // if this chunk's size is small enough, great\n                    QByteArray encoded = candidate.toBase64();\n                    if (!res.isEmpty())\n                        res.append(\"\\r\\n \");\n                    res.append(\"=?utf-8?B?\" + encoded + \"?=\");\n                    start += size;\n                    break;\n                } else {\n                    // otherwise, try with something smaller\n                    --size;\n                    Q_ASSERT(size >= 1);\n                }\n            }\n        }\n        return res;\n    } else {\n        QByteArray buf = \"=?\" + encoding + \"?Q?\";\n        int i = 0;\n        int currentLineLength = 0;\n        while (i < text.size()) {\n            QByteArray symbol;\n            const ushort unicode = text[i].unicode();\n            if (unicode == 0x20) {\n                symbol = \"_\";\n            } else if (!rfc2047QPNeedsEscpaing(unicode)) {\n                symbol += text[i].toLatin1();\n            } else {\n                symbol = toHexChar(unicode, '=');\n            }\n            currentLineLength += symbol.size();\n            if (currentLineLength > maximumEncoded) {\n                buf += \"?=\\r\\n =?\" + encoding + \"?Q?\";\n                currentLineLength = 0;\n            }\n            buf += symbol;\n            ++i;\n        }\n        buf += \"?=\";\n        return buf;\n    }\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeRFC2047String(const QString &text, const Rfc2047StringCharacterSetType charset)\n{\n    // We can't allow more than 75 chars per encoded-word, including the boiler plate (7 chars and the size of the encoding spec)\n    // -- this is defined by RFC2047.\n    int maximumEncoded = 75 - 7;\n    QByteArray encoding;\n    if (charset == RFC2047_STRING_UTF8)\n        encoding = \"utf-8\";\n    else\n        encoding = \"iso-8859-1\";\n    maximumEncoded -= encoding.size();\n\n    // If this is an encodedWord, we need to include any whitespace that we don't want to lose\n    if (charset == RFC2047_STRING_UTF8) {\n        QByteArray res;\n        int start = 0;\n\n        while (start < text.size()) {\n            // as long as we have something to work on...\n            int size = maximumEncoded;\n            QByteArray candidate;\n\n            // Find the character boundary at which we have to split the input.\n            // Remember that we're iterating on Unicode codepoints now, not on raw bytes.\n            while (true) {\n                candidate = text.mid(start, size).toUtf8();\n                int utf8Size = candidate.size();\n                int base64Size = utf8Size * 4 / 3 + utf8Size % 3;\n                if (base64Size <= maximumEncoded) {\n                    // if this chunk's size is small enough, great\n                    QByteArray encoded = candidate.toBase64();\n                    if (!res.isEmpty())\n                        res.append(\"\\r\\n \");\n                    res.append(\"=?utf-8?B?\" + encoded + \"?=\");\n                    start += size;\n                    break;\n                } else {\n                    // otherwise, try with something smaller\n                    --size;\n                    Q_ASSERT(size >= 1);\n                }\n            }\n        }\n        return res;\n    } else {\n        QByteArray buf = \"=?\" + encoding + \"?Q?\";\n        int i = 0;\n        int currentLineLength = 0;\n        while (i < text.size()) {\n            QByteArray symbol;\n            const ushort unicode = text[i].unicode();\n            if (unicode == 0x20) {\n                symbol = \"_\";\n            } else if (!rfc2047QPNeedsEscpaing(unicode)) {\n                symbol += text[i].toLatin1();\n            } else {\n                symbol = toHexChar(unicode, '=');\n            }\n            currentLineLength += symbol.size();\n            if (currentLineLength > maximumEncoded) {\n                buf += \"?=\\r\\n =?\" + encoding + \"?Q?\";\n                currentLineLength = 0;\n            }\n            buf += symbol;\n            ++i;\n        }\n        buf += \"?=\";\n        return buf;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uotedString(",
          "args": [
            "nquoted)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nquoted.size",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1->fromUnicode",
          "args": [
            "ext)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1->fromUnicode",
          "args": [
            "ext)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomPhraseRx.exactMatch",
          "args": [
            "ext)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1->canEncode",
          "args": [
            "ext)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextCodec::codecForMib(",
          "args": [
            ")"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeRFC2047Phrase( const QString &text )\n{\n    /* We want to know if we can encode as ASCII. But bizarrely, Qt\n       (on my system at least) doesn't have an ASCII codec. So we use\n       the ISO-8859-1 superset, and check for any non-ASCII characters\n       in the result. */\n    QTextCodec *latin1 = QTextCodec::codecForMib(4);\n\n    if (latin1->canEncode(text)) {\n        /* Attempt to represent it as an RFC2822 'phrase' --- either a\n           sequence of atoms or as a quoted-string. */\n        \n        if (atomPhraseRx.exactMatch(text)) {\n            /* Simplest case: a sequence of atoms (not dot-atoms) */\n            return latin1->fromUnicode(text);\n        } else {\n            /* Next-simplest representation: a quoted-string */\n            QByteArray unquoted = latin1->fromUnicode(text);\n            \n            /* Check for non-ASCII characters. */\n            for(int i = 0; i < unquoted.size(); i++) {\n                char ch = unquoted[i];\n                if (ch < 1 || ch >= 127) {\n                    /* This string contains non-ASCII characters, so the\n                       only way to represent it in a mail header is as an\n                       RFC2047 encoded-word. */\n                    return encodeRFC2047String(text, RFC2047_STRING_LATIN);\n                }\n            }\n\n            return quotedString(unquoted);\n        }\n    }\n\n    /* If the text has characters outside of the basic ASCII set, then\n       it has to be encoded using the RFC2047 encoded-word syntax. */\n    return encodeRFC2047String(text, RFC2047_STRING_UTF8);\n}"
  },
  {
    "function_name": "uotedString(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "398-441",
    "snippet": "ByteArray quotedString( const QByteArray& unquoted, QuotedStringStyle style )\n{\n    QByteArray quoted;\n    char lhq, rhq;\n    \n    /* Compose a double-quoted string according to RFC2822 3.2.5 \"quoted-string\" */\n    switch (style) {\n    default:\n    case DoubleQuoted:\n        lhq = rhq = '\"';\n        break;\n    case SquareBrackets:\n        lhq = '[';\n        rhq = ']';\n        break;\n    case Parentheses:\n        lhq = '(';\n        rhq = ')';\n        break;\n    }\n\n    quoted.append(lhq);\n    for(int i = 0; i < unquoted.size(); i++) {\n        char ch = unquoted[i];\n        if (ch == 9 || ch == 10 || ch == 13) {\n            /* Newlines and tabs: these are only allowed in\n               quoted-strings as folding-whitespace, where\n               they are \"semantically invisible\".  If we\n               really want to include them, we probably need\n               to do so as RFC2047 strings. But it's unlikely\n               that that's a desirable behavior in the final\n               application. Instead, translate embedded\n               tabs/newlines into normal whitespace. */\n            quoted.append(' ');\n        } else {\n            if (ch == lhq || ch == rhq || ch == '\\\\')\n                quoted.append('\\\\');  /* Quoted-pair */\n            quoted.append(ch);\n        }\n    }\n    quoted.append(rhq);\n\n    return quoted;\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uoted.append",
          "args": [
            "hq)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uoted.append",
          "args": [
            "h)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uoted.append",
          "args": [
            "\\\\')"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uoted.append",
          "args": [
            "')"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nquoted.size",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uoted.append",
          "args": [
            "hq)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray quotedString( const QByteArray& unquoted, QuotedStringStyle style )\n{\n    QByteArray quoted;\n    char lhq, rhq;\n    \n    /* Compose a double-quoted string according to RFC2822 3.2.5 \"quoted-string\" */\n    switch (style) {\n    default:\n    case DoubleQuoted:\n        lhq = rhq = '\"';\n        break;\n    case SquareBrackets:\n        lhq = '[';\n        rhq = ']';\n        break;\n    case Parentheses:\n        lhq = '(';\n        rhq = ')';\n        break;\n    }\n\n    quoted.append(lhq);\n    for(int i = 0; i < unquoted.size(); i++) {\n        char ch = unquoted[i];\n        if (ch == 9 || ch == 10 || ch == 13) {\n            /* Newlines and tabs: these are only allowed in\n               quoted-strings as folding-whitespace, where\n               they are \"semantically invisible\".  If we\n               really want to include them, we probably need\n               to do so as RFC2047 strings. But it's unlikely\n               that that's a desirable behavior in the final\n               application. Instead, translate embedded\n               tabs/newlines into normal whitespace. */\n            quoted.append(' ');\n        } else {\n            if (ch == lhq || ch == rhq || ch == '\\\\')\n                quoted.append('\\\\');  /* Quoted-pair */\n            quoted.append(ch);\n        }\n    }\n    quoted.append(rhq);\n\n    return quoted;\n}"
  },
  {
    "function_name": "uotedPrintableEncode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "392-395",
    "snippet": "ByteArray quotedPrintableEncode(const QByteArray &raw)\n{\n    return KCodecs::quotedPrintableEncode(raw);\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Codecs::quotedPrintableEncode(",
          "args": [
            "aw)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray quotedPrintableEncode(const QByteArray &raw)\n{\n    return KCodecs::quotedPrintableEncode(raw);\n}"
  },
  {
    "function_name": "uotedPrintableDecode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "387-390",
    "snippet": "ByteArray quotedPrintableDecode( const QByteArray& raw )\n{\n    return KCodecs::quotedPrintableDecode( raw );\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Codecs::quotedPrintableDecode(",
          "args": [
            "aw"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "quotedPrintableDecode(",
          "container": "Codecs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/kcodecs.cpp",
          "lines": "195-200",
          "snippet": "ByteArray KCodecs::quotedPrintableDecode(const QByteArray & in)\n{\n  QByteArray out;\n  quotedPrintableDecode (in, out);\n  return out;\n}",
          "includes": [
            "include <QtCore/QIODevice>",
            "include <stdlib.h>",
            "include <string.h>",
            "include <stdio.h>\n#",
            "include \"kcodecs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtCore/QIODevice>\ninclude <stdlib.h>\ninclude <string.h>\ninclude <stdio.h>\n#\ninclude \"kcodecs.h\"\n\nCodecs {\n  ByteArray KCodecs::quotedPrintableDecode(const QByteArray & in)\n  {\n    QByteArray out;\n    quotedPrintableDecode (in, out);\n    return out;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray quotedPrintableDecode( const QByteArray& raw )\n{\n    return KCodecs::quotedPrintableDecode( raw );\n}"
  },
  {
    "function_name": "ecodeImapFolderName(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "382-385",
    "snippet": "String decodeImapFolderName( const QByteArray& raw )\n{\n    return KIMAP::decodeImapFolderName( raw );\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IMAP::decodeImapFolderName(",
          "args": [
            "aw"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeImapFolderName( const QByteArray& raw )\n{\n    return KIMAP::decodeImapFolderName( raw );\n}"
  },
  {
    "function_name": "ncodeImapFolderName(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "377-380",
    "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IMAP::encodeImapFolderName",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IMAP::encodeImapFolderName(",
          "args": [
            "ext"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
  },
  {
    "function_name": "ecodeRFC2047String(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "372-375",
    "snippet": "String decodeRFC2047String( const QByteArray& raw )\n{\n    return ::decodeWordSequence( raw );\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ":decodeWordSequence(",
          "args": [
            "aw"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeRFC2047String( const QByteArray& raw )\n{\n    return ::decodeWordSequence( raw );\n}"
  },
  {
    "function_name": "ncodeRFC2047StringWithAsciiPrefix(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "343-370",
    "snippet": "ByteArray encodeRFC2047StringWithAsciiPrefix(const QString &text)\n{\n    // The maximal recommended line length, as defined by RFC 5322\n    const int maxLineLength = 78;\n\n    // Find first character which needs escaping\n    int pos = 0;\n    while (pos < text.size() && pos < maxLineLength &&\n           (text[pos].unicode() == 0x20 || !rfc2047QPNeedsEscpaing(text[pos].unicode())))\n        ++pos;\n\n    // Find last character of a word which doesn't need escaping\n    if (pos != text.size()) {\n        while (pos > 0 && text[pos-1].unicode() != 0x20)\n            --pos;\n        if (pos > 0 && text[pos].unicode() == 0x20)\n            --pos;\n    }\n\n    QByteArray prefix = text.left(pos).toUtf8();\n    if (pos == text.size())\n        return prefix;\n\n    QString rest = text.mid(pos);\n    Rfc2047StringCharacterSetType charset = charsetForInput(rest);\n\n    return prefix + encodeRFC2047String(rest, charset);\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncodeRFC2047String(",
          "args": [
            "est,",
            "harset)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeRFC2047String(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "262-331",
          "snippet": "ByteArray encodeRFC2047String(const QString &text, const Rfc2047StringCharacterSetType charset)\n{\n    // We can't allow more than 75 chars per encoded-word, including the boiler plate (7 chars and the size of the encoding spec)\n    // -- this is defined by RFC2047.\n    int maximumEncoded = 75 - 7;\n    QByteArray encoding;\n    if (charset == RFC2047_STRING_UTF8)\n        encoding = \"utf-8\";\n    else\n        encoding = \"iso-8859-1\";\n    maximumEncoded -= encoding.size();\n\n    // If this is an encodedWord, we need to include any whitespace that we don't want to lose\n    if (charset == RFC2047_STRING_UTF8) {\n        QByteArray res;\n        int start = 0;\n\n        while (start < text.size()) {\n            // as long as we have something to work on...\n            int size = maximumEncoded;\n            QByteArray candidate;\n\n            // Find the character boundary at which we have to split the input.\n            // Remember that we're iterating on Unicode codepoints now, not on raw bytes.\n            while (true) {\n                candidate = text.mid(start, size).toUtf8();\n                int utf8Size = candidate.size();\n                int base64Size = utf8Size * 4 / 3 + utf8Size % 3;\n                if (base64Size <= maximumEncoded) {\n                    // if this chunk's size is small enough, great\n                    QByteArray encoded = candidate.toBase64();\n                    if (!res.isEmpty())\n                        res.append(\"\\r\\n \");\n                    res.append(\"=?utf-8?B?\" + encoded + \"?=\");\n                    start += size;\n                    break;\n                } else {\n                    // otherwise, try with something smaller\n                    --size;\n                    Q_ASSERT(size >= 1);\n                }\n            }\n        }\n        return res;\n    } else {\n        QByteArray buf = \"=?\" + encoding + \"?Q?\";\n        int i = 0;\n        int currentLineLength = 0;\n        while (i < text.size()) {\n            QByteArray symbol;\n            const ushort unicode = text[i].unicode();\n            if (unicode == 0x20) {\n                symbol = \"_\";\n            } else if (!rfc2047QPNeedsEscpaing(unicode)) {\n                symbol += text[i].toLatin1();\n            } else {\n                symbol = toHexChar(unicode, '=');\n            }\n            currentLineLength += symbol.size();\n            if (currentLineLength > maximumEncoded) {\n                buf += \"?=\\r\\n =?\" + encoding + \"?Q?\";\n                currentLineLength = 0;\n            }\n            buf += symbol;\n            ++i;\n        }\n        buf += \"?=\";\n        return buf;\n    }\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeRFC2047String(const QString &text, const Rfc2047StringCharacterSetType charset)\n{\n    // We can't allow more than 75 chars per encoded-word, including the boiler plate (7 chars and the size of the encoding spec)\n    // -- this is defined by RFC2047.\n    int maximumEncoded = 75 - 7;\n    QByteArray encoding;\n    if (charset == RFC2047_STRING_UTF8)\n        encoding = \"utf-8\";\n    else\n        encoding = \"iso-8859-1\";\n    maximumEncoded -= encoding.size();\n\n    // If this is an encodedWord, we need to include any whitespace that we don't want to lose\n    if (charset == RFC2047_STRING_UTF8) {\n        QByteArray res;\n        int start = 0;\n\n        while (start < text.size()) {\n            // as long as we have something to work on...\n            int size = maximumEncoded;\n            QByteArray candidate;\n\n            // Find the character boundary at which we have to split the input.\n            // Remember that we're iterating on Unicode codepoints now, not on raw bytes.\n            while (true) {\n                candidate = text.mid(start, size).toUtf8();\n                int utf8Size = candidate.size();\n                int base64Size = utf8Size * 4 / 3 + utf8Size % 3;\n                if (base64Size <= maximumEncoded) {\n                    // if this chunk's size is small enough, great\n                    QByteArray encoded = candidate.toBase64();\n                    if (!res.isEmpty())\n                        res.append(\"\\r\\n \");\n                    res.append(\"=?utf-8?B?\" + encoded + \"?=\");\n                    start += size;\n                    break;\n                } else {\n                    // otherwise, try with something smaller\n                    --size;\n                    Q_ASSERT(size >= 1);\n                }\n            }\n        }\n        return res;\n    } else {\n        QByteArray buf = \"=?\" + encoding + \"?Q?\";\n        int i = 0;\n        int currentLineLength = 0;\n        while (i < text.size()) {\n            QByteArray symbol;\n            const ushort unicode = text[i].unicode();\n            if (unicode == 0x20) {\n                symbol = \"_\";\n            } else if (!rfc2047QPNeedsEscpaing(unicode)) {\n                symbol += text[i].toLatin1();\n            } else {\n                symbol = toHexChar(unicode, '=');\n            }\n            currentLineLength += symbol.size();\n            if (currentLineLength > maximumEncoded) {\n                buf += \"?=\\r\\n =?\" + encoding + \"?Q?\";\n                currentLineLength = 0;\n            }\n            buf += symbol;\n            ++i;\n        }\n        buf += \"?=\";\n        return buf;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "harsetForInput(",
          "args": [
            "est)"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "harsetForInput(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "106-128",
          "snippet": "tatic Imap::Rfc2047StringCharacterSetType charsetForInput(const QString& input)\n    {\n        // shamelessly stolen from QMF's qmailmessage.cpp\n\n        // See if this input needs encoding\n        Imap::Rfc2047StringCharacterSetType latin1 = Imap::RFC2047_STRING_ASCII;\n\n        const QChar* it = input.constData();\n        const QChar* const end = it + input.length();\n        for ( ; it != end; ++it) {\n            if ((*it).unicode() > 0xff) {\n                // Multi-byte characters included - we need to use UTF-8\n                return Imap::RFC2047_STRING_UTF8;\n            }\n            else if (!latin1 && rfc2047QPNeedsEscpaing(it->unicode()))\n            {\n                // We need encoding from latin-1\n                latin1 = Imap::RFC2047_STRING_LATIN;\n            }\n        }\n\n        return latin1;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic Imap::Rfc2047StringCharacterSetType charsetForInput(const QString& input)\n    {\n        // shamelessly stolen from QMF's qmailmessage.cpp\n\n        // See if this input needs encoding\n        Imap::Rfc2047StringCharacterSetType latin1 = Imap::RFC2047_STRING_ASCII;\n\n        const QChar* it = input.constData();\n        const QChar* const end = it + input.length();\n        for ( ; it != end; ++it) {\n            if ((*it).unicode() > 0xff) {\n                // Multi-byte characters included - we need to use UTF-8\n                return Imap::RFC2047_STRING_UTF8;\n            }\n            else if (!latin1 && rfc2047QPNeedsEscpaing(it->unicode()))\n            {\n                // We need encoding from latin-1\n                latin1 = Imap::RFC2047_STRING_LATIN;\n            }\n        }\n\n        return latin1;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ext.mid",
          "args": [
            "os)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.size",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.left",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.left",
          "args": [
            "os)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext[pos].unicode",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext[pos-1].unicode",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.size",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fc2047QPNeedsEscpaing(",
          "args": [
            "ext[pos].unicode())"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "fc2047QPNeedsEscpaing(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "63-72",
          "snippet": "tatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ext[pos].unicode",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext[pos].unicode",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.size",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeRFC2047StringWithAsciiPrefix(const QString &text)\n{\n    // The maximal recommended line length, as defined by RFC 5322\n    const int maxLineLength = 78;\n\n    // Find first character which needs escaping\n    int pos = 0;\n    while (pos < text.size() && pos < maxLineLength &&\n           (text[pos].unicode() == 0x20 || !rfc2047QPNeedsEscpaing(text[pos].unicode())))\n        ++pos;\n\n    // Find last character of a word which doesn't need escaping\n    if (pos != text.size()) {\n        while (pos > 0 && text[pos-1].unicode() != 0x20)\n            --pos;\n        if (pos > 0 && text[pos].unicode() == 0x20)\n            --pos;\n    }\n\n    QByteArray prefix = text.left(pos).toUtf8();\n    if (pos == text.size())\n        return prefix;\n\n    QString rest = text.mid(pos);\n    Rfc2047StringCharacterSetType charset = charsetForInput(rest);\n\n    return prefix + encodeRFC2047String(rest, charset);\n}"
  },
  {
    "function_name": "ecodeByteArray(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "334-340",
    "snippet": "String decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "ncoded,",
            "ncoded.size())"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncoded.size",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odec->toUnicode",
          "args": [
            "ncoded)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odecForName(",
          "args": [
            "harset.toLatin1())"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "harset.toLatin1",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nString decodeByteArray(const QByteArray &encoded, const QString &charset)\n{\n    if (QTextCodec *codec = codecForName(charset.toLatin1())) {\n        return codec->toUnicode(encoded);\n    }\n    return QString::fromUtf8(encoded, encoded.size());\n}"
  },
  {
    "function_name": "ncodeRFC2047String(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "262-331",
    "snippet": "ByteArray encodeRFC2047String(const QString &text, const Rfc2047StringCharacterSetType charset)\n{\n    // We can't allow more than 75 chars per encoded-word, including the boiler plate (7 chars and the size of the encoding spec)\n    // -- this is defined by RFC2047.\n    int maximumEncoded = 75 - 7;\n    QByteArray encoding;\n    if (charset == RFC2047_STRING_UTF8)\n        encoding = \"utf-8\";\n    else\n        encoding = \"iso-8859-1\";\n    maximumEncoded -= encoding.size();\n\n    // If this is an encodedWord, we need to include any whitespace that we don't want to lose\n    if (charset == RFC2047_STRING_UTF8) {\n        QByteArray res;\n        int start = 0;\n\n        while (start < text.size()) {\n            // as long as we have something to work on...\n            int size = maximumEncoded;\n            QByteArray candidate;\n\n            // Find the character boundary at which we have to split the input.\n            // Remember that we're iterating on Unicode codepoints now, not on raw bytes.\n            while (true) {\n                candidate = text.mid(start, size).toUtf8();\n                int utf8Size = candidate.size();\n                int base64Size = utf8Size * 4 / 3 + utf8Size % 3;\n                if (base64Size <= maximumEncoded) {\n                    // if this chunk's size is small enough, great\n                    QByteArray encoded = candidate.toBase64();\n                    if (!res.isEmpty())\n                        res.append(\"\\r\\n \");\n                    res.append(\"=?utf-8?B?\" + encoded + \"?=\");\n                    start += size;\n                    break;\n                } else {\n                    // otherwise, try with something smaller\n                    --size;\n                    Q_ASSERT(size >= 1);\n                }\n            }\n        }\n        return res;\n    } else {\n        QByteArray buf = \"=?\" + encoding + \"?Q?\";\n        int i = 0;\n        int currentLineLength = 0;\n        while (i < text.size()) {\n            QByteArray symbol;\n            const ushort unicode = text[i].unicode();\n            if (unicode == 0x20) {\n                symbol = \"_\";\n            } else if (!rfc2047QPNeedsEscpaing(unicode)) {\n                symbol += text[i].toLatin1();\n            } else {\n                symbol = toHexChar(unicode, '=');\n            }\n            currentLineLength += symbol.size();\n            if (currentLineLength > maximumEncoded) {\n                buf += \"?=\\r\\n =?\" + encoding + \"?Q?\";\n                currentLineLength = 0;\n            }\n            buf += symbol;\n            ++i;\n        }\n        buf += \"?=\";\n        return buf;\n    }\n}",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ymbol.size",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oHexChar(",
          "args": [
            "nicode,",
            "=')"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "oHexChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "252-256",
          "snippet": "ByteArray toHexChar(const ushort unicode, char prefix)\n    {\n        const char hexChars[] = \"0123456789ABCDEF\";\n        return QByteArray() + prefix + hexChars[(unicode >> 4) & 0xf] + hexChars[unicode & 0xf];\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray toHexChar(const ushort unicode, char prefix)\n    {\n        const char hexChars[] = \"0123456789ABCDEF\";\n        return QByteArray() + prefix + hexChars[(unicode >> 4) & 0xf] + hexChars[unicode & 0xf];\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ext[i].toLatin1",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fc2047QPNeedsEscpaing(",
          "args": [
            "nicode)"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "fc2047QPNeedsEscpaing(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "63-72",
          "snippet": "tatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ext[i].unicode",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.size",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ize >= 1)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.append",
          "args": [
            "=?utf-8?B?\" + encoded + \"?=\")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.append",
          "args": [
            "\\r\\n \")"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.isEmpty",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andidate.toBase64",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andidate.size",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.mid",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.mid",
          "args": [
            "tart,",
            "ize)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext.size",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncoding.size",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeRFC2047String(const QString &text, const Rfc2047StringCharacterSetType charset)\n{\n    // We can't allow more than 75 chars per encoded-word, including the boiler plate (7 chars and the size of the encoding spec)\n    // -- this is defined by RFC2047.\n    int maximumEncoded = 75 - 7;\n    QByteArray encoding;\n    if (charset == RFC2047_STRING_UTF8)\n        encoding = \"utf-8\";\n    else\n        encoding = \"iso-8859-1\";\n    maximumEncoded -= encoding.size();\n\n    // If this is an encodedWord, we need to include any whitespace that we don't want to lose\n    if (charset == RFC2047_STRING_UTF8) {\n        QByteArray res;\n        int start = 0;\n\n        while (start < text.size()) {\n            // as long as we have something to work on...\n            int size = maximumEncoded;\n            QByteArray candidate;\n\n            // Find the character boundary at which we have to split the input.\n            // Remember that we're iterating on Unicode codepoints now, not on raw bytes.\n            while (true) {\n                candidate = text.mid(start, size).toUtf8();\n                int utf8Size = candidate.size();\n                int base64Size = utf8Size * 4 / 3 + utf8Size % 3;\n                if (base64Size <= maximumEncoded) {\n                    // if this chunk's size is small enough, great\n                    QByteArray encoded = candidate.toBase64();\n                    if (!res.isEmpty())\n                        res.append(\"\\r\\n \");\n                    res.append(\"=?utf-8?B?\" + encoded + \"?=\");\n                    start += size;\n                    break;\n                } else {\n                    // otherwise, try with something smaller\n                    --size;\n                    Q_ASSERT(size >= 1);\n                }\n            }\n        }\n        return res;\n    } else {\n        QByteArray buf = \"=?\" + encoding + \"?Q?\";\n        int i = 0;\n        int currentLineLength = 0;\n        while (i < text.size()) {\n            QByteArray symbol;\n            const ushort unicode = text[i].unicode();\n            if (unicode == 0x20) {\n                symbol = \"_\";\n            } else if (!rfc2047QPNeedsEscpaing(unicode)) {\n                symbol += text[i].toLatin1();\n            } else {\n                symbol = toHexChar(unicode, '=');\n            }\n            currentLineLength += symbol.size();\n            if (currentLineLength > maximumEncoded) {\n                buf += \"?=\\r\\n =?\" + encoding + \"?Q?\";\n                currentLineLength = 0;\n            }\n            buf += symbol;\n            ++i;\n        }\n        buf += \"?=\";\n        return buf;\n    }\n}"
  },
  {
    "function_name": "oHexChar(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "252-256",
    "snippet": "ByteArray toHexChar(const ushort unicode, char prefix)\n    {\n        const char hexChars[] = \"0123456789ABCDEF\";\n        return QByteArray() + prefix + hexChars[(unicode >> 4) & 0xf] + hexChars[unicode & 0xf];\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray toHexChar(const ushort unicode, char prefix)\n    {\n        const char hexChars[] = \"0123456789ABCDEF\";\n        return QByteArray() + prefix + hexChars[(unicode >> 4) & 0xf] + hexChars[unicode & 0xf];\n    }"
  },
  {
    "function_name": "ecodeWordSequence(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "207-250",
    "snippet": "tatic QString decodeWordSequence(const QByteArray& str)\n    {\n        QRegExp whitespace(\"^\\\\s+$\");\n\n        QString out;\n\n        // Any idea why this isn't matching?\n        //QRegExp encodedWord(\"\\\\b=\\\\?\\\\S+\\\\?\\\\S+\\\\?\\\\S*\\\\?=\\\\b\");\n        QRegExp encodedWord(\"\\\"?=\\\\?(\\\\S+)\\\\?(\\\\S+)\\\\?(.*)\\\\?=\\\"?\");\n\n        // set minimal=true, to match sequences which do not have whit space in between 2 encoded words; otherwise by default greedy matching is performed\n        // eg. \"Sm=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=sbord\" will match \"=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=\" as a single encoded word without minimal=true\n        // with minimal=true, \"=?ISO-8859-1?B?9g==?=\" will be the first encoded word and \"=?ISO-8859-1?B?5Q==?=\" the second.\n        // -- assuming there are no nested encodings, will there be?\n        encodedWord.setMinimal(true);\n\n        int pos = 0;\n        int lastPos = 0;\n\n        while (pos != -1) {\n            pos = encodedWord.indexIn(str, pos);\n            if (pos != -1) {\n                int endPos = pos + encodedWord.matchedLength();\n\n                QString preceding(str.mid(lastPos, (pos - lastPos)));\n                QString decoded = decodeWord(str.mid(pos, (endPos - pos)), encodedWord.cap(1).toLatin1(),\n                                             encodedWord.cap(2).toUpper().toLatin1(), encodedWord.cap(3).toLatin1());\n\n                // If there is only whitespace between two encoded words, it should not be included\n                if (!whitespace.exactMatch(preceding))\n                    out.append(preceding);\n\n                out.append(decoded);\n\n                pos = endPos;\n                lastPos = pos;\n            }\n        }\n\n        // Copy anything left\n        out.append(QString::fromUtf8(str.mid(lastPos)));\n\n        return out;\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "String::fromUtf8(str.mid(lastPos)))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "tr.mid(lastPos))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr.mid",
          "args": [
            "astPos)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "ecoded)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "receding)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hitespace.exactMatch",
          "args": [
            "receding)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecodeWord(",
          "args": [
            "tr.mid(pos, (endPos - pos)),",
            "ncodedWord.cap(1).toLatin1(),",
            "ncodedWord.cap(2).toUpper().toLatin1(),",
            "ncodedWord.cap(3).toLatin1())"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ecodeWord(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "195-204",
          "snippet": "tatic QString decodeWord(const QByteArray &fullWord, const QByteArray &charset, const QByteArray &encoding, const QByteArray &encoded)\n    {\n        if (encoding == \"Q\") {\n            return Imap::decodeByteArray(translateQuotedPrintableToBin(encoded), charset);\n        } else if (encoding == \"B\") {\n            return Imap::decodeByteArray(QByteArray::fromBase64(encoded), charset);\n        } else {\n            return fullWord;\n        }\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic QString decodeWord(const QByteArray &fullWord, const QByteArray &charset, const QByteArray &encoding, const QByteArray &encoded)\n    {\n        if (encoding == \"Q\") {\n            return Imap::decodeByteArray(translateQuotedPrintableToBin(encoded), charset);\n        } else if (encoding == \"B\") {\n            return Imap::decodeByteArray(QByteArray::fromBase64(encoded), charset);\n        } else {\n            return fullWord;\n        }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [
            ")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [
            ")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.cap",
          "args": [
            ")"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr.mid",
          "args": [
            "os,",
            "endPos - pos))"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr.mid",
          "args": [
            "astPos,",
            "pos - lastPos))"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.matchedLength",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.indexIn",
          "args": [
            "tr,",
            "os)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodedWord.setMinimal",
          "args": [
            "rue)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic QString decodeWordSequence(const QByteArray& str)\n    {\n        QRegExp whitespace(\"^\\\\s+$\");\n\n        QString out;\n\n        // Any idea why this isn't matching?\n        //QRegExp encodedWord(\"\\\\b=\\\\?\\\\S+\\\\?\\\\S+\\\\?\\\\S*\\\\?=\\\\b\");\n        QRegExp encodedWord(\"\\\"?=\\\\?(\\\\S+)\\\\?(\\\\S+)\\\\?(.*)\\\\?=\\\"?\");\n\n        // set minimal=true, to match sequences which do not have whit space in between 2 encoded words; otherwise by default greedy matching is performed\n        // eg. \"Sm=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=sbord\" will match \"=?ISO-8859-1?B?9g==?=rg=?ISO-8859-1?B?5Q==?=\" as a single encoded word without minimal=true\n        // with minimal=true, \"=?ISO-8859-1?B?9g==?=\" will be the first encoded word and \"=?ISO-8859-1?B?5Q==?=\" the second.\n        // -- assuming there are no nested encodings, will there be?\n        encodedWord.setMinimal(true);\n\n        int pos = 0;\n        int lastPos = 0;\n\n        while (pos != -1) {\n            pos = encodedWord.indexIn(str, pos);\n            if (pos != -1) {\n                int endPos = pos + encodedWord.matchedLength();\n\n                QString preceding(str.mid(lastPos, (pos - lastPos)));\n                QString decoded = decodeWord(str.mid(pos, (endPos - pos)), encodedWord.cap(1).toLatin1(),\n                                             encodedWord.cap(2).toUpper().toLatin1(), encodedWord.cap(3).toLatin1());\n\n                // If there is only whitespace between two encoded words, it should not be included\n                if (!whitespace.exactMatch(preceding))\n                    out.append(preceding);\n\n                out.append(decoded);\n\n                pos = endPos;\n                lastPos = pos;\n            }\n        }\n\n        // Copy anything left\n        out.append(QString::fromUtf8(str.mid(lastPos)));\n\n        return out;\n    }"
  },
  {
    "function_name": "ecodeWord(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "195-204",
    "snippet": "tatic QString decodeWord(const QByteArray &fullWord, const QByteArray &charset, const QByteArray &encoding, const QByteArray &encoded)\n    {\n        if (encoding == \"Q\") {\n            return Imap::decodeByteArray(translateQuotedPrintableToBin(encoded), charset);\n        } else if (encoding == \"B\") {\n            return Imap::decodeByteArray(QByteArray::fromBase64(encoded), charset);\n        } else {\n            return fullWord;\n        }\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map::decodeByteArray(",
          "args": [
            "ByteArray::fromBase64(encoded),",
            "harset)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::fromBase64(",
          "args": [
            "ncoded)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::decodeByteArray(",
          "args": [
            "ranslateQuotedPrintableToBin(encoded),",
            "harset)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslateQuotedPrintableToBin(",
          "args": [
            "ncoded)"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ranslateQuotedPrintableToBin(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "149-168",
          "snippet": "tatic inline QByteArray translateQuotedPrintableToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '_') {\n                res += ' ';\n            } else if (input[i] == '=' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline QByteArray translateQuotedPrintableToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '_') {\n                res += ' ';\n            } else if (input[i] == '=' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }"
        }
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic QString decodeWord(const QByteArray &fullWord, const QByteArray &charset, const QByteArray &encoding, const QByteArray &encoded)\n    {\n        if (encoding == \"Q\") {\n            return Imap::decodeByteArray(translateQuotedPrintableToBin(encoded), charset);\n        } else if (encoding == \"B\") {\n            return Imap::decodeByteArray(QByteArray::fromBase64(encoded), charset);\n        } else {\n            return fullWord;\n        }\n    }"
  },
  {
    "function_name": "ranslatePercentToBin(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "175-192",
    "snippet": "tatic inline QByteArray translatePercentToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '%' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nput.mid",
          "args": [
            "- 2,",
            ")"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<char>",
          "args": [
            "hi << 4) + lo)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exValueOfChar(",
          "args": [
            "nput[++i])"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "exValueOfChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "131-142",
          "snippet": "tatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "nput.size",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.size",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline QByteArray translatePercentToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '%' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }"
  },
  {
    "function_name": "ranslateQuotedPrintableToBin(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "149-168",
    "snippet": "tatic inline QByteArray translateQuotedPrintableToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '_') {\n                res += ' ';\n            } else if (input[i] == '=' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nput.mid",
          "args": [
            "- 2,",
            ")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<char>",
          "args": [
            "hi << 4) + lo)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exValueOfChar(",
          "args": [
            "nput[++i])"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "exValueOfChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "131-142",
          "snippet": "tatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "nput.size",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.size",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline QByteArray translateQuotedPrintableToBin(const QByteArray &input)\n    {\n        QByteArray res;\n        for (int i = 0; i < input.size(); ++i) {\n            if (input[i] == '_') {\n                res += ' ';\n            } else if (input[i] == '=' && i < input.size() - 2) {\n                int hi = hexValueOfChar(input[++i]);\n                int lo = hexValueOfChar(input[++i]);\n                if (hi != -1 && lo != -1) {\n                    res += static_cast<char>((hi << 4) + lo);\n                } else {\n                    res += input.mid(i - 2, 3);\n                }\n            } else {\n                res += input[i];\n            }\n        }\n        return res;\n    }"
  },
  {
    "function_name": "exValueOfChar(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "131-142",
    "snippet": "tatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }"
  },
  {
    "function_name": "harsetForInput(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "106-128",
    "snippet": "tatic Imap::Rfc2047StringCharacterSetType charsetForInput(const QString& input)\n    {\n        // shamelessly stolen from QMF's qmailmessage.cpp\n\n        // See if this input needs encoding\n        Imap::Rfc2047StringCharacterSetType latin1 = Imap::RFC2047_STRING_ASCII;\n\n        const QChar* it = input.constData();\n        const QChar* const end = it + input.length();\n        for ( ; it != end; ++it) {\n            if ((*it).unicode() > 0xff) {\n                // Multi-byte characters included - we need to use UTF-8\n                return Imap::RFC2047_STRING_UTF8;\n            }\n            else if (!latin1 && rfc2047QPNeedsEscpaing(it->unicode()))\n            {\n                // We need encoding from latin-1\n                latin1 = Imap::RFC2047_STRING_LATIN;\n            }\n        }\n\n        return latin1;\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fc2047QPNeedsEscpaing(",
          "args": [
            "t->unicode())"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "fc2047QPNeedsEscpaing(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "63-72",
          "snippet": "tatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "t->unicode",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*it).unicode",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.length",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.constData",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic Imap::Rfc2047StringCharacterSetType charsetForInput(const QString& input)\n    {\n        // shamelessly stolen from QMF's qmailmessage.cpp\n\n        // See if this input needs encoding\n        Imap::Rfc2047StringCharacterSetType latin1 = Imap::RFC2047_STRING_ASCII;\n\n        const QChar* it = input.constData();\n        const QChar* const end = it + input.length();\n        for ( ; it != end; ++it) {\n            if ((*it).unicode() > 0xff) {\n                // Multi-byte characters included - we need to use UTF-8\n                return Imap::RFC2047_STRING_UTF8;\n            }\n            else if (!latin1 && rfc2047QPNeedsEscpaing(it->unicode()))\n            {\n                // We need encoding from latin-1\n                latin1 = Imap::RFC2047_STRING_LATIN;\n            }\n        }\n\n        return latin1;\n    }"
  },
  {
    "function_name": "fc2311NeedsEscaping(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "78-99",
    "snippet": "tatic inline bool rfc2311NeedsEscaping(const int unicode)\n    {\n        const unsigned char Ascii_Zero = 0x30;\n        const unsigned char Ascii_Nine = 0x39;\n        const unsigned char Ascii_A = 0x41;\n        const unsigned char Ascii_Z = 0x5a;\n        const unsigned char Ascii_a = 0x61;\n        const unsigned char Ascii_z = 0x7a;\n        const unsigned char Ascii_Minus = 0x2d;\n        const unsigned char Ascii_Dot = 0x2e;\n        const unsigned char Ascii_Underscore = 0x5f;\n\n        if (unicode == Ascii_Minus || unicode == Ascii_Dot || unicode == Ascii_Underscore)\n            return false;\n        if (unicode >= Ascii_Zero && unicode <= Ascii_Nine)\n            return false;\n        if (unicode >= Ascii_A && unicode <= Ascii_Z)\n            return false;\n        if (unicode >= Ascii_a && unicode <= Ascii_z)\n            return false;\n        return true;\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline bool rfc2311NeedsEscaping(const int unicode)\n    {\n        const unsigned char Ascii_Zero = 0x30;\n        const unsigned char Ascii_Nine = 0x39;\n        const unsigned char Ascii_A = 0x41;\n        const unsigned char Ascii_Z = 0x5a;\n        const unsigned char Ascii_a = 0x61;\n        const unsigned char Ascii_z = 0x7a;\n        const unsigned char Ascii_Minus = 0x2d;\n        const unsigned char Ascii_Dot = 0x2e;\n        const unsigned char Ascii_Underscore = 0x5f;\n\n        if (unicode == Ascii_Minus || unicode == Ascii_Dot || unicode == Ascii_Underscore)\n            return false;\n        if (unicode >= Ascii_Zero && unicode <= Ascii_Nine)\n            return false;\n        if (unicode >= Ascii_A && unicode <= Ascii_Z)\n            return false;\n        if (unicode >= Ascii_a && unicode <= Ascii_z)\n            return false;\n        return true;\n    }"
  },
  {
    "function_name": "fc2047QPNeedsEscpaing(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
    "lines": "63-72",
    "snippet": "tatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }",
    "includes": [
      "include \"Parser/3rdparty/kcodecs.h\"",
      "include \"Parser/3rdparty/rfccodecs.h\"\n#",
      "include \"Encoders.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline bool rfc2047QPNeedsEscpaing(const int unicode)\n    {\n        if (unicode <= Space)\n            return true;\n        if (unicode == Equals || unicode == QuestionMark || unicode == Underscore)\n            return true;\n        if (unicode > MaxPrintableRange)\n            return true;\n        return false;\n    }"
  }
]