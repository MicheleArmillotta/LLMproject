[
  {
    "function_name": "parse",
    "container": "QMimeTypeParserBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
    "lines": "204-339",
    "snippet": "bool QMimeTypeParserBase::parse(QIODevice *dev, const QString &fileName, QString *errorMessage)\n{\n    QMimeTypePrivate data;\n    int priority = 50;\n    QStack<QMimeMagicRule *> currentRules; // stack for the nesting of rules\n    QList<QMimeMagicRule> rules; // toplevel rules\n    QXmlStreamReader reader(dev);\n    ParseState ps = ParseBeginning;\n    QXmlStreamAttributes atts;\n    while (!reader.atEnd()) {\n        switch (reader.readNext()) {\n        case QXmlStreamReader::StartElement:\n            ps = nextState(ps, reader.name());\n            atts = reader.attributes();\n            switch (ps) {\n            case ParseMimeType: { // start parsing a MIME type name\n                const QString name = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                if (name.isEmpty()) {\n                    reader.raiseError(QString::fromLatin1(\"Missing '%1'-attribute\").arg(QString::fromLatin1(mimeTypeAttributeC)));\n                } else {\n                    data.name = name;\n                }\n            }\n                break;\n            case ParseGenericIcon:\n                data.genericIconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                break;\n            case ParseIcon:\n                data.iconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                break;\n            case ParseGlobPattern: {\n                const QString pattern = atts.value(QLatin1String(patternAttributeC)).toString();\n                unsigned weight = atts.value(QLatin1String(weightAttributeC)).toString().toInt();\n                const bool caseSensitive = atts.value(QLatin1String(caseSensitiveAttributeC)).toString() == QLatin1String(\"true\");\n\n                if (weight == 0)\n                    weight = QMimeGlobPattern::DefaultWeight;\n\n                Q_ASSERT(!data.name.isEmpty());\n                const QMimeGlobPattern glob(pattern, data.name, weight, caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive);\n                if (!process(glob, errorMessage))   // for actual glob matching\n                    return false;\n                data.addGlobPattern(pattern); // just for QMimeType::globPatterns()\n            }\n                break;\n            case ParseSubClass: {\n                const QString inheritsFrom = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                if (!inheritsFrom.isEmpty())\n                    processParent(data.name, inheritsFrom);\n            }\n                break;\n            case ParseComment: {\n                // comments have locale attributes. We want the default, English one\n                QString locale = atts.value(QLatin1String(localeAttributeC)).toString();\n                const QString comment = reader.readElementText();\n                if (locale.isEmpty())\n                    locale = QString::fromLatin1(\"en_US\");\n                data.localeComments.insert(locale, comment);\n            }\n                break;\n            case ParseAlias: {\n                const QString alias = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                if (!alias.isEmpty())\n                    processAlias(alias, data.name);\n            }\n                break;\n            case ParseMagic: {\n                priority = 50;\n                const QString priorityS = atts.value(QLatin1String(priorityAttributeC)).toString();\n                if (!priorityS.isEmpty()) {\n                    if (!parseNumber(priorityS, &priority, errorMessage))\n                        return false;\n\n                }\n                currentRules.clear();\n                //qDebug() << \"MAGIC start for mimetype\" << data.name;\n            }\n                break;\n            case ParseMagicMatchRule: {\n                QMimeMagicRule *rule = 0;\n                if (!createMagicMatchRule(atts, errorMessage, rule))\n                    return false;\n                QList<QMimeMagicRule> *ruleList;\n                if (currentRules.isEmpty())\n                    ruleList = &rules;\n                else // nest this rule into the proper parent\n                    ruleList = &currentRules.top()->m_subMatches;\n                ruleList->append(*rule);\n                //qDebug() << \" MATCH added. Stack size was\" << currentRules.size();\n                currentRules.push(&ruleList->last());\n                delete rule;\n                break;\n            }\n            case ParseError:\n                reader.raiseError(QString::fromLatin1(\"Unexpected element <%1>\").\n                                  arg(reader.name().toString()));\n                break;\n            default:\n                break;\n            }\n            break;\n        // continue switch QXmlStreamReader::Token...\n        case QXmlStreamReader::EndElement: // Finished element\n        {\n            const QStringRef elementName = reader.name();\n            if (elementName == QLatin1String(mimeTypeTagC)) {\n                if (!process(QMimeType(data), errorMessage))\n                    return false;\n                data.clear();\n            } else if (elementName == QLatin1String(matchTagC)) {\n                // Closing a <match> tag, pop stack\n                currentRules.pop();\n                //qDebug() << \" MATCH closed. Stack size is now\" << currentRules.size();\n            } else if (elementName == QLatin1String(magicTagC)) {\n                //qDebug() << \"MAGIC ended, we got\" << rules.count() << \"rules, with prio\" << priority;\n                // Finished a <magic> sequence\n                QMimeMagicRuleMatcher ruleMatcher(data.name, priority);\n                ruleMatcher.addRules(rules);\n                processMagicMatcher(ruleMatcher);\n                rules.clear();\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    if (reader.hasError()) {\n        if (errorMessage)\n            *errorMessage = QString::fromLatin1(\"An error has been encountered at line %1 of %2: %3:\").arg(reader.lineNumber()).arg(fileName, reader.errorString());\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <QStack>",
      "#include <QXmlStreamWriter>",
      "#include <QXmlStreamReader>",
      "#include <QPair>",
      "#include <QDir>",
      "#include <QDebug>",
      "#include <QCoreApplication>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimetypeparser_p.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char mimeTypeTagC[] = \"mime-type\";",
      "static const char mimeTypeAttributeC[] = \"type\";",
      "static const char nameAttributeC[] = \"name\";",
      "static const char patternAttributeC[] = \"pattern\";",
      "static const char weightAttributeC[] = \"weight\";",
      "static const char caseSensitiveAttributeC[] = \"case-sensitive\";",
      "static const char localeAttributeC[] = \"xml:lang\";",
      "static const char magicTagC[] = \"magic\";",
      "static const char priorityAttributeC[] = \"priority\";",
      "static const char matchTagC[] = \"match\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "fileName",
            "reader.errorString()"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.errorString",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "errorString",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "712-714",
          "snippet": "QString QwwSmtpClient::errorString() const{\n    return d->errorString;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  QString QwwSmtpClient::errorString() const{\n      return d->errorString;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "reader.lineNumber()"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.lineNumber",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"An error has been encountered at line %1 of %2: %3:\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.hasError",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rules.clear",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "processMagicMatcher",
          "args": [
            "ruleMatcher"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "processMagicMatcher",
          "container": "QMimeTypeParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser_p.h",
          "lines": "109-110",
          "snippet": "inline void processMagicMatcher(const QMimeMagicRuleMatcher &matcher)\n    { m_provider.addMagicMatcher(matcher); }",
          "includes": [
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n\nQMimeTypeParser {\n  inline void processMagicMatcher(const QMimeMagicRuleMatcher &matcher)\n      { m_provider.addMagicMatcher(matcher); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ruleMatcher.addRules",
          "args": [
            "rules"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "addRules",
          "container": "QMimeMagicRuleMatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrulematcher.cpp",
          "lines": "80-83",
          "snippet": "void QMimeMagicRuleMatcher::addRules(const QList<QMimeMagicRule> &rules)\n{\n    m_list.append(rules);\n}",
          "includes": [
            "#include \"qmimetype_p.h\"",
            "#include \"qmimemagicrulematcher_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimetype_p.h\"\n#include \"qmimemagicrulematcher_p.h\"\n\nQMimeMagicRuleMatcher {\n  void QMimeMagicRuleMatcher::addRules(const QList<QMimeMagicRule> &rules)\n  {\n      m_list.append(rules);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "magicTagC"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentRules.pop",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchTagC"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process",
          "args": [
            "QMimeType(data)",
            "errorMessage"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "processAlias",
          "container": "QMimeTypeParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser_p.h",
          "lines": "106-107",
          "snippet": "inline void processAlias(const QString &alias, const QString &name)\n    { m_provider.addAlias(alias, name); }",
          "includes": [
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n\nQMimeTypeParser {\n  inline void processAlias(const QString &alias, const QString &name)\n      { m_provider.addAlias(alias, name); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QMimeType",
          "args": [
            "data"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "inherits",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "414-419",
          "snippet": "bool QMimeType::inherits(const QString &mimeTypeName) const\n{\n    if (d->name == mimeTypeName)\n        return true;\n    return QMimeDatabasePrivate::instance()->inherits(d->name, mimeTypeName);\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  bool QMimeType::inherits(const QString &mimeTypeName) const\n  {\n      if (d->name == mimeTypeName)\n          return true;\n      return QMimeDatabasePrivate::instance()->inherits(d->name, mimeTypeName);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeTagC"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.name",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "208-211",
          "snippet": "QString QMimeType::name() const\n{\n    return d->name;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::name() const\n  {\n      return d->name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.raiseError",
          "args": [
            "QString::fromLatin1(\"Unexpected element <%1>\").\n                                  arg(reader.name().toString())"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "reader.name().toString()"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"Unexpected element <%1>\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentRules.push",
          "args": [
            "&ruleList->last()"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ruleList->last",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ruleList->append",
          "args": [
            "*rule"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentRules.top",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentRules.isEmpty",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createMagicMatchRule",
          "args": [
            "atts",
            "errorMessage",
            "rule"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "createMagicMatchRule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
          "lines": "175-202",
          "snippet": "static bool createMagicMatchRule(const QXmlStreamAttributes &atts,\n                                 QString *errorMessage, QMimeMagicRule *&rule)\n{\n    const QString type = atts.value(QLatin1String(matchTypeAttributeC)).toString();\n    QMimeMagicRule::Type magicType = QMimeMagicRule::type(type.toLatin1());\n    if (magicType == QMimeMagicRule::Invalid) {\n        qWarning(\"%s: match type %s is not supported.\", Q_FUNC_INFO, type.toUtf8().constData());\n        return true;\n    }\n    const QString value = atts.value(QLatin1String(matchValueAttributeC)).toString();\n    if (value.isEmpty()) {\n        *errorMessage = QString::fromLatin1(\"Empty match value detected.\");\n        return false;\n    }\n    // Parse for offset as \"1\" or \"1:10\"\n    int startPos, endPos;\n    const QString offsetS = atts.value(QLatin1String(matchOffsetAttributeC)).toString();\n    const int colonIndex = offsetS.indexOf(QLatin1Char(':'));\n    const QString startPosS = colonIndex == -1 ? offsetS : offsetS.mid(0, colonIndex);\n    const QString endPosS   = colonIndex == -1 ? offsetS : offsetS.mid(colonIndex + 1);\n    if (!parseNumber(startPosS, &startPos, errorMessage) || !parseNumber(endPosS, &endPos, errorMessage))\n        return false;\n    const QString mask = atts.value(QLatin1String(matchMaskAttributeC)).toString();\n\n    rule = new QMimeMagicRule(magicType, value.toUtf8(), startPos, endPos, mask.toLatin1());\n\n    return true;\n}",
          "includes": [
            "#include <QStack>",
            "#include <QXmlStreamWriter>",
            "#include <QXmlStreamReader>",
            "#include <QPair>",
            "#include <QDir>",
            "#include <QDebug>",
            "#include <QCoreApplication>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetypeparser_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char matchValueAttributeC[] = \"value\";",
            "static const char matchTypeAttributeC[] = \"type\";",
            "static const char matchOffsetAttributeC[] = \"offset\";",
            "static const char matchMaskAttributeC[] = \"mask\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic const char matchValueAttributeC[] = \"value\";\nstatic const char matchTypeAttributeC[] = \"type\";\nstatic const char matchOffsetAttributeC[] = \"offset\";\nstatic const char matchMaskAttributeC[] = \"mask\";\n\nstatic bool createMagicMatchRule(const QXmlStreamAttributes &atts,\n                                 QString *errorMessage, QMimeMagicRule *&rule)\n{\n    const QString type = atts.value(QLatin1String(matchTypeAttributeC)).toString();\n    QMimeMagicRule::Type magicType = QMimeMagicRule::type(type.toLatin1());\n    if (magicType == QMimeMagicRule::Invalid) {\n        qWarning(\"%s: match type %s is not supported.\", Q_FUNC_INFO, type.toUtf8().constData());\n        return true;\n    }\n    const QString value = atts.value(QLatin1String(matchValueAttributeC)).toString();\n    if (value.isEmpty()) {\n        *errorMessage = QString::fromLatin1(\"Empty match value detected.\");\n        return false;\n    }\n    // Parse for offset as \"1\" or \"1:10\"\n    int startPos, endPos;\n    const QString offsetS = atts.value(QLatin1String(matchOffsetAttributeC)).toString();\n    const int colonIndex = offsetS.indexOf(QLatin1Char(':'));\n    const QString startPosS = colonIndex == -1 ? offsetS : offsetS.mid(0, colonIndex);\n    const QString endPosS   = colonIndex == -1 ? offsetS : offsetS.mid(colonIndex + 1);\n    if (!parseNumber(startPosS, &startPos, errorMessage) || !parseNumber(endPosS, &endPos, errorMessage))\n        return false;\n    const QString mask = atts.value(QLatin1String(matchMaskAttributeC)).toString();\n\n    rule = new QMimeMagicRule(magicType, value.toUtf8(), startPos, endPos, mask.toLatin1());\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseNumber",
          "args": [
            "priorityS",
            "&priority",
            "errorMessage"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "parseNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
          "lines": "161-170",
          "snippet": "static bool parseNumber(const QString &n, int *target, QString *errorMessage)\n{\n    bool ok;\n    *target = n.toInt(&ok);\n    if (!ok) {\n        *errorMessage = QString::fromLatin1(\"Not a number '%1'.\").arg(n);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <QStack>",
            "#include <QXmlStreamWriter>",
            "#include <QXmlStreamReader>",
            "#include <QPair>",
            "#include <QDir>",
            "#include <QDebug>",
            "#include <QCoreApplication>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetypeparser_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic bool parseNumber(const QString &n, int *target, QString *errorMessage)\n{\n    bool ok;\n    *target = n.toInt(&ok);\n    if (!ok) {\n        *errorMessage = QString::fromLatin1(\"Not a number '%1'.\").arg(n);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "priorityS.isEmpty",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atts.value",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atts.value",
          "args": [
            "QLatin1String(priorityAttributeC)"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "priorityAttributeC"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alias.isEmpty",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeAttributeC"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.localeComments.insert",
          "args": [
            "locale",
            "comment"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"en_US\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locale.isEmpty",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.readElementText",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "localeAttributeC"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "processParent",
          "args": [
            "data.name",
            "inheritsFrom"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "processParent",
          "container": "QMimeTypeParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser_p.h",
          "lines": "103-104",
          "snippet": "inline void processParent(const QString &child, const QString &parent)\n    { m_provider.addParent(child, parent); }",
          "includes": [
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n\nQMimeTypeParser {\n  inline void processParent(const QString &child, const QString &parent)\n      { m_provider.addParent(child, parent); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inheritsFrom.isEmpty",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeAttributeC"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.addGlobPattern",
          "args": [
            "pattern"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "addGlobPattern",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "786-789",
          "snippet": "void QMimeXMLProvider::addGlobPattern(const QMimeGlobPattern &glob)\n{\n    m_mimeTypeGlobs.addGlob(glob);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addGlobPattern(const QMimeGlobPattern &glob)\n  {\n      m_mimeTypeGlobs.addGlob(glob);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "!data.name.isEmpty()"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.name.isEmpty",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"true\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "caseSensitiveAttributeC"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "weightAttributeC"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "patternAttributeC"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "nameAttributeC"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "nameAttributeC"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.raiseError",
          "args": [
            "QString::fromLatin1(\"Missing '%1'-attribute\").arg(QString::fromLatin1(mimeTypeAttributeC))"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "QString::fromLatin1(mimeTypeAttributeC)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "mimeTypeAttributeC"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"Missing '%1'-attribute\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.isEmpty",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeAttributeC"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.attributes",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextState",
          "args": [
            "ps",
            "reader.name()"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "nextState",
          "container": "QMimeTypeParserBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
          "lines": "111-158",
          "snippet": "QMimeTypeParserBase::ParseState QMimeTypeParserBase::nextState(ParseState currentState, const QStringRef &startElement)\n{\n    switch (currentState) {\n    case ParseBeginning:\n        if (startElement == QLatin1String(mimeInfoTagC))\n            return ParseMimeInfo;\n        if (startElement == QLatin1String(mimeTypeTagC))\n            return ParseMimeType;\n        return ParseError;\n    case ParseMimeInfo:\n        return startElement == QLatin1String(mimeTypeTagC) ? ParseMimeType : ParseError;\n    case ParseMimeType:\n    case ParseComment:\n    case ParseGenericIcon:\n    case ParseIcon:\n    case ParseGlobPattern:\n    case ParseSubClass:\n    case ParseAlias:\n    case ParseOtherMimeTypeSubTag:\n    case ParseMagicMatchRule:\n        if (startElement == QLatin1String(mimeTypeTagC)) // Sequence of <mime-type>\n            return ParseMimeType;\n        if (startElement == QLatin1String(commentTagC ))\n            return ParseComment;\n        if (startElement == QLatin1String(genericIconTagC))\n            return ParseGenericIcon;\n        if (startElement == QLatin1String(iconTagC))\n            return ParseIcon;\n        if (startElement == QLatin1String(globTagC))\n            return ParseGlobPattern;\n        if (startElement == QLatin1String(subClassTagC))\n            return ParseSubClass;\n        if (startElement == QLatin1String(aliasTagC))\n            return ParseAlias;\n        if (startElement == QLatin1String(magicTagC))\n            return ParseMagic;\n        if (startElement == QLatin1String(matchTagC))\n            return ParseMagicMatchRule;\n        return ParseOtherMimeTypeSubTag;\n    case ParseMagic:\n        if (startElement == QLatin1String(matchTagC))\n            return ParseMagicMatchRule;\n        break;\n    case ParseError:\n        break;\n    }\n    return ParseError;\n}",
          "includes": [
            "#include <QStack>",
            "#include <QXmlStreamWriter>",
            "#include <QXmlStreamReader>",
            "#include <QPair>",
            "#include <QDir>",
            "#include <QDebug>",
            "#include <QCoreApplication>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetypeparser_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\n// XML tags in MIME files\nstatic const char mimeInfoTagC[] = \"mime-info\";",
            "static const char mimeTypeTagC[] = \"mime-type\";",
            "static const char subClassTagC[] = \"sub-class-of\";",
            "static const char commentTagC[] = \"comment\";",
            "static const char genericIconTagC[] = \"generic-icon\";",
            "static const char iconTagC[] = \"icon\";",
            "static const char globTagC[] = \"glob\";",
            "static const char aliasTagC[] = \"alias\";",
            "static const char magicTagC[] = \"magic\";",
            "static const char matchTagC[] = \"match\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nQT_BEGIN_NAMESPACE\n\n// XML tags in MIME files\nstatic const char mimeInfoTagC[] = \"mime-info\";\nstatic const char mimeTypeTagC[] = \"mime-type\";\nstatic const char subClassTagC[] = \"sub-class-of\";\nstatic const char commentTagC[] = \"comment\";\nstatic const char genericIconTagC[] = \"generic-icon\";\nstatic const char iconTagC[] = \"icon\";\nstatic const char globTagC[] = \"glob\";\nstatic const char aliasTagC[] = \"alias\";\nstatic const char magicTagC[] = \"magic\";\nstatic const char matchTagC[] = \"match\";\n\nQMimeTypeParserBase {\n  QMimeTypeParserBase::ParseState QMimeTypeParserBase::nextState(ParseState currentState, const QStringRef &startElement)\n  {\n      switch (currentState) {\n      case ParseBeginning:\n          if (startElement == QLatin1String(mimeInfoTagC))\n              return ParseMimeInfo;\n          if (startElement == QLatin1String(mimeTypeTagC))\n              return ParseMimeType;\n          return ParseError;\n      case ParseMimeInfo:\n          return startElement == QLatin1String(mimeTypeTagC) ? ParseMimeType : ParseError;\n      case ParseMimeType:\n      case ParseComment:\n      case ParseGenericIcon:\n      case ParseIcon:\n      case ParseGlobPattern:\n      case ParseSubClass:\n      case ParseAlias:\n      case ParseOtherMimeTypeSubTag:\n      case ParseMagicMatchRule:\n          if (startElement == QLatin1String(mimeTypeTagC)) // Sequence of <mime-type>\n              return ParseMimeType;\n          if (startElement == QLatin1String(commentTagC ))\n              return ParseComment;\n          if (startElement == QLatin1String(genericIconTagC))\n              return ParseGenericIcon;\n          if (startElement == QLatin1String(iconTagC))\n              return ParseIcon;\n          if (startElement == QLatin1String(globTagC))\n              return ParseGlobPattern;\n          if (startElement == QLatin1String(subClassTagC))\n              return ParseSubClass;\n          if (startElement == QLatin1String(aliasTagC))\n              return ParseAlias;\n          if (startElement == QLatin1String(magicTagC))\n              return ParseMagic;\n          if (startElement == QLatin1String(matchTagC))\n              return ParseMagicMatchRule;\n          return ParseOtherMimeTypeSubTag;\n      case ParseMagic:\n          if (startElement == QLatin1String(matchTagC))\n              return ParseMagicMatchRule;\n          break;\n      case ParseError:\n          break;\n      }\n      return ParseError;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.readNext",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.atEnd",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic const char mimeTypeTagC[] = \"mime-type\";\nstatic const char mimeTypeAttributeC[] = \"type\";\nstatic const char nameAttributeC[] = \"name\";\nstatic const char patternAttributeC[] = \"pattern\";\nstatic const char weightAttributeC[] = \"weight\";\nstatic const char caseSensitiveAttributeC[] = \"case-sensitive\";\nstatic const char localeAttributeC[] = \"xml:lang\";\nstatic const char magicTagC[] = \"magic\";\nstatic const char priorityAttributeC[] = \"priority\";\nstatic const char matchTagC[] = \"match\";\n\nQMimeTypeParserBase {\n  bool QMimeTypeParserBase::parse(QIODevice *dev, const QString &fileName, QString *errorMessage)\n  {\n      QMimeTypePrivate data;\n      int priority = 50;\n      QStack<QMimeMagicRule *> currentRules; // stack for the nesting of rules\n      QList<QMimeMagicRule> rules; // toplevel rules\n      QXmlStreamReader reader(dev);\n      ParseState ps = ParseBeginning;\n      QXmlStreamAttributes atts;\n      while (!reader.atEnd()) {\n          switch (reader.readNext()) {\n          case QXmlStreamReader::StartElement:\n              ps = nextState(ps, reader.name());\n              atts = reader.attributes();\n              switch (ps) {\n              case ParseMimeType: { // start parsing a MIME type name\n                  const QString name = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                  if (name.isEmpty()) {\n                      reader.raiseError(QString::fromLatin1(\"Missing '%1'-attribute\").arg(QString::fromLatin1(mimeTypeAttributeC)));\n                  } else {\n                      data.name = name;\n                  }\n              }\n                  break;\n              case ParseGenericIcon:\n                  data.genericIconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                  break;\n              case ParseIcon:\n                  data.iconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                  break;\n              case ParseGlobPattern: {\n                  const QString pattern = atts.value(QLatin1String(patternAttributeC)).toString();\n                  unsigned weight = atts.value(QLatin1String(weightAttributeC)).toString().toInt();\n                  const bool caseSensitive = atts.value(QLatin1String(caseSensitiveAttributeC)).toString() == QLatin1String(\"true\");\n  \n                  if (weight == 0)\n                      weight = QMimeGlobPattern::DefaultWeight;\n  \n                  Q_ASSERT(!data.name.isEmpty());\n                  const QMimeGlobPattern glob(pattern, data.name, weight, caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive);\n                  if (!process(glob, errorMessage))   // for actual glob matching\n                      return false;\n                  data.addGlobPattern(pattern); // just for QMimeType::globPatterns()\n              }\n                  break;\n              case ParseSubClass: {\n                  const QString inheritsFrom = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                  if (!inheritsFrom.isEmpty())\n                      processParent(data.name, inheritsFrom);\n              }\n                  break;\n              case ParseComment: {\n                  // comments have locale attributes. We want the default, English one\n                  QString locale = atts.value(QLatin1String(localeAttributeC)).toString();\n                  const QString comment = reader.readElementText();\n                  if (locale.isEmpty())\n                      locale = QString::fromLatin1(\"en_US\");\n                  data.localeComments.insert(locale, comment);\n              }\n                  break;\n              case ParseAlias: {\n                  const QString alias = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                  if (!alias.isEmpty())\n                      processAlias(alias, data.name);\n              }\n                  break;\n              case ParseMagic: {\n                  priority = 50;\n                  const QString priorityS = atts.value(QLatin1String(priorityAttributeC)).toString();\n                  if (!priorityS.isEmpty()) {\n                      if (!parseNumber(priorityS, &priority, errorMessage))\n                          return false;\n  \n                  }\n                  currentRules.clear();\n                  //qDebug() << \"MAGIC start for mimetype\" << data.name;\n              }\n                  break;\n              case ParseMagicMatchRule: {\n                  QMimeMagicRule *rule = 0;\n                  if (!createMagicMatchRule(atts, errorMessage, rule))\n                      return false;\n                  QList<QMimeMagicRule> *ruleList;\n                  if (currentRules.isEmpty())\n                      ruleList = &rules;\n                  else // nest this rule into the proper parent\n                      ruleList = &currentRules.top()->m_subMatches;\n                  ruleList->append(*rule);\n                  //qDebug() << \" MATCH added. Stack size was\" << currentRules.size();\n                  currentRules.push(&ruleList->last());\n                  delete rule;\n                  break;\n              }\n              case ParseError:\n                  reader.raiseError(QString::fromLatin1(\"Unexpected element <%1>\").\n                                    arg(reader.name().toString()));\n                  break;\n              default:\n                  break;\n              }\n              break;\n          // continue switch QXmlStreamReader::Token...\n          case QXmlStreamReader::EndElement: // Finished element\n          {\n              const QStringRef elementName = reader.name();\n              if (elementName == QLatin1String(mimeTypeTagC)) {\n                  if (!process(QMimeType(data), errorMessage))\n                      return false;\n                  data.clear();\n              } else if (elementName == QLatin1String(matchTagC)) {\n                  // Closing a <match> tag, pop stack\n                  currentRules.pop();\n                  //qDebug() << \" MATCH closed. Stack size is now\" << currentRules.size();\n              } else if (elementName == QLatin1String(magicTagC)) {\n                  //qDebug() << \"MAGIC ended, we got\" << rules.count() << \"rules, with prio\" << priority;\n                  // Finished a <magic> sequence\n                  QMimeMagicRuleMatcher ruleMatcher(data.name, priority);\n                  ruleMatcher.addRules(rules);\n                  processMagicMatcher(ruleMatcher);\n                  rules.clear();\n              }\n              break;\n          }\n          default:\n              break;\n          }\n      }\n  \n      if (reader.hasError()) {\n          if (errorMessage)\n              *errorMessage = QString::fromLatin1(\"An error has been encountered at line %1 of %2: %3:\").arg(reader.lineNumber()).arg(fileName, reader.errorString());\n          return false;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "createMagicMatchRule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
    "lines": "175-202",
    "snippet": "static bool createMagicMatchRule(const QXmlStreamAttributes &atts,\n                                 QString *errorMessage, QMimeMagicRule *&rule)\n{\n    const QString type = atts.value(QLatin1String(matchTypeAttributeC)).toString();\n    QMimeMagicRule::Type magicType = QMimeMagicRule::type(type.toLatin1());\n    if (magicType == QMimeMagicRule::Invalid) {\n        qWarning(\"%s: match type %s is not supported.\", Q_FUNC_INFO, type.toUtf8().constData());\n        return true;\n    }\n    const QString value = atts.value(QLatin1String(matchValueAttributeC)).toString();\n    if (value.isEmpty()) {\n        *errorMessage = QString::fromLatin1(\"Empty match value detected.\");\n        return false;\n    }\n    // Parse for offset as \"1\" or \"1:10\"\n    int startPos, endPos;\n    const QString offsetS = atts.value(QLatin1String(matchOffsetAttributeC)).toString();\n    const int colonIndex = offsetS.indexOf(QLatin1Char(':'));\n    const QString startPosS = colonIndex == -1 ? offsetS : offsetS.mid(0, colonIndex);\n    const QString endPosS   = colonIndex == -1 ? offsetS : offsetS.mid(colonIndex + 1);\n    if (!parseNumber(startPosS, &startPos, errorMessage) || !parseNumber(endPosS, &endPos, errorMessage))\n        return false;\n    const QString mask = atts.value(QLatin1String(matchMaskAttributeC)).toString();\n\n    rule = new QMimeMagicRule(magicType, value.toUtf8(), startPos, endPos, mask.toLatin1());\n\n    return true;\n}",
    "includes": [
      "#include <QStack>",
      "#include <QXmlStreamWriter>",
      "#include <QXmlStreamReader>",
      "#include <QPair>",
      "#include <QDir>",
      "#include <QDebug>",
      "#include <QCoreApplication>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimetypeparser_p.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char matchValueAttributeC[] = \"value\";",
      "static const char matchTypeAttributeC[] = \"type\";",
      "static const char matchOffsetAttributeC[] = \"offset\";",
      "static const char matchMaskAttributeC[] = \"mask\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mask.toLatin1",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.toUtf8",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atts.value",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atts.value",
          "args": [
            "QLatin1String(matchMaskAttributeC)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchMaskAttributeC"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseNumber",
          "args": [
            "endPosS",
            "&endPos",
            "errorMessage"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "parseNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
          "lines": "161-170",
          "snippet": "static bool parseNumber(const QString &n, int *target, QString *errorMessage)\n{\n    bool ok;\n    *target = n.toInt(&ok);\n    if (!ok) {\n        *errorMessage = QString::fromLatin1(\"Not a number '%1'.\").arg(n);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <QStack>",
            "#include <QXmlStreamWriter>",
            "#include <QXmlStreamReader>",
            "#include <QPair>",
            "#include <QDir>",
            "#include <QDebug>",
            "#include <QCoreApplication>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetypeparser_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic bool parseNumber(const QString &n, int *target, QString *errorMessage)\n{\n    bool ok;\n    *target = n.toInt(&ok);\n    if (!ok) {\n        *errorMessage = QString::fromLatin1(\"Not a number '%1'.\").arg(n);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "offsetS.mid",
          "args": [
            "colonIndex + 1"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetS.mid",
          "args": [
            "0",
            "colonIndex"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetS.indexOf",
          "args": [
            "QLatin1Char(':')"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "':'"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchOffsetAttributeC"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"Empty match value detected.\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.isEmpty",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchValueAttributeC"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [
            "\"%s: match type %s is not supported.\"",
            "Q_FUNC_INFO",
            "type.toUtf8().constData()"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.toUtf8",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.toUtf8",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QMimeMagicRule::type",
          "args": [
            "type.toLatin1()"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "typeName",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "79-82",
          "snippet": "QByteArray QMimeMagicRule::typeName(QMimeMagicRule::Type theType)\n{\n    return magicRuleTypes_string + magicRuleTypes_indices[theType];\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\n// in the same order as Type!\nstatic const char magicRuleTypes_string[] =\n    \"invalid\\0\"\n    \"string\\0\"\n    \"host16\\0\"\n    \"host32\\0\"\n    \"big16\\0\"\n    \"big32\\0\"\n    \"little16\\0\"\n    \"little32\\0\"\n    \"byte\\0\"\n    \"\\0\";",
            "static const int magicRuleTypes_indices[] = {\n    0, 8, 15, 22, 29, 35, 41, 50, 59, 65, 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQT_BEGIN_NAMESPACE\n\n// in the same order as Type!\nstatic const char magicRuleTypes_string[] =\n    \"invalid\\0\"\n    \"string\\0\"\n    \"host16\\0\"\n    \"host32\\0\"\n    \"big16\\0\"\n    \"big32\\0\"\n    \"little16\\0\"\n    \"little32\\0\"\n    \"byte\\0\"\n    \"\\0\";\nstatic const int magicRuleTypes_indices[] = {\n    0, 8, 15, 22, 29, 35, 41, 50, 59, 65, 0\n};\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::typeName(QMimeMagicRule::Type theType)\n  {\n      return magicRuleTypes_string + magicRuleTypes_indices[theType];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.toLatin1",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchTypeAttributeC"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic const char matchValueAttributeC[] = \"value\";\nstatic const char matchTypeAttributeC[] = \"type\";\nstatic const char matchOffsetAttributeC[] = \"offset\";\nstatic const char matchMaskAttributeC[] = \"mask\";\n\nstatic bool createMagicMatchRule(const QXmlStreamAttributes &atts,\n                                 QString *errorMessage, QMimeMagicRule *&rule)\n{\n    const QString type = atts.value(QLatin1String(matchTypeAttributeC)).toString();\n    QMimeMagicRule::Type magicType = QMimeMagicRule::type(type.toLatin1());\n    if (magicType == QMimeMagicRule::Invalid) {\n        qWarning(\"%s: match type %s is not supported.\", Q_FUNC_INFO, type.toUtf8().constData());\n        return true;\n    }\n    const QString value = atts.value(QLatin1String(matchValueAttributeC)).toString();\n    if (value.isEmpty()) {\n        *errorMessage = QString::fromLatin1(\"Empty match value detected.\");\n        return false;\n    }\n    // Parse for offset as \"1\" or \"1:10\"\n    int startPos, endPos;\n    const QString offsetS = atts.value(QLatin1String(matchOffsetAttributeC)).toString();\n    const int colonIndex = offsetS.indexOf(QLatin1Char(':'));\n    const QString startPosS = colonIndex == -1 ? offsetS : offsetS.mid(0, colonIndex);\n    const QString endPosS   = colonIndex == -1 ? offsetS : offsetS.mid(colonIndex + 1);\n    if (!parseNumber(startPosS, &startPos, errorMessage) || !parseNumber(endPosS, &endPos, errorMessage))\n        return false;\n    const QString mask = atts.value(QLatin1String(matchMaskAttributeC)).toString();\n\n    rule = new QMimeMagicRule(magicType, value.toUtf8(), startPos, endPos, mask.toLatin1());\n\n    return true;\n}"
  },
  {
    "function_name": "parseNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
    "lines": "161-170",
    "snippet": "static bool parseNumber(const QString &n, int *target, QString *errorMessage)\n{\n    bool ok;\n    *target = n.toInt(&ok);\n    if (!ok) {\n        *errorMessage = QString::fromLatin1(\"Not a number '%1'.\").arg(n);\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include <QStack>",
      "#include <QXmlStreamWriter>",
      "#include <QXmlStreamReader>",
      "#include <QPair>",
      "#include <QDir>",
      "#include <QDebug>",
      "#include <QCoreApplication>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimetypeparser_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "n"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"Not a number '%1'.\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.toInt",
          "args": [
            "&ok"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic bool parseNumber(const QString &n, int *target, QString *errorMessage)\n{\n    bool ok;\n    *target = n.toInt(&ok);\n    if (!ok) {\n        *errorMessage = QString::fromLatin1(\"Not a number '%1'.\").arg(n);\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "nextState",
    "container": "QMimeTypeParserBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
    "lines": "111-158",
    "snippet": "QMimeTypeParserBase::ParseState QMimeTypeParserBase::nextState(ParseState currentState, const QStringRef &startElement)\n{\n    switch (currentState) {\n    case ParseBeginning:\n        if (startElement == QLatin1String(mimeInfoTagC))\n            return ParseMimeInfo;\n        if (startElement == QLatin1String(mimeTypeTagC))\n            return ParseMimeType;\n        return ParseError;\n    case ParseMimeInfo:\n        return startElement == QLatin1String(mimeTypeTagC) ? ParseMimeType : ParseError;\n    case ParseMimeType:\n    case ParseComment:\n    case ParseGenericIcon:\n    case ParseIcon:\n    case ParseGlobPattern:\n    case ParseSubClass:\n    case ParseAlias:\n    case ParseOtherMimeTypeSubTag:\n    case ParseMagicMatchRule:\n        if (startElement == QLatin1String(mimeTypeTagC)) // Sequence of <mime-type>\n            return ParseMimeType;\n        if (startElement == QLatin1String(commentTagC ))\n            return ParseComment;\n        if (startElement == QLatin1String(genericIconTagC))\n            return ParseGenericIcon;\n        if (startElement == QLatin1String(iconTagC))\n            return ParseIcon;\n        if (startElement == QLatin1String(globTagC))\n            return ParseGlobPattern;\n        if (startElement == QLatin1String(subClassTagC))\n            return ParseSubClass;\n        if (startElement == QLatin1String(aliasTagC))\n            return ParseAlias;\n        if (startElement == QLatin1String(magicTagC))\n            return ParseMagic;\n        if (startElement == QLatin1String(matchTagC))\n            return ParseMagicMatchRule;\n        return ParseOtherMimeTypeSubTag;\n    case ParseMagic:\n        if (startElement == QLatin1String(matchTagC))\n            return ParseMagicMatchRule;\n        break;\n    case ParseError:\n        break;\n    }\n    return ParseError;\n}",
    "includes": [
      "#include <QStack>",
      "#include <QXmlStreamWriter>",
      "#include <QXmlStreamReader>",
      "#include <QPair>",
      "#include <QDir>",
      "#include <QDebug>",
      "#include <QCoreApplication>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include \"qmimetype_p.h\"",
      "#include \"qmimetypeparser_p.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "QT_BEGIN_NAMESPACE\n\n// XML tags in MIME files\nstatic const char mimeInfoTagC[] = \"mime-info\";",
      "static const char mimeTypeTagC[] = \"mime-type\";",
      "static const char subClassTagC[] = \"sub-class-of\";",
      "static const char commentTagC[] = \"comment\";",
      "static const char genericIconTagC[] = \"generic-icon\";",
      "static const char iconTagC[] = \"icon\";",
      "static const char globTagC[] = \"glob\";",
      "static const char aliasTagC[] = \"alias\";",
      "static const char magicTagC[] = \"magic\";",
      "static const char matchTagC[] = \"match\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchTagC"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "matchTagC"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "magicTagC"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "aliasTagC"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "subClassTagC"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "globTagC"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "iconTagC"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "genericIconTagC"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "commentTagC"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeTagC"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeTagC"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeTypeTagC"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeInfoTagC"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nQT_BEGIN_NAMESPACE\n\n// XML tags in MIME files\nstatic const char mimeInfoTagC[] = \"mime-info\";\nstatic const char mimeTypeTagC[] = \"mime-type\";\nstatic const char subClassTagC[] = \"sub-class-of\";\nstatic const char commentTagC[] = \"comment\";\nstatic const char genericIconTagC[] = \"generic-icon\";\nstatic const char iconTagC[] = \"icon\";\nstatic const char globTagC[] = \"glob\";\nstatic const char aliasTagC[] = \"alias\";\nstatic const char magicTagC[] = \"magic\";\nstatic const char matchTagC[] = \"match\";\n\nQMimeTypeParserBase {\n  QMimeTypeParserBase::ParseState QMimeTypeParserBase::nextState(ParseState currentState, const QStringRef &startElement)\n  {\n      switch (currentState) {\n      case ParseBeginning:\n          if (startElement == QLatin1String(mimeInfoTagC))\n              return ParseMimeInfo;\n          if (startElement == QLatin1String(mimeTypeTagC))\n              return ParseMimeType;\n          return ParseError;\n      case ParseMimeInfo:\n          return startElement == QLatin1String(mimeTypeTagC) ? ParseMimeType : ParseError;\n      case ParseMimeType:\n      case ParseComment:\n      case ParseGenericIcon:\n      case ParseIcon:\n      case ParseGlobPattern:\n      case ParseSubClass:\n      case ParseAlias:\n      case ParseOtherMimeTypeSubTag:\n      case ParseMagicMatchRule:\n          if (startElement == QLatin1String(mimeTypeTagC)) // Sequence of <mime-type>\n              return ParseMimeType;\n          if (startElement == QLatin1String(commentTagC ))\n              return ParseComment;\n          if (startElement == QLatin1String(genericIconTagC))\n              return ParseGenericIcon;\n          if (startElement == QLatin1String(iconTagC))\n              return ParseIcon;\n          if (startElement == QLatin1String(globTagC))\n              return ParseGlobPattern;\n          if (startElement == QLatin1String(subClassTagC))\n              return ParseSubClass;\n          if (startElement == QLatin1String(aliasTagC))\n              return ParseAlias;\n          if (startElement == QLatin1String(magicTagC))\n              return ParseMagic;\n          if (startElement == QLatin1String(matchTagC))\n              return ParseMagicMatchRule;\n          return ParseOtherMimeTypeSubTag;\n      case ParseMagic:\n          if (startElement == QLatin1String(matchTagC))\n              return ParseMagicMatchRule;\n          break;\n      case ParseError:\n          break;\n      }\n      return ParseError;\n  }\n}"
  }
]