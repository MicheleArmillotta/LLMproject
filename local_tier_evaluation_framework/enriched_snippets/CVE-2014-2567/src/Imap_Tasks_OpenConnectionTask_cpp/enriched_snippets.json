[
  {
    "function_name": "handleSocketEncryptedResponse(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "487-506",
    "snippet": "ool OpenConnectionTask::handleSocketEncryptedResponse(const Responses::SocketEncryptedResponse *const resp)\n{\n    switch (model->accessParser(parser).connState) {\n    case CONN_STATE_SSL_HANDSHAKE:\n        model->changeConnectionState(parser, CONN_STATE_SSL_VERIFYING);\n        m_sslChain = resp->sslChain;\n        m_sslErrors = resp->sslErrors;\n        model->processSslErrors(this);\n        return true;\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        model->changeConnectionState(parser, CONN_STATE_STARTTLS_VERIFYING);\n        m_sslChain = resp->sslChain;\n        m_sslErrors = resp->sslErrors;\n        model->processSslErrors(this);\n        return true;\n    default:\n        qDebug() << model->accessParser(parser).connState;\n        return false;\n    }\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->processSslErrors",
          "args": [
            "his)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_STARTTLS_VERIFYING)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->processSslErrors",
          "args": [
            "his)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SSL_VERIFYING)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleSocketEncryptedResponse(const Responses::SocketEncryptedResponse *const resp)\n  {\n      switch (model->accessParser(parser).connState) {\n      case CONN_STATE_SSL_HANDSHAKE:\n          model->changeConnectionState(parser, CONN_STATE_SSL_VERIFYING);\n          m_sslChain = resp->sslChain;\n          m_sslErrors = resp->sslErrors;\n          model->processSslErrors(this);\n          return true;\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          model->changeConnectionState(parser, CONN_STATE_STARTTLS_VERIFYING);\n          m_sslChain = resp->sslChain;\n          m_sslErrors = resp->sslErrors;\n          model->processSslErrors(this);\n          return true;\n      default:\n          qDebug() << model->accessParser(parser).connState;\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "sslConnectionPolicyDecided(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "462-485",
    "snippet": "oid OpenConnectionTask::sslConnectionPolicyDecided(bool ok)\n{\n    switch (model->accessParser(parser).connState) {\n    case CONN_STATE_SSL_VERIFYING:\n        if (ok) {\n            model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS_PRECAPS);\n        } else {\n            logout(tr(\"The security state of the SSL connection got rejected\"));\n        }\n        break;\n    case CONN_STATE_STARTTLS_VERIFYING:\n        if (ok) {\n            model->changeConnectionState(parser, CONN_STATE_ESTABLISHED_PRECAPS);\n            model->accessParser(parser).capabilitiesFresh = false;\n            capabilityCmd = parser->capability();\n        } else {\n            logout(tr(\"The security state of the connection after a STARTTLS operation got rejected\"));\n        }\n        break;\n    default:\n        Q_ASSERT(false);\n    }\n    parser->unfreezeAfterEncryption();\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->unfreezeAfterEncryption",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "unfreezeAfterEncryption(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "773-779",
          "snippet": "oid Parser::unfreezeAfterEncryption()\n{\n    Q_ASSERT(waitingForSslPolicy);\n    waitingForSslPolicy = false;\n    handleReadyRead();\n    executeCommands();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::unfreezeAfterEncryption()\n  {\n      Q_ASSERT(waitingForSslPolicy);\n      waitingForSslPolicy = false;\n      handleReadyRead();\n      executeCommands();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ogout(",
          "args": [
            "r(\"The security state of the connection after a STARTTLS operation got rejected\"))"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "logout(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "418-422",
          "snippet": "oid OpenConnectionTask::logout(const QString &message)\n{\n    _failed(message);\n    model->setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::logout(const QString &message)\n  {\n      _failed(message);\n      model->setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "The security state of the connection after a STARTTLS operation got rejected\")"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "113-358",
          "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      using namespace Imap::Responses;\n  \n      if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (!resp->tag.isEmpty()) {\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n          }\n      } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (resp->tag.isEmpty()) {\n              return false;\n          }\n      }\n  \n      switch (model->accessParser(parser).connState) {\n  \n      case CONN_STATE_AUTHENTICATED:\n      case CONN_STATE_SELECTING:\n      case CONN_STATE_SYNCING:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_LOGOUT:\n      {\n          QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                  Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n          // These shall not ever be reached by this code\n          throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n      }\n  \n      case CONN_STATE_NONE:\n      case CONN_STATE_HOST_LOOKUP:\n      case CONN_STATE_CONNECTING:\n          // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n      case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n          // We're connected now -- this is our initial state.\n      {\n          switch (resp->kind) {\n          case PREAUTH:\n              // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n              if (model->accessParser(parser).capabilitiesFresh) {\n                  // We're alsmost done here, apart from compression\n                  if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                      compressCmd = parser->compressDeflate();\n                      model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                  } else {\n                      // really done\n                      model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                      onComplete();\n                  }\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                  capabilityCmd = parser->capability();\n              }\n              return true;\n  \n          case OK:\n              if (!model->accessParser(parser).capabilitiesFresh) {\n                  model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                  capabilityCmd = parser->capability();\n              } else {\n                  startTlsOrLoginNow();\n              }\n              return true;\n  \n          case BYE:\n              logout(tr(\"Server has closed the connection\"));\n              return true;\n  \n          case BAD:\n              model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n              // If it was an ALERT, we've already warned the user\n              if (resp->respCode != ALERT) {\n                  emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n              }\n              logout(tr(\"Server has greeted us with a BAD response\"));\n              return true;\n  \n          default:\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n          }\n          break;\n      }\n  \n      case CONN_STATE_CONNECTED_PRETLS:\n          // We've asked for capabilities upon the initial interaction\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              startTlsOrLoginNow();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_STARTTLS_ISSUED:\n      {\n          if (resp->tag == startTlsCmd) {\n              if (resp->kind == OK) {\n                  model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                  if (!model->m_startTls) {\n                      // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                      // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                      // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                      // password when a MITM removes the LOGINDISABLED in future.\n                      EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                  }\n              } else {\n                  logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_SSL_HANDSHAKE:\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n          // send the data\n          Q_ASSERT(false);\n          return false;\n  \n      case CONN_STATE_STARTTLS_VERIFYING:\n      case CONN_STATE_SSL_VERIFYING:\n      {\n          // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n          // FIXME: an assert(false) here?\n          qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n          return false;\n      }\n  \n      case CONN_STATE_ESTABLISHED_PRECAPS:\n          // Connection is established and we're waiting for updated capabilities\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                  logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                  askForAuth();\n              }\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_LOGIN:\n          // Check the result of the LOGIN command\n      {\n          if (resp->tag == loginCmd) {\n              loginCmd.clear();\n              // The LOGIN command is finished\n              if (resp->kind == OK) {\n                  if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                      // Capabilities are already known\n                      if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                          compressCmd = parser->compressDeflate();\n                          model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                      } else {\n                          model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                          onComplete();\n                      }\n                  } else {\n                      // Got to ask for the capabilities\n                      model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                      capabilityCmd = parser->capability();\n                  }\n              } else {\n                  // Login failed\n                  QString message;\n                  switch (resp->respCode) {\n                  case Responses::UNAVAILABLE:\n                      message = tr(\"Temporary failure because a subsystem is down.\");\n                      break;\n                  case Responses::AUTHENTICATIONFAILED:\n                      message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                      break;\n                  case Responses::AUTHORIZATIONFAILED:\n                      message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                   \"but the server cannot or will not allow the authentication \"\n                                   \"identity to act as the requested authorization identity.\");\n                      break;\n                  case Responses::EXPIRED:\n                      message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                   \"necessary data; either way, access is no longer permitted using \"\n                                   \"that passphrase.  You should get a new passphrase.\");\n                      break;\n                  case Responses::PRIVACYREQUIRED:\n                      message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                      break;\n                  case Responses::CONTACTADMIN:\n                      message = tr(\"You should contact the system administrator or support desk.\");\n                      break;\n                  default:\n                      break;\n                  }\n  \n                  if (message.isEmpty()) {\n                      message = tr(\"Login failed: %1\").arg(resp->message);\n                  } else {\n                      message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                  }\n                  EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                  model->m_imapPassword.clear();\n                  model->m_hasImapPassword = false;\n                  if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                      // The server has closed the conenction\n                      _failed(QLatin1String(\"Connection closed after a failed login\"));\n                      return true;\n                  }\n                  askForAuth();\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_POSTAUTH_PRECAPS:\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_COMPRESS_DEFLATE:\n          if (resp->tag == compressCmd) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n              return true;\n          } else {\n              return false;\n          }\n          break;\n  \n      }\n  \n      // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n      Q_ASSERT(false);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arser->capability",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "capability(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "121-126",
          "snippet": "ommandHandle Parser::capability()\n{\n    // CAPABILITY should take precedence over LOGIN, because we have to check for LOGINDISABLED\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::capability()\n  {\n      // CAPABILITY should take precedence over LOGIN, because we have to check for LOGINDISABLED\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_ESTABLISHED_PRECAPS)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_CONNECTED_PRETLS_PRECAPS)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::sslConnectionPolicyDecided(bool ok)\n  {\n      switch (model->accessParser(parser).connState) {\n      case CONN_STATE_SSL_VERIFYING:\n          if (ok) {\n              model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS_PRECAPS);\n          } else {\n              logout(tr(\"The security state of the SSL connection got rejected\"));\n          }\n          break;\n      case CONN_STATE_STARTTLS_VERIFYING:\n          if (ok) {\n              model->changeConnectionState(parser, CONN_STATE_ESTABLISHED_PRECAPS);\n              model->accessParser(parser).capabilitiesFresh = false;\n              capabilityCmd = parser->capability();\n          } else {\n              logout(tr(\"The security state of the connection after a STARTTLS operation got rejected\"));\n          }\n          break;\n      default:\n          Q_ASSERT(false);\n      }\n      parser->unfreezeAfterEncryption();\n  }\n}"
  },
  {
    "function_name": "sslErrors(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "457-460",
    "snippet": "List<QSslError> OpenConnectionTask::sslErrors() const\n{\n    return m_sslErrors;\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  List<QSslError> OpenConnectionTask::sslErrors() const\n  {\n      return m_sslErrors;\n  }\n}"
  },
  {
    "function_name": "sslCertificateChain(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "452-455",
    "snippet": "List<QSslCertificate> OpenConnectionTask::sslCertificateChain() const\n{\n    return m_sslChain;\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  List<QSslCertificate> OpenConnectionTask::sslCertificateChain() const\n  {\n      return m_sslChain;\n  }\n}"
  },
  {
    "function_name": "taskData(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "447-450",
    "snippet": "Variant OpenConnectionTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Connecting to mail server\")) : QVariant();\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [
            "r(\"Connecting to mail server\"))"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Connecting to mail server\")"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "113-358",
          "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      using namespace Imap::Responses;\n  \n      if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (!resp->tag.isEmpty()) {\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n          }\n      } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (resp->tag.isEmpty()) {\n              return false;\n          }\n      }\n  \n      switch (model->accessParser(parser).connState) {\n  \n      case CONN_STATE_AUTHENTICATED:\n      case CONN_STATE_SELECTING:\n      case CONN_STATE_SYNCING:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_LOGOUT:\n      {\n          QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                  Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n          // These shall not ever be reached by this code\n          throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n      }\n  \n      case CONN_STATE_NONE:\n      case CONN_STATE_HOST_LOOKUP:\n      case CONN_STATE_CONNECTING:\n          // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n      case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n          // We're connected now -- this is our initial state.\n      {\n          switch (resp->kind) {\n          case PREAUTH:\n              // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n              if (model->accessParser(parser).capabilitiesFresh) {\n                  // We're alsmost done here, apart from compression\n                  if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                      compressCmd = parser->compressDeflate();\n                      model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                  } else {\n                      // really done\n                      model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                      onComplete();\n                  }\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                  capabilityCmd = parser->capability();\n              }\n              return true;\n  \n          case OK:\n              if (!model->accessParser(parser).capabilitiesFresh) {\n                  model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                  capabilityCmd = parser->capability();\n              } else {\n                  startTlsOrLoginNow();\n              }\n              return true;\n  \n          case BYE:\n              logout(tr(\"Server has closed the connection\"));\n              return true;\n  \n          case BAD:\n              model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n              // If it was an ALERT, we've already warned the user\n              if (resp->respCode != ALERT) {\n                  emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n              }\n              logout(tr(\"Server has greeted us with a BAD response\"));\n              return true;\n  \n          default:\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n          }\n          break;\n      }\n  \n      case CONN_STATE_CONNECTED_PRETLS:\n          // We've asked for capabilities upon the initial interaction\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              startTlsOrLoginNow();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_STARTTLS_ISSUED:\n      {\n          if (resp->tag == startTlsCmd) {\n              if (resp->kind == OK) {\n                  model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                  if (!model->m_startTls) {\n                      // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                      // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                      // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                      // password when a MITM removes the LOGINDISABLED in future.\n                      EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                  }\n              } else {\n                  logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_SSL_HANDSHAKE:\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n          // send the data\n          Q_ASSERT(false);\n          return false;\n  \n      case CONN_STATE_STARTTLS_VERIFYING:\n      case CONN_STATE_SSL_VERIFYING:\n      {\n          // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n          // FIXME: an assert(false) here?\n          qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n          return false;\n      }\n  \n      case CONN_STATE_ESTABLISHED_PRECAPS:\n          // Connection is established and we're waiting for updated capabilities\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                  logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                  askForAuth();\n              }\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_LOGIN:\n          // Check the result of the LOGIN command\n      {\n          if (resp->tag == loginCmd) {\n              loginCmd.clear();\n              // The LOGIN command is finished\n              if (resp->kind == OK) {\n                  if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                      // Capabilities are already known\n                      if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                          compressCmd = parser->compressDeflate();\n                          model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                      } else {\n                          model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                          onComplete();\n                      }\n                  } else {\n                      // Got to ask for the capabilities\n                      model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                      capabilityCmd = parser->capability();\n                  }\n              } else {\n                  // Login failed\n                  QString message;\n                  switch (resp->respCode) {\n                  case Responses::UNAVAILABLE:\n                      message = tr(\"Temporary failure because a subsystem is down.\");\n                      break;\n                  case Responses::AUTHENTICATIONFAILED:\n                      message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                      break;\n                  case Responses::AUTHORIZATIONFAILED:\n                      message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                   \"but the server cannot or will not allow the authentication \"\n                                   \"identity to act as the requested authorization identity.\");\n                      break;\n                  case Responses::EXPIRED:\n                      message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                   \"necessary data; either way, access is no longer permitted using \"\n                                   \"that passphrase.  You should get a new passphrase.\");\n                      break;\n                  case Responses::PRIVACYREQUIRED:\n                      message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                      break;\n                  case Responses::CONTACTADMIN:\n                      message = tr(\"You should contact the system administrator or support desk.\");\n                      break;\n                  default:\n                      break;\n                  }\n  \n                  if (message.isEmpty()) {\n                      message = tr(\"Login failed: %1\").arg(resp->message);\n                  } else {\n                      message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                  }\n                  EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                  model->m_imapPassword.clear();\n                  model->m_hasImapPassword = false;\n                  if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                      // The server has closed the conenction\n                      _failed(QLatin1String(\"Connection closed after a failed login\"));\n                      return true;\n                  }\n                  askForAuth();\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_POSTAUTH_PRECAPS:\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_COMPRESS_DEFLATE:\n          if (resp->tag == compressCmd) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n              return true;\n          } else {\n              return false;\n          }\n          break;\n  \n      }\n  \n      // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n      Q_ASSERT(false);\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  Variant OpenConnectionTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Connecting to mail server\")) : QVariant();\n  }\n}"
  },
  {
    "function_name": "authCredentialsNowAvailable(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "435-445",
    "snippet": "oid OpenConnectionTask::authCredentialsNowAvailable()\n{\n    if (model->accessParser(parser).connState == CONN_STATE_LOGIN && loginCmd.isEmpty()) {\n        if (model->m_hasImapPassword) {\n            loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n            model->accessParser(parser).capabilitiesFresh = false;\n        } else {\n            logout(tr(\"No credentials available\"));\n        }\n    }\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ogout(",
          "args": [
            "r(\"No credentials available\"))"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "logout(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "418-422",
          "snippet": "oid OpenConnectionTask::logout(const QString &message)\n{\n    _failed(message);\n    model->setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::logout(const QString &message)\n  {\n      _failed(message);\n      model->setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "No credentials available\")"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "113-358",
          "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      using namespace Imap::Responses;\n  \n      if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (!resp->tag.isEmpty()) {\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n          }\n      } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (resp->tag.isEmpty()) {\n              return false;\n          }\n      }\n  \n      switch (model->accessParser(parser).connState) {\n  \n      case CONN_STATE_AUTHENTICATED:\n      case CONN_STATE_SELECTING:\n      case CONN_STATE_SYNCING:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_LOGOUT:\n      {\n          QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                  Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n          // These shall not ever be reached by this code\n          throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n      }\n  \n      case CONN_STATE_NONE:\n      case CONN_STATE_HOST_LOOKUP:\n      case CONN_STATE_CONNECTING:\n          // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n      case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n          // We're connected now -- this is our initial state.\n      {\n          switch (resp->kind) {\n          case PREAUTH:\n              // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n              if (model->accessParser(parser).capabilitiesFresh) {\n                  // We're alsmost done here, apart from compression\n                  if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                      compressCmd = parser->compressDeflate();\n                      model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                  } else {\n                      // really done\n                      model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                      onComplete();\n                  }\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                  capabilityCmd = parser->capability();\n              }\n              return true;\n  \n          case OK:\n              if (!model->accessParser(parser).capabilitiesFresh) {\n                  model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                  capabilityCmd = parser->capability();\n              } else {\n                  startTlsOrLoginNow();\n              }\n              return true;\n  \n          case BYE:\n              logout(tr(\"Server has closed the connection\"));\n              return true;\n  \n          case BAD:\n              model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n              // If it was an ALERT, we've already warned the user\n              if (resp->respCode != ALERT) {\n                  emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n              }\n              logout(tr(\"Server has greeted us with a BAD response\"));\n              return true;\n  \n          default:\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n          }\n          break;\n      }\n  \n      case CONN_STATE_CONNECTED_PRETLS:\n          // We've asked for capabilities upon the initial interaction\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              startTlsOrLoginNow();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_STARTTLS_ISSUED:\n      {\n          if (resp->tag == startTlsCmd) {\n              if (resp->kind == OK) {\n                  model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                  if (!model->m_startTls) {\n                      // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                      // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                      // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                      // password when a MITM removes the LOGINDISABLED in future.\n                      EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                  }\n              } else {\n                  logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_SSL_HANDSHAKE:\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n          // send the data\n          Q_ASSERT(false);\n          return false;\n  \n      case CONN_STATE_STARTTLS_VERIFYING:\n      case CONN_STATE_SSL_VERIFYING:\n      {\n          // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n          // FIXME: an assert(false) here?\n          qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n          return false;\n      }\n  \n      case CONN_STATE_ESTABLISHED_PRECAPS:\n          // Connection is established and we're waiting for updated capabilities\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                  logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                  askForAuth();\n              }\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_LOGIN:\n          // Check the result of the LOGIN command\n      {\n          if (resp->tag == loginCmd) {\n              loginCmd.clear();\n              // The LOGIN command is finished\n              if (resp->kind == OK) {\n                  if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                      // Capabilities are already known\n                      if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                          compressCmd = parser->compressDeflate();\n                          model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                      } else {\n                          model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                          onComplete();\n                      }\n                  } else {\n                      // Got to ask for the capabilities\n                      model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                      capabilityCmd = parser->capability();\n                  }\n              } else {\n                  // Login failed\n                  QString message;\n                  switch (resp->respCode) {\n                  case Responses::UNAVAILABLE:\n                      message = tr(\"Temporary failure because a subsystem is down.\");\n                      break;\n                  case Responses::AUTHENTICATIONFAILED:\n                      message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                      break;\n                  case Responses::AUTHORIZATIONFAILED:\n                      message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                   \"but the server cannot or will not allow the authentication \"\n                                   \"identity to act as the requested authorization identity.\");\n                      break;\n                  case Responses::EXPIRED:\n                      message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                   \"necessary data; either way, access is no longer permitted using \"\n                                   \"that passphrase.  You should get a new passphrase.\");\n                      break;\n                  case Responses::PRIVACYREQUIRED:\n                      message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                      break;\n                  case Responses::CONTACTADMIN:\n                      message = tr(\"You should contact the system administrator or support desk.\");\n                      break;\n                  default:\n                      break;\n                  }\n  \n                  if (message.isEmpty()) {\n                      message = tr(\"Login failed: %1\").arg(resp->message);\n                  } else {\n                      message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                  }\n                  EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                  model->m_imapPassword.clear();\n                  model->m_hasImapPassword = false;\n                  if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                      // The server has closed the conenction\n                      _failed(QLatin1String(\"Connection closed after a failed login\"));\n                      return true;\n                  }\n                  askForAuth();\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_POSTAUTH_PRECAPS:\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_COMPRESS_DEFLATE:\n          if (resp->tag == compressCmd) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n              return true;\n          } else {\n              return false;\n          }\n          break;\n  \n      }\n  \n      // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n      Q_ASSERT(false);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->login",
          "args": [
            "odel->m_imapUser,",
            "odel->m_imapPassword)"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "login(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "148-152",
          "snippet": "ommandHandle Parser::login(const QString &username, const QString &password)\n{\n    return queueCommand(Commands::Command(\"LOGIN\") <<\n                        Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::login(const QString &username, const QString &password)\n  {\n      return queueCommand(Commands::Command(\"LOGIN\") <<\n                          Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oginCmd.isEmpty",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::authCredentialsNowAvailable()\n  {\n      if (model->accessParser(parser).connState == CONN_STATE_LOGIN && loginCmd.isEmpty()) {\n          if (model->m_hasImapPassword) {\n              loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n              model->accessParser(parser).capabilitiesFresh = false;\n          } else {\n              logout(tr(\"No credentials available\"));\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "askForAuth(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "424-433",
    "snippet": "oid OpenConnectionTask::askForAuth()\n{\n    if (model->m_hasImapPassword) {\n        Q_ASSERT(loginCmd.isEmpty());\n        loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n        model->accessParser(parser).capabilitiesFresh = false;\n    } else {\n        EMIT_LATER_NOARG(model, authRequested);\n    }\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MIT_LATER_NOARG(",
          "args": [
            "odel,",
            "uthRequested)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->login",
          "args": [
            "odel->m_imapUser,",
            "odel->m_imapPassword)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "login(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "148-152",
          "snippet": "ommandHandle Parser::login(const QString &username, const QString &password)\n{\n    return queueCommand(Commands::Command(\"LOGIN\") <<\n                        Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::login(const QString &username, const QString &password)\n  {\n      return queueCommand(Commands::Command(\"LOGIN\") <<\n                          Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "oginCmd.isEmpty())"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oginCmd.isEmpty",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::askForAuth()\n  {\n      if (model->m_hasImapPassword) {\n          Q_ASSERT(loginCmd.isEmpty());\n          loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n          model->accessParser(parser).capabilitiesFresh = false;\n      } else {\n          EMIT_LATER_NOARG(model, authRequested);\n      }\n  }\n}"
  },
  {
    "function_name": "logout(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "418-422",
    "snippet": "oid OpenConnectionTask::logout(const QString &message)\n{\n    _failed(message);\n    model->setNetworkPolicy(NETWORK_OFFLINE);\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->setNetworkPolicy",
          "args": [
            "ETWORK_OFFLINE)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "setNetworkPolicy(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1069-1124",
          "snippet": "oid Model::setNetworkPolicy(const NetworkPolicy policy)\n{\n    bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n    switch (policy) {\n    case NETWORK_OFFLINE:\n        for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n            if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                // there's no point in sending LOGOUT over these\n                continue;\n            }\n            Q_ASSERT(it->parser);\n            if (it->maintainingTask) {\n                // First of all, give the maintaining task a chance to finish its housekeeping\n                it->maintainingTask->stopForLogout();\n            }\n            // Kill all tasks that are also using this connection\n            Q_FOREACH(ImapTask *task, it->activeTasks) {\n                task->die(tr(\"Going offline\"));\n            }\n            it->logoutCmd = it->parser->logout();\n            it->connState = CONN_STATE_LOGOUT;\n        }\n        m_netPolicy = NETWORK_OFFLINE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyOffline();\n\n        // FIXME: kill the connection\n        break;\n    case NETWORK_EXPENSIVE:\n        m_netPolicy = NETWORK_EXPENSIVE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyExpensive();\n        break;\n    case NETWORK_ONLINE:\n        m_netPolicy = NETWORK_ONLINE;\n        m_periodicMailboxNumbersRefresh->start();\n        emit networkPolicyChanged();\n        emit networkPolicyOnline();\n        break;\n    }\n\n    if (networkReconnected) {\n        // We're connecting after being offline\n        if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n            // We should ask for an updated list of mailboxes\n            // The main reason is that this happens after entering wrong password and going back online\n            reloadMailboxList();\n        }\n    } else if (m_netPolicy == NETWORK_ONLINE) {\n        // The connection is online after some time in a different mode. Let's use this opportunity to request\n        // updated message counts from all visible mailboxes.\n        invalidateAllMessageCounts();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::setNetworkPolicy(const NetworkPolicy policy)\n  {\n      bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n      switch (policy) {\n      case NETWORK_OFFLINE:\n          for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n              if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                  // there's no point in sending LOGOUT over these\n                  continue;\n              }\n              Q_ASSERT(it->parser);\n              if (it->maintainingTask) {\n                  // First of all, give the maintaining task a chance to finish its housekeeping\n                  it->maintainingTask->stopForLogout();\n              }\n              // Kill all tasks that are also using this connection\n              Q_FOREACH(ImapTask *task, it->activeTasks) {\n                  task->die(tr(\"Going offline\"));\n              }\n              it->logoutCmd = it->parser->logout();\n              it->connState = CONN_STATE_LOGOUT;\n          }\n          m_netPolicy = NETWORK_OFFLINE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyOffline();\n  \n          // FIXME: kill the connection\n          break;\n      case NETWORK_EXPENSIVE:\n          m_netPolicy = NETWORK_EXPENSIVE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyExpensive();\n          break;\n      case NETWORK_ONLINE:\n          m_netPolicy = NETWORK_ONLINE;\n          m_periodicMailboxNumbersRefresh->start();\n          emit networkPolicyChanged();\n          emit networkPolicyOnline();\n          break;\n      }\n  \n      if (networkReconnected) {\n          // We're connecting after being offline\n          if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n              // We should ask for an updated list of mailboxes\n              // The main reason is that this happens after entering wrong password and going back online\n              reloadMailboxList();\n          }\n      } else if (m_netPolicy == NETWORK_ONLINE) {\n          // The connection is online after some time in a different mode. Let's use this opportunity to request\n          // updated message counts from all visible mailboxes.\n          invalidateAllMessageCounts();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "essage)"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::logout(const QString &message)\n  {\n      _failed(message);\n      model->setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
  },
  {
    "function_name": "onComplete(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "399-416",
    "snippet": "oid OpenConnectionTask::onComplete()\n{\n    // Optionally issue the ID command\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ID\"))) {\n        Imap::Mailbox::ImapTask *task = model->m_taskFactory->createIdTask(model, this);\n        task->perform();\n    }\n    // Optionally enable QRESYNC\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\")) &&\n            model->accessParser(parser).capabilities.contains(QLatin1String(\"ENABLE\"))) {\n        Imap::Mailbox::ImapTask *task = model->m_taskFactory->createEnableTask(model, this,\n                                                                               QList<QByteArray>() << QByteArray(\"QRESYNC\"));\n        task->perform();\n    }\n\n    // But do terminate this task\n    _completed();\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask->perform",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "69-72",
          "snippet": "oid OpenConnectionTask::perform()\n{\n    // nothing should happen here\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::perform()\n  {\n      // nothing should happen here\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createEnableTask",
          "args": [
            "odel,",
            "his,",
            "List<QByteArray>() << QByteArray(\"QRESYNC\"))"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "QRESYNC\")"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "List<QByteArray>",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "ake_ListChildMailboxesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/Fake_ListChildMailboxesTask.cpp",
          "lines": "42-67",
          "snippet": "oid Fake_ListChildMailboxesTask::perform()\n{\n    parser = conn->parser;\n    markAsActiveTask();\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    parser = conn->parser;\n    QList<Responses::List> &listResponses = model->accessParser(parser).listResponses;\n    Q_ASSERT(listResponses.isEmpty());\n    TestingTaskFactory *factory = dynamic_cast<TestingTaskFactory *>(model->m_taskFactory.get());\n    Q_ASSERT(factory);\n    for (QMap<QString, QStringList>::const_iterator it = factory->fakeListChildMailboxesMap.constBegin();\n         it != factory->fakeListChildMailboxesMap.constEnd(); ++it) {\n        if (it.key() != mailbox->mailbox())\n            continue;\n        for (QStringList::const_iterator childIt = it->begin(); childIt != it->end(); ++childIt) {\n            QString childMailbox = mailbox->mailbox().isEmpty() ? *childIt : QString::fromUtf8(\"%1^%2\").arg(mailbox->mailbox(), *childIt);\n            listResponses.append(Responses::List(Responses::LIST, QStringList(), QLatin1String(\"^\"), childMailbox, QMap<QByteArray, QVariant>()));\n        }\n    }\n    model->finalizeList(parser, mailbox);\n    _completed();\n}",
          "includes": [
            "include \"GetAnyConnectionTask.h\"",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Fake_ListChildMailboxesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Fake_ListChildMailboxesTask.h\"\n#\n\nake_ListChildMailboxesTask {\n  oid Fake_ListChildMailboxesTask::perform()\n  {\n      parser = conn->parser;\n      markAsActiveTask();\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      parser = conn->parser;\n      QList<Responses::List> &listResponses = model->accessParser(parser).listResponses;\n      Q_ASSERT(listResponses.isEmpty());\n      TestingTaskFactory *factory = dynamic_cast<TestingTaskFactory *>(model->m_taskFactory.get());\n      Q_ASSERT(factory);\n      for (QMap<QString, QStringList>::const_iterator it = factory->fakeListChildMailboxesMap.constBegin();\n           it != factory->fakeListChildMailboxesMap.constEnd(); ++it) {\n          if (it.key() != mailbox->mailbox())\n              continue;\n          for (QStringList::const_iterator childIt = it->begin(); childIt != it->end(); ++childIt) {\n              QString childMailbox = mailbox->mailbox().isEmpty() ? *childIt : QString::fromUtf8(\"%1^%2\").arg(mailbox->mailbox(), *childIt);\n              listResponses.append(Responses::List(Responses::LIST, QStringList(), QLatin1String(\"^\"), childMailbox, QMap<QByteArray, QVariant>()));\n          }\n      }\n      model->finalizeList(parser, mailbox);\n      _completed();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"ENABLE\"))"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ENABLE\")"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"QRESYNC\"))"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "QRESYNC\")"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createIdTask",
          "args": [
            "odel,",
            "his)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"ID\"))"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ID\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::onComplete()\n  {\n      // Optionally issue the ID command\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ID\"))) {\n          Imap::Mailbox::ImapTask *task = model->m_taskFactory->createIdTask(model, this);\n          task->perform();\n      }\n      // Optionally enable QRESYNC\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\")) &&\n              model->accessParser(parser).capabilities.contains(QLatin1String(\"ENABLE\"))) {\n          Imap::Mailbox::ImapTask *task = model->m_taskFactory->createEnableTask(model, this,\n                                                                                 QList<QByteArray>() << QByteArray(\"QRESYNC\"));\n          task->perform();\n      }\n  \n      // But do terminate this task\n      _completed();\n  }\n}"
  },
  {
    "function_name": "checkCapabilitiesResult(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "380-397",
    "snippet": "ool OpenConnectionTask::checkCapabilitiesResult(const Responses::State *const resp)\n{\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (resp->tag == capabilityCmd) {\n        if (!model->accessParser(parser).capabilitiesFresh) {\n            logout(tr(\"Server did not provide useful capabilities\"));\n            return true;\n        }\n        if (resp->kind != Responses::OK) {\n            logout(tr(\"CAPABILITIES command has failed\"));\n        }\n        return true;\n    }\n\n    return false;\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ogout(",
          "args": [
            "r(\"CAPABILITIES command has failed\"))"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "logout(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "418-422",
          "snippet": "oid OpenConnectionTask::logout(const QString &message)\n{\n    _failed(message);\n    model->setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::logout(const QString &message)\n  {\n      _failed(message);\n      model->setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "CAPABILITIES command has failed\")"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "113-358",
          "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      using namespace Imap::Responses;\n  \n      if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (!resp->tag.isEmpty()) {\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n          }\n      } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (resp->tag.isEmpty()) {\n              return false;\n          }\n      }\n  \n      switch (model->accessParser(parser).connState) {\n  \n      case CONN_STATE_AUTHENTICATED:\n      case CONN_STATE_SELECTING:\n      case CONN_STATE_SYNCING:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_LOGOUT:\n      {\n          QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                  Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n          // These shall not ever be reached by this code\n          throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n      }\n  \n      case CONN_STATE_NONE:\n      case CONN_STATE_HOST_LOOKUP:\n      case CONN_STATE_CONNECTING:\n          // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n      case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n          // We're connected now -- this is our initial state.\n      {\n          switch (resp->kind) {\n          case PREAUTH:\n              // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n              if (model->accessParser(parser).capabilitiesFresh) {\n                  // We're alsmost done here, apart from compression\n                  if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                      compressCmd = parser->compressDeflate();\n                      model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                  } else {\n                      // really done\n                      model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                      onComplete();\n                  }\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                  capabilityCmd = parser->capability();\n              }\n              return true;\n  \n          case OK:\n              if (!model->accessParser(parser).capabilitiesFresh) {\n                  model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                  capabilityCmd = parser->capability();\n              } else {\n                  startTlsOrLoginNow();\n              }\n              return true;\n  \n          case BYE:\n              logout(tr(\"Server has closed the connection\"));\n              return true;\n  \n          case BAD:\n              model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n              // If it was an ALERT, we've already warned the user\n              if (resp->respCode != ALERT) {\n                  emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n              }\n              logout(tr(\"Server has greeted us with a BAD response\"));\n              return true;\n  \n          default:\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n          }\n          break;\n      }\n  \n      case CONN_STATE_CONNECTED_PRETLS:\n          // We've asked for capabilities upon the initial interaction\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              startTlsOrLoginNow();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_STARTTLS_ISSUED:\n      {\n          if (resp->tag == startTlsCmd) {\n              if (resp->kind == OK) {\n                  model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                  if (!model->m_startTls) {\n                      // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                      // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                      // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                      // password when a MITM removes the LOGINDISABLED in future.\n                      EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                  }\n              } else {\n                  logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_SSL_HANDSHAKE:\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n          // send the data\n          Q_ASSERT(false);\n          return false;\n  \n      case CONN_STATE_STARTTLS_VERIFYING:\n      case CONN_STATE_SSL_VERIFYING:\n      {\n          // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n          // FIXME: an assert(false) here?\n          qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n          return false;\n      }\n  \n      case CONN_STATE_ESTABLISHED_PRECAPS:\n          // Connection is established and we're waiting for updated capabilities\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                  logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                  askForAuth();\n              }\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_LOGIN:\n          // Check the result of the LOGIN command\n      {\n          if (resp->tag == loginCmd) {\n              loginCmd.clear();\n              // The LOGIN command is finished\n              if (resp->kind == OK) {\n                  if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                      // Capabilities are already known\n                      if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                          compressCmd = parser->compressDeflate();\n                          model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                      } else {\n                          model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                          onComplete();\n                      }\n                  } else {\n                      // Got to ask for the capabilities\n                      model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                      capabilityCmd = parser->capability();\n                  }\n              } else {\n                  // Login failed\n                  QString message;\n                  switch (resp->respCode) {\n                  case Responses::UNAVAILABLE:\n                      message = tr(\"Temporary failure because a subsystem is down.\");\n                      break;\n                  case Responses::AUTHENTICATIONFAILED:\n                      message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                      break;\n                  case Responses::AUTHORIZATIONFAILED:\n                      message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                   \"but the server cannot or will not allow the authentication \"\n                                   \"identity to act as the requested authorization identity.\");\n                      break;\n                  case Responses::EXPIRED:\n                      message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                   \"necessary data; either way, access is no longer permitted using \"\n                                   \"that passphrase.  You should get a new passphrase.\");\n                      break;\n                  case Responses::PRIVACYREQUIRED:\n                      message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                      break;\n                  case Responses::CONTACTADMIN:\n                      message = tr(\"You should contact the system administrator or support desk.\");\n                      break;\n                  default:\n                      break;\n                  }\n  \n                  if (message.isEmpty()) {\n                      message = tr(\"Login failed: %1\").arg(resp->message);\n                  } else {\n                      message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                  }\n                  EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                  model->m_imapPassword.clear();\n                  model->m_hasImapPassword = false;\n                  if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                      // The server has closed the conenction\n                      _failed(QLatin1String(\"Connection closed after a failed login\"));\n                      return true;\n                  }\n                  askForAuth();\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_POSTAUTH_PRECAPS:\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_COMPRESS_DEFLATE:\n          if (resp->tag == compressCmd) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n              return true;\n          } else {\n              return false;\n          }\n          break;\n  \n      }\n  \n      // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n      Q_ASSERT(false);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::checkCapabilitiesResult(const Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (resp->tag == capabilityCmd) {\n          if (!model->accessParser(parser).capabilitiesFresh) {\n              logout(tr(\"Server did not provide useful capabilities\"));\n              return true;\n          }\n          if (resp->kind != Responses::OK) {\n              logout(tr(\"CAPABILITIES command has failed\"));\n          }\n          return true;\n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "startTlsOrLoginNow(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "361-378",
    "snippet": "oid OpenConnectionTask::startTlsOrLoginNow()\n{\n    if (model->m_startTls || model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n        // Should run STARTTLS later and already have the capabilities\n        Q_ASSERT(model->accessParser(parser).capabilitiesFresh);\n        if (!model->accessParser(parser).capabilities.contains(QLatin1String(\"STARTTLS\"))) {\n            logout(tr(\"Server does not support STARTTLS\"));\n        } else {\n            startTlsCmd = parser->startTls();\n            model->changeConnectionState(parser, CONN_STATE_STARTTLS_ISSUED);\n        }\n    } else {\n        // We're requested to authenticate even without STARTTLS\n        Q_ASSERT(!model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\")));\n        model->changeConnectionState(parser, CONN_STATE_LOGIN);\n        askForAuth();\n    }\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skForAuth(",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "askForAuth(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "424-433",
          "snippet": "oid OpenConnectionTask::askForAuth()\n{\n    if (model->m_hasImapPassword) {\n        Q_ASSERT(loginCmd.isEmpty());\n        loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n        model->accessParser(parser).capabilitiesFresh = false;\n    } else {\n        EMIT_LATER_NOARG(model, authRequested);\n    }\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::askForAuth()\n  {\n      if (model->m_hasImapPassword) {\n          Q_ASSERT(loginCmd.isEmpty());\n          loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n          model->accessParser(parser).capabilitiesFresh = false;\n      } else {\n          EMIT_LATER_NOARG(model, authRequested);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_LOGIN)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\")))"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"LOGINDISABLED\"))"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "LOGINDISABLED\")"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_STARTTLS_ISSUED)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->startTls",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "startTls(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "128-132",
          "snippet": "ommandHandle Parser::startTls()\n{\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::STARTTLS, \"STARTTLS\"));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::startTls()\n  {\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::STARTTLS, \"STARTTLS\"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogout(",
          "args": [
            "r(\"Server does not support STARTTLS\"))"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "logout(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "418-422",
          "snippet": "oid OpenConnectionTask::logout(const QString &message)\n{\n    _failed(message);\n    model->setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::logout(const QString &message)\n  {\n      _failed(message);\n      model->setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Server does not support STARTTLS\")"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "113-358",
          "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      using namespace Imap::Responses;\n  \n      if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (!resp->tag.isEmpty()) {\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n          }\n      } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (resp->tag.isEmpty()) {\n              return false;\n          }\n      }\n  \n      switch (model->accessParser(parser).connState) {\n  \n      case CONN_STATE_AUTHENTICATED:\n      case CONN_STATE_SELECTING:\n      case CONN_STATE_SYNCING:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_LOGOUT:\n      {\n          QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                  Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n          // These shall not ever be reached by this code\n          throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n      }\n  \n      case CONN_STATE_NONE:\n      case CONN_STATE_HOST_LOOKUP:\n      case CONN_STATE_CONNECTING:\n          // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n      case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n          // We're connected now -- this is our initial state.\n      {\n          switch (resp->kind) {\n          case PREAUTH:\n              // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n              if (model->accessParser(parser).capabilitiesFresh) {\n                  // We're alsmost done here, apart from compression\n                  if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                      compressCmd = parser->compressDeflate();\n                      model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                  } else {\n                      // really done\n                      model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                      onComplete();\n                  }\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                  capabilityCmd = parser->capability();\n              }\n              return true;\n  \n          case OK:\n              if (!model->accessParser(parser).capabilitiesFresh) {\n                  model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                  capabilityCmd = parser->capability();\n              } else {\n                  startTlsOrLoginNow();\n              }\n              return true;\n  \n          case BYE:\n              logout(tr(\"Server has closed the connection\"));\n              return true;\n  \n          case BAD:\n              model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n              // If it was an ALERT, we've already warned the user\n              if (resp->respCode != ALERT) {\n                  emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n              }\n              logout(tr(\"Server has greeted us with a BAD response\"));\n              return true;\n  \n          default:\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n          }\n          break;\n      }\n  \n      case CONN_STATE_CONNECTED_PRETLS:\n          // We've asked for capabilities upon the initial interaction\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              startTlsOrLoginNow();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_STARTTLS_ISSUED:\n      {\n          if (resp->tag == startTlsCmd) {\n              if (resp->kind == OK) {\n                  model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                  if (!model->m_startTls) {\n                      // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                      // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                      // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                      // password when a MITM removes the LOGINDISABLED in future.\n                      EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                  }\n              } else {\n                  logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_SSL_HANDSHAKE:\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n          // send the data\n          Q_ASSERT(false);\n          return false;\n  \n      case CONN_STATE_STARTTLS_VERIFYING:\n      case CONN_STATE_SSL_VERIFYING:\n      {\n          // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n          // FIXME: an assert(false) here?\n          qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n          return false;\n      }\n  \n      case CONN_STATE_ESTABLISHED_PRECAPS:\n          // Connection is established and we're waiting for updated capabilities\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                  logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                  askForAuth();\n              }\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_LOGIN:\n          // Check the result of the LOGIN command\n      {\n          if (resp->tag == loginCmd) {\n              loginCmd.clear();\n              // The LOGIN command is finished\n              if (resp->kind == OK) {\n                  if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                      // Capabilities are already known\n                      if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                          compressCmd = parser->compressDeflate();\n                          model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                      } else {\n                          model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                          onComplete();\n                      }\n                  } else {\n                      // Got to ask for the capabilities\n                      model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                      capabilityCmd = parser->capability();\n                  }\n              } else {\n                  // Login failed\n                  QString message;\n                  switch (resp->respCode) {\n                  case Responses::UNAVAILABLE:\n                      message = tr(\"Temporary failure because a subsystem is down.\");\n                      break;\n                  case Responses::AUTHENTICATIONFAILED:\n                      message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                      break;\n                  case Responses::AUTHORIZATIONFAILED:\n                      message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                   \"but the server cannot or will not allow the authentication \"\n                                   \"identity to act as the requested authorization identity.\");\n                      break;\n                  case Responses::EXPIRED:\n                      message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                   \"necessary data; either way, access is no longer permitted using \"\n                                   \"that passphrase.  You should get a new passphrase.\");\n                      break;\n                  case Responses::PRIVACYREQUIRED:\n                      message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                      break;\n                  case Responses::CONTACTADMIN:\n                      message = tr(\"You should contact the system administrator or support desk.\");\n                      break;\n                  default:\n                      break;\n                  }\n  \n                  if (message.isEmpty()) {\n                      message = tr(\"Login failed: %1\").arg(resp->message);\n                  } else {\n                      message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                  }\n                  EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                  model->m_imapPassword.clear();\n                  model->m_hasImapPassword = false;\n                  if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                      // The server has closed the conenction\n                      _failed(QLatin1String(\"Connection closed after a failed login\"));\n                      return true;\n                  }\n                  askForAuth();\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_POSTAUTH_PRECAPS:\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_COMPRESS_DEFLATE:\n          if (resp->tag == compressCmd) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n              return true;\n          } else {\n              return false;\n          }\n          break;\n  \n      }\n  \n      // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n      Q_ASSERT(false);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"STARTTLS\"))"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "STARTTLS\")"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel->accessParser(parser).capabilitiesFresh)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"LOGINDISABLED\"))"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "LOGINDISABLED\")"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::startTlsOrLoginNow()\n  {\n      if (model->m_startTls || model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n          // Should run STARTTLS later and already have the capabilities\n          Q_ASSERT(model->accessParser(parser).capabilitiesFresh);\n          if (!model->accessParser(parser).capabilities.contains(QLatin1String(\"STARTTLS\"))) {\n              logout(tr(\"Server does not support STARTTLS\"));\n          } else {\n              startTlsCmd = parser->startTls();\n              model->changeConnectionState(parser, CONN_STATE_STARTTLS_ISSUED);\n          }\n      } else {\n          // We're requested to authenticate even without STARTTLS\n          Q_ASSERT(!model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\")));\n          model->changeConnectionState(parser, CONN_STATE_LOGIN);\n          askForAuth();\n      }\n  }\n}"
  },
  {
    "function_name": "handleStateHelper(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "113-358",
    "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nComplete(",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "onComplete(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "399-416",
          "snippet": "oid OpenConnectionTask::onComplete()\n{\n    // Optionally issue the ID command\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ID\"))) {\n        Imap::Mailbox::ImapTask *task = model->m_taskFactory->createIdTask(model, this);\n        task->perform();\n    }\n    // Optionally enable QRESYNC\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\")) &&\n            model->accessParser(parser).capabilities.contains(QLatin1String(\"ENABLE\"))) {\n        Imap::Mailbox::ImapTask *task = model->m_taskFactory->createEnableTask(model, this,\n                                                                               QList<QByteArray>() << QByteArray(\"QRESYNC\"));\n        task->perform();\n    }\n\n    // But do terminate this task\n    _completed();\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::onComplete()\n  {\n      // Optionally issue the ID command\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ID\"))) {\n          Imap::Mailbox::ImapTask *task = model->m_taskFactory->createIdTask(model, this);\n          task->perform();\n      }\n      // Optionally enable QRESYNC\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\")) &&\n              model->accessParser(parser).capabilities.contains(QLatin1String(\"ENABLE\"))) {\n          Imap::Mailbox::ImapTask *task = model->m_taskFactory->createEnableTask(model, this,\n                                                                                 QList<QByteArray>() << QByteArray(\"QRESYNC\"));\n          task->perform();\n      }\n  \n      // But do terminate this task\n      _completed();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_AUTHENTICATED)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_AUTHENTICATED)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heckCapabilitiesResult(",
          "args": [
            "esp)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "checkCapabilitiesResult(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "380-397",
          "snippet": "ool OpenConnectionTask::checkCapabilitiesResult(const Responses::State *const resp)\n{\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (resp->tag == capabilityCmd) {\n        if (!model->accessParser(parser).capabilitiesFresh) {\n            logout(tr(\"Server did not provide useful capabilities\"));\n            return true;\n        }\n        if (resp->kind != Responses::OK) {\n            logout(tr(\"CAPABILITIES command has failed\"));\n        }\n        return true;\n    }\n\n    return false;\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::checkCapabilitiesResult(const Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (resp->tag == capabilityCmd) {\n          if (!model->accessParser(parser).capabilitiesFresh) {\n              logout(tr(\"Server did not provide useful capabilities\"));\n              return true;\n          }\n          if (resp->kind != Responses::OK) {\n              logout(tr(\"CAPABILITIES command has failed\"));\n          }\n          return true;\n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "skForAuth(",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "askForAuth(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "424-433",
          "snippet": "oid OpenConnectionTask::askForAuth()\n{\n    if (model->m_hasImapPassword) {\n        Q_ASSERT(loginCmd.isEmpty());\n        loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n        model->accessParser(parser).capabilitiesFresh = false;\n    } else {\n        EMIT_LATER_NOARG(model, authRequested);\n    }\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::askForAuth()\n  {\n      if (model->m_hasImapPassword) {\n          Q_ASSERT(loginCmd.isEmpty());\n          loginCmd = parser->login(model->m_imapUser, model->m_imapPassword);\n          model->accessParser(parser).capabilitiesFresh = false;\n      } else {\n          EMIT_LATER_NOARG(model, authRequested);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Latin1String(\"Connection closed after a failed login\"))"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Connection closed after a failed login\")"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_imapPassword.clear",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "odel,",
            "uthAttemptFailed,",
            "_ARG(QString, message))"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "essage)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "essage,",
            "esp->message)"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "NumberOfMessagesTask(",
          "container": "umberOfMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/NumberOfMessagesTask.cpp",
          "lines": "36-42",
          "snippet": "umberOfMessagesTask::NumberOfMessagesTask(Model *model, const QModelIndex &mailbox):\n    ImapTask(model), mailboxIndex(mailbox)\n{\n    Q_ASSERT(dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailbox.internalPointer())));\n    conn = model->m_taskFactory->createGetAnyConnectionTask(model);\n    conn->addDependentTask(this);\n}",
          "includes": [
            "include \"GetAnyConnectionTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"NumberOfMessagesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"NumberOfMessagesTask.h\"\n#\n\numberOfMessagesTask {\n  umberOfMessagesTask::NumberOfMessagesTask(Model *model, const QModelIndex &mailbox):\n      ImapTask(model), mailboxIndex(mailbox)\n  {\n      Q_ASSERT(dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailbox.internalPointer())));\n      conn = model->m_taskFactory->createGetAnyConnectionTask(model);\n      conn->addDependentTask(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "%1\\n\\n%2\")"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "113-358",
          "snippet": "ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    using namespace Imap::Responses;\n\n    if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (!resp->tag.isEmpty()) {\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n        }\n    } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n        if (resp->tag.isEmpty()) {\n            return false;\n        }\n    }\n\n    switch (model->accessParser(parser).connState) {\n\n    case CONN_STATE_AUTHENTICATED:\n    case CONN_STATE_SELECTING:\n    case CONN_STATE_SYNCING:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_LOGOUT:\n    {\n        QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n        // These shall not ever be reached by this code\n        throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n    }\n\n    case CONN_STATE_NONE:\n    case CONN_STATE_HOST_LOOKUP:\n    case CONN_STATE_CONNECTING:\n        // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n    case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n        // We're connected now -- this is our initial state.\n    {\n        switch (resp->kind) {\n        case PREAUTH:\n            // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n            if (model->accessParser(parser).capabilitiesFresh) {\n                // We're alsmost done here, apart from compression\n                if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                    compressCmd = parser->compressDeflate();\n                    model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                } else {\n                    // really done\n                    model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                    onComplete();\n                }\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                capabilityCmd = parser->capability();\n            }\n            return true;\n\n        case OK:\n            if (!model->accessParser(parser).capabilitiesFresh) {\n                model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                capabilityCmd = parser->capability();\n            } else {\n                startTlsOrLoginNow();\n            }\n            return true;\n\n        case BYE:\n            logout(tr(\"Server has closed the connection\"));\n            return true;\n\n        case BAD:\n            model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n            // If it was an ALERT, we've already warned the user\n            if (resp->respCode != ALERT) {\n                emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n            }\n            logout(tr(\"Server has greeted us with a BAD response\"));\n            return true;\n\n        default:\n            throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n        }\n        break;\n    }\n\n    case CONN_STATE_CONNECTED_PRETLS:\n        // We've asked for capabilities upon the initial interaction\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            startTlsOrLoginNow();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_STARTTLS_ISSUED:\n    {\n        if (resp->tag == startTlsCmd) {\n            if (resp->kind == OK) {\n                model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                if (!model->m_startTls) {\n                    // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                    // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                    // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                    // password when a MITM removes the LOGINDISABLED in future.\n                    EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                }\n            } else {\n                logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_SSL_HANDSHAKE:\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n        // send the data\n        Q_ASSERT(false);\n        return false;\n\n    case CONN_STATE_STARTTLS_VERIFYING:\n    case CONN_STATE_SSL_VERIFYING:\n    {\n        // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n        // FIXME: an assert(false) here?\n        qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n        return false;\n    }\n\n    case CONN_STATE_ESTABLISHED_PRECAPS:\n        // Connection is established and we're waiting for updated capabilities\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n            } else {\n                model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                askForAuth();\n            }\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_LOGIN:\n        // Check the result of the LOGIN command\n    {\n        if (resp->tag == loginCmd) {\n            loginCmd.clear();\n            // The LOGIN command is finished\n            if (resp->kind == OK) {\n                if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                    // Capabilities are already known\n                    if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                        compressCmd = parser->compressDeflate();\n                        model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                    } else {\n                        model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                        onComplete();\n                    }\n                } else {\n                    // Got to ask for the capabilities\n                    model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                    capabilityCmd = parser->capability();\n                }\n            } else {\n                // Login failed\n                QString message;\n                switch (resp->respCode) {\n                case Responses::UNAVAILABLE:\n                    message = tr(\"Temporary failure because a subsystem is down.\");\n                    break;\n                case Responses::AUTHENTICATIONFAILED:\n                    message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                    break;\n                case Responses::AUTHORIZATIONFAILED:\n                    message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                 \"but the server cannot or will not allow the authentication \"\n                                 \"identity to act as the requested authorization identity.\");\n                    break;\n                case Responses::EXPIRED:\n                    message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                 \"necessary data; either way, access is no longer permitted using \"\n                                 \"that passphrase.  You should get a new passphrase.\");\n                    break;\n                case Responses::PRIVACYREQUIRED:\n                    message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                    break;\n                case Responses::CONTACTADMIN:\n                    message = tr(\"You should contact the system administrator or support desk.\");\n                    break;\n                default:\n                    break;\n                }\n\n                if (message.isEmpty()) {\n                    message = tr(\"Login failed: %1\").arg(resp->message);\n                } else {\n                    message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                }\n                EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                model->m_imapPassword.clear();\n                model->m_hasImapPassword = false;\n                if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                    // The server has closed the conenction\n                    _failed(QLatin1String(\"Connection closed after a failed login\"));\n                    return true;\n                }\n                askForAuth();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    case CONN_STATE_POSTAUTH_PRECAPS:\n    {\n        bool wasCaps = checkCapabilitiesResult(resp);\n        if (wasCaps && !_finished) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n        }\n        return wasCaps;\n    }\n\n    case CONN_STATE_COMPRESS_DEFLATE:\n        if (resp->tag == compressCmd) {\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n            onComplete();\n            return true;\n        } else {\n            return false;\n        }\n        break;\n\n    }\n\n    // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n    Q_ASSERT(false);\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "esp->message)"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketEncryptedResponse(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "487-506",
          "snippet": "ool OpenConnectionTask::handleSocketEncryptedResponse(const Responses::SocketEncryptedResponse *const resp)\n{\n    switch (model->accessParser(parser).connState) {\n    case CONN_STATE_SSL_HANDSHAKE:\n        model->changeConnectionState(parser, CONN_STATE_SSL_VERIFYING);\n        m_sslChain = resp->sslChain;\n        m_sslErrors = resp->sslErrors;\n        model->processSslErrors(this);\n        return true;\n    case CONN_STATE_STARTTLS_HANDSHAKE:\n        model->changeConnectionState(parser, CONN_STATE_STARTTLS_VERIFYING);\n        m_sslChain = resp->sslChain;\n        m_sslErrors = resp->sslErrors;\n        model->processSslErrors(this);\n        return true;\n    default:\n        qDebug() << model->accessParser(parser).connState;\n        return false;\n    }\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleSocketEncryptedResponse(const Responses::SocketEncryptedResponse *const resp)\n  {\n      switch (model->accessParser(parser).connState) {\n      case CONN_STATE_SSL_HANDSHAKE:\n          model->changeConnectionState(parser, CONN_STATE_SSL_VERIFYING);\n          m_sslChain = resp->sslChain;\n          m_sslErrors = resp->sslErrors;\n          model->processSslErrors(this);\n          return true;\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          model->changeConnectionState(parser, CONN_STATE_STARTTLS_VERIFYING);\n          m_sslChain = resp->sslChain;\n          m_sslErrors = resp->sslErrors;\n          model->processSslErrors(this);\n          return true;\n      default:\n          qDebug() << model->accessParser(parser).connState;\n          return false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.isEmpty",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->capability",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "capability(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "121-126",
          "snippet": "ommandHandle Parser::capability()\n{\n    // CAPABILITY should take precedence over LOGIN, because we have to check for LOGINDISABLED\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::capability()\n  {\n      // CAPABILITY should take precedence over LOGIN, because we have to check for LOGINDISABLED\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_POSTAUTH_PRECAPS)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_AUTHENTICATED)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_COMPRESS_DEFLATE)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->compressDeflate",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "compressDeflate(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "134-138",
          "snippet": "ommandHandle Parser::compressDeflate()\n{\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::COMPRESS_DEFLATE, \"COMPRESS DEFLATE\"));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::compressDeflate()\n  {\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::COMPRESS_DEFLATE, \"COMPRESS DEFLATE\"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"COMPRESS=DEFLATE\"))"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "COMPRESS=DEFLATE\")"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_LOGIN)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ogout(",
          "args": [
            "r(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"))"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "logout(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "418-422",
          "snippet": "oid OpenConnectionTask::logout(const QString &message)\n{\n    _failed(message);\n    model->setNetworkPolicy(NETWORK_OFFLINE);\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::logout(const QString &message)\n  {\n      _failed(message);\n      model->setNetworkPolicy(NETWORK_OFFLINE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"LOGINDISABLED\"))"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "LOGINDISABLED\")"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIT_LATER_NOARG(",
          "args": [
            "odel,",
            "equireStartTlsInFuture)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_STARTTLS_HANDSHAKE)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tartTlsOrLoginNow(",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "startTlsOrLoginNow(",
          "container": "penConnectionTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
          "lines": "361-378",
          "snippet": "oid OpenConnectionTask::startTlsOrLoginNow()\n{\n    if (model->m_startTls || model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n        // Should run STARTTLS later and already have the capabilities\n        Q_ASSERT(model->accessParser(parser).capabilitiesFresh);\n        if (!model->accessParser(parser).capabilities.contains(QLatin1String(\"STARTTLS\"))) {\n            logout(tr(\"Server does not support STARTTLS\"));\n        } else {\n            startTlsCmd = parser->startTls();\n            model->changeConnectionState(parser, CONN_STATE_STARTTLS_ISSUED);\n        }\n    } else {\n        // We're requested to authenticate even without STARTTLS\n        Q_ASSERT(!model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\")));\n        model->changeConnectionState(parser, CONN_STATE_LOGIN);\n        askForAuth();\n    }\n}",
          "includes": [
            "include \"Streams/TrojitaZlibStatus.h\"",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"Imap/Tasks/IdTask.h\"\n#",
            "include \"Imap/Tasks/EnableTask.h\"\n#",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/ConnectionId.h\"\n#",
            "include <QTimer>\n#",
            "include \"OpenConnectionTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::startTlsOrLoginNow()\n  {\n      if (model->m_startTls || model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n          // Should run STARTTLS later and already have the capabilities\n          Q_ASSERT(model->accessParser(parser).capabilitiesFresh);\n          if (!model->accessParser(parser).capabilities.contains(QLatin1String(\"STARTTLS\"))) {\n              logout(tr(\"Server does not support STARTTLS\"));\n          } else {\n              startTlsCmd = parser->startTls();\n              model->changeConnectionState(parser, CONN_STATE_STARTTLS_ISSUED);\n          }\n      } else {\n          // We're requested to authenticate even without STARTTLS\n          Q_ASSERT(!model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\")));\n          model->changeConnectionState(parser, CONN_STATE_LOGIN);\n          askForAuth();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::UnexpectedResponseReceived(",
          "args": [
            "Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\",",
            "resp)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_LOGOUT)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_CONNECTED_PRETLS)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_POSTAUTH_PRECAPS)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_AUTHENTICATED)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_COMPRESS_DEFLATE)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"COMPRESS=DEFLATE\"))"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "COMPRESS=DEFLATE\")"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnexpectedResponseReceived(",
          "args": [
            "essage.constData(),",
            "resp)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.constData",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::connectionStateToString",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::connectionStateToString(",
          "args": [
            "odel->accessParser(parser).connState)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnexpectedResponseReceived(",
          "args": [
            "Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\",",
            "resp)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  ool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      using namespace Imap::Responses;\n  \n      if (model->accessParser(parser).connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (!resp->tag.isEmpty()) {\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/PREAUTH, but got tagged response instead\", *resp);\n          }\n      } else if (model->accessParser(parser).connState > CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n          if (resp->tag.isEmpty()) {\n              return false;\n          }\n      }\n  \n      switch (model->accessParser(parser).connState) {\n  \n      case CONN_STATE_AUTHENTICATED:\n      case CONN_STATE_SELECTING:\n      case CONN_STATE_SYNCING:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_LOGOUT:\n      {\n          QByteArray message = \"No response expected by the OpenConnectionTask in state \" +\n                  Imap::connectionStateToString(model->accessParser(parser).connState).toUtf8();\n          // These shall not ever be reached by this code\n          throw Imap::UnexpectedResponseReceived(message.constData(), *resp);\n      }\n  \n      case CONN_STATE_NONE:\n      case CONN_STATE_HOST_LOOKUP:\n      case CONN_STATE_CONNECTING:\n          // Looks like the corresponding stateChanged() signal could be delayed, at least with QProcess-based sockets\n      case CONN_STATE_CONNECTED_PRETLS_PRECAPS:\n          // We're connected now -- this is our initial state.\n      {\n          switch (resp->kind) {\n          case PREAUTH:\n              // Cool, we're already authenticated. Now, let's see if we have to issue CAPABILITY or if we already know that\n              if (model->accessParser(parser).capabilitiesFresh) {\n                  // We're alsmost done here, apart from compression\n                  if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                      compressCmd = parser->compressDeflate();\n                      model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                  } else {\n                      // really done\n                      model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                      onComplete();\n                  }\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                  capabilityCmd = parser->capability();\n              }\n              return true;\n  \n          case OK:\n              if (!model->accessParser(parser).capabilitiesFresh) {\n                  model->changeConnectionState(parser, CONN_STATE_CONNECTED_PRETLS);\n                  capabilityCmd = parser->capability();\n              } else {\n                  startTlsOrLoginNow();\n              }\n              return true;\n  \n          case BYE:\n              logout(tr(\"Server has closed the connection\"));\n              return true;\n  \n          case BAD:\n              model->changeConnectionState(parser, CONN_STATE_LOGOUT);\n              // If it was an ALERT, we've already warned the user\n              if (resp->respCode != ALERT) {\n                  emit model->alertReceived(tr(\"The server replied with the following BAD response:\\n%1\").arg(resp->message));\n              }\n              logout(tr(\"Server has greeted us with a BAD response\"));\n              return true;\n  \n          default:\n              throw Imap::UnexpectedResponseReceived(\"Waiting for initial OK/BYE/BAD/PREAUTH, but got this instead\", *resp);\n          }\n          break;\n      }\n  \n      case CONN_STATE_CONNECTED_PRETLS:\n          // We've asked for capabilities upon the initial interaction\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              startTlsOrLoginNow();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_STARTTLS_ISSUED:\n      {\n          if (resp->tag == startTlsCmd) {\n              if (resp->kind == OK) {\n                  model->changeConnectionState(parser, CONN_STATE_STARTTLS_HANDSHAKE);\n                  if (!model->m_startTls) {\n                      // The model was not configured to perform STARTTLS, but we still did that for some reason.\n                      // As suggested by Mike Cardwell on the trojita ML (http://article.gmane.org/gmane.mail.trojita.general/299),\n                      // it makes sense to make this settings permanent, so that a user is not tricked into revealing their\n                      // password when a MITM removes the LOGINDISABLED in future.\n                      EMIT_LATER_NOARG(model, requireStartTlsInFuture);\n                  }\n              } else {\n                  logout(tr(\"STARTTLS failed: %1\").arg(resp->message));\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_SSL_HANDSHAKE:\n      case CONN_STATE_STARTTLS_HANDSHAKE:\n          // nothing should really arrive at this point; the Parser is expected to wait for encryption and only after that\n          // send the data\n          Q_ASSERT(false);\n          return false;\n  \n      case CONN_STATE_STARTTLS_VERIFYING:\n      case CONN_STATE_SSL_VERIFYING:\n      {\n          // We're waiting for a decision based on a policy, so we do not really expect any network IO at this point\n          // FIXME: an assert(false) here?\n          qDebug() << \"OpenConnectionTask: ignoring response, we're still waiting for SSL policy decision\";\n          return false;\n      }\n  \n      case CONN_STATE_ESTABLISHED_PRECAPS:\n          // Connection is established and we're waiting for updated capabilities\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"LOGINDISABLED\"))) {\n                  logout(tr(\"Capabilities still contain LOGINDISABLED even after STARTTLS\"));\n              } else {\n                  model->changeConnectionState(parser, CONN_STATE_LOGIN);\n                  askForAuth();\n              }\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_LOGIN:\n          // Check the result of the LOGIN command\n      {\n          if (resp->tag == loginCmd) {\n              loginCmd.clear();\n              // The LOGIN command is finished\n              if (resp->kind == OK) {\n                  if (resp->respCode == CAPABILITIES || model->accessParser(parser).capabilitiesFresh) {\n                      // Capabilities are already known\n                      if (TROJITA_COMPRESS_DEFLATE && model->accessParser(parser).capabilities.contains(QLatin1String(\"COMPRESS=DEFLATE\"))) {\n                          compressCmd = parser->compressDeflate();\n                          model->changeConnectionState(parser, CONN_STATE_COMPRESS_DEFLATE);\n                      } else {\n                          model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n                          onComplete();\n                      }\n                  } else {\n                      // Got to ask for the capabilities\n                      model->changeConnectionState(parser, CONN_STATE_POSTAUTH_PRECAPS);\n                      capabilityCmd = parser->capability();\n                  }\n              } else {\n                  // Login failed\n                  QString message;\n                  switch (resp->respCode) {\n                  case Responses::UNAVAILABLE:\n                      message = tr(\"Temporary failure because a subsystem is down.\");\n                      break;\n                  case Responses::AUTHENTICATIONFAILED:\n                      message = tr(\"Authentication failed.  This often happens due to bad password or wrong user name.\");\n                      break;\n                  case Responses::AUTHORIZATIONFAILED:\n                      message = tr(\"Authentication succeeded in using the authentication identity, \"\n                                   \"but the server cannot or will not allow the authentication \"\n                                   \"identity to act as the requested authorization identity.\");\n                      break;\n                  case Responses::EXPIRED:\n                      message = tr(\"Either authentication succeeded or the server no longer had the \"\n                                   \"necessary data; either way, access is no longer permitted using \"\n                                   \"that passphrase.  You should get a new passphrase.\");\n                      break;\n                  case Responses::PRIVACYREQUIRED:\n                      message = tr(\"The operation is not permitted due to a lack of privacy.\");\n                      break;\n                  case Responses::CONTACTADMIN:\n                      message = tr(\"You should contact the system administrator or support desk.\");\n                      break;\n                  default:\n                      break;\n                  }\n  \n                  if (message.isEmpty()) {\n                      message = tr(\"Login failed: %1\").arg(resp->message);\n                  } else {\n                      message = tr(\"%1\\n\\n%2\").arg(message, resp->message);\n                  }\n                  EMIT_LATER(model, authAttemptFailed, Q_ARG(QString, message));\n                  model->m_imapPassword.clear();\n                  model->m_hasImapPassword = false;\n                  if (model->accessParser(parser).connState == CONN_STATE_LOGOUT) {\n                      // The server has closed the conenction\n                      _failed(QLatin1String(\"Connection closed after a failed login\"));\n                      return true;\n                  }\n                  askForAuth();\n              }\n              return true;\n          }\n          return false;\n      }\n  \n      case CONN_STATE_POSTAUTH_PRECAPS:\n      {\n          bool wasCaps = checkCapabilitiesResult(resp);\n          if (wasCaps && !_finished) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n          }\n          return wasCaps;\n      }\n  \n      case CONN_STATE_COMPRESS_DEFLATE:\n          if (resp->tag == compressCmd) {\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n              onComplete();\n              return true;\n          } else {\n              return false;\n          }\n          break;\n  \n      }\n  \n      // Required catch-all for OpenSuSE's build service (Tumbleweed, 2012-04-03)\n      Q_ASSERT(false);\n      return false;\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "69-72",
    "snippet": "oid OpenConnectionTask::perform()\n{\n    // nothing should happen here\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  oid OpenConnectionTask::perform()\n  {\n      // nothing should happen here\n  }\n}"
  },
  {
    "function_name": "debugIdentification(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "61-67",
    "snippet": "String OpenConnectionTask::debugIdentification() const\n{\n    if (parser)\n        return QString::fromUtf8(\"OpenConnectionTask: %1\").arg(Imap::connectionStateToString(model->accessParser(parser).connState));\n    else\n        return QLatin1String(\"OpenConnectionTask: no parser\");\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "OpenConnectionTask: no parser\")"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "map::connectionStateToString(model->accessParser(parser).connState))"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::connectionStateToString(",
          "args": [
            "odel->accessParser(parser).connState)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "OpenConnectionTask: %1\")"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  String OpenConnectionTask::debugIdentification() const\n  {\n      if (parser)\n          return QString::fromUtf8(\"OpenConnectionTask: %1\").arg(Imap::connectionStateToString(model->accessParser(parser).connState));\n      else\n          return QLatin1String(\"OpenConnectionTask: no parser\");\n  }\n}"
  },
  {
    "function_name": "OpenConnectionTask(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "55-59",
    "snippet": "penConnectionTask::OpenConnectionTask(Model *model, void *dummy):\n    ImapTask(model)\n{\n    Q_UNUSED(dummy);\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ummy)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  penConnectionTask::OpenConnectionTask(Model *model, void *dummy):\n      ImapTask(model)\n  {\n      Q_UNUSED(dummy);\n  }\n}"
  },
  {
    "function_name": "OpenConnectionTask(",
    "container": "penConnectionTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/OpenConnectionTask.cpp",
    "lines": "39-53",
    "snippet": "penConnectionTask::OpenConnectionTask(Model *model) :\n    ImapTask(model)\n{\n    // Offline mode shall be checked by the caller who decides to create the connection\n    Q_ASSERT(model->networkPolicy() != NETWORK_OFFLINE);\n    parser = new Parser(model, model->m_socketFactory->create(), Common::ConnectionId::next());\n    ParserState parserState(parser);\n    connect(parser, SIGNAL(responseReceived(Imap::Parser *)), model, SLOT(responseReceived(Imap::Parser*)), Qt::QueuedConnection);\n    connect(parser, SIGNAL(connectionStateChanged(Imap::Parser *,Imap::ConnectionState)), model, SLOT(handleSocketStateChanged(Imap::Parser *,Imap::ConnectionState)));\n    connect(parser, SIGNAL(lineReceived(Imap::Parser *,QByteArray)), model, SLOT(slotParserLineReceived(Imap::Parser *,QByteArray)));\n    connect(parser, SIGNAL(lineSent(Imap::Parser *,QByteArray)), model, SLOT(slotParserLineSent(Imap::Parser *,QByteArray)));\n    model->m_parsers[ parser ] = parserState;\n    model->m_taskModel->slotParserCreated(parser);\n    markAsActiveTask();\n}",
    "includes": [
      "include \"Streams/TrojitaZlibStatus.h\"",
      "include \"Streams/SocketFactory.h\"\n#",
      "include \"Imap/Tasks/IdTask.h\"\n#",
      "include \"Imap/Tasks/EnableTask.h\"\n#",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"Common/ConnectionId.h\"\n#",
      "include <QTimer>\n#",
      "include \"OpenConnectionTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskModel->slotParserCreated",
          "args": [
            "arser)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommon::ConnectionId::next(",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "next(",
          "container": "ommon::ConnectionId",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Common/ConnectionId.cpp",
          "lines": "26-26",
          "snippet": "nsigned int Common::ConnectionId::next() { return ++s_id; }",
          "includes": [
            "include \"ConnectionId.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "nsigned int Common::ConnectionId::s_id = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"ConnectionId.h\"\n\nnsigned int Common::ConnectionId::s_id = 0;\n\nommon {\n  ConnectionId {\n    nsigned int Common::ConnectionId::next() { return ++s_id; }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->m_socketFactory->create",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel->networkPolicy() != NETWORK_OFFLINE)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->networkPolicy",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/TrojitaZlibStatus.h\"\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"Imap/Tasks/IdTask.h\"\n#\ninclude \"Imap/Tasks/EnableTask.h\"\n#\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/ConnectionId.h\"\n#\ninclude <QTimer>\n#\ninclude \"OpenConnectionTask.h\"\n#\n\npenConnectionTask {\n  penConnectionTask::OpenConnectionTask(Model *model) :\n      ImapTask(model)\n  {\n      // Offline mode shall be checked by the caller who decides to create the connection\n      Q_ASSERT(model->networkPolicy() != NETWORK_OFFLINE);\n      parser = new Parser(model, model->m_socketFactory->create(), Common::ConnectionId::next());\n      ParserState parserState(parser);\n      connect(parser, SIGNAL(responseReceived(Imap::Parser *)), model, SLOT(responseReceived(Imap::Parser*)), Qt::QueuedConnection);\n      connect(parser, SIGNAL(connectionStateChanged(Imap::Parser *,Imap::ConnectionState)), model, SLOT(handleSocketStateChanged(Imap::Parser *,Imap::ConnectionState)));\n      connect(parser, SIGNAL(lineReceived(Imap::Parser *,QByteArray)), model, SLOT(slotParserLineReceived(Imap::Parser *,QByteArray)));\n      connect(parser, SIGNAL(lineSent(Imap::Parser *,QByteArray)), model, SLOT(slotParserLineSent(Imap::Parser *,QByteArray)));\n      model->m_parsers[ parser ] = parserState;\n      model->m_taskModel->slotParserCreated(parser);\n      markAsActiveTask();\n  }\n}"
  }
]