[
  {
    "function_name": "slotSqlError(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "321-325",
    "snippet": "oid XtConnect::slotSqlError(const QString &message)\n{\n    qWarning() << message;\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"SqlCache\"), message);\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_model->logTrace",
          "args": [
            ",",
            "ommon::LOG_OTHER,",
            "Latin1String(\"SqlCache\"),",
            "essage)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SqlCache\")"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "maybeShowPasswordWarning()",
          "container": "goingPage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/SettingsDialog.cpp",
          "lines": "761-764",
          "snippet": "d OutgoingPage::maybeShowPasswordWarning()\n{\n    passwordWarning->setVisible(!smtpPass->text().isEmpty());\n}\n\n#",
          "includes": [
            "include \"Gui/Util.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include <QDataWidgetMapper>\n#",
            "include <QMessageBox>\n#",
            "include <QToolTip>\n#",
            "include <QStandardItemModel>\n#",
            "include <QDebug>\n#",
            "include <QResizeEvent>\n#",
            "include <QPushButton>\n#",
            "include <QProcess>\n#",
            "include <QVBoxLayout>\n#",
            "include <QTabWidget>\n#",
            "include <QSpinBox>\n#",
            "include <QRadioButton>\n#",
            "include <QListWidget>\n#",
            "include <QLineEdit>\n#",
            "include <QInputDialog>\n#",
            "include <QGroupBox>\n#",
            "include <QFormLayout>\n#",
            "include <QDir>\n#",
            "include <QDialogButtonBox>\n#",
            "include <QComboBox>\n#",
            "include <QCheckBox>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Gui/Util.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude <QDataWidgetMapper>\n#\ninclude <QMessageBox>\n#\ninclude <QToolTip>\n#\ninclude <QStandardItemModel>\n#\ninclude <QDebug>\n#\ninclude <QResizeEvent>\n#\ninclude <QPushButton>\n#\ninclude <QProcess>\n#\ninclude <QVBoxLayout>\n#\ninclude <QTabWidget>\n#\ninclude <QSpinBox>\n#\ninclude <QRadioButton>\n#\ninclude <QListWidget>\n#\ninclude <QLineEdit>\n#\ninclude <QInputDialog>\n#\ninclude <QGroupBox>\n#\ninclude <QFormLayout>\n#\ninclude <QDir>\n#\ninclude <QDialogButtonBox>\n#\ninclude <QComboBox>\n#\ninclude <QCheckBox>\n#\n\ngoingPage {\n  d OutgoingPage::maybeShowPasswordWarning()\n  {\n      passwordWarning->setVisible(!smtpPass->text().isEmpty());\n  }\n  \n  #\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotSqlError(const QString &message)\n  {\n      qWarning() << message;\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"SqlCache\"), message);\n  }\n}"
  },
  {
    "function_name": "slotDumpStats(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "313-319",
    "snippet": "oid XtConnect::slotDumpStats()\n{\n    qDebug() << QDateTime::currentDateTime();\n    Q_FOREACH( const QPointer<MailSynchronizer> item, m_syncers ) {\n        item->debugStats();\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tem->debugStats",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTime::currentDateTime(",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotDumpStats()\n  {\n      qDebug() << QDateTime::currentDateTime();\n      Q_FOREACH( const QPointer<MailSynchronizer> item, m_syncers ) {\n          item->debugStats();\n      }\n  }\n}"
  },
  {
    "function_name": "slotMessageIsDuplicate(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "306-311",
    "snippet": "oid XtConnect::slotMessageIsDuplicate( const QString &mailbox, const QModelIndex &message )\n{\n    if ( m_cache ) {\n        m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_DUPLICATE );\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_cache->setMessageSavingStatus",
          "args": [
            "ailbox,",
            "essage.data( Imap::Mailbox::RoleMessageUid ).toUInt(),",
            "tCache::STATE_DUPLICATE"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotMessageIsDuplicate( const QString &mailbox, const QModelIndex &message )\n  {\n      if ( m_cache ) {\n          m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_DUPLICATE );\n      }\n  }\n}"
  },
  {
    "function_name": "slotMessageStored(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "299-304",
    "snippet": "oid XtConnect::slotMessageStored( const QString &mailbox, const QModelIndex &message )\n{\n    if ( m_cache ) {\n        m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_SAVED );\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_cache->setMessageSavingStatus",
          "args": [
            "ailbox,",
            "essage.data( Imap::Mailbox::RoleMessageUid ).toUInt(),",
            "tCache::STATE_SAVED"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotMessageStored( const QString &mailbox, const QModelIndex &message )\n  {\n      if ( m_cache ) {\n          m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_SAVED );\n      }\n  }\n}"
  },
  {
    "function_name": "slotAboutToRequestMessage(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "283-297",
    "snippet": "oid XtConnect::slotAboutToRequestMessage( const QString &mailbox, const QModelIndex &message, bool *shouldLoad )\n{\n    Q_ASSERT( shouldLoad );\n    if ( m_cache ) {\n        XtCache::SavingState status = m_cache->messageSavingStatus( mailbox, message.data( Imap::Mailbox::RoleMessageUid ).toUInt() );\n        switch ( status ) {\n        case XtCache::STATE_DUPLICATE:\n        case XtCache::STATE_SAVED:\n            *shouldLoad = false;\n            break;\n        case XtCache::STATE_UNKNOWN:\n            break;\n        }\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_cache->messageSavingStatus",
          "args": [
            "ailbox,",
            "essage.data( Imap::Mailbox::RoleMessageUid ).toUInt()"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage.data",
          "args": [
            "map::Mailbox::RoleMessageUid"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "houldLoad"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotAboutToRequestMessage( const QString &mailbox, const QModelIndex &message, bool *shouldLoad )\n  {\n      Q_ASSERT( shouldLoad );\n      if ( m_cache ) {\n          XtCache::SavingState status = m_cache->messageSavingStatus( mailbox, message.data( Imap::Mailbox::RoleMessageUid ).toUInt() );\n          switch ( status ) {\n          case XtCache::STATE_DUPLICATE:\n          case XtCache::STATE_SAVED:\n              *shouldLoad = false;\n              break;\n          case XtCache::STATE_UNKNOWN:\n              break;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "goTroughMailboxes(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "276-281",
    "snippet": "oid XtConnect::goTroughMailboxes()\n{\n    Q_FOREACH( MailSynchronizer *sync, m_syncers ) {\n        sync->switchHere();\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ync->switchHere",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::goTroughMailboxes()\n  {\n      Q_FOREACH( MailSynchronizer *sync, m_syncers ) {\n          sync->switchHere();\n      }\n  }\n}"
  },
  {
    "function_name": "showConnectionStatus(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "257-274",
    "snippet": "oid XtConnect::showConnectionStatus( QObject* parser, Imap::ConnectionState state )\n{\n    Q_UNUSED( parser );\n    using namespace Imap;\n\n    switch ( state ) {\n    case CONN_STATE_FETCHING_MSG_METADATA:\n    case CONN_STATE_FETCHING_PART:\n    case CONN_STATE_SELECTED:\n    case CONN_STATE_SELECTING:\n        return;\n    default:\n        // well, we're interested in the rest\n        break;\n    }\n\n    qDebug() << \"Connection status:\" <<  Imap::connectionStateToString( state );\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map::connectionStateToString(",
          "args": [
            "tate"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "arser"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::showConnectionStatus( QObject* parser, Imap::ConnectionState state )\n  {\n      Q_UNUSED( parser );\n      using namespace Imap;\n  \n      switch ( state ) {\n      case CONN_STATE_FETCHING_MSG_METADATA:\n      case CONN_STATE_FETCHING_PART:\n      case CONN_STATE_SELECTED:\n      case CONN_STATE_SELECTING:\n          return;\n      default:\n          // well, we're interested in the rest\n          break;\n      }\n  \n      qDebug() << \"Connection status:\" <<  Imap::connectionStateToString( state );\n  }\n}"
  },
  {
    "function_name": "cacheError(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "248-255",
    "snippet": "oid XtConnect::cacheError(const QString &error)\n{\n    qCritical() << \"Cache error: \" << error;\n    if ( m_model ) {\n        m_cache = 0;\n        m_model->setCache(new Imap::Mailbox::MemoryCache(m_model));\n    }\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_model->setCache",
          "args": [
            "ew Imap::Mailbox::MemoryCache(m_model))"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Critical(",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::cacheError(const QString &error)\n  {\n      qCritical() << \"Cache error: \" << error;\n      if ( m_model ) {\n          m_cache = 0;\n          m_model->setCache(new Imap::Mailbox::MemoryCache(m_model));\n      }\n  }\n}"
  },
  {
    "function_name": "authenticationFailed(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "241-246",
    "snippet": "oid XtConnect::authenticationFailed(const QString &message)\n{\n    qCritical() << \"Cannot login to the IMAP server: \" << message;\n    m_model->setNetworkOffline();\n    qFatal(\"Unable to login to the IMAP server\");\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "Unable to login to the IMAP server\")"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setNetworkOffline",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Critical(",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::authenticationFailed(const QString &message)\n  {\n      qCritical() << \"Cannot login to the IMAP server: \" << message;\n      m_model->setNetworkOffline();\n      qFatal(\"Unable to login to the IMAP server\");\n  }\n}"
  },
  {
    "function_name": "connectionError(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "233-239",
    "snippet": "oid XtConnect::connectionError(const QString &error)\n{\n    qCritical() << \"Connection error: \" << error;\n    m_model->setNetworkOffline();\n    // FIXME: add some nice behavior for reconnecting. Also handle failed logins...\n    qFatal(\"Reconnects not supported yet -> see you.\");\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "Reconnects not supported yet -> see you.\")"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setNetworkOffline",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Critical(",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::connectionError(const QString &error)\n  {\n      qCritical() << \"Connection error: \" << error;\n      m_model->setNetworkOffline();\n      // FIXME: add some nice behavior for reconnecting. Also handle failed logins...\n      qFatal(\"Reconnects not supported yet -> see you.\");\n  }\n}"
  },
  {
    "function_name": "sslErrors(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "218-231",
    "snippet": "oid XtConnect::sslErrors(const QList<QSslCertificate> &certificateChain, const QList<QSslError> &errors)\n{\n    QByteArray lastKnownCertPem = m_settings->value(Common::SettingsNames::imapSslPemCertificate).toByteArray();\n    QList<QSslCertificate> lastKnownCerts = lastKnownCertPem.isEmpty() ?\n                QList<QSslCertificate>() :\n                QSslCertificate::fromData(lastKnownCertPem, QSsl::Pem);\n    if (!certificateChain.isEmpty() && !lastKnownCerts.isEmpty() && certificateChain == lastKnownCerts) {\n        // It's the same certificate as the last time; we should accept that\n        m_model->setSslPolicy(certificateChain, errors, true);\n        return;\n    }\n    m_model->setSslPolicy(certificateChain, errors, false);\n    qFatal(\"SECURITY ERROR: SSL certificate validation has failed. Please run Trojita to accept the certificate.\");\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "SECURITY ERROR: SSL certificate validation has failed. Please run Trojita to accept the certificate.\")"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setSslPolicy",
          "args": [
            "ertificateChain,",
            "rrors,",
            "alse)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setSslPolicy",
          "args": [
            "ertificateChain,",
            "rrors,",
            "rue)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "astKnownCerts.isEmpty",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ertificateChain.isEmpty",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SslCertificate::fromData(",
          "args": [
            "astKnownCertPem,",
            "Ssl::Pem)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<QSslCertificate>",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "~XSqlQueryErrorListener",
          "container": "XSqlQueryErrorListener",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "102-105",
          "snippet": "XSqlQueryErrorListener::~XSqlQueryErrorListener()\n{\n  XSqlQuery::removeErrorListener(this);\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQueryErrorListener {\n  XSqlQueryErrorListener::~XSqlQueryErrorListener()\n  {\n    XSqlQuery::removeErrorListener(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "astKnownCertPem.isEmpty",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [
            "ommon::SettingsNames::imapSslPemCertificate)"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::sslErrors(const QList<QSslCertificate> &certificateChain, const QList<QSslError> &errors)\n  {\n      QByteArray lastKnownCertPem = m_settings->value(Common::SettingsNames::imapSslPemCertificate).toByteArray();\n      QList<QSslCertificate> lastKnownCerts = lastKnownCertPem.isEmpty() ?\n                  QList<QSslCertificate>() :\n                  QSslCertificate::fromData(lastKnownCertPem, QSsl::Pem);\n      if (!certificateChain.isEmpty() && !lastKnownCerts.isEmpty() && certificateChain == lastKnownCerts) {\n          // It's the same certificate as the last time; we should accept that\n          m_model->setSslPolicy(certificateChain, errors, true);\n          return;\n      }\n      m_model->setSslPolicy(certificateChain, errors, false);\n      qFatal(\"SECURITY ERROR: SSL certificate validation has failed. Please run Trojita to accept the certificate.\");\n  }\n}"
  },
  {
    "function_name": "authenticationRequested(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "208-216",
    "snippet": "oid XtConnect::authenticationRequested()\n{\n    if ( ! m_settings->contains(Common::SettingsNames::imapPassKey) ) {\n        qWarning() << \"Warning: no IMAP password set in the configuration.\";\n        qWarning() << \"Please remember to configure the synchronization service in Trojita GUI's settings dialog.\";\n    }\n    m_model->setImapUser(m_settings->value(Common::SettingsNames::imapUserKey).toString());\n    m_model->setImapPassword(m_settings->value(Common::SettingsNames::imapPassKey).toString());\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_model->setImapPassword",
          "args": [
            "_settings->value(Common::SettingsNames::imapPassKey).toString())"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [
            "ommon::SettingsNames::imapPassKey)"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_model->setImapUser",
          "args": [
            "_settings->value(Common::SettingsNames::imapUserKey).toString())"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "maybeShowPasswordWarning()",
          "container": "goingPage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/SettingsDialog.cpp",
          "lines": "761-764",
          "snippet": "d OutgoingPage::maybeShowPasswordWarning()\n{\n    passwordWarning->setVisible(!smtpPass->text().isEmpty());\n}\n\n#",
          "includes": [
            "include \"Gui/Util.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include <QDataWidgetMapper>\n#",
            "include <QMessageBox>\n#",
            "include <QToolTip>\n#",
            "include <QStandardItemModel>\n#",
            "include <QDebug>\n#",
            "include <QResizeEvent>\n#",
            "include <QPushButton>\n#",
            "include <QProcess>\n#",
            "include <QVBoxLayout>\n#",
            "include <QTabWidget>\n#",
            "include <QSpinBox>\n#",
            "include <QRadioButton>\n#",
            "include <QListWidget>\n#",
            "include <QLineEdit>\n#",
            "include <QInputDialog>\n#",
            "include <QGroupBox>\n#",
            "include <QFormLayout>\n#",
            "include <QDir>\n#",
            "include <QDialogButtonBox>\n#",
            "include <QComboBox>\n#",
            "include <QCheckBox>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Gui/Util.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude <QDataWidgetMapper>\n#\ninclude <QMessageBox>\n#\ninclude <QToolTip>\n#\ninclude <QStandardItemModel>\n#\ninclude <QDebug>\n#\ninclude <QResizeEvent>\n#\ninclude <QPushButton>\n#\ninclude <QProcess>\n#\ninclude <QVBoxLayout>\n#\ninclude <QTabWidget>\n#\ninclude <QSpinBox>\n#\ninclude <QRadioButton>\n#\ninclude <QListWidget>\n#\ninclude <QLineEdit>\n#\ninclude <QInputDialog>\n#\ninclude <QGroupBox>\n#\ninclude <QFormLayout>\n#\ninclude <QDir>\n#\ninclude <QDialogButtonBox>\n#\ninclude <QComboBox>\n#\ninclude <QCheckBox>\n#\n\ngoingPage {\n  d OutgoingPage::maybeShowPasswordWarning()\n  {\n      passwordWarning->setVisible(!smtpPass->text().isEmpty());\n  }\n  \n  #\n}"
        }
      },
      {
        "call_info": {
          "callee": "_settings->contains",
          "args": [
            "ommon::SettingsNames::imapPassKey)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::authenticationRequested()\n  {\n      if ( ! m_settings->contains(Common::SettingsNames::imapPassKey) ) {\n          qWarning() << \"Warning: no IMAP password set in the configuration.\";\n          qWarning() << \"Please remember to configure the synchronization service in Trojita GUI's settings dialog.\";\n      }\n      m_model->setImapUser(m_settings->value(Common::SettingsNames::imapUserKey).toString());\n      m_model->setImapPassword(m_settings->value(Common::SettingsNames::imapPassKey).toString());\n  }\n}"
  },
  {
    "function_name": "alertReceived(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "203-206",
    "snippet": "oid XtConnect::alertReceived(const QString &alert)\n{\n    qCritical() << \"ALERT: \" << alert;\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Critical(",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::alertReceived(const QString &alert)\n  {\n      qCritical() << \"ALERT: \" << alert;\n  }\n}"
  },
  {
    "function_name": "setupModels(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "141-201",
    "snippet": "oid XtConnect::setupModels()\n{\n    Imap::Mailbox::SocketFactoryPtr factory;\n    Imap::Mailbox::TaskFactoryPtr taskFactory( new Imap::Mailbox::TaskFactory() );\n\n    using Common::SettingsNames;\n    if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodTCP ) {\n        factory.reset( new Imap::Mailbox::TlsAbleSocketFactory(\n                m_settings->value( SettingsNames::imapHostKey ).toString(),\n                m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAP) ).toUInt() ) );\n        factory->setStartTlsRequired( m_settings->value( SettingsNames::imapStartTlsKey, true ).toBool() );\n    } else if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodSSL ) {\n        factory.reset( new Imap::Mailbox::SslSocketFactory(\n                m_settings->value( SettingsNames::imapHostKey ).toString(),\n                m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAPS) ).toUInt() ) );\n    } else {\n        QStringList args = m_settings->value( SettingsNames::imapProcessKey ).toString().split( QLatin1Char(' ') );\n        if ( args.isEmpty() ) {\n            qFatal(\"Invalid value found in the settings of imapProcessKey\");\n        }\n        QString appName = args.takeFirst();\n        factory.reset( new Imap::Mailbox::ProcessSocketFactory( appName, args ) );\n    }\n\n    bool shouldUsePersistentCache = true;\n    QString cacheDir = m_settings->value( Common::SettingsNames::xtConnectCacheDirectory).toString();\n\n    if ( ! QDir().mkpath( cacheDir ) ) {\n        qCritical() << \"Failed to create directory\" << cacheDir << \" -- will not remember anything on restart!\";\n        shouldUsePersistentCache = false;\n    }\n\n    if ( shouldUsePersistentCache ) {\n        m_cache = new XtCache( this, QLatin1String(\"trojita-imap-cache\"), cacheDir );\n        connect( m_cache, SIGNAL(error(QString)), this, SLOT(cacheError(QString)) );\n        if ( ! m_cache->open() ) {\n            // Error message was already shown by the cacheError() slot\n            m_cache->deleteLater();\n            m_cache = 0;\n        }\n    }\n\n    m_model = new Imap::Mailbox::Model(this, m_cache ? static_cast<Imap::Mailbox::AbstractCache*>(m_cache) :\n                                                       static_cast<Imap::Mailbox::AbstractCache*>(new Imap::Mailbox::MemoryCache(this)),\n                                       factory, taskFactory, m_settings->value(SettingsNames::imapStartOffline).toBool());\n    m_model->setObjectName( QLatin1String(\"model\") );\n    // We want to wait longer to increase the potential of better grouping -- we don't care much about the latency\n    m_model->setProperty( \"trojita-imap-delayed-fetch-part\", 300 );\n    // Disable preload of message envelopes. We are aggresively cleaning the cache as soon as possible, and\n    // we don't want to re-request message envelopes for messages which have been already processed before.\n    m_model->setProperty(\"trojita-imap-preload-msg-metadata\", 0);\n\n    connect( m_model, SIGNAL( alertReceived( const QString& ) ), this, SLOT( alertReceived( const QString& ) ) );\n    connect( m_model, SIGNAL( imapError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n    connect( m_model, SIGNAL( networkError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n    connect(m_model, SIGNAL(authRequested()), this, SLOT(authenticationRequested()), Qt::QueuedConnection);\n    connect(m_model, SIGNAL(authAttemptFailed(QString)), this, SLOT(authenticationFailed(QString)));\n    connect(m_model, SIGNAL(needsSslDecision(QList<QSslCertificate>,QList<QSslError>)),\n            this, SLOT(sslErrors(QList<QSslCertificate>,QList<QSslError>)), Qt::QueuedConnection);\n    connect( m_model, SIGNAL(connectionStateChanged(QObject*,Imap::ConnectionState)), this, SLOT(showConnectionStatus(QObject*,Imap::ConnectionState)) );\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(needsSslDecision(QList<QSslCertificate>,QList<QSslError>)),",
            "his,",
            "LOT(sslErrors(QList<QSslCertificate>,QList<QSslError>)),",
            "t::QueuedConnection)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "slErrors(QList<QSslCertificate>,QList<QSslError>))"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slErrors(",
          "args": [
            "List<QSslCertificate>,",
            "List<QSslError>)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "sslErrors(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "218-231",
          "snippet": "oid XtConnect::sslErrors(const QList<QSslCertificate> &certificateChain, const QList<QSslError> &errors)\n{\n    QByteArray lastKnownCertPem = m_settings->value(Common::SettingsNames::imapSslPemCertificate).toByteArray();\n    QList<QSslCertificate> lastKnownCerts = lastKnownCertPem.isEmpty() ?\n                QList<QSslCertificate>() :\n                QSslCertificate::fromData(lastKnownCertPem, QSsl::Pem);\n    if (!certificateChain.isEmpty() && !lastKnownCerts.isEmpty() && certificateChain == lastKnownCerts) {\n        // It's the same certificate as the last time; we should accept that\n        m_model->setSslPolicy(certificateChain, errors, true);\n        return;\n    }\n    m_model->setSslPolicy(certificateChain, errors, false);\n    qFatal(\"SECURITY ERROR: SSL certificate validation has failed. Please run Trojita to accept the certificate.\");\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::sslErrors(const QList<QSslCertificate> &certificateChain, const QList<QSslError> &errors)\n  {\n      QByteArray lastKnownCertPem = m_settings->value(Common::SettingsNames::imapSslPemCertificate).toByteArray();\n      QList<QSslCertificate> lastKnownCerts = lastKnownCertPem.isEmpty() ?\n                  QList<QSslCertificate>() :\n                  QSslCertificate::fromData(lastKnownCertPem, QSsl::Pem);\n      if (!certificateChain.isEmpty() && !lastKnownCerts.isEmpty() && certificateChain == lastKnownCerts) {\n          // It's the same certificate as the last time; we should accept that\n          m_model->setSslPolicy(certificateChain, errors, true);\n          return;\n      }\n      m_model->setSslPolicy(certificateChain, errors, false);\n      qFatal(\"SECURITY ERROR: SSL certificate validation has failed. Please run Trojita to accept the certificate.\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "eedsSslDecision(QList<QSslCertificate>,QList<QSslError>))"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eedsSslDecision(",
          "args": [
            "List<QSslCertificate>,",
            "List<QSslError>)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(authAttemptFailed(QString)),",
            "his,",
            "LOT(authenticationFailed(QString)))"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "uthenticationFailed(QString))"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uthenticationFailed(",
          "args": [
            "String)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "authenticationFailed(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "241-246",
          "snippet": "oid XtConnect::authenticationFailed(const QString &message)\n{\n    qCritical() << \"Cannot login to the IMAP server: \" << message;\n    m_model->setNetworkOffline();\n    qFatal(\"Unable to login to the IMAP server\");\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::authenticationFailed(const QString &message)\n  {\n      qCritical() << \"Cannot login to the IMAP server: \" << message;\n      m_model->setNetworkOffline();\n      qFatal(\"Unable to login to the IMAP server\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "uthAttemptFailed(QString))"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uthAttemptFailed(",
          "args": [
            "String)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(authRequested()),",
            "his,",
            "LOT(authenticationRequested()),",
            "t::QueuedConnection)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "uthenticationRequested())"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uthenticationRequested(",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "authenticationRequested(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "208-216",
          "snippet": "oid XtConnect::authenticationRequested()\n{\n    if ( ! m_settings->contains(Common::SettingsNames::imapPassKey) ) {\n        qWarning() << \"Warning: no IMAP password set in the configuration.\";\n        qWarning() << \"Please remember to configure the synchronization service in Trojita GUI's settings dialog.\";\n    }\n    m_model->setImapUser(m_settings->value(Common::SettingsNames::imapUserKey).toString());\n    m_model->setImapPassword(m_settings->value(Common::SettingsNames::imapPassKey).toString());\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::authenticationRequested()\n  {\n      if ( ! m_settings->contains(Common::SettingsNames::imapPassKey) ) {\n          qWarning() << \"Warning: no IMAP password set in the configuration.\";\n          qWarning() << \"Please remember to configure the synchronization service in Trojita GUI's settings dialog.\";\n      }\n      m_model->setImapUser(m_settings->value(Common::SettingsNames::imapUserKey).toString());\n      m_model->setImapPassword(m_settings->value(Common::SettingsNames::imapPassKey).toString());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "uthRequested())"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uthRequested(",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setProperty",
          "args": [
            "trojita-imap-preload-msg-metadata\",",
            ")"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setProperty",
          "args": [
            "trojita-imap-delayed-fetch-part\",",
            "00"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->setObjectName",
          "args": [
            "Latin1String(\"model\")"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "model\")"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [
            "ettingsNames::imapStartOffline)"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<Imap::Mailbox::AbstractCache*>",
          "args": [
            "ew Imap::Mailbox::MemoryCache(this))"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<Imap::Mailbox::AbstractCache*>",
          "args": [
            "_cache)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cache->deleteLater",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cache->open",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_cache,",
            "IGNAL(error(QString)),",
            "his,",
            "LOT(cacheError(QString))"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "acheError(QString))"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acheError(",
          "args": [
            "String)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "cacheError(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "248-255",
          "snippet": "oid XtConnect::cacheError(const QString &error)\n{\n    qCritical() << \"Cache error: \" << error;\n    if ( m_model ) {\n        m_cache = 0;\n        m_model->setCache(new Imap::Mailbox::MemoryCache(m_model));\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::cacheError(const QString &error)\n  {\n      qCritical() << \"Cache error: \" << error;\n      if ( m_model ) {\n          m_cache = 0;\n          m_model->setCache(new Imap::Mailbox::MemoryCache(m_model));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "rror(QString))"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rror(",
          "args": [
            "String)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "slotSqlError(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "321-325",
          "snippet": "oid XtConnect::slotSqlError(const QString &message)\n{\n    qWarning() << message;\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"SqlCache\"), message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotSqlError(const QString &message)\n  {\n      qWarning() << message;\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"SqlCache\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "trojita-imap-cache\")"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Critical(",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dir",
          "args": [
            "acheDir"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dir(",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "kgDataDir(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Util.cpp",
          "lines": "113-120",
          "snippet": "String pkgDataDir()\n{\n#ifdef PKGDATADIR\n    return QLatin1String(PKGDATADIR);\n#else\n    return QString();\n#endif\n}",
          "includes": [
            "include \"Window.h\"",
            "include \"Util.h\"\n#",
            "include \"configure.cmake.h\"\n#",
            "include <QSettings>",
            "include <QProcess>\n#",
            "include <QIcon>\n#",
            "include <QGridLayout>\n#",
            "include <QDir>\n#",
            "include <QDesktopWidget> // for Util::centerWidgetOnScreen\n#",
            "include <QCursor> // for Util::centerWidgetOnScreen\n#",
            "include <QCheckBox>\n#",
            "include <QBuffer>\n#",
            "include <QApplication>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Window.h\"\ninclude \"Util.h\"\n#\ninclude \"configure.cmake.h\"\n#\ninclude <QSettings>\ninclude <QProcess>\n#\ninclude <QIcon>\n#\ninclude <QGridLayout>\n#\ninclude <QDir>\n#\ninclude <QDesktopWidget> // for Util::centerWidgetOnScreen\n#\ninclude <QCursor> // for Util::centerWidgetOnScreen\n#\ninclude <QCheckBox>\n#\ninclude <QBuffer>\n#\ninclude <QApplication>\n#\n\nString pkgDataDir()\n{\n#ifdef PKGDATADIR\n    return QLatin1String(PKGDATADIR);\n#else\n    return QString();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "actory.reset",
          "args": [
            "ew Imap::Mailbox::ProcessSocketFactory( appName, args )"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.takeFirst",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "Invalid value found in the settings of imapProcessKey\")"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.isEmpty",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actory.reset",
          "args": [
            "ew Imap::Mailbox::SslSocketFactory(\n                m_settings->value( SettingsNames::imapHostKey ).toString(),\n                m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAPS) ).toUInt() )"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [
            "ettingsNames::imapPortKey,",
            "String::number(Common::PORT_IMAPS)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ommon::PORT_IMAPS)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actory->setStartTlsRequired",
          "args": [
            "_settings->value( SettingsNames::imapStartTlsKey, true ).toBool()"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "setStartTlsRequired(",
          "container": "ocketFactory",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/SocketFactory.cpp",
          "lines": "36-39",
          "snippet": "oid SocketFactory::setStartTlsRequired(const bool doIt)\n{\n    m_startTls = doIt;\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include \"IODeviceSocket.h\"\n#",
            "include <QSslSocket>\n#",
            "include <QProcess>\n#",
            "include <stdexcept>\n#",
            "include \"SocketFactory.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude \"IODeviceSocket.h\"\n#\ninclude <QSslSocket>\n#\ninclude <QProcess>\n#\ninclude <stdexcept>\n#\ninclude \"SocketFactory.h\"\n#\n\nocketFactory {\n  oid SocketFactory::setStartTlsRequired(const bool doIt)\n  {\n      m_startTls = doIt;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [
            "ettingsNames::imapStartTlsKey,",
            "rue"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actory.reset",
          "args": [
            "ew Imap::Mailbox::TlsAbleSocketFactory(\n                m_settings->value( SettingsNames::imapHostKey ).toString(),\n                m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAP) ).toUInt() )"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->value",
          "args": [
            "ettingsNames::imapPortKey,",
            "String::number(Common::PORT_IMAP)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ommon::PORT_IMAP)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::setupModels()\n  {\n      Imap::Mailbox::SocketFactoryPtr factory;\n      Imap::Mailbox::TaskFactoryPtr taskFactory( new Imap::Mailbox::TaskFactory() );\n  \n      using Common::SettingsNames;\n      if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodTCP ) {\n          factory.reset( new Imap::Mailbox::TlsAbleSocketFactory(\n                  m_settings->value( SettingsNames::imapHostKey ).toString(),\n                  m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAP) ).toUInt() ) );\n          factory->setStartTlsRequired( m_settings->value( SettingsNames::imapStartTlsKey, true ).toBool() );\n      } else if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodSSL ) {\n          factory.reset( new Imap::Mailbox::SslSocketFactory(\n                  m_settings->value( SettingsNames::imapHostKey ).toString(),\n                  m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAPS) ).toUInt() ) );\n      } else {\n          QStringList args = m_settings->value( SettingsNames::imapProcessKey ).toString().split( QLatin1Char(' ') );\n          if ( args.isEmpty() ) {\n              qFatal(\"Invalid value found in the settings of imapProcessKey\");\n          }\n          QString appName = args.takeFirst();\n          factory.reset( new Imap::Mailbox::ProcessSocketFactory( appName, args ) );\n      }\n  \n      bool shouldUsePersistentCache = true;\n      QString cacheDir = m_settings->value( Common::SettingsNames::xtConnectCacheDirectory).toString();\n  \n      if ( ! QDir().mkpath( cacheDir ) ) {\n          qCritical() << \"Failed to create directory\" << cacheDir << \" -- will not remember anything on restart!\";\n          shouldUsePersistentCache = false;\n      }\n  \n      if ( shouldUsePersistentCache ) {\n          m_cache = new XtCache( this, QLatin1String(\"trojita-imap-cache\"), cacheDir );\n          connect( m_cache, SIGNAL(error(QString)), this, SLOT(cacheError(QString)) );\n          if ( ! m_cache->open() ) {\n              // Error message was already shown by the cacheError() slot\n              m_cache->deleteLater();\n              m_cache = 0;\n          }\n      }\n  \n      m_model = new Imap::Mailbox::Model(this, m_cache ? static_cast<Imap::Mailbox::AbstractCache*>(m_cache) :\n                                                         static_cast<Imap::Mailbox::AbstractCache*>(new Imap::Mailbox::MemoryCache(this)),\n                                         factory, taskFactory, m_settings->value(SettingsNames::imapStartOffline).toBool());\n      m_model->setObjectName( QLatin1String(\"model\") );\n      // We want to wait longer to increase the potential of better grouping -- we don't care much about the latency\n      m_model->setProperty( \"trojita-imap-delayed-fetch-part\", 300 );\n      // Disable preload of message envelopes. We are aggresively cleaning the cache as soon as possible, and\n      // we don't want to re-request message envelopes for messages which have been already processed before.\n      m_model->setProperty(\"trojita-imap-preload-msg-metadata\", 0);\n  \n      connect( m_model, SIGNAL( alertReceived( const QString& ) ), this, SLOT( alertReceived( const QString& ) ) );\n      connect( m_model, SIGNAL( imapError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n      connect( m_model, SIGNAL( networkError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n      connect(m_model, SIGNAL(authRequested()), this, SLOT(authenticationRequested()), Qt::QueuedConnection);\n      connect(m_model, SIGNAL(authAttemptFailed(QString)), this, SLOT(authenticationFailed(QString)));\n      connect(m_model, SIGNAL(needsSslDecision(QList<QSslCertificate>,QList<QSslError>)),\n              this, SLOT(sslErrors(QList<QSslCertificate>,QList<QSslError>)), Qt::QueuedConnection);\n      connect( m_model, SIGNAL(connectionStateChanged(QObject*,Imap::ConnectionState)), this, SLOT(showConnectionStatus(QObject*,Imap::ConnectionState)) );\n  }\n}"
  },
  {
    "function_name": "XtConnect(",
    "container": "tConnect",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
    "lines": "49-139",
    "snippet": "tConnect::XtConnect(QObject *parent, QSettings *s) :\n    QObject(parent), m_model(0), m_settings(s), m_cache(0)\n{\n    Q_ASSERT(m_settings);\n    m_settings->setParent(this);\n    if ( ! m_settings->contains( Common::SettingsNames::xtConnectCacheDirectory ) ) {\n        qFatal(\"The service is not configured yet. Please use the Trojita GUI for configuration.\");\n    }\n\n    QString host = s->value( Common::SettingsNames::xtDbHost ).toString();\n    int port = s->value( Common::SettingsNames::xtDbPort, QVariant(5432) ).toInt();\n    QString dbname = s->value( Common::SettingsNames::xtDbDbName ).toString();\n    QString username = s->value( Common::SettingsNames::xtDbUser ).toString();\n    QString password;\n    bool readstdin = true;\n    bool logConsole = false;\n    QString logFile;\n\n    QStringList args = QCoreApplication::arguments();\n    for ( int i = 1; i < args.length(); i++ ) {\n        if (args.at(i) == \"-h\" && args.length() > i ) {\n            if (args.length() <= i + 1) qFatal(\"The \\\"-h\\\" option requires a value.\");\n            host = args.at(++i);\n        } else if (args.at(i) == \"-d\" && args.length() > i ) {\n            if (args.length() <= i + 1) qFatal(\"The \\\"-d\\\" option requires a value.\");\n            dbname = args.at(++i);\n        } else if (args.at(i) == \"-p\" && args.length() > i ) {\n            if (args.length() <= i + 1) qFatal(\"The \\\"-p\\\" option requires a value.\");\n            port = args.at(++i).toInt();\n        } else if (args.at(i) == \"-U\" && args.length() > i ) {\n            if (args.length() <= i + 1) qFatal(\"The \\\"-U\\\" option requires a value.\");\n            username = args.at(++i);\n        } else if (args.at(i) == \"-w\") {\n            if (args.length() <= i + 1) qFatal(\"The \\\"-w\\\" option requires a value.\");\n            readstdin = false;\n            password = args.at(++i);\n        } else if (args.at(i) == \"-W\") {\n            readstdin = true;\n        } else if (args.at(i) == \"--debug\") {\n            logConsole = true;\n        } else if (args.at(i) == \"--log\" && args.length() > i) {\n            if (args.length() <= i + 1) qFatal(\"The \\\"--log\\\" option requires a value.\");\n            logFile = args.at(++i);\n        } else {\n            QByteArray err = args.at(i).toLocal8Bit();\n            qFatal(\"Error: unrecognized command line option '%s'.\", err.constData());\n        }\n    }\n\n    for ( int i = 0; i < 3 && password.isEmpty() && readstdin; i++ ) {\n        QTextStream(stdout) << tr(\"Database Password: \");\n        password = QTextStream(stdin).readLine();\n    }\n\n    setupModels();\n\n    Common::FileLogger *logger = new Common::FileLogger(this);\n    if (logConsole)\n        logger->setConsoleLogging(true);\n    if (!logFile.isEmpty()) {\n        logger->setFileLogging(true, logFile);\n        logger->setAutoFlush(true);\n    }\n    connect(m_model, SIGNAL(logged(uint,Common::LogMessage)), logger, SLOT(slotImapLogged(uint,Common::LogMessage)));\n\n    // Prepare the mailboxes\n    m_finder = new MailboxFinder( this, m_model );\n    SqlStorage *storage = new SqlStorage( this, host, port, dbname, username, password );\n    connect(storage, SIGNAL(encounteredError(QString)), this, SLOT(slotSqlError(QString)));\n    storage->open();\n\n    QTimer *statsDumper = new QTimer(this);\n    connect( statsDumper, SIGNAL(timeout()), this, SLOT(slotDumpStats()) );\n    statsDumper->setInterval( 5000 );\n    statsDumper->start();\n\n    Q_FOREACH( const QString &mailbox, s->value( Common::SettingsNames::xtSyncMailboxList ).toStringList() ) {\n        MessageDownloader *downloader = new MessageDownloader(this, m_model, mailbox);\n        MailSynchronizer *sync = new MailSynchronizer(this, m_model, m_finder, downloader, storage);\n        connect( sync, SIGNAL(aboutToRequestMessage(QString,QModelIndex,bool*)), this, SLOT(slotAboutToRequestMessage(QString,QModelIndex,bool*)) );\n        connect( sync, SIGNAL(messageSaved(QString,QModelIndex)), this, SLOT(slotMessageStored(QString,QModelIndex)) );\n        connect( sync, SIGNAL(messageIsDuplicate(QString,QModelIndex)), this, SLOT(slotMessageIsDuplicate(QString,QModelIndex)) );\n        m_syncers[ mailbox ] = sync;\n        sync->setMailbox( mailbox );\n    }\n\n    m_rotateMailboxes = new QTimer(this);\n    m_rotateMailboxes->setInterval( 1000 * 60 * 3 ); // every three minutes\n    connect( m_rotateMailboxes, SIGNAL(timeout()), this, SLOT(goTroughMailboxes()) );\n    m_rotateMailboxes->start();\n}",
    "includes": [
      "include \"Streams/SocketFactory.h\"",
      "include \"SqlStorage.h\"\n#",
      "include \"MessageDownloader.h\"\n#",
      "include \"Imap/Model/MemoryCache.h\"\n#",
      "include \"Imap/Model/MailboxFinder.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"XtCache.h\"\n#",
      "include \"Common/SettingsNames.h\"\n#",
      "include \"Common/PortNumbers.h\"\n#",
      "include \"Common/FileLogger.h\"\n#",
      "include <QSettings>\n#",
      "include <QDebug>\n#",
      "include <QDir>\n#",
      "include <QCoreApplication>\n#",
      "include <QAuthenticator>\n#",
      "include \"XtConnect.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_rotateMailboxes->start",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_rotateMailboxes,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(goTroughMailboxes())"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "oTroughMailboxes())"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oTroughMailboxes(",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "goTroughMailboxes(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "276-281",
          "snippet": "oid XtConnect::goTroughMailboxes()\n{\n    Q_FOREACH( MailSynchronizer *sync, m_syncers ) {\n        sync->switchHere();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::goTroughMailboxes()\n  {\n      Q_FOREACH( MailSynchronizer *sync, m_syncers ) {\n          sync->switchHere();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_rotateMailboxes->setInterval",
          "args": [
            "000 * 60 * 3"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ync->setMailbox",
          "args": [
            "ailbox"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ync,",
            "IGNAL(messageIsDuplicate(QString,QModelIndex)),",
            "his,",
            "LOT(slotMessageIsDuplicate(QString,QModelIndex))"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotMessageIsDuplicate(QString,QModelIndex))"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotMessageIsDuplicate(",
          "args": [
            "String,",
            "ModelIndex)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "slotMessageIsDuplicate(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "306-311",
          "snippet": "oid XtConnect::slotMessageIsDuplicate( const QString &mailbox, const QModelIndex &message )\n{\n    if ( m_cache ) {\n        m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_DUPLICATE );\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotMessageIsDuplicate( const QString &mailbox, const QModelIndex &message )\n  {\n      if ( m_cache ) {\n          m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_DUPLICATE );\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "essageIsDuplicate(QString,QModelIndex))"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ync,",
            "IGNAL(messageSaved(QString,QModelIndex)),",
            "his,",
            "LOT(slotMessageStored(QString,QModelIndex))"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotMessageStored(QString,QModelIndex))"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotMessageStored(",
          "args": [
            "String,",
            "ModelIndex)"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "slotMessageStored(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "299-304",
          "snippet": "oid XtConnect::slotMessageStored( const QString &mailbox, const QModelIndex &message )\n{\n    if ( m_cache ) {\n        m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_SAVED );\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotMessageStored( const QString &mailbox, const QModelIndex &message )\n  {\n      if ( m_cache ) {\n          m_cache->setMessageSavingStatus( mailbox,  message.data( Imap::Mailbox::RoleMessageUid ).toUInt(), XtCache::STATE_SAVED );\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "essageSaved(QString,QModelIndex))"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageSaved(",
          "args": [
            "String,",
            "ModelIndex)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatsDumper->start",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatsDumper->setInterval",
          "args": [
            "000"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "tatsDumper,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotDumpStats())"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotDumpStats())"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotDumpStats(",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "slotDumpStats(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "313-319",
          "snippet": "oid XtConnect::slotDumpStats()\n{\n    qDebug() << QDateTime::currentDateTime();\n    Q_FOREACH( const QPointer<MailSynchronizer> item, m_syncers ) {\n        item->debugStats();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotDumpStats()\n  {\n      qDebug() << QDateTime::currentDateTime();\n      Q_FOREACH( const QPointer<MailSynchronizer> item, m_syncers ) {\n          item->debugStats();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torage->open",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "open(",
          "container": "qlStorage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/SqlStorage.cpp",
          "lines": "48-71",
          "snippet": "oid SqlStorage::open()\n{\n    db = QSqlDatabase::addDatabase( QLatin1String(\"QPSQL\"), QLatin1String(\"xtconnect-sqlstorage\") );\n    if ( ! _host.isEmpty() )\n        db.setHostName(_host);\n\n    if ( _port != 5432 && _port > 0 && _port < 65536 )\n        db.setPort(_port);\n\n    if ( ! _dbname.isEmpty() )\n        db.setDatabaseName( _dbname );\n\n    if ( ! _username.isEmpty() )\n        db.setUserName( _username );\n\n    if ( ! _password.isEmpty() )\n        db.setPassword( _password );\n\n    if ( ! db.open() ) {\n        _fail( \"Failed to open database connection\", db );\n    }\n\n    _prepareStatements();\n}",
          "includes": [
            "include <QVariant>",
            "include <QTimer>\n#",
            "include <QSqlError>\n#",
            "include <QDebug>\n#",
            "include <QCryptographicHash>\n#",
            "include \"SqlStorage.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariant>\ninclude <QTimer>\n#\ninclude <QSqlError>\n#\ninclude <QDebug>\n#\ninclude <QCryptographicHash>\n#\ninclude \"SqlStorage.h\"\n#\n\nqlStorage {\n  oid SqlStorage::open()\n  {\n      db = QSqlDatabase::addDatabase( QLatin1String(\"QPSQL\"), QLatin1String(\"xtconnect-sqlstorage\") );\n      if ( ! _host.isEmpty() )\n          db.setHostName(_host);\n  \n      if ( _port != 5432 && _port > 0 && _port < 65536 )\n          db.setPort(_port);\n  \n      if ( ! _dbname.isEmpty() )\n          db.setDatabaseName( _dbname );\n  \n      if ( ! _username.isEmpty() )\n          db.setUserName( _username );\n  \n      if ( ! _password.isEmpty() )\n          db.setPassword( _password );\n  \n      if ( ! db.open() ) {\n          _fail( \"Failed to open database connection\", db );\n      }\n  \n      _prepareStatements();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "torage,",
            "IGNAL(encounteredError(QString)),",
            "his,",
            "LOT(slotSqlError(QString)))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSqlError(QString))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSqlError(",
          "args": [
            "String)"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "slotSqlError(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "321-325",
          "snippet": "oid XtConnect::slotSqlError(const QString &message)\n{\n    qWarning() << message;\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"SqlCache\"), message);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::slotSqlError(const QString &message)\n  {\n      qWarning() << message;\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"SqlCache\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncounteredError(QString))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncounteredError(",
          "args": [
            "String)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(logged(uint,Common::LogMessage)),",
            "ogger,",
            "LOT(slotImapLogged(uint,Common::LogMessage)))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotImapLogged(uint,Common::LogMessage))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotImapLogged(",
          "args": [
            "int,",
            "ommon::LogMessage)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "slotImapLogged(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "145-165",
          "snippet": "oid ProtocolLoggerWidget::slotImapLogged(uint parser, Common::LogMessage message)\n{\n    using namespace Common;\n\n    QMap<uint, RingBuffer<LogMessage> >::iterator bufIt = buffers.find(parser);\n    if (bufIt == buffers.end()) {\n        // FIXME: don't hard-code that\n        bufIt = buffers.insert(parser, RingBuffer<LogMessage>(900));\n    }\n    if (m_fileLogger) {\n        m_fileLogger->slotImapLogged(parser, message);\n    }\n    enum {CUTOFF=200};\n    if (message.message.size() > CUTOFF) {\n        message.truncatedBytes = message.message.size() - CUTOFF;\n        message.message = message.message.left(CUTOFF);\n    }\n    bufIt->append(message);\n    if (loggingActive && !delayedDisplay->isActive())\n        delayedDisplay->start();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::slotImapLogged(uint parser, Common::LogMessage message)\n  {\n      using namespace Common;\n  \n      QMap<uint, RingBuffer<LogMessage> >::iterator bufIt = buffers.find(parser);\n      if (bufIt == buffers.end()) {\n          // FIXME: don't hard-code that\n          bufIt = buffers.insert(parser, RingBuffer<LogMessage>(900));\n      }\n      if (m_fileLogger) {\n          m_fileLogger->slotImapLogged(parser, message);\n      }\n      enum {CUTOFF=200};\n      if (message.message.size() > CUTOFF) {\n          message.truncatedBytes = message.message.size() - CUTOFF;\n          message.message = message.message.left(CUTOFF);\n      }\n      bufIt->append(message);\n      if (loggingActive && !delayedDisplay->isActive())\n          delayedDisplay->start();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ogged(uint,Common::LogMessage))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ogger->setAutoFlush",
          "args": [
            "rue)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "setAutoFlush(",
          "container": "ileLogger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Common/FileLogger.cpp",
          "lines": "134-139",
          "snippet": "oid FileLogger::setAutoFlush(const bool autoFlush)\n{\n    m_autoFlush = autoFlush;\n    if (m_autoFlush && m_fileLog)\n        m_fileLog->flush();\n}",
          "includes": [
            "include \"../Imap/Model/Utils.h\"",
            "include \"FileLogger.h\"\n#",
            "include <QTextStream>\n#",
            "include <QFile>\n#",
            "include <QDebug>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Imap/Model/Utils.h\"\ninclude \"FileLogger.h\"\n#\ninclude <QTextStream>\n#\ninclude <QFile>\n#\ninclude <QDebug>\n#\ninclude <QDateTime>\n#\n\nileLogger {\n  oid FileLogger::setAutoFlush(const bool autoFlush)\n  {\n      m_autoFlush = autoFlush;\n      if (m_autoFlush && m_fileLog)\n          m_fileLog->flush();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogger->setFileLogging",
          "args": [
            "rue,",
            "ogFile)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "setFileLogging(",
          "container": "ileLogger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Common/FileLogger.cpp",
          "lines": "38-55",
          "snippet": "oid FileLogger::setFileLogging(const bool enabled, const QString &fileName)\n{\n    if (enabled) {\n        if (m_fileLog)\n            return;\n\n        QFile *logFile = new QFile(fileName, this);\n        logFile->open(QIODevice::Truncate | QIODevice::WriteOnly);\n        m_fileLog = new QTextStream(logFile);\n    } else {\n        if (m_fileLog) {\n            QIODevice *dev = m_fileLog->device();\n            delete m_fileLog;\n            delete dev;\n            m_fileLog = 0;\n        }\n    }\n}",
          "includes": [
            "include \"../Imap/Model/Utils.h\"",
            "include \"FileLogger.h\"\n#",
            "include <QTextStream>\n#",
            "include <QFile>\n#",
            "include <QDebug>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Imap/Model/Utils.h\"\ninclude \"FileLogger.h\"\n#\ninclude <QTextStream>\n#\ninclude <QFile>\n#\ninclude <QDebug>\n#\ninclude <QDateTime>\n#\n\nileLogger {\n  oid FileLogger::setFileLogging(const bool enabled, const QString &fileName)\n  {\n      if (enabled) {\n          if (m_fileLog)\n              return;\n  \n          QFile *logFile = new QFile(fileName, this);\n          logFile->open(QIODevice::Truncate | QIODevice::WriteOnly);\n          m_fileLog = new QTextStream(logFile);\n      } else {\n          if (m_fileLog) {\n              QIODevice *dev = m_fileLog->device();\n              delete m_fileLog;\n              delete dev;\n              m_fileLog = 0;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogFile.isEmpty",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ogger->setConsoleLogging",
          "args": [
            "rue)"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "setConsoleLogging(",
          "container": "ileLogger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Common/FileLogger.cpp",
          "lines": "141-144",
          "snippet": "oid FileLogger::setConsoleLogging(const bool enabled)\n{\n    m_consoleLog = enabled;\n}",
          "includes": [
            "include \"../Imap/Model/Utils.h\"",
            "include \"FileLogger.h\"\n#",
            "include <QTextStream>\n#",
            "include <QFile>\n#",
            "include <QDebug>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Imap/Model/Utils.h\"\ninclude \"FileLogger.h\"\n#\ninclude <QTextStream>\n#\ninclude <QFile>\n#\ninclude <QDebug>\n#\ninclude <QDateTime>\n#\n\nileLogger {\n  oid FileLogger::setConsoleLogging(const bool enabled)\n  {\n      m_consoleLog = enabled;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etupModels(",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "setupModels(",
          "container": "tConnect",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/XtConnect.cpp",
          "lines": "141-201",
          "snippet": "oid XtConnect::setupModels()\n{\n    Imap::Mailbox::SocketFactoryPtr factory;\n    Imap::Mailbox::TaskFactoryPtr taskFactory( new Imap::Mailbox::TaskFactory() );\n\n    using Common::SettingsNames;\n    if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodTCP ) {\n        factory.reset( new Imap::Mailbox::TlsAbleSocketFactory(\n                m_settings->value( SettingsNames::imapHostKey ).toString(),\n                m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAP) ).toUInt() ) );\n        factory->setStartTlsRequired( m_settings->value( SettingsNames::imapStartTlsKey, true ).toBool() );\n    } else if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodSSL ) {\n        factory.reset( new Imap::Mailbox::SslSocketFactory(\n                m_settings->value( SettingsNames::imapHostKey ).toString(),\n                m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAPS) ).toUInt() ) );\n    } else {\n        QStringList args = m_settings->value( SettingsNames::imapProcessKey ).toString().split( QLatin1Char(' ') );\n        if ( args.isEmpty() ) {\n            qFatal(\"Invalid value found in the settings of imapProcessKey\");\n        }\n        QString appName = args.takeFirst();\n        factory.reset( new Imap::Mailbox::ProcessSocketFactory( appName, args ) );\n    }\n\n    bool shouldUsePersistentCache = true;\n    QString cacheDir = m_settings->value( Common::SettingsNames::xtConnectCacheDirectory).toString();\n\n    if ( ! QDir().mkpath( cacheDir ) ) {\n        qCritical() << \"Failed to create directory\" << cacheDir << \" -- will not remember anything on restart!\";\n        shouldUsePersistentCache = false;\n    }\n\n    if ( shouldUsePersistentCache ) {\n        m_cache = new XtCache( this, QLatin1String(\"trojita-imap-cache\"), cacheDir );\n        connect( m_cache, SIGNAL(error(QString)), this, SLOT(cacheError(QString)) );\n        if ( ! m_cache->open() ) {\n            // Error message was already shown by the cacheError() slot\n            m_cache->deleteLater();\n            m_cache = 0;\n        }\n    }\n\n    m_model = new Imap::Mailbox::Model(this, m_cache ? static_cast<Imap::Mailbox::AbstractCache*>(m_cache) :\n                                                       static_cast<Imap::Mailbox::AbstractCache*>(new Imap::Mailbox::MemoryCache(this)),\n                                       factory, taskFactory, m_settings->value(SettingsNames::imapStartOffline).toBool());\n    m_model->setObjectName( QLatin1String(\"model\") );\n    // We want to wait longer to increase the potential of better grouping -- we don't care much about the latency\n    m_model->setProperty( \"trojita-imap-delayed-fetch-part\", 300 );\n    // Disable preload of message envelopes. We are aggresively cleaning the cache as soon as possible, and\n    // we don't want to re-request message envelopes for messages which have been already processed before.\n    m_model->setProperty(\"trojita-imap-preload-msg-metadata\", 0);\n\n    connect( m_model, SIGNAL( alertReceived( const QString& ) ), this, SLOT( alertReceived( const QString& ) ) );\n    connect( m_model, SIGNAL( imapError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n    connect( m_model, SIGNAL( networkError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n    connect(m_model, SIGNAL(authRequested()), this, SLOT(authenticationRequested()), Qt::QueuedConnection);\n    connect(m_model, SIGNAL(authAttemptFailed(QString)), this, SLOT(authenticationFailed(QString)));\n    connect(m_model, SIGNAL(needsSslDecision(QList<QSslCertificate>,QList<QSslError>)),\n            this, SLOT(sslErrors(QList<QSslCertificate>,QList<QSslError>)), Qt::QueuedConnection);\n    connect( m_model, SIGNAL(connectionStateChanged(QObject*,Imap::ConnectionState)), this, SLOT(showConnectionStatus(QObject*,Imap::ConnectionState)) );\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"SqlStorage.h\"\n#",
            "include \"MessageDownloader.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/MailboxFinder.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"XtCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/FileLogger.h\"\n#",
            "include <QSettings>\n#",
            "include <QDebug>\n#",
            "include <QDir>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include \"XtConnect.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  oid XtConnect::setupModels()\n  {\n      Imap::Mailbox::SocketFactoryPtr factory;\n      Imap::Mailbox::TaskFactoryPtr taskFactory( new Imap::Mailbox::TaskFactory() );\n  \n      using Common::SettingsNames;\n      if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodTCP ) {\n          factory.reset( new Imap::Mailbox::TlsAbleSocketFactory(\n                  m_settings->value( SettingsNames::imapHostKey ).toString(),\n                  m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAP) ).toUInt() ) );\n          factory->setStartTlsRequired( m_settings->value( SettingsNames::imapStartTlsKey, true ).toBool() );\n      } else if ( m_settings->value( SettingsNames::imapMethodKey ).toString() == SettingsNames::methodSSL ) {\n          factory.reset( new Imap::Mailbox::SslSocketFactory(\n                  m_settings->value( SettingsNames::imapHostKey ).toString(),\n                  m_settings->value( SettingsNames::imapPortKey, QString::number(Common::PORT_IMAPS) ).toUInt() ) );\n      } else {\n          QStringList args = m_settings->value( SettingsNames::imapProcessKey ).toString().split( QLatin1Char(' ') );\n          if ( args.isEmpty() ) {\n              qFatal(\"Invalid value found in the settings of imapProcessKey\");\n          }\n          QString appName = args.takeFirst();\n          factory.reset( new Imap::Mailbox::ProcessSocketFactory( appName, args ) );\n      }\n  \n      bool shouldUsePersistentCache = true;\n      QString cacheDir = m_settings->value( Common::SettingsNames::xtConnectCacheDirectory).toString();\n  \n      if ( ! QDir().mkpath( cacheDir ) ) {\n          qCritical() << \"Failed to create directory\" << cacheDir << \" -- will not remember anything on restart!\";\n          shouldUsePersistentCache = false;\n      }\n  \n      if ( shouldUsePersistentCache ) {\n          m_cache = new XtCache( this, QLatin1String(\"trojita-imap-cache\"), cacheDir );\n          connect( m_cache, SIGNAL(error(QString)), this, SLOT(cacheError(QString)) );\n          if ( ! m_cache->open() ) {\n              // Error message was already shown by the cacheError() slot\n              m_cache->deleteLater();\n              m_cache = 0;\n          }\n      }\n  \n      m_model = new Imap::Mailbox::Model(this, m_cache ? static_cast<Imap::Mailbox::AbstractCache*>(m_cache) :\n                                                         static_cast<Imap::Mailbox::AbstractCache*>(new Imap::Mailbox::MemoryCache(this)),\n                                         factory, taskFactory, m_settings->value(SettingsNames::imapStartOffline).toBool());\n      m_model->setObjectName( QLatin1String(\"model\") );\n      // We want to wait longer to increase the potential of better grouping -- we don't care much about the latency\n      m_model->setProperty( \"trojita-imap-delayed-fetch-part\", 300 );\n      // Disable preload of message envelopes. We are aggresively cleaning the cache as soon as possible, and\n      // we don't want to re-request message envelopes for messages which have been already processed before.\n      m_model->setProperty(\"trojita-imap-preload-msg-metadata\", 0);\n  \n      connect( m_model, SIGNAL( alertReceived( const QString& ) ), this, SLOT( alertReceived( const QString& ) ) );\n      connect( m_model, SIGNAL( imapError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n      connect( m_model, SIGNAL( networkError( const QString& ) ), this, SLOT( connectionError( const QString& ) ) );\n      connect(m_model, SIGNAL(authRequested()), this, SLOT(authenticationRequested()), Qt::QueuedConnection);\n      connect(m_model, SIGNAL(authAttemptFailed(QString)), this, SLOT(authenticationFailed(QString)));\n      connect(m_model, SIGNAL(needsSslDecision(QList<QSslCertificate>,QList<QSslError>)),\n              this, SLOT(sslErrors(QList<QSslCertificate>,QList<QSslError>)), Qt::QueuedConnection);\n      connect( m_model, SIGNAL(connectionStateChanged(QObject*,Imap::ConnectionState)), this, SLOT(showConnectionStatus(QObject*,Imap::ConnectionState)) );\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextStream",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextStream(",
          "args": [
            "tdin)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextStream(",
          "args": [
            "tdout)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assword.isEmpty",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "Error: unrecognized command line option '%s'.\",",
            "rr.constData())"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rr.constData",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            "+i)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The \\\"--log\\\" option requires a value.\")"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            "+i)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The \\\"-w\\\" option requires a value.\")"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            "+i)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The \\\"-U\\\" option requires a value.\")"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            "+i)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The \\\"-p\\\" option requires a value.\")"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            "+i)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The \\\"-d\\\" option requires a value.\")"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            "+i)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The \\\"-h\\\" option requires a value.\")"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.at",
          "args": [
            ")"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.length",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CoreApplication::arguments(",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->value",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->value",
          "args": [
            "ommon::SettingsNames::xtDbUser"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->value",
          "args": [
            "ommon::SettingsNames::xtDbPort,",
            "Variant(5432)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [
            "432)"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Fatal(",
          "args": [
            "The service is not configured yet. Please use the Trojita GUI for configuration.\")"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->contains",
          "args": [
            "ommon::SettingsNames::xtConnectCacheDirectory"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_settings->setParent",
          "args": [
            "his)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_settings)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"SqlStorage.h\"\n#\ninclude \"MessageDownloader.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/MailboxFinder.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"XtCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/FileLogger.h\"\n#\ninclude <QSettings>\n#\ninclude <QDebug>\n#\ninclude <QDir>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude \"XtConnect.h\"\n#\n\ntConnect {\n  tConnect::XtConnect(QObject *parent, QSettings *s) :\n      QObject(parent), m_model(0), m_settings(s), m_cache(0)\n  {\n      Q_ASSERT(m_settings);\n      m_settings->setParent(this);\n      if ( ! m_settings->contains( Common::SettingsNames::xtConnectCacheDirectory ) ) {\n          qFatal(\"The service is not configured yet. Please use the Trojita GUI for configuration.\");\n      }\n  \n      QString host = s->value( Common::SettingsNames::xtDbHost ).toString();\n      int port = s->value( Common::SettingsNames::xtDbPort, QVariant(5432) ).toInt();\n      QString dbname = s->value( Common::SettingsNames::xtDbDbName ).toString();\n      QString username = s->value( Common::SettingsNames::xtDbUser ).toString();\n      QString password;\n      bool readstdin = true;\n      bool logConsole = false;\n      QString logFile;\n  \n      QStringList args = QCoreApplication::arguments();\n      for ( int i = 1; i < args.length(); i++ ) {\n          if (args.at(i) == \"-h\" && args.length() > i ) {\n              if (args.length() <= i + 1) qFatal(\"The \\\"-h\\\" option requires a value.\");\n              host = args.at(++i);\n          } else if (args.at(i) == \"-d\" && args.length() > i ) {\n              if (args.length() <= i + 1) qFatal(\"The \\\"-d\\\" option requires a value.\");\n              dbname = args.at(++i);\n          } else if (args.at(i) == \"-p\" && args.length() > i ) {\n              if (args.length() <= i + 1) qFatal(\"The \\\"-p\\\" option requires a value.\");\n              port = args.at(++i).toInt();\n          } else if (args.at(i) == \"-U\" && args.length() > i ) {\n              if (args.length() <= i + 1) qFatal(\"The \\\"-U\\\" option requires a value.\");\n              username = args.at(++i);\n          } else if (args.at(i) == \"-w\") {\n              if (args.length() <= i + 1) qFatal(\"The \\\"-w\\\" option requires a value.\");\n              readstdin = false;\n              password = args.at(++i);\n          } else if (args.at(i) == \"-W\") {\n              readstdin = true;\n          } else if (args.at(i) == \"--debug\") {\n              logConsole = true;\n          } else if (args.at(i) == \"--log\" && args.length() > i) {\n              if (args.length() <= i + 1) qFatal(\"The \\\"--log\\\" option requires a value.\");\n              logFile = args.at(++i);\n          } else {\n              QByteArray err = args.at(i).toLocal8Bit();\n              qFatal(\"Error: unrecognized command line option '%s'.\", err.constData());\n          }\n      }\n  \n      for ( int i = 0; i < 3 && password.isEmpty() && readstdin; i++ ) {\n          QTextStream(stdout) << tr(\"Database Password: \");\n          password = QTextStream(stdin).readLine();\n      }\n  \n      setupModels();\n  \n      Common::FileLogger *logger = new Common::FileLogger(this);\n      if (logConsole)\n          logger->setConsoleLogging(true);\n      if (!logFile.isEmpty()) {\n          logger->setFileLogging(true, logFile);\n          logger->setAutoFlush(true);\n      }\n      connect(m_model, SIGNAL(logged(uint,Common::LogMessage)), logger, SLOT(slotImapLogged(uint,Common::LogMessage)));\n  \n      // Prepare the mailboxes\n      m_finder = new MailboxFinder( this, m_model );\n      SqlStorage *storage = new SqlStorage( this, host, port, dbname, username, password );\n      connect(storage, SIGNAL(encounteredError(QString)), this, SLOT(slotSqlError(QString)));\n      storage->open();\n  \n      QTimer *statsDumper = new QTimer(this);\n      connect( statsDumper, SIGNAL(timeout()), this, SLOT(slotDumpStats()) );\n      statsDumper->setInterval( 5000 );\n      statsDumper->start();\n  \n      Q_FOREACH( const QString &mailbox, s->value( Common::SettingsNames::xtSyncMailboxList ).toStringList() ) {\n          MessageDownloader *downloader = new MessageDownloader(this, m_model, mailbox);\n          MailSynchronizer *sync = new MailSynchronizer(this, m_model, m_finder, downloader, storage);\n          connect( sync, SIGNAL(aboutToRequestMessage(QString,QModelIndex,bool*)), this, SLOT(slotAboutToRequestMessage(QString,QModelIndex,bool*)) );\n          connect( sync, SIGNAL(messageSaved(QString,QModelIndex)), this, SLOT(slotMessageStored(QString,QModelIndex)) );\n          connect( sync, SIGNAL(messageIsDuplicate(QString,QModelIndex)), this, SLOT(slotMessageIsDuplicate(QString,QModelIndex)) );\n          m_syncers[ mailbox ] = sync;\n          sync->setMailbox( mailbox );\n      }\n  \n      m_rotateMailboxes = new QTimer(this);\n      m_rotateMailboxes->setInterval( 1000 * 60 * 3 ); // every three minutes\n      connect( m_rotateMailboxes, SIGNAL(timeout()), this, SLOT(goTroughMailboxes()) );\n      m_rotateMailboxes->start();\n  }\n}"
  }
]