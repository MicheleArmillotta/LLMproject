[
  {
    "function_name": "restoreInlineCompletion",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "180-185",
    "snippet": "void LineEdit::restoreInlineCompletion()\n{\n    m_currentText = text(); // this was probably just updated by seleting from combobox\n    completer()->setCompletionMode(QCompleter::InlineCompletion);\n    CALL_LATER_NOARG(this, setFocus); // can't get in the second event cycle either\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CALL_LATER_NOARG",
          "args": [
            "this",
            "setFocus"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [
            "QCompleter::InlineCompletion"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "text(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "63-66",
          "snippet": "String Spinner::text() const\n{\n    return m_text;\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  String Spinner::text() const\n  {\n      return m_text;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::restoreInlineCompletion()\n  {\n      m_currentText = text(); // this was probably just updated by seleting from combobox\n      completer()->setCompletionMode(QCompleter::InlineCompletion);\n      CALL_LATER_NOARG(this, setFocus); // can't get in the second event cycle either\n  }\n}"
  },
  {
    "function_name": "learnEntry",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "164-178",
    "snippet": "void LineEdit::learnEntry()\n{\n    QAbstractItemModel *m = completer()->model();\n    int rows = m->rowCount();\n    for (int i = 0; i < rows; ++i) {\n        if (m->index(i,0).data() == text()) {\n            m->removeRow(i);\n            --rows;\n            break;\n        }\n    }\n    m->insertRows(rows, 1);\n    m->setData(m->index(rows, 0), text(), Qt::DisplayRole);\n    m_historyPosition = rows + 1;\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m->setData",
          "args": [
            "m->index(rows, 0)",
            "text()",
            "Qt::DisplayRole"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "text(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "63-66",
          "snippet": "String Spinner::text() const\n{\n    return m_text;\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  String Spinner::text() const\n  {\n      return m_text;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [
            "rows",
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->insertRows",
          "args": [
            "rows",
            "1"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->removeRow",
          "args": [
            "i"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "index",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "200-224",
          "snippet": "void ModelTest::index()\n{\n    // Make sure that invalid values returns an invalid index\n    Q_ASSERT(model->index(-2, -2) == QModelIndex());\n    Q_ASSERT(model->index(-2, 0) == QModelIndex());\n    Q_ASSERT(model->index(0, -2) == QModelIndex());\n\n    int rows = model->rowCount();\n    int columns = model->columnCount();\n\n    if (rows == 0)\n        return;\n\n    // Catch off by one errors\n    Q_ASSERT(model->index(rows, columns) == QModelIndex());\n    Q_ASSERT(model->index(0, 0).isValid() == true);\n\n    // Make sure that the same index is *always* returned\n    QModelIndex a = model->index(0, 0);\n    QModelIndex b = model->index(0, 0);\n    Q_ASSERT(a == b);\n\n    // index() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::index()\n  {\n      // Make sure that invalid values returns an invalid index\n      Q_ASSERT(model->index(-2, -2) == QModelIndex());\n      Q_ASSERT(model->index(-2, 0) == QModelIndex());\n      Q_ASSERT(model->index(0, -2) == QModelIndex());\n  \n      int rows = model->rowCount();\n      int columns = model->columnCount();\n  \n      if (rows == 0)\n          return;\n  \n      // Catch off by one errors\n      Q_ASSERT(model->index(rows, columns) == QModelIndex());\n      Q_ASSERT(model->index(0, 0).isValid() == true);\n  \n      // Make sure that the same index is *always* returned\n      QModelIndex a = model->index(0, 0);\n      QModelIndex b = model->index(0, 0);\n      Q_ASSERT(a == b);\n  \n      // index() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [
            "i",
            "0"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->rowCount",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "133-153",
          "snippet": "void ModelTest::rowCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    int rows = model->rowCount(topIndex);\n    Q_ASSERT(rows >= 0);\n    if (rows > 0)\n        Q_ASSERT(model->hasChildren(topIndex) == true);\n\n    QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n    if (secondLevelIndex.isValid()) { // not the top level\n        // check a row count where parent is valid\n        rows = model->rowCount(secondLevelIndex);\n        Q_ASSERT(rows >= 0);\n        if (rows > 0)\n            Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n    }\n\n    // The models rowCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::rowCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      int rows = model->rowCount(topIndex);\n      Q_ASSERT(rows >= 0);\n      if (rows > 0)\n          Q_ASSERT(model->hasChildren(topIndex) == true);\n  \n      QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n      if (secondLevelIndex.isValid()) { // not the top level\n          // check a row count where parent is valid\n          rows = model->rowCount(secondLevelIndex);\n          Q_ASSERT(rows >= 0);\n          if (rows > 0)\n              Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n      }\n  \n      // The models rowCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::learnEntry()\n  {\n      QAbstractItemModel *m = completer()->model();\n      int rows = m->rowCount();\n      for (int i = 0; i < rows; ++i) {\n          if (m->index(i,0).data() == text()) {\n              m->removeRow(i);\n              --rows;\n              break;\n          }\n      }\n      m->insertRows(rows, 1);\n      m->setData(m->index(rows, 0), text(), Qt::DisplayRole);\n      m_historyPosition = rows + 1;\n  }\n}"
  },
  {
    "function_name": "updateClearButton",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "159-162",
    "snippet": "void LineEdit::updateClearButton(const QString &text)\n{\n    m_clearButton->setVisible(!text.isEmpty());\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_clearButton->setVisible",
          "args": [
            "!text.isEmpty()"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "setVisible",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "134-164",
          "snippet": "void FindBar::setVisible(bool visible)\n{\n    QWidget::setVisible(visible);\n\n    if (!m_associatedWebView)\n        return;\n\n    if (visible) {\n        const QString selectedText = m_associatedWebView->page()->selectedText();\n        if (!hasFocus() && !selectedText.isEmpty()) {\n            const QString previousText = m_lineEdit->text();\n            m_lineEdit->setText(selectedText);\n\n            if (m_lineEdit->text() != previousText) {\n                findPrevious();\n            } else {\n                updateHighlight();\n            }\n        } else if (selectedText.isEmpty()) {\n            emit searchString(m_lineEdit->text());\n        }\n\n        m_lineEdit->setFocus();\n        m_lineEdit->selectAll();\n    } else {\n        updateHighlight();\n\n        // Clear the selection\n        m_associatedWebView->page()->findText(QString());\n    }\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::setVisible(bool visible)\n  {\n      QWidget::setVisible(visible);\n  \n      if (!m_associatedWebView)\n          return;\n  \n      if (visible) {\n          const QString selectedText = m_associatedWebView->page()->selectedText();\n          if (!hasFocus() && !selectedText.isEmpty()) {\n              const QString previousText = m_lineEdit->text();\n              m_lineEdit->setText(selectedText);\n  \n              if (m_lineEdit->text() != previousText) {\n                  findPrevious();\n              } else {\n                  updateHighlight();\n              }\n          } else if (selectedText.isEmpty()) {\n              emit searchString(m_lineEdit->text());\n          }\n  \n          m_lineEdit->setFocus();\n          m_lineEdit->selectAll();\n      } else {\n          updateHighlight();\n  \n          // Clear the selection\n          m_associatedWebView->page()->findText(QString());\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.isEmpty",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::updateClearButton(const QString &text)\n  {\n      m_clearButton->setVisible(!text.isEmpty());\n  }\n}"
  },
  {
    "function_name": "keyReleaseEvent",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "106-157",
    "snippet": "void LineEdit::keyReleaseEvent(QKeyEvent *ke)\n{\n    if (!m_historyEnabled || completer()->completionMode() == QCompleter::UnfilteredPopupCompletion ||\n        !(ke->key() == Qt::Key_Up || ke->key() == Qt::Key_Down)) {\n        // irrelevant events -> ignore\n        QLineEdit::keyReleaseEvent(ke);\n        return;\n    }\n\n    // this manages the shell-a-like history and\n    // triggers a popdown (when pressing \"down\" arrow from current entry)\n\n    QAbstractItemModel *m = completer()->model();\n    int historyCount = m->rowCount();\n\n    if (ke->key() == Qt::Key_Up) {\n        // shell-a-like history navigation\n        if (m_historyPosition == historyCount) {\n            m_currentText = text();\n            if (historyCount && m->index(m_historyPosition - 1,0).data().toString() == m_currentText) {\n                // user still sees entry he entered (into history) last - skip that one.\n                --m_historyPosition;\n            }\n        }\n        if (--m_historyPosition < 0) {\n            m_historyPosition = historyCount;\n            setText(m_currentText);\n        } else {\n            setText(m->index(m_historyPosition,0).data().toString());\n        }\n    } else if (ke->key() == Qt::Key_Down) {\n        if (m_historyPosition + 1 < historyCount && m->index(m_historyPosition + 1,0).data().toString() == m_currentText) {\n            // user still sees entry he entered (into history) last - skip that one.\n            ++m_historyPosition;\n        }\n        if (++m_historyPosition == historyCount) {\n            // returning from shell-a-like journey\n            setText(m_currentText);\n        } else if (m_historyPosition > historyCount) {\n            // trigger pop...down ;-)\n            completer()->setCompletionMode(QCompleter::UnfilteredPopupCompletion);\n            completer()->complete(); // make a popup\n            completer()->popup()->removeEventFilter(this); // protected against accidental double filtering\n            completer()->popup()->installEventFilter(this); // to restore inline completion when it closes\n            m_historyPosition = historyCount; // fix value to \"current\" (it's usually historyCount + 1 now)\n        } else {\n            // shell-a-like history navigation\n            setText(m->index(m_historyPosition,0).data().toString());\n        }\n    }\n    QLineEdit::keyReleaseEvent(ke);\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QLineEdit::keyReleaseEvent",
          "args": [
            "ke"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "keyReleaseEvent",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "106-157",
          "snippet": "void LineEdit::keyReleaseEvent(QKeyEvent *ke)\n{\n    if (!m_historyEnabled || completer()->completionMode() == QCompleter::UnfilteredPopupCompletion ||\n        !(ke->key() == Qt::Key_Up || ke->key() == Qt::Key_Down)) {\n        // irrelevant events -> ignore\n        QLineEdit::keyReleaseEvent(ke);\n        return;\n    }\n\n    // this manages the shell-a-like history and\n    // triggers a popdown (when pressing \"down\" arrow from current entry)\n\n    QAbstractItemModel *m = completer()->model();\n    int historyCount = m->rowCount();\n\n    if (ke->key() == Qt::Key_Up) {\n        // shell-a-like history navigation\n        if (m_historyPosition == historyCount) {\n            m_currentText = text();\n            if (historyCount && m->index(m_historyPosition - 1,0).data().toString() == m_currentText) {\n                // user still sees entry he entered (into history) last - skip that one.\n                --m_historyPosition;\n            }\n        }\n        if (--m_historyPosition < 0) {\n            m_historyPosition = historyCount;\n            setText(m_currentText);\n        } else {\n            setText(m->index(m_historyPosition,0).data().toString());\n        }\n    } else if (ke->key() == Qt::Key_Down) {\n        if (m_historyPosition + 1 < historyCount && m->index(m_historyPosition + 1,0).data().toString() == m_currentText) {\n            // user still sees entry he entered (into history) last - skip that one.\n            ++m_historyPosition;\n        }\n        if (++m_historyPosition == historyCount) {\n            // returning from shell-a-like journey\n            setText(m_currentText);\n        } else if (m_historyPosition > historyCount) {\n            // trigger pop...down ;-)\n            completer()->setCompletionMode(QCompleter::UnfilteredPopupCompletion);\n            completer()->complete(); // make a popup\n            completer()->popup()->removeEventFilter(this); // protected against accidental double filtering\n            completer()->popup()->installEventFilter(this); // to restore inline completion when it closes\n            m_historyPosition = historyCount; // fix value to \"current\" (it's usually historyCount + 1 now)\n        } else {\n            // shell-a-like history navigation\n            setText(m->index(m_historyPosition,0).data().toString());\n        }\n    }\n    QLineEdit::keyReleaseEvent(ke);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "setText",
          "args": [
            "m->index(m_historyPosition,0).data().toString()"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "setText(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "43-61",
          "snippet": "oid Spinner::setText(const QString &text)\n{\n    static const QLatin1Char newLine('\\n');\n    m_text = text;\n    // calculate the maximum glyphs per row\n    // this is later on used in the painting code to determine the font size\n    // size altering pointsizes of fonts does not scale dimensions in a linear way (depending on the\n    // hinter) this is precise enough and by using the maximum glyph width has enough padding from\n    // the circle\n    int idx = text.indexOf(newLine);\n    int lidx = 0;\n    m_textCols = 0;\n    while (idx > -1) {\n        m_textCols = qMax(m_textCols, idx - lidx);\n        lidx = idx + 1;\n        idx = text.indexOf(newLine, lidx);\n    }\n    m_textCols = qMax(m_textCols, text.length() - lidx);\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  oid Spinner::setText(const QString &text)\n  {\n      static const QLatin1Char newLine('\\n');\n      m_text = text;\n      // calculate the maximum glyphs per row\n      // this is later on used in the painting code to determine the font size\n      // size altering pointsizes of fonts does not scale dimensions in a linear way (depending on the\n      // hinter) this is precise enough and by using the maximum glyph width has enough padding from\n      // the circle\n      int idx = text.indexOf(newLine);\n      int lidx = 0;\n      m_textCols = 0;\n      while (idx > -1) {\n          m_textCols = qMax(m_textCols, idx - lidx);\n          lidx = idx + 1;\n          idx = text.indexOf(newLine, lidx);\n      }\n      m_textCols = qMax(m_textCols, text.length() - lidx);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "index",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "200-224",
          "snippet": "void ModelTest::index()\n{\n    // Make sure that invalid values returns an invalid index\n    Q_ASSERT(model->index(-2, -2) == QModelIndex());\n    Q_ASSERT(model->index(-2, 0) == QModelIndex());\n    Q_ASSERT(model->index(0, -2) == QModelIndex());\n\n    int rows = model->rowCount();\n    int columns = model->columnCount();\n\n    if (rows == 0)\n        return;\n\n    // Catch off by one errors\n    Q_ASSERT(model->index(rows, columns) == QModelIndex());\n    Q_ASSERT(model->index(0, 0).isValid() == true);\n\n    // Make sure that the same index is *always* returned\n    QModelIndex a = model->index(0, 0);\n    QModelIndex b = model->index(0, 0);\n    Q_ASSERT(a == b);\n\n    // index() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::index()\n  {\n      // Make sure that invalid values returns an invalid index\n      Q_ASSERT(model->index(-2, -2) == QModelIndex());\n      Q_ASSERT(model->index(-2, 0) == QModelIndex());\n      Q_ASSERT(model->index(0, -2) == QModelIndex());\n  \n      int rows = model->rowCount();\n      int columns = model->columnCount();\n  \n      if (rows == 0)\n          return;\n  \n      // Catch off by one errors\n      Q_ASSERT(model->index(rows, columns) == QModelIndex());\n      Q_ASSERT(model->index(0, 0).isValid() == true);\n  \n      // Make sure that the same index is *always* returned\n      QModelIndex a = model->index(0, 0);\n      QModelIndex b = model->index(0, 0);\n      Q_ASSERT(a == b);\n  \n      // index() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [
            "m_historyPosition",
            "0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [
            "this"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [
            "this"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [
            "QCompleter::UnfilteredPopupCompletion"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [
            "m_historyPosition + 1",
            "0"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke->key",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [
            "m_historyPosition",
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->index",
          "args": [
            "m_historyPosition - 1",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "text(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "63-66",
          "snippet": "String Spinner::text() const\n{\n    return m_text;\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  String Spinner::text() const\n  {\n      return m_text;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ke->key",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->rowCount",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "133-153",
          "snippet": "void ModelTest::rowCount()\n{\n    // check top row\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    int rows = model->rowCount(topIndex);\n    Q_ASSERT(rows >= 0);\n    if (rows > 0)\n        Q_ASSERT(model->hasChildren(topIndex) == true);\n\n    QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n    if (secondLevelIndex.isValid()) { // not the top level\n        // check a row count where parent is valid\n        rows = model->rowCount(secondLevelIndex);\n        Q_ASSERT(rows >= 0);\n        if (rows > 0)\n            Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n    }\n\n    // The models rowCount() is tested more extensively in checkChildren(),\n    // but this catches the big mistakes\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::rowCount()\n  {\n      // check top row\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      int rows = model->rowCount(topIndex);\n      Q_ASSERT(rows >= 0);\n      if (rows > 0)\n          Q_ASSERT(model->hasChildren(topIndex) == true);\n  \n      QModelIndex secondLevelIndex = model->index(0, 0, topIndex);\n      if (secondLevelIndex.isValid()) { // not the top level\n          // check a row count where parent is valid\n          rows = model->rowCount(secondLevelIndex);\n          Q_ASSERT(rows >= 0);\n          if (rows > 0)\n              Q_ASSERT(model->hasChildren(secondLevelIndex) == true);\n      }\n  \n      // The models rowCount() is tested more extensively in checkChildren(),\n      // but this catches the big mistakes\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke->key",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke->key",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::keyReleaseEvent(QKeyEvent *ke)\n  {\n      if (!m_historyEnabled || completer()->completionMode() == QCompleter::UnfilteredPopupCompletion ||\n          !(ke->key() == Qt::Key_Up || ke->key() == Qt::Key_Down)) {\n          // irrelevant events -> ignore\n          QLineEdit::keyReleaseEvent(ke);\n          return;\n      }\n  \n      // this manages the shell-a-like history and\n      // triggers a popdown (when pressing \"down\" arrow from current entry)\n  \n      QAbstractItemModel *m = completer()->model();\n      int historyCount = m->rowCount();\n  \n      if (ke->key() == Qt::Key_Up) {\n          // shell-a-like history navigation\n          if (m_historyPosition == historyCount) {\n              m_currentText = text();\n              if (historyCount && m->index(m_historyPosition - 1,0).data().toString() == m_currentText) {\n                  // user still sees entry he entered (into history) last - skip that one.\n                  --m_historyPosition;\n              }\n          }\n          if (--m_historyPosition < 0) {\n              m_historyPosition = historyCount;\n              setText(m_currentText);\n          } else {\n              setText(m->index(m_historyPosition,0).data().toString());\n          }\n      } else if (ke->key() == Qt::Key_Down) {\n          if (m_historyPosition + 1 < historyCount && m->index(m_historyPosition + 1,0).data().toString() == m_currentText) {\n              // user still sees entry he entered (into history) last - skip that one.\n              ++m_historyPosition;\n          }\n          if (++m_historyPosition == historyCount) {\n              // returning from shell-a-like journey\n              setText(m_currentText);\n          } else if (m_historyPosition > historyCount) {\n              // trigger pop...down ;-)\n              completer()->setCompletionMode(QCompleter::UnfilteredPopupCompletion);\n              completer()->complete(); // make a popup\n              completer()->popup()->removeEventFilter(this); // protected against accidental double filtering\n              completer()->popup()->installEventFilter(this); // to restore inline completion when it closes\n              m_historyPosition = historyCount; // fix value to \"current\" (it's usually historyCount + 1 now)\n          } else {\n              // shell-a-like history navigation\n              setText(m->index(m_historyPosition,0).data().toString());\n          }\n      }\n      QLineEdit::keyReleaseEvent(ke);\n  }\n}"
  },
  {
    "function_name": "eventFilter",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "96-104",
    "snippet": "bool LineEdit::eventFilter(QObject *o, QEvent *e)\n{\n    if (e->type() == QEvent::Hide && o == completer()->popup()) {\n        // next event cycle, the popup is deleted by the change and \"return true\" does not help\n        // connect queued to not manipulate the history *during* selection from popup, but *after*\n        CALL_LATER_NOARG(this, restoreInlineCompletion);\n    }\n    return false;\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CALL_LATER_NOARG",
          "args": [
            "this",
            "restoreInlineCompletion"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->type",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "328-331",
          "snippet": "QMimeMagicRule::Type QMimeMagicRule::type() const\n{\n    return d->type;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type() const\n  {\n      return d->type;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  bool LineEdit::eventFilter(QObject *o, QEvent *e)\n  {\n      if (e->type() == QEvent::Hide && o == completer()->popup()) {\n          // next event cycle, the popup is deleted by the change and \"return true\" does not help\n          // connect queued to not manipulate the history *during* selection from popup, but *after*\n          CALL_LATER_NOARG(this, restoreInlineCompletion);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "sizeHint",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "89-94",
    "snippet": "QSize LineEdit::sizeHint() const\n{\n    const QSize defaultSize = QLineEdit::sizeHint();\n    const int minimumWidth = m_clearButton->sizeHint().width() + 2;\n    return QSize(qMax(defaultSize.width(), minimumWidth), defaultSize.height());\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QSize",
          "args": [
            "qMax(defaultSize.width(), minimumWidth)",
            "defaultSize.height()"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defaultSize.height",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qMax",
          "args": [
            "defaultSize.width()",
            "minimumWidth"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defaultSize.width",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_clearButton->sizeHint",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sizeHint",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "89-94",
          "snippet": "QSize LineEdit::sizeHint() const\n{\n    const QSize defaultSize = QLineEdit::sizeHint();\n    const int minimumWidth = m_clearButton->sizeHint().width() + 2;\n    return QSize(qMax(defaultSize.width(), minimumWidth), defaultSize.height());\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  QSize LineEdit::sizeHint() const\n  {\n      const QSize defaultSize = QLineEdit::sizeHint();\n      const int minimumWidth = m_clearButton->sizeHint().width() + 2;\n      return QSize(qMax(defaultSize.width(), minimumWidth), defaultSize.height());\n  }\n}"
  },
  {
    "function_name": "setHistoryEnabled",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "70-87",
    "snippet": "void LineEdit::setHistoryEnabled(bool enabled)\n{\n    if (enabled == m_historyEnabled)\n        return;\n    m_historyEnabled = enabled;\n    if (m_historyEnabled) {\n        // queued so we learn and update the history list *after* the user selected an item from popup\n        connect(this, SIGNAL(returnPressed()), this, SLOT(learnEntry()), Qt::QueuedConnection);\n        QCompleter *completer = new QCompleter(QStringList(), this);\n        completer->setCaseSensitivity(Qt::CaseInsensitive);\n        completer->setCompletionMode(QCompleter::InlineCompletion);\n        setCompleter(completer);\n    } else {\n        disconnect(this, SIGNAL(returnPressed()), this, SLOT(learnEntry()));\n        delete completer();\n        setCompleter(NULL);\n    }\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setCompleter",
          "args": [
            "NULL"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disconnect",
          "args": [
            "this",
            "SIGNAL(returnPressed())",
            "this",
            "SLOT(learnEntry())"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "learnEntry()"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "learnEntry",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "learnEntry",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "164-178",
          "snippet": "void LineEdit::learnEntry()\n{\n    QAbstractItemModel *m = completer()->model();\n    int rows = m->rowCount();\n    for (int i = 0; i < rows; ++i) {\n        if (m->index(i,0).data() == text()) {\n            m->removeRow(i);\n            --rows;\n            break;\n        }\n    }\n    m->insertRows(rows, 1);\n    m->setData(m->index(rows, 0), text(), Qt::DisplayRole);\n    m_historyPosition = rows + 1;\n}",
          "includes": [
            "#include \"Common/InvokeMethod.h\"",
            "#include <QStyle>",
            "#include <QToolButton>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCompleter>",
            "#include <QAbstractItemView>",
            "#include <QAbstractItemModel>",
            "#include \"LineEdit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::learnEntry()\n  {\n      QAbstractItemModel *m = completer()->model();\n      int rows = m->rowCount();\n      for (int i = 0; i < rows; ++i) {\n          if (m->index(i,0).data() == text()) {\n              m->removeRow(i);\n              --rows;\n              break;\n          }\n      }\n      m->insertRows(rows, 1);\n      m->setData(m->index(rows, 0), text(), Qt::DisplayRole);\n      m_historyPosition = rows + 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIGNAL",
          "args": [
            "returnPressed()"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "returnPressed",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setCompleter",
          "args": [
            "completer"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer->setCompletionMode",
          "args": [
            "QCompleter::InlineCompletion"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completer->setCaseSensitivity",
          "args": [
            "Qt::CaseInsensitive"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringList",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "this",
            "SIGNAL(returnPressed())",
            "this",
            "SLOT(learnEntry())",
            "Qt::QueuedConnection"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "learnEntry()"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIGNAL",
          "args": [
            "returnPressed()"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "returnPressed",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::setHistoryEnabled(bool enabled)\n  {\n      if (enabled == m_historyEnabled)\n          return;\n      m_historyEnabled = enabled;\n      if (m_historyEnabled) {\n          // queued so we learn and update the history list *after* the user selected an item from popup\n          connect(this, SIGNAL(returnPressed()), this, SLOT(learnEntry()), Qt::QueuedConnection);\n          QCompleter *completer = new QCompleter(QStringList(), this);\n          completer->setCaseSensitivity(Qt::CaseInsensitive);\n          completer->setCompletionMode(QCompleter::InlineCompletion);\n          setCompleter(completer);\n      } else {\n          disconnect(this, SIGNAL(returnPressed()), this, SLOT(learnEntry()));\n          delete completer();\n          setCompleter(NULL);\n      }\n  }\n}"
  },
  {
    "function_name": "isHistoryEnabled",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "65-68",
    "snippet": "bool LineEdit::isHistoryEnabled()\n{\n    return m_historyEnabled;\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  bool LineEdit::isHistoryEnabled()\n  {\n      return m_historyEnabled;\n  }\n}"
  },
  {
    "function_name": "init",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "35-58",
    "snippet": "void LineEdit::init()\n{\n    m_clearButton = new QToolButton(this);\n    const QPixmap pixmap(QLatin1String(\":/icons/edit-clear-locationbar-rtl.png\"));\n    m_clearButton->setIcon(QIcon(pixmap));\n    m_clearButton->setIconSize(pixmap.size());\n    m_clearButton->setCursor(Qt::ArrowCursor);\n    m_clearButton->setToolTip(tr(\"Clear input field\"));\n    m_clearButton->setFocusPolicy(Qt::NoFocus);\n    m_clearButton->hide();\n    connect(m_clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n    connect(this, SIGNAL(textChanged(QString)), this, SLOT(updateClearButton(QString)));\n\n    const int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);\n    m_clearButton->setStyleSheet(QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n        .arg(frameWidth + 1));\n    setStyleSheet(QString(\"QLineEdit { padding-right: %1px; }\")\n        .arg(m_clearButton->sizeHint().width()));\n\n    QHBoxLayout *layout = new QHBoxLayout(this);\n    layout->setContentsMargins(0, 0, 0, 0);\n    layout->addStretch();\n    layout->addWidget(m_clearButton);\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout->addWidget",
          "args": [
            "m_clearButton"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layout->addStretch",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layout->setContentsMargins",
          "args": [
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setStyleSheet",
          "args": [
            "QString(\"QLineEdit { padding-right: %1px; }\")\n        .arg(m_clearButton->sizeHint().width())"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "m_clearButton->sizeHint().width()"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "slotDownloadMessageFileNameRequested(QString",
          "container": "w",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Window.cpp",
          "lines": "1702-1706",
          "snippet": "Window::slotDownloadMessageFileNameRequested(QString *fileName)\n{\n    *fileName = QFileDialog::getSaveFileName(this, tr(\"Save Message\"), *fileName, QString(), 0,\n                                             QFileDialog::HideNameFilterDetails);\n}\n\nvoid Ma",
          "includes": [
            "include \"Imap/Model/ModelTest/modeltest.h\"",
            "include \"ui_AboutDialog.h\"",
            "include \"ui_CreateMailboxDialog.h\"\n#",
            "include \"ShortcutHandler/ShortcutHandler.h\"",
            "include \"Window.h\"\n#",
            "include \"Util.h\"\n#",
            "include \"TaskProgressIndicator.h\"\n#",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"SimplePartWidget.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include \"PasswordDialog.h\"\n#",
            "include \"OnePanelAtTimeWidget.h\"\n#",
            "include \"MsgListView.h\"\n#",
            "include \"MessageSourceWidget.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"MessageListWidget.h\"\n#",
            "include \"MailBoxTreeView.h\"\n#",
            "include \"IconLoader.h\"\n#",
            "include \"ComposeWidget.h\"\n#",
            "include \"CompleteMessageWidget.h\"\n#",
            "include \"Plugins/PluginManager.h\"\n#",
            "include \"MSA/SMTP.h\"\n#",
            "include \"MSA/Sendmail.h\"\n#",
            "include \"Imap/Network/FileDownloadManager.h\"\n#",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/ThreadingMsgListModel.h\"\n#",
            "include \"Imap/Model/PrettyMsgListModel.h\"\n#",
            "include \"Imap/Model/PrettyMailboxModel.h\"\n#",
            "include \"Imap/Model/NetworkWatcher.h\"\n#",
            "include \"Imap/Model/MsgListModel.h\"\n#",
            "include \"Imap/Model/ModelWatcher.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ImapAccess.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"Composer/Mailto.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/Application.h\"\n#",
            "include \"AbookAddressbook/be-contacts.h\"\n#",
            "include \"AbookAddressbook/AbookAddressbook.h\"\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QToolButton>\n#",
            "include <QToolBar>\n#",
            "include <QTextDocument>\n#",
            "include <QStatusBar>\n#",
            "include <QStackedWidget>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSplitter>\n#",
            "include <QProgressBar>\n#",
            "include <QMessageBox>\n#",
            "include <QMenuBar>\n#",
            "include <QItemSelectionModel>\n#",
            "include <QHeaderView>\n#",
            "include <QFileDialog>\n#",
            "include <QDockWidget>\n#",
            "include <QDir>\n#",
            "include <QDesktopWidget>\n#",
            "include <QDesktopServices>\n#",
            "include <QAuthenticator>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/ModelTest/modeltest.h\"\ninclude \"ui_AboutDialog.h\"\ninclude \"ui_CreateMailboxDialog.h\"\n#\ninclude \"ShortcutHandler/ShortcutHandler.h\"\ninclude \"Window.h\"\n#\ninclude \"Util.h\"\n#\ninclude \"TaskProgressIndicator.h\"\n#\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"SimplePartWidget.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude \"PasswordDialog.h\"\n#\ninclude \"OnePanelAtTimeWidget.h\"\n#\ninclude \"MsgListView.h\"\n#\ninclude \"MessageSourceWidget.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"MessageListWidget.h\"\n#\ninclude \"MailBoxTreeView.h\"\n#\ninclude \"IconLoader.h\"\n#\ninclude \"ComposeWidget.h\"\n#\ninclude \"CompleteMessageWidget.h\"\n#\ninclude \"Plugins/PluginManager.h\"\n#\ninclude \"MSA/SMTP.h\"\n#\ninclude \"MSA/Sendmail.h\"\n#\ninclude \"Imap/Network/FileDownloadManager.h\"\n#\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/ThreadingMsgListModel.h\"\n#\ninclude \"Imap/Model/PrettyMsgListModel.h\"\n#\ninclude \"Imap/Model/PrettyMailboxModel.h\"\n#\ninclude \"Imap/Model/NetworkWatcher.h\"\n#\ninclude \"Imap/Model/MsgListModel.h\"\n#\ninclude \"Imap/Model/ModelWatcher.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ImapAccess.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"Composer/Mailto.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude \"AbookAddressbook/be-contacts.h\"\n#\ninclude \"AbookAddressbook/AbookAddressbook.h\"\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QToolButton>\n#\ninclude <QToolBar>\n#\ninclude <QTextDocument>\n#\ninclude <QStatusBar>\n#\ninclude <QStackedWidget>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSplitter>\n#\ninclude <QProgressBar>\n#\ninclude <QMessageBox>\n#\ninclude <QMenuBar>\n#\ninclude <QItemSelectionModel>\n#\ninclude <QHeaderView>\n#\ninclude <QFileDialog>\n#\ninclude <QDockWidget>\n#\ninclude <QDir>\n#\ninclude <QDesktopWidget>\n#\ninclude <QDesktopServices>\n#\ninclude <QAuthenticator>\n#\n\nw {\n  Window::slotDownloadMessageFileNameRequested(QString *fileName)\n  {\n      *fileName = QFileDialog::getSaveFileName(this, tr(\"Save Message\"), *fileName, QString(), 0,\n                                               QFileDialog::HideNameFilterDetails);\n  }\n  \n  void Ma\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_clearButton->sizeHint",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "sizeHint",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "89-94",
          "snippet": "QSize LineEdit::sizeHint() const\n{\n    const QSize defaultSize = QLineEdit::sizeHint();\n    const int minimumWidth = m_clearButton->sizeHint().width() + 2;\n    return QSize(qMax(defaultSize.width(), minimumWidth), defaultSize.height());\n}",
          "includes": [
            "#include \"Common/InvokeMethod.h\"",
            "#include <QStyle>",
            "#include <QToolButton>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCompleter>",
            "#include <QAbstractItemView>",
            "#include <QAbstractItemModel>",
            "#include \"LineEdit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  QSize LineEdit::sizeHint() const\n  {\n      const QSize defaultSize = QLineEdit::sizeHint();\n      const int minimumWidth = m_clearButton->sizeHint().width() + 2;\n      return QSize(qMax(defaultSize.width(), minimumWidth), defaultSize.height());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_clearButton->setStyleSheet",
          "args": [
            "QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n        .arg(frameWidth + 1)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "style",
          "args": [
            "QStyle::PM_DefaultFrameWidth"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "style",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "this",
            "SIGNAL(textChanged(QString))",
            "this",
            "SLOT(updateClearButton(QString))"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "updateClearButton(QString)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "updateClearButton",
          "args": [
            "QString"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "updateClearButton",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "159-162",
          "snippet": "void LineEdit::updateClearButton(const QString &text)\n{\n    m_clearButton->setVisible(!text.isEmpty());\n}",
          "includes": [
            "#include \"Common/InvokeMethod.h\"",
            "#include <QStyle>",
            "#include <QToolButton>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCompleter>",
            "#include <QAbstractItemView>",
            "#include <QAbstractItemModel>",
            "#include \"LineEdit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::updateClearButton(const QString &text)\n  {\n      m_clearButton->setVisible(!text.isEmpty());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIGNAL",
          "args": [
            "textChanged(QString)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textChanged",
          "args": [
            "QString"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "m_clearButton",
            "SIGNAL(clicked())",
            "this",
            "SLOT(clear())"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "clear()"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "clearLogDisplay(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "115-130",
          "snippet": "oid ProtocolLoggerWidget::clearLogDisplay()\n{\n    // These will be freed from the GUI\n    loggerWidgets.clear();\n\n    // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n    // so it's much better to clean up the GUI at first and only after that purge the underlying data\n    while (tabs->count()) {\n        QWidget *w = tabs->widget(0);\n        Q_ASSERT(w);\n        tabs->removeTab(0);\n        w->deleteLater();\n    }\n\n    buffers.clear();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::clearLogDisplay()\n  {\n      // These will be freed from the GUI\n      loggerWidgets.clear();\n  \n      // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n      // so it's much better to clean up the GUI at first and only after that purge the underlying data\n      while (tabs->count()) {\n          QWidget *w = tabs->widget(0);\n          Q_ASSERT(w);\n          tabs->removeTab(0);\n          w->deleteLater();\n      }\n  \n      buffers.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIGNAL",
          "args": [
            "clicked()"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clicked",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_clearButton->hide",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_clearButton->setFocusPolicy",
          "args": [
            "Qt::NoFocus"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_clearButton->setToolTip",
          "args": [
            "tr(\"Clear input field\")"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [
            "\"Clear input field\""
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "setGeometry",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "125-129",
          "snippet": "void FlowLayout::setGeometry(const QRect &rect)\n{\n    QLayout::setGeometry(rect);\n    doLayout(rect, false);\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  void FlowLayout::setGeometry(const QRect &rect)\n  {\n      QLayout::setGeometry(rect);\n      doLayout(rect, false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_clearButton->setCursor",
          "args": [
            "Qt::ArrowCursor"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_clearButton->setIconSize",
          "args": [
            "pixmap.size()"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pixmap.size",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_clearButton->setIcon",
          "args": [
            "QIcon(pixmap)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QIcon",
          "args": [
            "pixmap"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\":/icons/edit-clear-locationbar-rtl.png\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::init()\n  {\n      m_clearButton = new QToolButton(this);\n      const QPixmap pixmap(QLatin1String(\":/icons/edit-clear-locationbar-rtl.png\"));\n      m_clearButton->setIcon(QIcon(pixmap));\n      m_clearButton->setIconSize(pixmap.size());\n      m_clearButton->setCursor(Qt::ArrowCursor);\n      m_clearButton->setToolTip(tr(\"Clear input field\"));\n      m_clearButton->setFocusPolicy(Qt::NoFocus);\n      m_clearButton->hide();\n      connect(m_clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n      connect(this, SIGNAL(textChanged(QString)), this, SLOT(updateClearButton(QString)));\n  \n      const int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);\n      m_clearButton->setStyleSheet(QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n          .arg(frameWidth + 1));\n      setStyleSheet(QString(\"QLineEdit { padding-right: %1px; }\")\n          .arg(m_clearButton->sizeHint().width()));\n  \n      QHBoxLayout *layout = new QHBoxLayout(this);\n      layout->setContentsMargins(0, 0, 0, 0);\n      layout->addStretch();\n      layout->addWidget(m_clearButton);\n  }\n}"
  },
  {
    "function_name": "LineEdit",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "29-33",
    "snippet": "LineEdit::LineEdit(QWidget *parent)\n    : QLineEdit(parent), m_historyEnabled(false), m_historyPosition(0)\n{\n    init();\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "35-58",
          "snippet": "void LineEdit::init()\n{\n    m_clearButton = new QToolButton(this);\n    const QPixmap pixmap(QLatin1String(\":/icons/edit-clear-locationbar-rtl.png\"));\n    m_clearButton->setIcon(QIcon(pixmap));\n    m_clearButton->setIconSize(pixmap.size());\n    m_clearButton->setCursor(Qt::ArrowCursor);\n    m_clearButton->setToolTip(tr(\"Clear input field\"));\n    m_clearButton->setFocusPolicy(Qt::NoFocus);\n    m_clearButton->hide();\n    connect(m_clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n    connect(this, SIGNAL(textChanged(QString)), this, SLOT(updateClearButton(QString)));\n\n    const int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);\n    m_clearButton->setStyleSheet(QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n        .arg(frameWidth + 1));\n    setStyleSheet(QString(\"QLineEdit { padding-right: %1px; }\")\n        .arg(m_clearButton->sizeHint().width()));\n\n    QHBoxLayout *layout = new QHBoxLayout(this);\n    layout->setContentsMargins(0, 0, 0, 0);\n    layout->addStretch();\n    layout->addWidget(m_clearButton);\n}",
          "includes": [
            "#include \"Common/InvokeMethod.h\"",
            "#include <QStyle>",
            "#include <QToolButton>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCompleter>",
            "#include <QAbstractItemView>",
            "#include <QAbstractItemModel>",
            "#include \"LineEdit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::init()\n  {\n      m_clearButton = new QToolButton(this);\n      const QPixmap pixmap(QLatin1String(\":/icons/edit-clear-locationbar-rtl.png\"));\n      m_clearButton->setIcon(QIcon(pixmap));\n      m_clearButton->setIconSize(pixmap.size());\n      m_clearButton->setCursor(Qt::ArrowCursor);\n      m_clearButton->setToolTip(tr(\"Clear input field\"));\n      m_clearButton->setFocusPolicy(Qt::NoFocus);\n      m_clearButton->hide();\n      connect(m_clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n      connect(this, SIGNAL(textChanged(QString)), this, SLOT(updateClearButton(QString)));\n  \n      const int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);\n      m_clearButton->setStyleSheet(QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n          .arg(frameWidth + 1));\n      setStyleSheet(QString(\"QLineEdit { padding-right: %1px; }\")\n          .arg(m_clearButton->sizeHint().width()));\n  \n      QHBoxLayout *layout = new QHBoxLayout(this);\n      layout->setContentsMargins(0, 0, 0, 0);\n      layout->addStretch();\n      layout->addWidget(m_clearButton);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  LineEdit::LineEdit(QWidget *parent)\n      : QLineEdit(parent), m_historyEnabled(false), m_historyPosition(0)\n  {\n      init();\n  }\n}"
  },
  {
    "function_name": "LineEdit",
    "container": "LineEdit",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
    "lines": "22-27",
    "snippet": "LineEdit::LineEdit(const QString &text, QWidget *parent)\n    : QLineEdit(parent), m_historyEnabled(false), m_historyPosition(0)\n{\n    init();\n    setText(text);\n}",
    "includes": [
      "#include \"Common/InvokeMethod.h\"",
      "#include <QStyle>",
      "#include <QToolButton>",
      "#include <QKeyEvent>",
      "#include <QHBoxLayout>",
      "#include <QCompleter>",
      "#include <QAbstractItemView>",
      "#include <QAbstractItemModel>",
      "#include \"LineEdit.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setText",
          "args": [
            "text"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "setText(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "43-61",
          "snippet": "oid Spinner::setText(const QString &text)\n{\n    static const QLatin1Char newLine('\\n');\n    m_text = text;\n    // calculate the maximum glyphs per row\n    // this is later on used in the painting code to determine the font size\n    // size altering pointsizes of fonts does not scale dimensions in a linear way (depending on the\n    // hinter) this is precise enough and by using the maximum glyph width has enough padding from\n    // the circle\n    int idx = text.indexOf(newLine);\n    int lidx = 0;\n    m_textCols = 0;\n    while (idx > -1) {\n        m_textCols = qMax(m_textCols, idx - lidx);\n        lidx = idx + 1;\n        idx = text.indexOf(newLine, lidx);\n    }\n    m_textCols = qMax(m_textCols, text.length() - lidx);\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  oid Spinner::setText(const QString &text)\n  {\n      static const QLatin1Char newLine('\\n');\n      m_text = text;\n      // calculate the maximum glyphs per row\n      // this is later on used in the painting code to determine the font size\n      // size altering pointsizes of fonts does not scale dimensions in a linear way (depending on the\n      // hinter) this is precise enough and by using the maximum glyph width has enough padding from\n      // the circle\n      int idx = text.indexOf(newLine);\n      int lidx = 0;\n      m_textCols = 0;\n      while (idx > -1) {\n          m_textCols = qMax(m_textCols, idx - lidx);\n          lidx = idx + 1;\n          idx = text.indexOf(newLine, lidx);\n      }\n      m_textCols = qMax(m_textCols, text.length() - lidx);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "init",
          "args": [],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "LineEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LineEdit.cpp",
          "lines": "35-58",
          "snippet": "void LineEdit::init()\n{\n    m_clearButton = new QToolButton(this);\n    const QPixmap pixmap(QLatin1String(\":/icons/edit-clear-locationbar-rtl.png\"));\n    m_clearButton->setIcon(QIcon(pixmap));\n    m_clearButton->setIconSize(pixmap.size());\n    m_clearButton->setCursor(Qt::ArrowCursor);\n    m_clearButton->setToolTip(tr(\"Clear input field\"));\n    m_clearButton->setFocusPolicy(Qt::NoFocus);\n    m_clearButton->hide();\n    connect(m_clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n    connect(this, SIGNAL(textChanged(QString)), this, SLOT(updateClearButton(QString)));\n\n    const int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);\n    m_clearButton->setStyleSheet(QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n        .arg(frameWidth + 1));\n    setStyleSheet(QString(\"QLineEdit { padding-right: %1px; }\")\n        .arg(m_clearButton->sizeHint().width()));\n\n    QHBoxLayout *layout = new QHBoxLayout(this);\n    layout->setContentsMargins(0, 0, 0, 0);\n    layout->addStretch();\n    layout->addWidget(m_clearButton);\n}",
          "includes": [
            "#include \"Common/InvokeMethod.h\"",
            "#include <QStyle>",
            "#include <QToolButton>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCompleter>",
            "#include <QAbstractItemView>",
            "#include <QAbstractItemModel>",
            "#include \"LineEdit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  void LineEdit::init()\n  {\n      m_clearButton = new QToolButton(this);\n      const QPixmap pixmap(QLatin1String(\":/icons/edit-clear-locationbar-rtl.png\"));\n      m_clearButton->setIcon(QIcon(pixmap));\n      m_clearButton->setIconSize(pixmap.size());\n      m_clearButton->setCursor(Qt::ArrowCursor);\n      m_clearButton->setToolTip(tr(\"Clear input field\"));\n      m_clearButton->setFocusPolicy(Qt::NoFocus);\n      m_clearButton->hide();\n      connect(m_clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n      connect(this, SIGNAL(textChanged(QString)), this, SLOT(updateClearButton(QString)));\n  \n      const int frameWidth = style()->pixelMetric(QStyle::PM_DefaultFrameWidth);\n      m_clearButton->setStyleSheet(QString(\"QToolButton { border: none; padding-left: 1px; padding-top: %1px; padding-bottom: %1px; padding-right: %1px; }\")\n          .arg(frameWidth + 1));\n      setStyleSheet(QString(\"QLineEdit { padding-right: %1px; }\")\n          .arg(m_clearButton->sizeHint().width()));\n  \n      QHBoxLayout *layout = new QHBoxLayout(this);\n      layout->setContentsMargins(0, 0, 0, 0);\n      layout->addStretch();\n      layout->addWidget(m_clearButton);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"Common/InvokeMethod.h\"\n#include <QStyle>\n#include <QToolButton>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCompleter>\n#include <QAbstractItemView>\n#include <QAbstractItemModel>\n#include \"LineEdit.h\"\n\nLineEdit {\n  LineEdit::LineEdit(const QString &text, QWidget *parent)\n      : QLineEdit(parent), m_historyEnabled(false), m_historyPosition(0)\n  {\n      init();\n      setText(text);\n  }\n}"
  }
]