[
  {
    "function_name": "ainTextToHtml(c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
    "lines": "198-512",
    "snippet": "tring plainTextToHtml(const QString &plaintext, const FlowedFormat flowed)\n{\n    static QRegExp quotemarks(\"^>[>\\\\s]*\");\n    const int SIGNATURE_SEPARATOR = -2;\n\n    QList<TextInfo> lineBuffer;\n\n    // First pass: determine the quote level for each source line.\n    // The quote level is ignored for the signature.\n    bool signatureSeparatorSeen = false;\n    Q_FOREACH(QString line, plaintext.split('\\n')) {\n\n        // Fast path for empty lines\n        if (line.isEmpty()) {\n            lineBuffer << TextInfo(0, line);\n            continue;\n        }\n\n        // Special marker for the signature separator\n        if (signatureSeparator().exactMatch(line)) {\n            lineBuffer << TextInfo(SIGNATURE_SEPARATOR, line);\n            signatureSeparatorSeen = true;\n            continue;\n        }\n\n        // Determine the quoting level\n        int quoteLevel = 0;\n        if (!signatureSeparatorSeen && line.at(0) == '>') {\n            int j = 1;\n            quoteLevel = 1;\n            while (j < line.length() && (line.at(j) == '>' || line.at(j) == ' '))\n                quoteLevel += line.at(j++) == '>';\n        }\n\n        lineBuffer << TextInfo(quoteLevel, line);\n    }\n\n    // Second pass:\n    // - Remove the quotemarks for everything prior to the signature separator.\n    // - Collapse the lines with the same quoting level into a single block\n    //   (optionally into a single line if format=flowed is active)\n    auto it = lineBuffer.begin();\n    while (it < lineBuffer.end() && it->depth != SIGNATURE_SEPARATOR) {\n\n        // Remove the quotemarks\n        it->text.remove(quotemarks);\n\n        if (flowed == FORMAT_FLOWED_DELSP) {\n            if (it->text.endsWith(QLatin1String(\" \\r\"))) {\n                it->text.chop(2);\n                it->text += QLatin1Char('\\r');\n            } else if (it->text.endsWith(QLatin1Char(' '))) {\n                it->text.chop(1);\n            }\n        }\n\n        if (it == lineBuffer.begin()) {\n            // No \"previous line\"\n            ++it;\n            continue;\n        }\n\n        // Check for the line joining\n        auto prev = it - 1;\n        if (prev->depth == it->depth) {\n            // empty lines must not be removed\n\n            QString separator = QLatin1String(\"\\n\");\n            switch (flowed) {\n            case FORMAT_PLAIN:\n                // nothing fancy to do here\n                break;\n            case FORMAT_FLOWED:\n            case FORMAT_FLOWED_DELSP:\n                // Now the trailing \\n is striped already; we only have to check for stuff ending with \" \" or \" \\r\".\n                if (prev->text.endsWith(QLatin1Char(' '))) {\n                    separator = QString();\n                } else if (prev->text.endsWith(QLatin1String(\" \\r\"))) {\n                    separator = QString();\n                    // Remove that extra \\r\n                    prev->text.chop(1);\n                }\n                break;\n            }\n            prev->text += separator + it->text;\n            it = lineBuffer.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Third pass: HTML escaping, formatting and adding fancy markup\n    signatureSeparatorSeen = false;\n    int quoteLevel = 0;\n    QStringList markup;\n    int interactiveControlsId = 0;\n    QStack<QPair<int,int> > controlStack;\n    for (it = lineBuffer.begin(); it != lineBuffer.end(); ++it) {\n\n        if (it->depth == SIGNATURE_SEPARATOR && !signatureSeparatorSeen) {\n            // The first signature separator\n            signatureSeparatorSeen = true;\n            closeQuotesUpTo(markup, controlStack, quoteLevel, 0);\n            markup << QLatin1String(\"<span class=\\\"signature\\\">\") + helperHtmlifySingleLine(it->text);\n            markup << QLatin1String(\"\\n\");\n            continue;\n        }\n\n        if (signatureSeparatorSeen) {\n            // Just copy the data\n            markup << helperHtmlifySingleLine(it->text);\n            if (it+1 != lineBuffer.end())\n                markup << QLatin1String(\"\\n\");\n            continue;\n        }\n\n        Q_ASSERT(quoteLevel == 0 || quoteLevel != it->depth);\n\n        if (quoteLevel > it->depth) {\n            // going back in the quote hierarchy\n            closeQuotesUpTo(markup, controlStack, quoteLevel, it->depth);\n        }\n\n        // Pretty-formatted block of the \">>>\" characters\n        QString quotemarks;\n\n        if (it->depth) {\n            quotemarks += QLatin1String(\"<span class=\\\"quotemarks\\\">\");\n            for (int i = 0; i < it->depth; ++i) {\n                quotemarks += QLatin1String(\"&gt;\");\n            }\n            quotemarks += QLatin1String(\" </span>\");\n        }\n\n        static const int previewLines = 5;\n        static const int charsPerLineEquivalent = 160;\n        static const int forceCollapseAfterLines = 10;\n\n        if (quoteLevel < it->depth) {\n            // We're going deeper in the quote hierarchy\n            QString line;\n            while (quoteLevel < it->depth) {\n                ++quoteLevel;\n\n                // Check whether there is anything at the newly entered level of nesting\n                bool anythingOnJustThisLevel = false;\n\n                // A short summary of the quotation\n                QString preview;\n\n                auto runner = it;\n                while (runner != lineBuffer.end()) {\n                    if (runner->depth == quoteLevel) {\n                        anythingOnJustThisLevel = true;\n\n                        ++interactiveControlsId;\n                        controlStack.push(qMakePair(quoteLevel, interactiveControlsId));\n\n                        QString omittedStuff;\n                        QString previewPrefix, previewSuffix;\n                        QString currentChunk = firstNLines(runner->text, previewLines, charsPerLineEquivalent);\n                        QString omittedPrefix, omittedSuffix;\n                        QString previewQuotemarks;\n\n                        if (runner != it ) {\n                            // we have skipped something, make it obvious to the user\n\n                            // Find the closest level which got collapsed\n                            int closestDepth = std::numeric_limits<int>::max();\n                            auto depthRunner(it);\n                            while (depthRunner != runner) {\n                                closestDepth = std::min(closestDepth, depthRunner->depth);\n                                ++depthRunner;\n                            }\n\n                            // The [...] marks shall be prefixed by the closestDepth quote markers\n                            omittedStuff = QLatin1String(\"<span class=\\\"quotemarks\\\">\");\n                            for (int i = 0; i < closestDepth; ++i) {\n                                omittedStuff += QLatin1String(\"&gt;\");\n                            }\n                            for (int i = runner->depth; i < closestDepth; ++i) {\n                                omittedPrefix += QLatin1String(\"<blockquote>\");\n                                omittedSuffix += QLatin1String(\"</blockquote>\");\n                            }\n                            omittedStuff += QString::fromUtf8(\" </span><label for=\\\"q%1\\\">...</label>\").arg(interactiveControlsId);\n\n                            // Now produce the proper quotation for the preview itself\n                            for (int i = quoteLevel; i < runner->depth; ++i) {\n                                previewPrefix.append(QLatin1String(\"<blockquote>\"));\n                                previewSuffix.append(QLatin1String(\"</blockquote>\"));\n                            }\n                        }\n\n                        previewQuotemarks = QLatin1String(\"<span class=\\\"quotemarks\\\">\");\n                        for (int i = 0; i < runner->depth; ++i) {\n                            previewQuotemarks += QLatin1String(\"&gt;\");\n                        }\n                        previewQuotemarks += QLatin1String(\" </span>\");\n\n                        preview = previewPrefix\n                                    + omittedPrefix + omittedStuff + omittedSuffix\n                                + previewQuotemarks\n                                + helperHtmlifySingleLine(currentChunk)\n                                    .replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + previewQuotemarks)\n                                + previewSuffix;\n\n                        break;\n                    }\n                    if (runner->depth < quoteLevel) {\n                        // This means that we have left the current level of nesting, so there cannot possible be anything else\n                        // at the current level of nesting *and* in the current quote block\n                        break;\n                    }\n                    ++runner;\n                }\n\n                // Is there nothing but quotes until the end of mail or until the signature separator?\n                bool nothingButQuotesAndSpaceTillSignature = true;\n                runner = it;\n                while (++runner != lineBuffer.end()) {\n                    if (runner->depth == SIGNATURE_SEPARATOR)\n                        break;\n                    if (runner->depth > 0)\n                        continue;\n                    if (runner->depth == 0 && !runner->text.isEmpty()) {\n                        nothingButQuotesAndSpaceTillSignature = false;\n                        break;\n                    }\n                }\n\n                // Size of the current level, including the nested stuff\n                int currentLevelCharCount = 0;\n                int currentLevelLineCount = 0;\n                runner = it;\n                while (runner != lineBuffer.end() && runner->depth >= quoteLevel) {\n                    currentLevelCharCount += runner->text.size();\n                    // one for the actual block\n                    currentLevelLineCount += runner->text.count(QLatin1Char('\\n')) + 1;\n                    ++runner;\n                }\n\n\n                if (!anythingOnJustThisLevel) {\n                    // no need for fancy UI controls\n                    line += QLatin1String(\"<blockquote>\");\n                    continue;\n                }\n\n                if (quoteLevel == it->depth\n                        && currentLevelCharCount <= charsPerLineEquivalent * previewLines\n                        && currentLevelLineCount <= previewLines) {\n                    // special case: the quote is very short, no point in making it collapsible\n                    line += QString::fromUtf8(\"<span class=\\\"level\\\"><input type=\\\"checkbox\\\" id=\\\"q%1\\\"/>\").arg(interactiveControlsId)\n                            + QLatin1String(\"<span class=\\\"shortquote\\\"><blockquote>\") + quotemarks\n                            + helperHtmlifySingleLine(it->text).replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + quotemarks);\n                } else {\n#if QT_VERSION < QT_VERSION_CHECK(4, 8, 0)\n                    // old WebKit doesn't really support the dynamic updates of the :checked pseudoclass\n                    bool collapsed = false;\n                    Q_UNUSED(forceCollapseAfterLines);\n#else\n                    bool collapsed = nothingButQuotesAndSpaceTillSignature\n                            || quoteLevel > 1\n                            || currentLevelCharCount >= charsPerLineEquivalent * forceCollapseAfterLines\n                            || currentLevelLineCount >= forceCollapseAfterLines;\n#endif\n\n                    line += QString::fromUtf8(\"<span class=\\\"level\\\"><input type=\\\"checkbox\\\" id=\\\"q%1\\\" %2/>\")\n                            .arg(QString::number(interactiveControlsId),\n                                 collapsed ? QString::fromUtf8(\"checked=\\\"checked\\\"\") : QString())\n                            + QLatin1String(\"<span class=\\\"short\\\"><blockquote>\")\n                              + preview\n                              + QString::fromUtf8(\" <label for=\\\"q%1\\\">...</label>\").arg(interactiveControlsId)\n                              + QLatin1String(\"</blockquote></span>\")\n                            + QLatin1String(\"<span class=\\\"full\\\"><blockquote>\");\n                    if (quoteLevel == it->depth) {\n                        // We're now finally on the correct level of nesting so we can output the current line\n                        line += quotemarks + helperHtmlifySingleLine(it->text)\n                                .replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + quotemarks);\n                    }\n                }\n            }\n            markup << line;\n        } else {\n            // Either no quotation or we're continuing an old quote block and there was a nested quotation before\n            markup << quotemarks + helperHtmlifySingleLine(it->text)\n                      .replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + quotemarks);\n        }\n\n        auto next = it + 1;\n        if (next != lineBuffer.end()) {\n            if (next->depth >= 0 && next->depth < it->depth) {\n                // Decreasing the quotation level -> no starting <blockquote>\n                markup << QLatin1String(\"\\n\");\n            } else if (it->depth == 0) {\n                // Non-quoted block which is not enclosed in a <blockquote>\n                markup << QLatin1String(\"\\n\");\n            }\n        }\n    }\n\n    if (signatureSeparatorSeen) {\n        // Terminate the signature\n        markup << QLatin1String(\"</span>\");\n    }\n\n    if (quoteLevel) {\n        // Terminate the quotes\n        closeQuotesUpTo(markup, controlStack, quoteLevel, 0);\n    }\n\n    Q_ASSERT(controlStack.isEmpty());\n\n    return markup.join(QString());\n}",
    "includes": [
      "nclude \"PlainTextFormatter.h\"\n\nn",
      "nclude <QTextDocument>\n#e",
      "nclude <QStack>\n#i",
      "nclude <QPair>\n#i",
      "nclude <QObject>\n#i",
      "nclude <limits>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rkup.join",
          "args": [
            "tring());"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(c",
          "args": [
            "ntrolStack.isEmpty());"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntrolStack.isEmpty",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oseQuotesUpTo(m",
          "args": [
            "rkup,",
            "ntrolStack,",
            "oteLevel,",
            ";"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "/span>\");"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\");"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\");"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine",
          "args": [
            "atin1String(\"\\n\"),",
            "atin1String(\"\\n\") + quotemarks);"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\")"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\"),"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(i",
          "args": [
            "->text)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine",
          "args": [
            "atin1String(\"\\n\"),",
            "atin1String(\"\\n\") + quotemarks);"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\")"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\"),"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(i",
          "args": [
            "->text)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"full\\\"><blockquote>\");"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "/blockquote></span>\")"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "teractiveControlsId)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "<label for=\\\"q%1\\\">...</label>\")."
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"short\\\"><blockquote>\")"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "tring::number(interactiveControlsId),",
            "llapsed ? QString::fromUtf8(\"checked=\\\"checked\\\"\") : QString())"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "hecked=\\\"checked\\\"\")"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::number(i",
          "args": [
            "teractiveControlsId),"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "span class=\\\"level\\\"><input type=\\\"checkbox\\\" id=\\\"q%1\\\" %2/>\")"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNUSED(f",
          "args": [
            "rceCollapseAfterLines);"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_VERSION_CHECK(4",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine",
          "args": [
            "atin1String(\"\\n\"),",
            "atin1String(\"\\n\") + quotemarks);"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\")"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\"),"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(i",
          "args": [
            "->text)."
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"shortquote\\\"><blockquote>\")"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "teractiveControlsId)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "span class=\\\"level\\\"><input type=\\\"checkbox\\\" id=\\\"q%1\\\"/>\")."
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "blockquote>\");"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nner->text.count",
          "args": [
            "atin1Char('\\n'))"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "n'))"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nner->text.size",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nner->text.isEmpty",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine",
          "args": [
            "atin1String(\"\\n\"),",
            "atin1String(\"\\n\") + previewQuotemarks)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\")"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\"),"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(c",
          "args": [
            "rrentChunk)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "</span>\");"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "gt;\");"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"quotemarks\\\">\");"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eviewSuffix.append",
          "args": [
            "atin1String(\"</blockquote>\"));"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "/blockquote>\"))"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eviewPrefix.append",
          "args": [
            "atin1String(\"<blockquote>\"));"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "blockquote>\"))"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "teractiveControlsId);"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "</span><label for=\\\"q%1\\\">...</label>\")."
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "/blockquote>\");"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "blockquote>\");"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "gt;\");"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"quotemarks\\\">\");"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d::min(c",
          "args": [
            "osestDepth,",
            "pthRunner->depth);"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d::numeric_limits<int>::max()",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rstNLines(r",
          "args": [
            "nner->text,",
            "eviewLines,",
            "arsPerLineEquivalent);"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntrolStack.push",
          "args": [
            "akePair(quoteLevel, interactiveControlsId));"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "akePair(q",
          "args": [
            "oteLevel,",
            "teractiveControlsId))"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "</span>\");"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "gt;\");"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"quotemarks\\\">\");"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oseQuotesUpTo(m",
          "args": [
            "rkup,",
            "ntrolStack,",
            "oteLevel,",
            "->depth);"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(q",
          "args": [
            "oteLevel == 0 || quoteLevel != it->depth);"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\");"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(i",
          "args": [
            "->text);"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\");"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(i",
          "args": [
            "->text);"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "span class=\\\"signature\\\">\")"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oseQuotesUpTo(m",
          "args": [
            "rkup,",
            "ntrolStack,",
            "oteLevel,",
            ";"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.begin",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.erase",
          "args": [
            ");"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev->text.chop",
          "args": [
            ";"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev->text.endsWith",
          "args": [
            "atin1String(\" \\r\")))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "\\r\"))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev->text.endsWith",
          "args": [
            "atin1Char(' ')))"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "'))"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "n\");"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.begin",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->text.chop",
          "args": [
            ";"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->text.endsWith",
          "args": [
            "atin1Char(' ')))"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "'))"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "r');"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->text.chop",
          "args": [
            ";"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->text.endsWith",
          "args": [
            "atin1String(\" \\r\")))"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "\\r\"))"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->text.remove",
          "args": [
            "otemarks);"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.end",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "neBuffer.begin",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtInfo(q",
          "args": [
            "oteLevel,",
            "ne);"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.at",
          "args": [
            "+)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.at",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.at",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.length",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.at",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtInfo(S",
          "args": [
            "GNATURE_SEPARATOR,",
            "ne);"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnatureSeparator",
          "args": [
            "ne))"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnatureSeparator()",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "gnatureSeparator()",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
          "lines": "182-187",
          "snippet": "egExp signatureSeparator()\n{\n    // \"-- \" is the standards-compliant signature separator.\n    // \"Line of underscores\" is non-standard garbage which Mailman happily generates. Yes, it's nasty and ugly.\n    return QRegExp(QLatin1String(\"(-- |_{45,})(\\\\r)?\"));\n}",
          "includes": [
            "nclude \"PlainTextFormatter.h\"\n\nn",
            "nclude <QTextDocument>\n#e",
            "nclude <QStack>\n#i",
            "nclude <QPair>\n#i",
            "nclude <QObject>\n#i",
            "nclude <limits>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\negExp signatureSeparator()\n{\n    // \"-- \" is the standards-compliant signature separator.\n    // \"Line of underscores\" is non-standard garbage which Mailman happily generates. Yes, it's nasty and ugly.\n    return QRegExp(QLatin1String(\"(-- |_{45,})(\\\\r)?\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtInfo(0",
          "args": [
            "ne);"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.isEmpty",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\ntring plainTextToHtml(const QString &plaintext, const FlowedFormat flowed)\n{\n    static QRegExp quotemarks(\"^>[>\\\\s]*\");\n    const int SIGNATURE_SEPARATOR = -2;\n\n    QList<TextInfo> lineBuffer;\n\n    // First pass: determine the quote level for each source line.\n    // The quote level is ignored for the signature.\n    bool signatureSeparatorSeen = false;\n    Q_FOREACH(QString line, plaintext.split('\\n')) {\n\n        // Fast path for empty lines\n        if (line.isEmpty()) {\n            lineBuffer << TextInfo(0, line);\n            continue;\n        }\n\n        // Special marker for the signature separator\n        if (signatureSeparator().exactMatch(line)) {\n            lineBuffer << TextInfo(SIGNATURE_SEPARATOR, line);\n            signatureSeparatorSeen = true;\n            continue;\n        }\n\n        // Determine the quoting level\n        int quoteLevel = 0;\n        if (!signatureSeparatorSeen && line.at(0) == '>') {\n            int j = 1;\n            quoteLevel = 1;\n            while (j < line.length() && (line.at(j) == '>' || line.at(j) == ' '))\n                quoteLevel += line.at(j++) == '>';\n        }\n\n        lineBuffer << TextInfo(quoteLevel, line);\n    }\n\n    // Second pass:\n    // - Remove the quotemarks for everything prior to the signature separator.\n    // - Collapse the lines with the same quoting level into a single block\n    //   (optionally into a single line if format=flowed is active)\n    auto it = lineBuffer.begin();\n    while (it < lineBuffer.end() && it->depth != SIGNATURE_SEPARATOR) {\n\n        // Remove the quotemarks\n        it->text.remove(quotemarks);\n\n        if (flowed == FORMAT_FLOWED_DELSP) {\n            if (it->text.endsWith(QLatin1String(\" \\r\"))) {\n                it->text.chop(2);\n                it->text += QLatin1Char('\\r');\n            } else if (it->text.endsWith(QLatin1Char(' '))) {\n                it->text.chop(1);\n            }\n        }\n\n        if (it == lineBuffer.begin()) {\n            // No \"previous line\"\n            ++it;\n            continue;\n        }\n\n        // Check for the line joining\n        auto prev = it - 1;\n        if (prev->depth == it->depth) {\n            // empty lines must not be removed\n\n            QString separator = QLatin1String(\"\\n\");\n            switch (flowed) {\n            case FORMAT_PLAIN:\n                // nothing fancy to do here\n                break;\n            case FORMAT_FLOWED:\n            case FORMAT_FLOWED_DELSP:\n                // Now the trailing \\n is striped already; we only have to check for stuff ending with \" \" or \" \\r\".\n                if (prev->text.endsWith(QLatin1Char(' '))) {\n                    separator = QString();\n                } else if (prev->text.endsWith(QLatin1String(\" \\r\"))) {\n                    separator = QString();\n                    // Remove that extra \\r\n                    prev->text.chop(1);\n                }\n                break;\n            }\n            prev->text += separator + it->text;\n            it = lineBuffer.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Third pass: HTML escaping, formatting and adding fancy markup\n    signatureSeparatorSeen = false;\n    int quoteLevel = 0;\n    QStringList markup;\n    int interactiveControlsId = 0;\n    QStack<QPair<int,int> > controlStack;\n    for (it = lineBuffer.begin(); it != lineBuffer.end(); ++it) {\n\n        if (it->depth == SIGNATURE_SEPARATOR && !signatureSeparatorSeen) {\n            // The first signature separator\n            signatureSeparatorSeen = true;\n            closeQuotesUpTo(markup, controlStack, quoteLevel, 0);\n            markup << QLatin1String(\"<span class=\\\"signature\\\">\") + helperHtmlifySingleLine(it->text);\n            markup << QLatin1String(\"\\n\");\n            continue;\n        }\n\n        if (signatureSeparatorSeen) {\n            // Just copy the data\n            markup << helperHtmlifySingleLine(it->text);\n            if (it+1 != lineBuffer.end())\n                markup << QLatin1String(\"\\n\");\n            continue;\n        }\n\n        Q_ASSERT(quoteLevel == 0 || quoteLevel != it->depth);\n\n        if (quoteLevel > it->depth) {\n            // going back in the quote hierarchy\n            closeQuotesUpTo(markup, controlStack, quoteLevel, it->depth);\n        }\n\n        // Pretty-formatted block of the \">>>\" characters\n        QString quotemarks;\n\n        if (it->depth) {\n            quotemarks += QLatin1String(\"<span class=\\\"quotemarks\\\">\");\n            for (int i = 0; i < it->depth; ++i) {\n                quotemarks += QLatin1String(\"&gt;\");\n            }\n            quotemarks += QLatin1String(\" </span>\");\n        }\n\n        static const int previewLines = 5;\n        static const int charsPerLineEquivalent = 160;\n        static const int forceCollapseAfterLines = 10;\n\n        if (quoteLevel < it->depth) {\n            // We're going deeper in the quote hierarchy\n            QString line;\n            while (quoteLevel < it->depth) {\n                ++quoteLevel;\n\n                // Check whether there is anything at the newly entered level of nesting\n                bool anythingOnJustThisLevel = false;\n\n                // A short summary of the quotation\n                QString preview;\n\n                auto runner = it;\n                while (runner != lineBuffer.end()) {\n                    if (runner->depth == quoteLevel) {\n                        anythingOnJustThisLevel = true;\n\n                        ++interactiveControlsId;\n                        controlStack.push(qMakePair(quoteLevel, interactiveControlsId));\n\n                        QString omittedStuff;\n                        QString previewPrefix, previewSuffix;\n                        QString currentChunk = firstNLines(runner->text, previewLines, charsPerLineEquivalent);\n                        QString omittedPrefix, omittedSuffix;\n                        QString previewQuotemarks;\n\n                        if (runner != it ) {\n                            // we have skipped something, make it obvious to the user\n\n                            // Find the closest level which got collapsed\n                            int closestDepth = std::numeric_limits<int>::max();\n                            auto depthRunner(it);\n                            while (depthRunner != runner) {\n                                closestDepth = std::min(closestDepth, depthRunner->depth);\n                                ++depthRunner;\n                            }\n\n                            // The [...] marks shall be prefixed by the closestDepth quote markers\n                            omittedStuff = QLatin1String(\"<span class=\\\"quotemarks\\\">\");\n                            for (int i = 0; i < closestDepth; ++i) {\n                                omittedStuff += QLatin1String(\"&gt;\");\n                            }\n                            for (int i = runner->depth; i < closestDepth; ++i) {\n                                omittedPrefix += QLatin1String(\"<blockquote>\");\n                                omittedSuffix += QLatin1String(\"</blockquote>\");\n                            }\n                            omittedStuff += QString::fromUtf8(\" </span><label for=\\\"q%1\\\">...</label>\").arg(interactiveControlsId);\n\n                            // Now produce the proper quotation for the preview itself\n                            for (int i = quoteLevel; i < runner->depth; ++i) {\n                                previewPrefix.append(QLatin1String(\"<blockquote>\"));\n                                previewSuffix.append(QLatin1String(\"</blockquote>\"));\n                            }\n                        }\n\n                        previewQuotemarks = QLatin1String(\"<span class=\\\"quotemarks\\\">\");\n                        for (int i = 0; i < runner->depth; ++i) {\n                            previewQuotemarks += QLatin1String(\"&gt;\");\n                        }\n                        previewQuotemarks += QLatin1String(\" </span>\");\n\n                        preview = previewPrefix\n                                    + omittedPrefix + omittedStuff + omittedSuffix\n                                + previewQuotemarks\n                                + helperHtmlifySingleLine(currentChunk)\n                                    .replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + previewQuotemarks)\n                                + previewSuffix;\n\n                        break;\n                    }\n                    if (runner->depth < quoteLevel) {\n                        // This means that we have left the current level of nesting, so there cannot possible be anything else\n                        // at the current level of nesting *and* in the current quote block\n                        break;\n                    }\n                    ++runner;\n                }\n\n                // Is there nothing but quotes until the end of mail or until the signature separator?\n                bool nothingButQuotesAndSpaceTillSignature = true;\n                runner = it;\n                while (++runner != lineBuffer.end()) {\n                    if (runner->depth == SIGNATURE_SEPARATOR)\n                        break;\n                    if (runner->depth > 0)\n                        continue;\n                    if (runner->depth == 0 && !runner->text.isEmpty()) {\n                        nothingButQuotesAndSpaceTillSignature = false;\n                        break;\n                    }\n                }\n\n                // Size of the current level, including the nested stuff\n                int currentLevelCharCount = 0;\n                int currentLevelLineCount = 0;\n                runner = it;\n                while (runner != lineBuffer.end() && runner->depth >= quoteLevel) {\n                    currentLevelCharCount += runner->text.size();\n                    // one for the actual block\n                    currentLevelLineCount += runner->text.count(QLatin1Char('\\n')) + 1;\n                    ++runner;\n                }\n\n\n                if (!anythingOnJustThisLevel) {\n                    // no need for fancy UI controls\n                    line += QLatin1String(\"<blockquote>\");\n                    continue;\n                }\n\n                if (quoteLevel == it->depth\n                        && currentLevelCharCount <= charsPerLineEquivalent * previewLines\n                        && currentLevelLineCount <= previewLines) {\n                    // special case: the quote is very short, no point in making it collapsible\n                    line += QString::fromUtf8(\"<span class=\\\"level\\\"><input type=\\\"checkbox\\\" id=\\\"q%1\\\"/>\").arg(interactiveControlsId)\n                            + QLatin1String(\"<span class=\\\"shortquote\\\"><blockquote>\") + quotemarks\n                            + helperHtmlifySingleLine(it->text).replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + quotemarks);\n                } else {\n#if QT_VERSION < QT_VERSION_CHECK(4, 8, 0)\n                    // old WebKit doesn't really support the dynamic updates of the :checked pseudoclass\n                    bool collapsed = false;\n                    Q_UNUSED(forceCollapseAfterLines);\n#else\n                    bool collapsed = nothingButQuotesAndSpaceTillSignature\n                            || quoteLevel > 1\n                            || currentLevelCharCount >= charsPerLineEquivalent * forceCollapseAfterLines\n                            || currentLevelLineCount >= forceCollapseAfterLines;\n#endif\n\n                    line += QString::fromUtf8(\"<span class=\\\"level\\\"><input type=\\\"checkbox\\\" id=\\\"q%1\\\" %2/>\")\n                            .arg(QString::number(interactiveControlsId),\n                                 collapsed ? QString::fromUtf8(\"checked=\\\"checked\\\"\") : QString())\n                            + QLatin1String(\"<span class=\\\"short\\\"><blockquote>\")\n                              + preview\n                              + QString::fromUtf8(\" <label for=\\\"q%1\\\">...</label>\").arg(interactiveControlsId)\n                              + QLatin1String(\"</blockquote></span>\")\n                            + QLatin1String(\"<span class=\\\"full\\\"><blockquote>\");\n                    if (quoteLevel == it->depth) {\n                        // We're now finally on the correct level of nesting so we can output the current line\n                        line += quotemarks + helperHtmlifySingleLine(it->text)\n                                .replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + quotemarks);\n                    }\n                }\n            }\n            markup << line;\n        } else {\n            // Either no quotation or we're continuing an old quote block and there was a nested quotation before\n            markup << quotemarks + helperHtmlifySingleLine(it->text)\n                      .replace(QLatin1String(\"\\n\"), QLatin1String(\"\\n\") + quotemarks);\n        }\n\n        auto next = it + 1;\n        if (next != lineBuffer.end()) {\n            if (next->depth >= 0 && next->depth < it->depth) {\n                // Decreasing the quotation level -> no starting <blockquote>\n                markup << QLatin1String(\"\\n\");\n            } else if (it->depth == 0) {\n                // Non-quoted block which is not enclosed in a <blockquote>\n                markup << QLatin1String(\"\\n\");\n            }\n        }\n    }\n\n    if (signatureSeparatorSeen) {\n        // Terminate the signature\n        markup << QLatin1String(\"</span>\");\n    }\n\n    if (quoteLevel) {\n        // Terminate the quotes\n        closeQuotesUpTo(markup, controlStack, quoteLevel, 0);\n    }\n\n    Q_ASSERT(controlStack.isEmpty());\n\n    return markup.join(QString());\n}"
  },
  {
    "function_name": "xtInfo(c",
    "container": "xtInfo {",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
    "lines": "193-195",
    "snippet": "xtInfo(const int depth, const QString &text): depth(depth), text(text)\n    {\n    }\n}",
    "includes": [
      "nclude \"PlainTextFormatter.h\"\n\nn",
      "nclude <QTextDocument>\n#e",
      "nclude <QStack>\n#i",
      "nclude <QPair>\n#i",
      "nclude <QObject>\n#i",
      "nclude <limits>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\nxtInfo { {\n  xtInfo(const int depth, const QString &text): depth(depth), text(text)\n      {\n      }\n  }\n}"
  },
  {
    "function_name": "gnatureSeparator()",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
    "lines": "182-187",
    "snippet": "egExp signatureSeparator()\n{\n    // \"-- \" is the standards-compliant signature separator.\n    // \"Line of underscores\" is non-standard garbage which Mailman happily generates. Yes, it's nasty and ugly.\n    return QRegExp(QLatin1String(\"(-- |_{45,})(\\\\r)?\"));\n}",
    "includes": [
      "nclude \"PlainTextFormatter.h\"\n\nn",
      "nclude <QTextDocument>\n#e",
      "nclude <QStack>\n#i",
      "nclude <QPair>\n#i",
      "nclude <QObject>\n#i",
      "nclude <limits>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "egExp(Q",
          "args": [
            "atin1String(\"(-- |_{45,})(\\\\r)?\"));"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "-- |_{45,})(\\\\r)?\"))"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\negExp signatureSeparator()\n{\n    // \"-- \" is the standards-compliant signature separator.\n    // \"Line of underscores\" is non-standard garbage which Mailman happily generates. Yes, it's nasty and ugly.\n    return QRegExp(QLatin1String(\"(-- |_{45,})(\\\\r)?\"));\n}"
  },
  {
    "function_name": "oseQuotesUpTo(Q",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
    "lines": "159-179",
    "snippet": "id closeQuotesUpTo(QStringList &markup, QStack<QPair<int, int> > &controlStack, int &quoteLevel, const int finalQuoteLevel)\n{\n    static QString closingLabel(\"<label for=\\\"q%1\\\"></label>\");\n    static QLatin1String closeSingleQuote(\"</blockquote>\");\n    static QLatin1String closeQuoteBlock(\"</span></span>\");\n\n    Q_ASSERT(quoteLevel >= finalQuoteLevel);\n\n    while (quoteLevel > finalQuoteLevel) {\n        // Check whether an interactive control element is supposed to be present here\n        bool controlBlock = !controlStack.isEmpty() && (quoteLevel == controlStack.top().first);\n        if (controlBlock) {\n            markup << closingLabel.arg(controlStack.pop().second);\n        }\n        markup << closeSingleQuote;\n        --quoteLevel;\n        if (controlBlock) {\n            markup << closeQuoteBlock;\n        }\n    }\n}",
    "includes": [
      "nclude \"PlainTextFormatter.h\"\n\nn",
      "nclude <QTextDocument>\n#e",
      "nclude <QStack>\n#i",
      "nclude <QPair>\n#i",
      "nclude <QObject>\n#i",
      "nclude <limits>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osingLabel.arg",
          "args": [
            "ntrolStack.pop().second);"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntrolStack.pop",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntrolStack.top",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntrolStack.isEmpty",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(q",
          "args": [
            "oteLevel >= finalQuoteLevel);"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\nid closeQuotesUpTo(QStringList &markup, QStack<QPair<int, int> > &controlStack, int &quoteLevel, const int finalQuoteLevel)\n{\n    static QString closingLabel(\"<label for=\\\"q%1\\\"></label>\");\n    static QLatin1String closeSingleQuote(\"</blockquote>\");\n    static QLatin1String closeQuoteBlock(\"</span></span>\");\n\n    Q_ASSERT(quoteLevel >= finalQuoteLevel);\n\n    while (quoteLevel > finalQuoteLevel) {\n        // Check whether an interactive control element is supposed to be present here\n        bool controlBlock = !controlStack.isEmpty() && (quoteLevel == controlStack.top().first);\n        if (controlBlock) {\n            markup << closingLabel.arg(controlStack.pop().second);\n        }\n        markup << closeSingleQuote;\n        --quoteLevel;\n        if (controlBlock) {\n            markup << closeQuoteBlock;\n        }\n    }\n}"
  },
  {
    "function_name": "rstNLines(c",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
    "lines": "145-156",
    "snippet": "tring firstNLines(const QString &input, int numLines, const int charsPerLine)\n{\n    Q_ASSERT(numLines >= 2);\n    QString out = input.section(QLatin1Char('\\n'), 0, numLines - 1, QString::SectionSkipEmpty);\n    const int cutoff = numLines * charsPerLine;\n    if (out.size() >= cutoff) {\n        int pos = input.indexOf(QLatin1Char(' '), cutoff);\n        if (pos != -1)\n            return out.left(pos - 1);\n    }\n    return out;\n}",
    "includes": [
      "nclude \"PlainTextFormatter.h\"\n\nn",
      "nclude <QTextDocument>\n#e",
      "nclude <QStack>\n#i",
      "nclude <QPair>\n#i",
      "nclude <QObject>\n#i",
      "nclude <limits>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t.left",
          "args": [
            "s - 1);"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put.indexOf",
          "args": [
            "atin1Char(' '),",
            "toff);"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "'),"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.size",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "sizeHint",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "131-134",
          "snippet": "QSize FlowLayout::sizeHint() const\n{\n    return minimumSize();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  QSize FlowLayout::sizeHint() const\n  {\n      return minimumSize();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "put.section",
          "args": [
            "atin1Char('\\n'),",
            "mLines - 1,",
            "tring::SectionSkipEmpty);"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "n'),"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(n",
          "args": [
            "mLines >= 2);"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\ntring firstNLines(const QString &input, int numLines, const int charsPerLine)\n{\n    Q_ASSERT(numLines >= 2);\n    QString out = input.section(QLatin1Char('\\n'), 0, numLines - 1, QString::SectionSkipEmpty);\n    const int cutoff = numLines * charsPerLine;\n    if (out.size() >= cutoff) {\n        int pos = input.indexOf(QLatin1Char(' '), cutoff);\n        if (pos != -1)\n            return out.left(pos - 1);\n    }\n    return out;\n}"
  },
  {
    "function_name": "lperHtmlifySingleLine(Q",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/PlainTextFormatter.cpp",
    "lines": "40-137",
    "snippet": "tring helperHtmlifySingleLine(QString line)\n{\n    // Static regexps for the engine construction.\n    // Warning, these operate on the *escaped* HTML!\n    static QString intro(\"(^|[\\\\s\\\\(\\\\[\\\\{])\");\n    static QString extro(\"($|[\\\\s\\\\),;.\\\\]\\\\}])\");\n    static const QRegExp patternRe(\n                // hyperlinks\n                \"(\" // cap(1)\n                \"https?://\" // scheme prefix\n                \"(?:[;/?:@=$\\\\-_.+!',0-9a-zA-Z%#~\\\\[\\\\]\\\\(\\\\)\\\\*]|&amp;)+\" // allowed characters\n                \"(?:[/@=$\\\\-_+'0-9a-zA-Z%#~]|&amp;)\" // termination\n                \")\"\n                // end of hyperlink\n                \"|\"\n                // e-mail pattern\n                \"((?:[a-zA-Z0-9_\\\\.!#$%'\\\\*\\\\+\\\\-/=?^`\\\\{|\\\\}~]|&amp;)+@[a-zA-Z0-9\\\\.\\\\-_]+)\" // cap(2)\n                // end of e-mail pattern\n                \"|\"\n                // formatting markup\n                \"(\" // cap(3)\n                // bold text\n                + intro /* cap(4) */ + \"\\\\*((?!\\\\*)\\\\S+)\\\\*\" /* cap(5) */ + extro /* cap(6) */\n                + \"|\"\n                // italics\n                + intro /* cap(7) */ + \"/((?!/)\\\\S+)/\" /* cap(8) */ + extro /* cap(9) */\n                + \"|\"\n                // underline\n                + intro /* cap(10) */ + \"_((?!_)\\\\S+)_\" /* cap(11) */ + extro /* cap(12) */\n                + \")\"\n                // end of the formatting markup\n                , Qt::CaseSensitive, QRegExp::RegExp2\n                );\n\n    // RE instances to work on\n    QRegExp pattern(patternRe);\n\n    // Escape the HTML entities\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    line = Qt::escape(line);\n#else\n    line = line.toHtmlEscaped();\n#endif\n\n    // Now prepare markup *bold*, /italic/ and _underline_ and also turn links into HTML.\n    // This is a bit more involved because we want to apply the regular expressions in a certain order and also at the same\n    // time prevent the lower-priority regexps from clobbering the output of the previous stages.\n    int start = 0;\n    while (start < line.size()) {\n        // Find the position of the first thing which matches\n        int pos = pattern.indexIn(line, start, QRegExp::CaretAtOffset);\n        if (pos == -1 || pos == line.size()) {\n            // No further matches for this line -> we're done\n            break;\n        }\n\n        const QString &linkText = pattern.cap(1);\n        const QString &mailText = pattern.cap(2);\n        const QString &boldText = pattern.cap(5);\n        const QString &italicText = pattern.cap(8);\n        const QString &underlineText = pattern.cap(11);\n        bool isSpecialFormat = !boldText.isEmpty() || !italicText.isEmpty() || !underlineText.isEmpty();\n        QString replacement;\n\n        if (!linkText.isEmpty()) {\n            replacement = QString::fromUtf8(\"<a href=\\\"%1\\\">%1</a>\").arg(linkText);\n        } else if (!mailText.isEmpty()) {\n            replacement = QString::fromUtf8(\"<a href=\\\"mailto:%1\\\">%1</a>\").arg(mailText);\n        } else if (isSpecialFormat) {\n            // Careful here; the inner contents of the current match shall be formatted as well which is why we need recursion\n            QChar elementName;\n            QChar markupChar;\n            int whichOne = 0;\n\n            if (!boldText.isEmpty()) {\n                elementName = QLatin1Char('b');\n                markupChar = QLatin1Char('*');\n                whichOne = 3;\n            } else if (!italicText.isEmpty()) {\n                elementName = QLatin1Char('i');\n                markupChar = QLatin1Char('/');\n                whichOne = 6;\n            } else if (!underlineText.isEmpty()) {\n                elementName = QLatin1Char('u');\n                markupChar = QLatin1Char('_');\n                whichOne = 9;\n            }\n            Q_ASSERT(whichOne);\n            replacement = QString::fromUtf8(\"%1<%2><span class=\\\"markup\\\">%3</span>%4<span class=\\\"markup\\\">%3</span></%2>%5\")\n                    .arg(pattern.cap(whichOne + 1), elementName, markupChar,\n                         helperHtmlifySingleLine(pattern.cap(whichOne + 2)), pattern.cap(whichOne + 3));\n        }\n        Q_ASSERT(!replacement.isEmpty());\n        line = line.left(pos) + replacement + line.mid(pos + pattern.matchedLength());\n        start = pos + replacement.size();\n    }\n    return line;\n}",
    "includes": [
      "nclude \"PlainTextFormatter.h\"\n\nn",
      "nclude <QTextDocument>\n#e",
      "nclude <QStack>\n#i",
      "nclude <QPair>\n#i",
      "nclude <QObject>\n#i",
      "nclude <limits>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "placement.size",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.mid",
          "args": [
            "s + pattern.matchedLength());"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.matchedLength",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.left",
          "args": [
            "s)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(!",
          "args": [
            "eplacement.isEmpty());"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "placement.isEmpty",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "ttern.cap(whichOne + 1),",
            "ementName,",
            "rkupChar,",
            "lperHtmlifySingleLine(pattern.cap(whichOne + 2)),",
            "ttern.cap(whichOne + 3));"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            "ichOne + 3))"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lperHtmlifySingleLine(p",
          "args": [
            "ttern.cap(whichOne + 2)),"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            "ichOne + 2))"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            "ichOne + 1),"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "1<%2><span class=\\\"markup\\\">%3</span>%4<span class=\\\"markup\\\">%3</span></%2>%5\")"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT(w",
          "args": [
            "ichOne);"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "');"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "');"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "derlineText.isEmpty",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "');"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "');"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alicText.isEmpty",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "');"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1Char('",
          "args": [
            "');"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldText.isEmpty",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "ilText);"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "a href=\\\"mailto:%1\\\">%1</a>\")."
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilText.isEmpty",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8",
          "args": [
            "nkText);"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring::fromUtf8(\"",
          "args": [
            "a href=\\\"%1\\\">%1</a>\")."
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nkText.isEmpty",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "derlineText.isEmpty",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alicText.isEmpty",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldText.isEmpty",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            ");"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            ";"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            ";"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            ";"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.cap",
          "args": [
            ";"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.size",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttern.indexIn",
          "args": [
            "ne,",
            "art,",
            "egExp::CaretAtOffset);"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.size",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ne.toHtmlEscaped",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::escape(l",
          "args": [
            "ne);"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_VERSION_CHECK(5",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"PlainTextFormatter.h\"\n\nn\nnclude <QTextDocument>\n#e\nnclude <QStack>\n#i\nnclude <QPair>\n#i\nnclude <QObject>\n#i\nnclude <limits>\n#i\n\ntring helperHtmlifySingleLine(QString line)\n{\n    // Static regexps for the engine construction.\n    // Warning, these operate on the *escaped* HTML!\n    static QString intro(\"(^|[\\\\s\\\\(\\\\[\\\\{])\");\n    static QString extro(\"($|[\\\\s\\\\),;.\\\\]\\\\}])\");\n    static const QRegExp patternRe(\n                // hyperlinks\n                \"(\" // cap(1)\n                \"https?://\" // scheme prefix\n                \"(?:[;/?:@=$\\\\-_.+!',0-9a-zA-Z%#~\\\\[\\\\]\\\\(\\\\)\\\\*]|&amp;)+\" // allowed characters\n                \"(?:[/@=$\\\\-_+'0-9a-zA-Z%#~]|&amp;)\" // termination\n                \")\"\n                // end of hyperlink\n                \"|\"\n                // e-mail pattern\n                \"((?:[a-zA-Z0-9_\\\\.!#$%'\\\\*\\\\+\\\\-/=?^`\\\\{|\\\\}~]|&amp;)+@[a-zA-Z0-9\\\\.\\\\-_]+)\" // cap(2)\n                // end of e-mail pattern\n                \"|\"\n                // formatting markup\n                \"(\" // cap(3)\n                // bold text\n                + intro /* cap(4) */ + \"\\\\*((?!\\\\*)\\\\S+)\\\\*\" /* cap(5) */ + extro /* cap(6) */\n                + \"|\"\n                // italics\n                + intro /* cap(7) */ + \"/((?!/)\\\\S+)/\" /* cap(8) */ + extro /* cap(9) */\n                + \"|\"\n                // underline\n                + intro /* cap(10) */ + \"_((?!_)\\\\S+)_\" /* cap(11) */ + extro /* cap(12) */\n                + \")\"\n                // end of the formatting markup\n                , Qt::CaseSensitive, QRegExp::RegExp2\n                );\n\n    // RE instances to work on\n    QRegExp pattern(patternRe);\n\n    // Escape the HTML entities\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    line = Qt::escape(line);\n#else\n    line = line.toHtmlEscaped();\n#endif\n\n    // Now prepare markup *bold*, /italic/ and _underline_ and also turn links into HTML.\n    // This is a bit more involved because we want to apply the regular expressions in a certain order and also at the same\n    // time prevent the lower-priority regexps from clobbering the output of the previous stages.\n    int start = 0;\n    while (start < line.size()) {\n        // Find the position of the first thing which matches\n        int pos = pattern.indexIn(line, start, QRegExp::CaretAtOffset);\n        if (pos == -1 || pos == line.size()) {\n            // No further matches for this line -> we're done\n            break;\n        }\n\n        const QString &linkText = pattern.cap(1);\n        const QString &mailText = pattern.cap(2);\n        const QString &boldText = pattern.cap(5);\n        const QString &italicText = pattern.cap(8);\n        const QString &underlineText = pattern.cap(11);\n        bool isSpecialFormat = !boldText.isEmpty() || !italicText.isEmpty() || !underlineText.isEmpty();\n        QString replacement;\n\n        if (!linkText.isEmpty()) {\n            replacement = QString::fromUtf8(\"<a href=\\\"%1\\\">%1</a>\").arg(linkText);\n        } else if (!mailText.isEmpty()) {\n            replacement = QString::fromUtf8(\"<a href=\\\"mailto:%1\\\">%1</a>\").arg(mailText);\n        } else if (isSpecialFormat) {\n            // Careful here; the inner contents of the current match shall be formatted as well which is why we need recursion\n            QChar elementName;\n            QChar markupChar;\n            int whichOne = 0;\n\n            if (!boldText.isEmpty()) {\n                elementName = QLatin1Char('b');\n                markupChar = QLatin1Char('*');\n                whichOne = 3;\n            } else if (!italicText.isEmpty()) {\n                elementName = QLatin1Char('i');\n                markupChar = QLatin1Char('/');\n                whichOne = 6;\n            } else if (!underlineText.isEmpty()) {\n                elementName = QLatin1Char('u');\n                markupChar = QLatin1Char('_');\n                whichOne = 9;\n            }\n            Q_ASSERT(whichOne);\n            replacement = QString::fromUtf8(\"%1<%2><span class=\\\"markup\\\">%3</span>%4<span class=\\\"markup\\\">%3</span></%2>%5\")\n                    .arg(pattern.cap(whichOne + 1), elementName, markupChar,\n                         helperHtmlifySingleLine(pattern.cap(whichOne + 2)), pattern.cap(whichOne + 3));\n        }\n        Q_ASSERT(!replacement.isEmpty());\n        line = line.left(pos) + replacement + line.mid(pos + pattern.matchedLength());\n        start = pos + replacement.size();\n    }\n    return line;\n}"
  }
]