[
  {
    "function_name": "slotDataChanged(",
    "container": "ullMessageCombiner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
    "lines": "88-110",
    "snippet": "oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n{\n    Q_UNUSED(left);\n    Q_UNUSED(right);\n\n    if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n       emit completed();\n       // Disconnect this slot from its connected signal to prevent emitting completed() many times\n       // when dataChanged() is emitted and the parts are already fetched.\n       disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n    }\n\n    Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n    bool headerOffline = headerPartPtr()->isUnavailable(model);\n    bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n    if (headerOffline && bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached message data not available\"));\n    } else if (headerOffline) {\n        emit failed(tr(\"Offline mode: uncached header data not available\"));\n    } else if (bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached body data not available\"));\n    }\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"FullMessageCombiner.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Offline mode: uncached body data not available\")"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odyPartPtr",
          "args": [
            "odel)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr(",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr",
          "args": [
            "odel)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr(",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Imap::Mailbox::Model*>",
          "args": [
            "_model)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_model,",
            "IGNAL(dataChanged(QModelIndex,QModelIndex)),",
            "his,",
            "LOT(slotDataChanged(QModelIndex,QModelIndex)))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotDataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotDataChanged(",
          "args": [
            "ModelIndex,",
            "ModelIndex)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "slotDataChanged(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "88-110",
          "snippet": "oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n{\n    Q_UNUSED(left);\n    Q_UNUSED(right);\n\n    if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n       emit completed();\n       // Disconnect this slot from its connected signal to prevent emitting completed() many times\n       // when dataChanged() is emitted and the parts are already fetched.\n       disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n    }\n\n    Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n    bool headerOffline = headerPartPtr()->isUnavailable(model);\n    bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n    if (headerOffline && bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached message data not available\"));\n    } else if (headerOffline) {\n        emit failed(tr(\"Offline mode: uncached header data not available\"));\n    } else if (bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached body data not available\"));\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr(",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr(",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ight)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "eft)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n  {\n      Q_UNUSED(left);\n      Q_UNUSED(right);\n  \n      if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n         emit completed();\n         // Disconnect this slot from its connected signal to prevent emitting completed() many times\n         // when dataChanged() is emitted and the parts are already fetched.\n         disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n      }\n  \n      Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n      bool headerOffline = headerPartPtr()->isUnavailable(model);\n      bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n      if (headerOffline && bodyOffline) {\n          emit failed(tr(\"Offline mode: uncached message data not available\"));\n      } else if (headerOffline) {\n          emit failed(tr(\"Offline mode: uncached header data not available\"));\n      } else if (bodyOffline) {\n          emit failed(tr(\"Offline mode: uncached body data not available\"));\n      }\n  }\n}"
  },
  {
    "function_name": "load(",
    "container": "ullMessageCombiner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
    "lines": "67-74",
    "snippet": "oid FullMessageCombiner::load()\n{\n    Imap::Mailbox::TreeItemPart *headerPart = headerPartPtr();\n    headerPart->fetch(const_cast<Mailbox::Model *>(m_model));\n    Imap::Mailbox::TreeItemPart *bodyPart = bodyPartPtr();\n    bodyPart->fetch(const_cast<Mailbox::Model *>(m_model));\n    slotDataChanged(QModelIndex(), QModelIndex());\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"FullMessageCombiner.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lotDataChanged(",
          "args": [
            "ModelIndex(),",
            "ModelIndex())"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "slotDataChanged(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "88-110",
          "snippet": "oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n{\n    Q_UNUSED(left);\n    Q_UNUSED(right);\n\n    if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n       emit completed();\n       // Disconnect this slot from its connected signal to prevent emitting completed() many times\n       // when dataChanged() is emitted and the parts are already fetched.\n       disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n    }\n\n    Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n    bool headerOffline = headerPartPtr()->isUnavailable(model);\n    bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n    if (headerOffline && bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached message data not available\"));\n    } else if (headerOffline) {\n        emit failed(tr(\"Offline mode: uncached header data not available\"));\n    } else if (bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached body data not available\"));\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"FullMessageCombiner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n  {\n      Q_UNUSED(left);\n      Q_UNUSED(right);\n  \n      if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n         emit completed();\n         // Disconnect this slot from its connected signal to prevent emitting completed() many times\n         // when dataChanged() is emitted and the parts are already fetched.\n         disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n      }\n  \n      Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n      bool headerOffline = headerPartPtr()->isUnavailable(model);\n      bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n      if (headerOffline && bodyOffline) {\n          emit failed(tr(\"Offline mode: uncached message data not available\"));\n      } else if (headerOffline) {\n          emit failed(tr(\"Offline mode: uncached header data not available\"));\n      } else if (bodyOffline) {\n          emit failed(tr(\"Offline mode: uncached body data not available\"));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPart->fetch",
          "args": [
            "onst_cast<Mailbox::Model *>(m_model))"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Mailbox::Model *>",
          "args": [
            "_model)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr(",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPart->fetch",
          "args": [
            "onst_cast<Mailbox::Model *>(m_model))"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Mailbox::Model *>",
          "args": [
            "_model)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr(",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  oid FullMessageCombiner::load()\n  {\n      Imap::Mailbox::TreeItemPart *headerPart = headerPartPtr();\n      headerPart->fetch(const_cast<Mailbox::Model *>(m_model));\n      Imap::Mailbox::TreeItemPart *bodyPart = bodyPartPtr();\n      bodyPart->fetch(const_cast<Mailbox::Model *>(m_model));\n      slotDataChanged(QModelIndex(), QModelIndex());\n  }\n}"
  },
  {
    "function_name": "loaded(",
    "container": "ullMessageCombiner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
    "lines": "62-65",
    "snippet": "ool FullMessageCombiner::loaded() const\n{\n    return headerPartPtr()->fetched() && bodyPartPtr()->fetched();\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"FullMessageCombiner.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odyPartPtr",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr(",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr(",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  ool FullMessageCombiner::loaded() const\n  {\n      return headerPartPtr()->fetched() && bodyPartPtr()->fetched();\n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "ullMessageCombiner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
    "lines": "54-60",
    "snippet": "ByteArray FullMessageCombiner::data() const\n{\n    if (loaded())\n        return *(headerPartPtr()->dataPtr()) + *(bodyPartPtr()->dataPtr());\n\n    return QByteArray();\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"FullMessageCombiner.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odyPartPtr",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr(",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr(",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oaded(",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "loaded(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "62-65",
          "snippet": "ool FullMessageCombiner::loaded() const\n{\n    return headerPartPtr()->fetched() && bodyPartPtr()->fetched();\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"FullMessageCombiner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  ool FullMessageCombiner::loaded() const\n  {\n      return headerPartPtr()->fetched() && bodyPartPtr()->fetched();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  ByteArray FullMessageCombiner::data() const\n  {\n      if (loaded())\n          return *(headerPartPtr()->dataPtr()) + *(bodyPartPtr()->dataPtr());\n  \n      return QByteArray();\n  }\n}"
  },
  {
    "function_name": "FullMessageCombiner(",
    "container": "ullMessageCombiner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
    "lines": "34-52",
    "snippet": "ullMessageCombiner::FullMessageCombiner(const QModelIndex &messageIndex, QObject *parent) :\n    QObject(parent), m_model(0), m_messageIndex(messageIndex)\n{\n    Imap::Mailbox::Model::realTreeItem(messageIndex, &m_model);\n    Q_ASSERT(m_model);\n    Imap::Mailbox::TreeItemPart *headerPart = headerPartPtr();\n    Imap::Mailbox::TreeItemPart *bodyPart = bodyPartPtr();\n\n    Q_ASSERT(headerPart);\n    Q_ASSERT(bodyPart);\n\n    m_headerPartIndex = headerPart->toIndex(const_cast<Mailbox::Model *>(m_model));\n    Q_ASSERT(m_headerPartIndex.isValid());\n\n    m_bodyPartIndex = bodyPart->toIndex(const_cast<Mailbox::Model *>(m_model));\n    Q_ASSERT(m_bodyPartIndex.isValid());\n\n    connect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n}",
    "includes": [
      "include \"Imap/Model/MailboxTree.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"FullMessageCombiner.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_model,",
            "IGNAL(dataChanged(QModelIndex,QModelIndex)),",
            "LOT(slotDataChanged(QModelIndex,QModelIndex)))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotDataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotDataChanged(",
          "args": [
            "ModelIndex,",
            "ModelIndex)"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "slotDataChanged(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "88-110",
          "snippet": "oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n{\n    Q_UNUSED(left);\n    Q_UNUSED(right);\n\n    if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n       emit completed();\n       // Disconnect this slot from its connected signal to prevent emitting completed() many times\n       // when dataChanged() is emitted and the parts are already fetched.\n       disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n    }\n\n    Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n    bool headerOffline = headerPartPtr()->isUnavailable(model);\n    bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n    if (headerOffline && bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached message data not available\"));\n    } else if (headerOffline) {\n        emit failed(tr(\"Offline mode: uncached header data not available\"));\n    } else if (bodyOffline) {\n        emit failed(tr(\"Offline mode: uncached body data not available\"));\n    }\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"FullMessageCombiner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  oid FullMessageCombiner::slotDataChanged(const QModelIndex &left, const QModelIndex &right)\n  {\n      Q_UNUSED(left);\n      Q_UNUSED(right);\n  \n      if (headerPartPtr()->fetched() && bodyPartPtr()->fetched()) {\n         emit completed();\n         // Disconnect this slot from its connected signal to prevent emitting completed() many times\n         // when dataChanged() is emitted and the parts are already fetched.\n         disconnect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n      }\n  \n      Imap::Mailbox::Model *model = const_cast<Imap::Mailbox::Model*>(m_model);\n      bool headerOffline = headerPartPtr()->isUnavailable(model);\n      bool bodyOffline = bodyPartPtr()->isUnavailable(model);\n      if (headerOffline && bodyOffline) {\n          emit failed(tr(\"Offline mode: uncached message data not available\"));\n      } else if (headerOffline) {\n          emit failed(tr(\"Offline mode: uncached header data not available\"));\n      } else if (bodyOffline) {\n          emit failed(tr(\"Offline mode: uncached body data not available\"));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_bodyPartIndex.isValid())"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bodyPartIndex.isValid",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odyPart->toIndex",
          "args": [
            "onst_cast<Mailbox::Model *>(m_model))"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Mailbox::Model *>",
          "args": [
            "_model)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_headerPartIndex.isValid())"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPart->toIndex",
          "args": [
            "onst_cast<Mailbox::Model *>(m_model))"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Mailbox::Model *>",
          "args": [
            "_model)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odyPart)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "eaderPart)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odyPartPtr(",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderPartPtr(",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_model)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Mailbox::Model::realTreeItem(",
          "args": [
            "essageIndex,",
            "m_model)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  ullMessageCombiner::FullMessageCombiner(const QModelIndex &messageIndex, QObject *parent) :\n      QObject(parent), m_model(0), m_messageIndex(messageIndex)\n  {\n      Imap::Mailbox::Model::realTreeItem(messageIndex, &m_model);\n      Q_ASSERT(m_model);\n      Imap::Mailbox::TreeItemPart *headerPart = headerPartPtr();\n      Imap::Mailbox::TreeItemPart *bodyPart = bodyPartPtr();\n  \n      Q_ASSERT(headerPart);\n      Q_ASSERT(bodyPart);\n  \n      m_headerPartIndex = headerPart->toIndex(const_cast<Mailbox::Model *>(m_model));\n      Q_ASSERT(m_headerPartIndex.isValid());\n  \n      m_bodyPartIndex = bodyPart->toIndex(const_cast<Mailbox::Model *>(m_model));\n      Q_ASSERT(m_bodyPartIndex.isValid());\n  \n      connect(m_model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), SLOT(slotDataChanged(QModelIndex,QModelIndex)));\n  }\n}"
  }
]