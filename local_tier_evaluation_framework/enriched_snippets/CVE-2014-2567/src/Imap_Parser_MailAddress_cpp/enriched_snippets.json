[
  {
    "function_name": "operator()(",
    "container": "ailAddressesEqualByDomainSuffix",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "327-333",
    "snippet": "ailAddressesEqualByDomainSuffix::result_type MailAddressesEqualByDomainSuffix::operator()(const MailAddress &a, const MailAddress &b) const\n{\n    // FIXME: fancy stuff like the IDN?\n    auto aHost = a.host.toLower();\n    auto bHost = b.host.toLower();\n    return aHost == bHost || aHost.endsWith(QLatin1Char('.') + bHost);\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Host.endsWith",
          "args": [
            "Latin1Char('.') + bHost)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            ".')"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".host.toLower",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".host.toLower",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddressesEqualByDomainSuffix {\n  ailAddressesEqualByDomainSuffix::result_type MailAddressesEqualByDomainSuffix::operator()(const MailAddress &a, const MailAddress &b) const\n  {\n      // FIXME: fancy stuff like the IDN?\n      auto aHost = a.host.toLower();\n      auto bHost = b.host.toLower();\n      return aHost == bHost || aHost.endsWith(QLatin1Char('.') + bHost);\n  }\n}"
  },
  {
    "function_name": "operator()(",
    "container": "ailAddressesEqualByDomain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "320-324",
    "snippet": "ailAddressesEqualByDomain::result_type MailAddressesEqualByDomain::operator()(const MailAddress &a, const MailAddress &b) const\n{\n    // FIXME: fancy stuff like the IDN?\n    return a.host.toLower() == b.host.toLower();\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ".host.toLower",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".host.toLower",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddressesEqualByDomain {\n  ailAddressesEqualByDomain::result_type MailAddressesEqualByDomain::operator()(const MailAddress &a, const MailAddress &b) const\n  {\n      // FIXME: fancy stuff like the IDN?\n      return a.host.toLower() == b.host.toLower();\n  }\n}"
  },
  {
    "function_name": "operator()(",
    "container": "ailAddressesEqualByMail",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "314-318",
    "snippet": "ailAddressesEqualByMail::result_type MailAddressesEqualByMail::operator()(const MailAddress &a, const MailAddress &b) const\n{\n    // FIXME: fancy stuff like the IDN?\n    return a.mailbox.toLower() == b.mailbox.toLower() && a.host.toLower() == b.host.toLower();\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ".host.toLower",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".host.toLower",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".mailbox.toLower",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".mailbox.toLower",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddressesEqualByMail {\n  ailAddressesEqualByMail::result_type MailAddressesEqualByMail::operator()(const MailAddress &a, const MailAddress &b) const\n  {\n      // FIXME: fancy stuff like the IDN?\n      return a.mailbox.toLower() == b.mailbox.toLower() && a.host.toLower() == b.host.toLower();\n  }\n}"
  },
  {
    "function_name": "fromUrl(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "275-296",
    "snippet": "ool MailAddress::fromUrl(MailAddress &into, const QUrl &url, const QString &expectedScheme)\n{\n    if (url.scheme().toLower() != expectedScheme.toLower())\n        return false;\n\n    QStringList list = url.path().split(QLatin1Char('@'));\n    if (list.size() != 2)\n        return false;\n\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    Imap::Message::MailAddress addr(url.queryItemValue(QLatin1String(\"X-Trojita-DisplayName\")), QString(),\n                                    list[0], list[1]);\n#else\n    QUrlQuery q(url);\n    Imap::Message::MailAddress addr(q.queryItemValue(QLatin1String(\"X-Trojita-DisplayName\")), QString(),\n                                    list[0], list[1]);\n#endif\n    if (!addr.hasUsefulDisplayName())\n        addr.name.clear();\n    into = addr;\n    return true;\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ddr.name.clear",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ddr.hasUsefulDisplayName",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".queryItemValue",
          "args": [
            "Latin1String(\"X-Trojita-DisplayName\"))"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "X-Trojita-DisplayName\")"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.queryItemValue",
          "args": [
            "Latin1String(\"X-Trojita-DisplayName\"))"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "X-Trojita-DisplayName\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.size",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [
            "Latin1Char('@'))"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "@')"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xpectedScheme.toLower",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ool MailAddress::fromUrl(MailAddress &into, const QUrl &url, const QString &expectedScheme)\n  {\n      if (url.scheme().toLower() != expectedScheme.toLower())\n          return false;\n  \n      QStringList list = url.path().split(QLatin1Char('@'));\n      if (list.size() != 2)\n          return false;\n  \n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      Imap::Message::MailAddress addr(url.queryItemValue(QLatin1String(\"X-Trojita-DisplayName\")), QString(),\n                                      list[0], list[1]);\n  #else\n      QUrlQuery q(url);\n      Imap::Message::MailAddress addr(q.queryItemValue(QLatin1String(\"X-Trojita-DisplayName\")), QString(),\n                                      list[0], list[1]);\n  #endif\n      if (!addr.hasUsefulDisplayName())\n          addr.name.clear();\n      into = addr;\n      return true;\n  }\n}"
  },
  {
    "function_name": "hasUsefulDisplayName(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "269-272",
    "snippet": "ool MailAddress::hasUsefulDisplayName() const\n{\n    return !name.isEmpty() && name.trimmed().toLower() != asSMTPMailbox().toLower();\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sSMTPMailbox",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "asSMTPMailbox(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "190-244",
          "snippet": "ByteArray MailAddress::asSMTPMailbox() const\n{\n    QByteArray result;\n\n    /* Check whether the local-part contains any characters\n       preventing it from being a dot-atom. */\n    if (dotAtomRx.exactMatch(mailbox)) {\n        /* Using .toLatin1() here even though we know it only contains\n           ASCII, because QString.toAscii() does not necessarily convert\n           to ASCII (despite the name). .toLatin1() always converts to\n           Latin-1. */\n        result = mailbox.toLatin1();\n    } else {\n        /* The other syntax allowed for local-parts is a double-quoted string.\n           Note that RFC2047 tokens aren't allowed there --- local-parts are\n           fundamentally bytestrings, apparently, whose interpretation is\n           up to the receiving system. If someone types non-ASCII characters\n           into the address field we'll generate non-conforming headers, but\n           it's the best we can do. */\n        result = Imap::quotedString(mailbox.toUtf8());\n    }\n    \n    result.append(\"@\");\n    \n    QByteArray domainpart;\n\n    if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n        /* IDN-encode the hostname part of the address */\n        domainpart = QUrl::toAce(host);\n        \n        /* TODO: QUrl::toAce() is documented to return an empty result if\n           the string isn't a valid hostname --- for example, if it's a\n           domain literal containing an IP address. In that case, we'll\n           need to encode it ourselves (making sure there are square\n           brackets, no forbidden characters, appropriate backslashes, and so on). */\n    }\n\n    if (domainpart.isEmpty()) {\n        /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n        \n        domainpart = host.toUtf8();\n        if (domainpart.startsWith('[')) {\n            domainpart.remove(0, 1);\n        }\n        if (domainpart.endsWith(']')) {\n            domainpart.remove(domainpart.size()-1, 1);\n        }\n        \n        result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n    } else {\n        result.append(domainpart);\n    }\n\n    return result;\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ByteArray MailAddress::asSMTPMailbox() const\n  {\n      QByteArray result;\n  \n      /* Check whether the local-part contains any characters\n         preventing it from being a dot-atom. */\n      if (dotAtomRx.exactMatch(mailbox)) {\n          /* Using .toLatin1() here even though we know it only contains\n             ASCII, because QString.toAscii() does not necessarily convert\n             to ASCII (despite the name). .toLatin1() always converts to\n             Latin-1. */\n          result = mailbox.toLatin1();\n      } else {\n          /* The other syntax allowed for local-parts is a double-quoted string.\n             Note that RFC2047 tokens aren't allowed there --- local-parts are\n             fundamentally bytestrings, apparently, whose interpretation is\n             up to the receiving system. If someone types non-ASCII characters\n             into the address field we'll generate non-conforming headers, but\n             it's the best we can do. */\n          result = Imap::quotedString(mailbox.toUtf8());\n      }\n      \n      result.append(\"@\");\n      \n      QByteArray domainpart;\n  \n      if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n          /* IDN-encode the hostname part of the address */\n          domainpart = QUrl::toAce(host);\n          \n          /* TODO: QUrl::toAce() is documented to return an empty result if\n             the string isn't a valid hostname --- for example, if it's a\n             domain literal containing an IP address. In that case, we'll\n             need to encode it ourselves (making sure there are square\n             brackets, no forbidden characters, appropriate backslashes, and so on). */\n      }\n  \n      if (domainpart.isEmpty()) {\n          /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n          \n          domainpart = host.toUtf8();\n          if (domainpart.startsWith('[')) {\n              domainpart.remove(0, 1);\n          }\n          if (domainpart.endsWith(']')) {\n              domainpart.remove(domainpart.size()-1, 1);\n          }\n          \n          result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n      } else {\n          result.append(domainpart);\n      }\n  \n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ame.trimmed",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.trimmed",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.isEmpty",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ool MailAddress::hasUsefulDisplayName() const\n  {\n      return !name.isEmpty() && name.trimmed().toLower() != asSMTPMailbox().toLower();\n  }\n}"
  },
  {
    "function_name": "asPrettyString(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "261-266",
    "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            ">')"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sSMTPMailbox(",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "asSMTPMailbox(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "190-244",
          "snippet": "ByteArray MailAddress::asSMTPMailbox() const\n{\n    QByteArray result;\n\n    /* Check whether the local-part contains any characters\n       preventing it from being a dot-atom. */\n    if (dotAtomRx.exactMatch(mailbox)) {\n        /* Using .toLatin1() here even though we know it only contains\n           ASCII, because QString.toAscii() does not necessarily convert\n           to ASCII (despite the name). .toLatin1() always converts to\n           Latin-1. */\n        result = mailbox.toLatin1();\n    } else {\n        /* The other syntax allowed for local-parts is a double-quoted string.\n           Note that RFC2047 tokens aren't allowed there --- local-parts are\n           fundamentally bytestrings, apparently, whose interpretation is\n           up to the receiving system. If someone types non-ASCII characters\n           into the address field we'll generate non-conforming headers, but\n           it's the best we can do. */\n        result = Imap::quotedString(mailbox.toUtf8());\n    }\n    \n    result.append(\"@\");\n    \n    QByteArray domainpart;\n\n    if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n        /* IDN-encode the hostname part of the address */\n        domainpart = QUrl::toAce(host);\n        \n        /* TODO: QUrl::toAce() is documented to return an empty result if\n           the string isn't a valid hostname --- for example, if it's a\n           domain literal containing an IP address. In that case, we'll\n           need to encode it ourselves (making sure there are square\n           brackets, no forbidden characters, appropriate backslashes, and so on). */\n    }\n\n    if (domainpart.isEmpty()) {\n        /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n        \n        domainpart = host.toUtf8();\n        if (domainpart.startsWith('[')) {\n            domainpart.remove(0, 1);\n        }\n        if (domainpart.endsWith(']')) {\n            domainpart.remove(domainpart.size()-1, 1);\n        }\n        \n        result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n    } else {\n        result.append(domainpart);\n    }\n\n    return result;\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ByteArray MailAddress::asSMTPMailbox() const\n  {\n      QByteArray result;\n  \n      /* Check whether the local-part contains any characters\n         preventing it from being a dot-atom. */\n      if (dotAtomRx.exactMatch(mailbox)) {\n          /* Using .toLatin1() here even though we know it only contains\n             ASCII, because QString.toAscii() does not necessarily convert\n             to ASCII (despite the name). .toLatin1() always converts to\n             Latin-1. */\n          result = mailbox.toLatin1();\n      } else {\n          /* The other syntax allowed for local-parts is a double-quoted string.\n             Note that RFC2047 tokens aren't allowed there --- local-parts are\n             fundamentally bytestrings, apparently, whose interpretation is\n             up to the receiving system. If someone types non-ASCII characters\n             into the address field we'll generate non-conforming headers, but\n             it's the best we can do. */\n          result = Imap::quotedString(mailbox.toUtf8());\n      }\n      \n      result.append(\"@\");\n      \n      QByteArray domainpart;\n  \n      if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n          /* IDN-encode the hostname part of the address */\n          domainpart = QUrl::toAce(host);\n          \n          /* TODO: QUrl::toAce() is documented to return an empty result if\n             the string isn't a valid hostname --- for example, if it's a\n             domain literal containing an IP address. In that case, we'll\n             need to encode it ourselves (making sure there are square\n             brackets, no forbidden characters, appropriate backslashes, and so on). */\n      }\n  \n      if (domainpart.isEmpty()) {\n          /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n          \n          domainpart = host.toUtf8();\n          if (domainpart.startsWith('[')) {\n              domainpart.remove(0, 1);\n          }\n          if (domainpart.endsWith(']')) {\n              domainpart.remove(domainpart.size()-1, 1);\n          }\n          \n          result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n      } else {\n          result.append(domainpart);\n      }\n  \n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "<')"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "')"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.isEmpty",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
  },
  {
    "function_name": "asMailHeader(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "246-258",
    "snippet": "ByteArray MailAddress::asMailHeader() const\n{\n    QByteArray result = Imap::encodeRFC2047Phrase(name);\n\n    if (!result.isEmpty())\n        result.append(\" \");\n    \n    result.append(\"<\");\n    result.append(asSMTPMailbox());\n    result.append(\">\");\n\n    return result;\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            ">\")"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            "sSMTPMailbox())"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sSMTPMailbox(",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "asSMTPMailbox(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "190-244",
          "snippet": "ByteArray MailAddress::asSMTPMailbox() const\n{\n    QByteArray result;\n\n    /* Check whether the local-part contains any characters\n       preventing it from being a dot-atom. */\n    if (dotAtomRx.exactMatch(mailbox)) {\n        /* Using .toLatin1() here even though we know it only contains\n           ASCII, because QString.toAscii() does not necessarily convert\n           to ASCII (despite the name). .toLatin1() always converts to\n           Latin-1. */\n        result = mailbox.toLatin1();\n    } else {\n        /* The other syntax allowed for local-parts is a double-quoted string.\n           Note that RFC2047 tokens aren't allowed there --- local-parts are\n           fundamentally bytestrings, apparently, whose interpretation is\n           up to the receiving system. If someone types non-ASCII characters\n           into the address field we'll generate non-conforming headers, but\n           it's the best we can do. */\n        result = Imap::quotedString(mailbox.toUtf8());\n    }\n    \n    result.append(\"@\");\n    \n    QByteArray domainpart;\n\n    if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n        /* IDN-encode the hostname part of the address */\n        domainpart = QUrl::toAce(host);\n        \n        /* TODO: QUrl::toAce() is documented to return an empty result if\n           the string isn't a valid hostname --- for example, if it's a\n           domain literal containing an IP address. In that case, we'll\n           need to encode it ourselves (making sure there are square\n           brackets, no forbidden characters, appropriate backslashes, and so on). */\n    }\n\n    if (domainpart.isEmpty()) {\n        /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n        \n        domainpart = host.toUtf8();\n        if (domainpart.startsWith('[')) {\n            domainpart.remove(0, 1);\n        }\n        if (domainpart.endsWith(']')) {\n            domainpart.remove(domainpart.size()-1, 1);\n        }\n        \n        result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n    } else {\n        result.append(domainpart);\n    }\n\n    return result;\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ByteArray MailAddress::asSMTPMailbox() const\n  {\n      QByteArray result;\n  \n      /* Check whether the local-part contains any characters\n         preventing it from being a dot-atom. */\n      if (dotAtomRx.exactMatch(mailbox)) {\n          /* Using .toLatin1() here even though we know it only contains\n             ASCII, because QString.toAscii() does not necessarily convert\n             to ASCII (despite the name). .toLatin1() always converts to\n             Latin-1. */\n          result = mailbox.toLatin1();\n      } else {\n          /* The other syntax allowed for local-parts is a double-quoted string.\n             Note that RFC2047 tokens aren't allowed there --- local-parts are\n             fundamentally bytestrings, apparently, whose interpretation is\n             up to the receiving system. If someone types non-ASCII characters\n             into the address field we'll generate non-conforming headers, but\n             it's the best we can do. */\n          result = Imap::quotedString(mailbox.toUtf8());\n      }\n      \n      result.append(\"@\");\n      \n      QByteArray domainpart;\n  \n      if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n          /* IDN-encode the hostname part of the address */\n          domainpart = QUrl::toAce(host);\n          \n          /* TODO: QUrl::toAce() is documented to return an empty result if\n             the string isn't a valid hostname --- for example, if it's a\n             domain literal containing an IP address. In that case, we'll\n             need to encode it ourselves (making sure there are square\n             brackets, no forbidden characters, appropriate backslashes, and so on). */\n      }\n  \n      if (domainpart.isEmpty()) {\n          /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n          \n          domainpart = host.toUtf8();\n          if (domainpart.startsWith('[')) {\n              domainpart.remove(0, 1);\n          }\n          if (domainpart.endsWith(']')) {\n              domainpart.remove(domainpart.size()-1, 1);\n          }\n          \n          result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n      } else {\n          result.append(domainpart);\n      }\n  \n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            "<\")"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            "\")"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esult.isEmpty",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::encodeRFC2047Phrase(",
          "args": [
            "ame)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ByteArray MailAddress::asMailHeader() const\n  {\n      QByteArray result = Imap::encodeRFC2047Phrase(name);\n  \n      if (!result.isEmpty())\n          result.append(\" \");\n      \n      result.append(\"<\");\n      result.append(asSMTPMailbox());\n      result.append(\">\");\n  \n      return result;\n  }\n}"
  },
  {
    "function_name": "asSMTPMailbox(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "190-244",
    "snippet": "ByteArray MailAddress::asSMTPMailbox() const\n{\n    QByteArray result;\n\n    /* Check whether the local-part contains any characters\n       preventing it from being a dot-atom. */\n    if (dotAtomRx.exactMatch(mailbox)) {\n        /* Using .toLatin1() here even though we know it only contains\n           ASCII, because QString.toAscii() does not necessarily convert\n           to ASCII (despite the name). .toLatin1() always converts to\n           Latin-1. */\n        result = mailbox.toLatin1();\n    } else {\n        /* The other syntax allowed for local-parts is a double-quoted string.\n           Note that RFC2047 tokens aren't allowed there --- local-parts are\n           fundamentally bytestrings, apparently, whose interpretation is\n           up to the receiving system. If someone types non-ASCII characters\n           into the address field we'll generate non-conforming headers, but\n           it's the best we can do. */\n        result = Imap::quotedString(mailbox.toUtf8());\n    }\n    \n    result.append(\"@\");\n    \n    QByteArray domainpart;\n\n    if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n        /* IDN-encode the hostname part of the address */\n        domainpart = QUrl::toAce(host);\n        \n        /* TODO: QUrl::toAce() is documented to return an empty result if\n           the string isn't a valid hostname --- for example, if it's a\n           domain literal containing an IP address. In that case, we'll\n           need to encode it ourselves (making sure there are square\n           brackets, no forbidden characters, appropriate backslashes, and so on). */\n    }\n\n    if (domainpart.isEmpty()) {\n        /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n        \n        domainpart = host.toUtf8();\n        if (domainpart.startsWith('[')) {\n            domainpart.remove(0, 1);\n        }\n        if (domainpart.endsWith(']')) {\n            domainpart.remove(domainpart.size()-1, 1);\n        }\n        \n        result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n    } else {\n        result.append(domainpart);\n    }\n\n    return result;\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            "omainpart)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            "map::quotedString(domainpart, Imap::SquareBrackets))"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::quotedString(",
          "args": [
            "omainpart,",
            "map::SquareBrackets)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omainpart.remove",
          "args": [
            "omainpart.size()-1,",
            ")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omainpart.size",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omainpart.endsWith",
          "args": [
            "]')"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omainpart.remove",
          "args": [
            ",",
            ")"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omainpart.startsWith",
          "args": [
            "[')"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost.toUtf8",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omainpart.isEmpty",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Url::toAce(",
          "args": [
            "ost)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost.endsWith",
          "args": [
            "Latin1Char(']'))"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "]')"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost.startsWith",
          "args": [
            "Latin1Char('['))"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "[')"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esult.append",
          "args": [
            "@\")"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::quotedString(",
          "args": [
            "ailbox.toUtf8())"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox.toUtf8",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox.toLatin1",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "otAtomRx.exactMatch",
          "args": [
            "ailbox)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ByteArray MailAddress::asSMTPMailbox() const\n  {\n      QByteArray result;\n  \n      /* Check whether the local-part contains any characters\n         preventing it from being a dot-atom. */\n      if (dotAtomRx.exactMatch(mailbox)) {\n          /* Using .toLatin1() here even though we know it only contains\n             ASCII, because QString.toAscii() does not necessarily convert\n             to ASCII (despite the name). .toLatin1() always converts to\n             Latin-1. */\n          result = mailbox.toLatin1();\n      } else {\n          /* The other syntax allowed for local-parts is a double-quoted string.\n             Note that RFC2047 tokens aren't allowed there --- local-parts are\n             fundamentally bytestrings, apparently, whose interpretation is\n             up to the receiving system. If someone types non-ASCII characters\n             into the address field we'll generate non-conforming headers, but\n             it's the best we can do. */\n          result = Imap::quotedString(mailbox.toUtf8());\n      }\n      \n      result.append(\"@\");\n      \n      QByteArray domainpart;\n  \n      if (!(host.startsWith(QLatin1Char('[')) || host.endsWith(QLatin1Char(']')))) {\n          /* IDN-encode the hostname part of the address */\n          domainpart = QUrl::toAce(host);\n          \n          /* TODO: QUrl::toAce() is documented to return an empty result if\n             the string isn't a valid hostname --- for example, if it's a\n             domain literal containing an IP address. In that case, we'll\n             need to encode it ourselves (making sure there are square\n             brackets, no forbidden characters, appropriate backslashes, and so on). */\n      }\n  \n      if (domainpart.isEmpty()) {\n          /* Either the domainpart looks like a domain-literal, or toAce() failed. */\n          \n          domainpart = host.toUtf8();\n          if (domainpart.startsWith('[')) {\n              domainpart.remove(0, 1);\n          }\n          if (domainpart.endsWith(']')) {\n              domainpart.remove(domainpart.size()-1, 1);\n          }\n          \n          result.append(Imap::quotedString(domainpart, Imap::SquareBrackets));\n      } else {\n          result.append(domainpart);\n      }\n  \n      return result;\n  }\n}"
  },
  {
    "function_name": "prettyList(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "174-185",
    "snippet": "String MailAddress::prettyList(const QVariantList &list, FormattingMode mode)\n{\n    QStringList buf;\n    for (QVariantList::const_iterator it = list.begin(); it != list.end(); ++it) {\n        Q_ASSERT(it->type() == QVariant::StringList);\n        QStringList item = it->toStringList();\n        Q_ASSERT(item.size() == 4);\n        MailAddress a(item[0], item[1], item[2], item[3]);\n        buf << a.prettyName(mode);\n    }\n    return buf.join(QLatin1String(\", \"));\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uf.join",
          "args": [
            "Latin1String(\", \"))"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ", \")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".prettyName",
          "args": [
            "ode)"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "prettyName(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "133-164",
          "snippet": "String MailAddress::prettyName(FormattingMode mode) const\n{\n    bool hasNiceName = !name.isEmpty();\n\n    if (!hasNiceName && mode == FORMAT_JUST_NAME)\n        mode = FORMAT_READABLE;\n\n    if (mode == FORMAT_JUST_NAME) {\n        return name;\n    } else {\n        QString address = mailbox + QLatin1Char('@') + host;\n        QString niceName;\n        if (hasNiceName) {\n            niceName = name;\n        } else {\n            niceName = address;\n        }\n        if (mode == FORMAT_READABLE) {\n            if (hasNiceName) {\n                return name + QLatin1String(\" <\") + address + QLatin1Char('>');\n            } else {\n                return address;\n            }\n        } else {\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n            return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(Qt::escape(asUrl().toString()), Qt::escape(niceName));\n#else\n            return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(asUrl().toString().toHtmlEscaped(), niceName.toHtmlEscaped());\n#endif\n        }\n    }\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::prettyName(FormattingMode mode) const\n  {\n      bool hasNiceName = !name.isEmpty();\n  \n      if (!hasNiceName && mode == FORMAT_JUST_NAME)\n          mode = FORMAT_READABLE;\n  \n      if (mode == FORMAT_JUST_NAME) {\n          return name;\n      } else {\n          QString address = mailbox + QLatin1Char('@') + host;\n          QString niceName;\n          if (hasNiceName) {\n              niceName = name;\n          } else {\n              niceName = address;\n          }\n          if (mode == FORMAT_READABLE) {\n              if (hasNiceName) {\n                  return name + QLatin1String(\" <\") + address + QLatin1Char('>');\n              } else {\n                  return address;\n              }\n          } else {\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n              return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(Qt::escape(asUrl().toString()), Qt::escape(niceName));\n  #else\n              return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(asUrl().toString().toHtmlEscaped(), niceName.toHtmlEscaped());\n  #endif\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tem.size() == 4)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem.size",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->toStringList",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t->type() == QVariant::StringList)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->type",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "328-331",
          "snippet": "QMimeMagicRule::Type QMimeMagicRule::type() const\n{\n    return d->type;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type() const\n  {\n      return d->type;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist.end",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.begin",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::prettyList(const QVariantList &list, FormattingMode mode)\n  {\n      QStringList buf;\n      for (QVariantList::const_iterator it = list.begin(); it != list.end(); ++it) {\n          Q_ASSERT(it->type() == QVariant::StringList);\n          QStringList item = it->toStringList();\n          Q_ASSERT(item.size() == 4);\n          MailAddress a(item[0], item[1], item[2], item[3]);\n          buf << a.prettyName(mode);\n      }\n      return buf.join(QLatin1String(\", \"));\n  }\n}"
  },
  {
    "function_name": "prettyList(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "166-172",
    "snippet": "String MailAddress::prettyList(const QList<MailAddress> &list, FormattingMode mode)\n{\n    QStringList buf;\n    for (QList<MailAddress>::const_iterator it = list.begin(); it != list.end(); ++it)\n        buf << it->prettyName(mode);\n    return buf.join(QLatin1String(\", \"));\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uf.join",
          "args": [
            "Latin1String(\", \"))"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ", \")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->prettyName",
          "args": [
            "ode)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.end",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.begin",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::prettyList(const QList<MailAddress> &list, FormattingMode mode)\n  {\n      QStringList buf;\n      for (QList<MailAddress>::const_iterator it = list.begin(); it != list.end(); ++it)\n          buf << it->prettyName(mode);\n      return buf.join(QLatin1String(\", \"));\n  }\n}"
  },
  {
    "function_name": "prettyName(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "133-164",
    "snippet": "String MailAddress::prettyName(FormattingMode mode) const\n{\n    bool hasNiceName = !name.isEmpty();\n\n    if (!hasNiceName && mode == FORMAT_JUST_NAME)\n        mode = FORMAT_READABLE;\n\n    if (mode == FORMAT_JUST_NAME) {\n        return name;\n    } else {\n        QString address = mailbox + QLatin1Char('@') + host;\n        QString niceName;\n        if (hasNiceName) {\n            niceName = name;\n        } else {\n            niceName = address;\n        }\n        if (mode == FORMAT_READABLE) {\n            if (hasNiceName) {\n                return name + QLatin1String(\" <\") + address + QLatin1Char('>');\n            } else {\n                return address;\n            }\n        } else {\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n            return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(Qt::escape(asUrl().toString()), Qt::escape(niceName));\n#else\n            return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(asUrl().toString().toHtmlEscaped(), niceName.toHtmlEscaped());\n#endif\n        }\n    }\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "sUrl().toString().toHtmlEscaped(),",
            "iceName.toHtmlEscaped())"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iceName.toHtmlEscaped",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sUrl",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "asUrl(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "116-131",
          "snippet": "Url MailAddress::asUrl() const\n{\n    QUrl url;\n    url.setScheme(QLatin1String(\"mailto\"));\n    url.setPath(QString::fromUtf8(\"%1@%2\").arg(mailbox, host));\n    if (!name.isEmpty()) {\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n        url.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n#else\n        QUrlQuery q(url);\n        q.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n        url.setQuery(q);\n#endif\n    }\n    return url;\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  Url MailAddress::asUrl() const\n  {\n      QUrl url;\n      url.setScheme(QLatin1String(\"mailto\"));\n      url.setPath(QString::fromUtf8(\"%1@%2\").arg(mailbox, host));\n      if (!name.isEmpty()) {\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n          url.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n  #else\n          QUrlQuery q(url);\n          q.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n          url.setQuery(q);\n  #endif\n      }\n      return url;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "<a href=\\\"%1\\\">%2</a>\")"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "t::escape(asUrl().toString()),",
            "t::escape(niceName))"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t::escape(",
          "args": [
            "iceName)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t::escape(",
          "args": [
            "sUrl().toString())"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "<a href=\\\"%1\\\">%2</a>\")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            ">')"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "<\")"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "@')"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.isEmpty",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::prettyName(FormattingMode mode) const\n  {\n      bool hasNiceName = !name.isEmpty();\n  \n      if (!hasNiceName && mode == FORMAT_JUST_NAME)\n          mode = FORMAT_READABLE;\n  \n      if (mode == FORMAT_JUST_NAME) {\n          return name;\n      } else {\n          QString address = mailbox + QLatin1Char('@') + host;\n          QString niceName;\n          if (hasNiceName) {\n              niceName = name;\n          } else {\n              niceName = address;\n          }\n          if (mode == FORMAT_READABLE) {\n              if (hasNiceName) {\n                  return name + QLatin1String(\" <\") + address + QLatin1Char('>');\n              } else {\n                  return address;\n              }\n          } else {\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n              return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(Qt::escape(asUrl().toString()), Qt::escape(niceName));\n  #else\n              return QString::fromUtf8(\"<a href=\\\"%1\\\">%2</a>\").arg(asUrl().toString().toHtmlEscaped(), niceName.toHtmlEscaped());\n  #endif\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "asUrl(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "116-131",
    "snippet": "Url MailAddress::asUrl() const\n{\n    QUrl url;\n    url.setScheme(QLatin1String(\"mailto\"));\n    url.setPath(QString::fromUtf8(\"%1@%2\").arg(mailbox, host));\n    if (!name.isEmpty()) {\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n        url.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n#else\n        QUrlQuery q(url);\n        q.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n        url.setQuery(q);\n#endif\n    }\n    return url;\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rl.setQuery",
          "args": [
            ")"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".addQueryItem",
          "args": [
            "Latin1String(\"X-Trojita-DisplayName\"),",
            "ame)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "X-Trojita-DisplayName\")"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.addQueryItem",
          "args": [
            "Latin1String(\"X-Trojita-DisplayName\"),",
            "ame)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "X-Trojita-DisplayName\")"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.isEmpty",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.setPath",
          "args": [
            "String::fromUtf8(\"%1@%2\").arg(mailbox, host))"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "ailbox,",
            "ost)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "%1@%2\")"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.setScheme",
          "args": [
            "Latin1String(\"mailto\"))"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mailto\")"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  Url MailAddress::asUrl() const\n  {\n      QUrl url;\n      url.setScheme(QLatin1String(\"mailto\"));\n      url.setPath(QString::fromUtf8(\"%1@%2\").arg(mailbox, host));\n      if (!name.isEmpty()) {\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n          url.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n  #else\n          QUrlQuery q(url);\n          q.addQueryItem(QLatin1String(\"X-Trojita-DisplayName\"), name);\n          url.setQuery(q);\n  #endif\n      }\n      return url;\n  }\n}"
  },
  {
    "function_name": "MailAddress(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "95-114",
    "snippet": "ailAddress::MailAddress(const QVariantList &input, const QByteArray &line, const int start)\n{\n    // FIXME: all offsets are wrong here\n    if (input.size() != 4)\n        throw ParseError(\"MailAddress: not four items\", line, start);\n\n    if (input[0].type() != QVariant::ByteArray)\n        throw UnexpectedHere(\"MailAddress: item#1 not a QByteArray\", line, start);\n    if (input[1].type() != QVariant::ByteArray)\n        throw UnexpectedHere(\"MailAddress: item#2 not a QByteArray\", line, start);\n    if (input[2].type() != QVariant::ByteArray)\n        throw UnexpectedHere(\"MailAddress: item#3 not a QByteArray\", line, start);\n    if (input[3].type() != QVariant::ByteArray)\n        throw UnexpectedHere(\"MailAddress: item#4 not a QByteArray\", line, start);\n\n    name = Imap::decodeRFC2047String(input[0].toByteArray());\n    adl = Imap::decodeRFC2047String(input[1].toByteArray());\n    mailbox = Imap::decodeRFC2047String(input[2].toByteArray());\n    host = Imap::decodeRFC2047String(input[3].toByteArray());\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map::decodeRFC2047String(",
          "args": [
            "nput[3].toByteArray())"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput[3].toByteArray",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::decodeRFC2047String(",
          "args": [
            "nput[2].toByteArray())"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput[2].toByteArray",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::decodeRFC2047String(",
          "args": [
            "nput[1].toByteArray())"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput[1].toByteArray",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::decodeRFC2047String(",
          "args": [
            "nput[0].toByteArray())"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput[0].toByteArray",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "MailAddress: item#4 not a QByteArray\",",
            "ine,",
            "tart)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput[3].type",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "328-331",
          "snippet": "QMimeMagicRule::Type QMimeMagicRule::type() const\n{\n    return d->type;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type() const\n  {\n      return d->type;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "MailAddress: item#3 not a QByteArray\",",
            "ine,",
            "tart)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "MailAddress: item#2 not a QByteArray\",",
            "ine,",
            "tart)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "MailAddress: item#1 not a QByteArray\",",
            "ine,",
            "tart)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "MailAddress: not four items\",",
            "ine,",
            "tart)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nput.size",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ailAddress::MailAddress(const QVariantList &input, const QByteArray &line, const int start)\n  {\n      // FIXME: all offsets are wrong here\n      if (input.size() != 4)\n          throw ParseError(\"MailAddress: not four items\", line, start);\n  \n      if (input[0].type() != QVariant::ByteArray)\n          throw UnexpectedHere(\"MailAddress: item#1 not a QByteArray\", line, start);\n      if (input[1].type() != QVariant::ByteArray)\n          throw UnexpectedHere(\"MailAddress: item#2 not a QByteArray\", line, start);\n      if (input[2].type() != QVariant::ByteArray)\n          throw UnexpectedHere(\"MailAddress: item#3 not a QByteArray\", line, start);\n      if (input[3].type() != QVariant::ByteArray)\n          throw UnexpectedHere(\"MailAddress: item#4 not a QByteArray\", line, start);\n  \n      name = Imap::decodeRFC2047String(input[0].toByteArray());\n      adl = Imap::decodeRFC2047String(input[1].toByteArray());\n      mailbox = Imap::decodeRFC2047String(input[2].toByteArray());\n      host = Imap::decodeRFC2047String(input[3].toByteArray());\n  }\n}"
  },
  {
    "function_name": "parseOneAddress(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "64-93",
    "snippet": "ool MailAddress::parseOneAddress(Imap::Message::MailAddress &into, const QString &address, int &startOffset)\n{\n    int offset;\n    static QRegExp commaRx(QLatin1String(\"^\\\\s*(?:,\\\\s*)*\"));\n\n    offset = mailishRx.indexIn(address, startOffset);\n    if (offset < 0) {\n        /* Try stripping a leading comma? */\n        offset = commaRx.indexIn(address, startOffset, QRegExp::CaretAtOffset);\n        if (offset < startOffset)\n            return false;\n        offset += commaRx.matchedLength();\n        startOffset = offset;\n        offset = mailishRx.indexIn(address, offset);\n        if (offset < 0)\n            return false;\n    }\n\n    QString before = address.mid(startOffset, offset - startOffset);\n    into = MailAddress(before.simplified(), QString(), mailishRx.cap(1), mailishRx.cap(2));\n\n    offset += mailishRx.matchedLength();\n\n    int comma = commaRx.indexIn(address, offset, QRegExp::CaretAtOffset);\n    if (comma >= offset)\n        offset = comma + commaRx.matchedLength();\n\n    startOffset = offset;\n    return true;\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ommaRx.matchedLength",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommaRx.indexIn",
          "args": [
            "ddress,",
            "ffset,",
            "RegExp::CaretAtOffset)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailishRx.matchedLength",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailAddress(",
          "args": [
            "efore.simplified(),",
            "String(),",
            "ailishRx.cap(1),",
            "ailishRx.cap(2))"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ailAddress(",
          "container": "ailAddress ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.h",
          "lines": "63-65",
          "snippet": "ailAddress(const QString &_name, const QString &_adl,\n                const QString &_mailbox, const QString &_host):\n        name(_name), adl(_adl), mailbox(_mailbox), host(_host) {}",
          "includes": [
            "include <QVariantList>",
            "include <QString>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVariantList>\ninclude <QString>\n#\n\nailAddress  {\n  ailAddress(const QString &_name, const QString &_adl,\n                  const QString &_mailbox, const QString &_host):\n          name(_name), adl(_adl), mailbox(_mailbox), host(_host) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailishRx.cap",
          "args": [
            ")"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailishRx.cap",
          "args": [
            ")"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "efore.simplified",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddress.mid",
          "args": [
            "tartOffset,",
            "ffset - startOffset)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailishRx.indexIn",
          "args": [
            "ddress,",
            "ffset)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommaRx.matchedLength",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommaRx.indexIn",
          "args": [
            "ddress,",
            "tartOffset,",
            "RegExp::CaretAtOffset)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailishRx.indexIn",
          "args": [
            "ddress,",
            "tartOffset)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "^\\\\s*(?:,\\\\s*)*\")"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ool MailAddress::parseOneAddress(Imap::Message::MailAddress &into, const QString &address, int &startOffset)\n  {\n      int offset;\n      static QRegExp commaRx(QLatin1String(\"^\\\\s*(?:,\\\\s*)*\"));\n  \n      offset = mailishRx.indexIn(address, startOffset);\n      if (offset < 0) {\n          /* Try stripping a leading comma? */\n          offset = commaRx.indexIn(address, startOffset, QRegExp::CaretAtOffset);\n          if (offset < startOffset)\n              return false;\n          offset += commaRx.matchedLength();\n          startOffset = offset;\n          offset = mailishRx.indexIn(address, offset);\n          if (offset < 0)\n              return false;\n      }\n  \n      QString before = address.mid(startOffset, offset - startOffset);\n      into = MailAddress(before.simplified(), QString(), mailishRx.cap(1), mailishRx.cap(2));\n  \n      offset += mailishRx.matchedLength();\n  \n      int comma = commaRx.indexIn(address, offset, QRegExp::CaretAtOffset);\n      if (comma >= offset)\n          offset = comma + commaRx.matchedLength();\n  \n      startOffset = offset;\n      return true;\n  }\n}"
  },
  {
    "function_name": "fromPrettyString(",
    "container": "ailAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
    "lines": "41-52",
    "snippet": "ool MailAddress::fromPrettyString(MailAddress &into, const QString &address)\n{\n    int offset = 0;\n\n    if (!parseOneAddress(into, address, offset))\n        return false;\n\n    if (offset < address.size())\n        return false;\n\n    return true;\n}",
    "includes": [
      "include \"../Parser/Rfc5322HeaderParser.h\"",
      "include \"../Encoders.h\"\n#",
      "include \"../Model/MailboxTree.h\"\n#",
      "include \"MailAddress.h\"\n#",
      "include <QTextCodec>\n#",
      "include <QUrlQuery>\n#",
      "include <QUrl>\n#",
      "include <QTextDocument>\n#",
      "include <typeinfo>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ddress.size",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseOneAddress(",
          "args": [
            "nto,",
            "ddress,",
            "ffset)"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "parseOneAddress(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "64-93",
          "snippet": "ool MailAddress::parseOneAddress(Imap::Message::MailAddress &into, const QString &address, int &startOffset)\n{\n    int offset;\n    static QRegExp commaRx(QLatin1String(\"^\\\\s*(?:,\\\\s*)*\"));\n\n    offset = mailishRx.indexIn(address, startOffset);\n    if (offset < 0) {\n        /* Try stripping a leading comma? */\n        offset = commaRx.indexIn(address, startOffset, QRegExp::CaretAtOffset);\n        if (offset < startOffset)\n            return false;\n        offset += commaRx.matchedLength();\n        startOffset = offset;\n        offset = mailishRx.indexIn(address, offset);\n        if (offset < 0)\n            return false;\n    }\n\n    QString before = address.mid(startOffset, offset - startOffset);\n    into = MailAddress(before.simplified(), QString(), mailishRx.cap(1), mailishRx.cap(2));\n\n    offset += mailishRx.matchedLength();\n\n    int comma = commaRx.indexIn(address, offset, QRegExp::CaretAtOffset);\n    if (comma >= offset)\n        offset = comma + commaRx.matchedLength();\n\n    startOffset = offset;\n    return true;\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ool MailAddress::parseOneAddress(Imap::Message::MailAddress &into, const QString &address, int &startOffset)\n  {\n      int offset;\n      static QRegExp commaRx(QLatin1String(\"^\\\\s*(?:,\\\\s*)*\"));\n  \n      offset = mailishRx.indexIn(address, startOffset);\n      if (offset < 0) {\n          /* Try stripping a leading comma? */\n          offset = commaRx.indexIn(address, startOffset, QRegExp::CaretAtOffset);\n          if (offset < startOffset)\n              return false;\n          offset += commaRx.matchedLength();\n          startOffset = offset;\n          offset = mailishRx.indexIn(address, offset);\n          if (offset < 0)\n              return false;\n      }\n  \n      QString before = address.mid(startOffset, offset - startOffset);\n      into = MailAddress(before.simplified(), QString(), mailishRx.cap(1), mailishRx.cap(2));\n  \n      offset += mailishRx.matchedLength();\n  \n      int comma = commaRx.indexIn(address, offset, QRegExp::CaretAtOffset);\n      if (comma >= offset)\n          offset = comma + commaRx.matchedLength();\n  \n      startOffset = offset;\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  ool MailAddress::fromPrettyString(MailAddress &into, const QString &address)\n  {\n      int offset = 0;\n  \n      if (!parseOneAddress(into, address, offset))\n          return false;\n  \n      if (offset < address.size())\n          return false;\n  \n      return true;\n  }\n}"
  }
]