[
  {
    "function_name": "dropMimeData(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "134-815",
    "snippet": "ool MessageComposer::dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent)\n{\n    if (action == Qt::IgnoreAction)\n        return true;\n\n    if (column > 0)\n        return false;\n\n    if (!m_model)\n        return false;\n\n    Q_UNUSED(row);\n    Q_UNUSED(parent);\n    // FIXME: would be cool to support attachment reshuffling and to respect the desired drop position\n\n\n    if (data->hasFormat(xTrojitaAttachmentList)) {\n        QByteArray encodedData = data->data(xTrojitaAttachmentList);\n        QDataStream stream(&encodedData, QIODevice::ReadOnly);\n        return dropAttachmentList(stream);\n    } else if (data->hasFormat(xTrojitaMessageList)) {\n        QByteArray encodedData = data->data(xTrojitaMessageList);\n        QDataStream stream(&encodedData, QIODevice::ReadOnly);\n        return dropImapMessage(stream);\n    } else if (data->hasFormat(xTrojitaImapPart)) {\n        QByteArray encodedData = data->data(xTrojitaImapPart);\n        QDataStream stream(&encodedData, QIODevice::ReadOnly);\n        return dropImapPart(stream);\n    } else if (data->hasUrls()) {\n        bool attached = false;\n        QList<QUrl> urls = data->urls();\n        foreach (const QUrl &url, urls) {\n#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n            if (url.isLocalFile()) {\n#else\n            if (url.scheme() == QLatin1String(\"file\")) {\n#endif\n                // Careful here -- we definitely don't want the boolean evaluation shortcuts taking effect!\n                // At the same time, any file being recognized and attached is enough to \"satisfy\" the drop\n                attached = addFileAttachment(url.path()) || attached;\n            }\n        }\n        return attached;\n    } else {\n        return false;\n    }\n}\n\n/** @short Container wrapper which calls qDeleteAll on all items which remain in the list at the time of destruction */\ntemplate <typename T>\nclass WillDeleteAll {\npublic:\n    T d;\n    ~WillDeleteAll() {\n        qDeleteAll(d);\n    }\n};\n\n/** @short Handle a drag-and-drop of a list of attachments */\nbool MessageComposer::dropAttachmentList(QDataStream &stream)\n{\n    stream.setVersion(QDataStream::Qt_4_6);\n    if (stream.atEnd()) {\n        qDebug() << \"drag-and-drop: cannot decode data: end of stream\";\n        return false;\n    }\n    int num;\n    stream >> num;\n    if (stream.status() != QDataStream::Ok) {\n        qDebug() << \"drag-and-drop: stream failed:\" << stream.status();\n        return false;\n    }\n    if (num < 0) {\n        qDebug() << \"drag-and-drop: invalid number of items\";\n        return false;\n    }\n\n    // A crude RAII here; there are many places where the validation might fail even though we have already allocated memory\n    WillDeleteAll<QList<AttachmentItem*>> items;\n\n    for (int i = 0; i < num; ++i) {\n        int kind = -1;\n        stream >> kind;\n\n        switch (kind) {\n        case AttachmentItem::ATTACHMENT_IMAP_MESSAGE:\n        {\n            QString mailbox;\n            uint uidValidity;\n            QList<uint> uids;\n            stream >> mailbox >> uidValidity >> uids;\n            if (!validateDropImapMessage(stream, mailbox, uidValidity, uids))\n                return false;\n            if (uids.size() != 1) {\n                qDebug() << \"drag-and-drop: malformed data for a single message in a mixed list: too many UIDs\";\n                return false;\n            }\n            try {\n                items.d << new ImapMessageAttachmentItem(m_model, mailbox, uidValidity, uids.front());\n            } catch (Imap::UnknownMessageIndex &) {\n                return false;\n            }\n\n            break;\n        }\n\n        case AttachmentItem::ATTACHMENT_IMAP_PART:\n        {\n            QString mailbox;\n            uint uidValidity;\n            uint uid;\n            QString trojitaPath;\n            if (!validateDropImapPart(stream, mailbox, uidValidity, uid, trojitaPath))\n                return false;\n            try {\n                items.d << new ImapPartAttachmentItem(m_model, mailbox, uidValidity, uid, trojitaPath);\n            } catch (Imap::UnknownMessageIndex &) {\n                return false;\n            }\n\n            break;\n        }\n\n        case AttachmentItem::ATTACHMENT_FILE:\n        {\n            QString fileName;\n            stream >> fileName;\n            items.d << new FileAttachmentItem(fileName);\n            break;\n        }\n\n        default:\n            qDebug() << \"drag-and-drop: invalid kind of attachment\";\n            return false;\n        }\n    }\n\n    beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size() + items.d.size() - 1);\n    Q_FOREACH(AttachmentItem *attachment, items.d) {\n        if (m_shouldPreload)\n            attachment->preload();\n        m_attachments << attachment;\n    }\n    items.d.clear();\n    endInsertRows();\n\n    return true;\n}\n\n/** @short Check that the data representing a list of messages is correct */\nbool MessageComposer::validateDropImapMessage(QDataStream &stream, QString &mailbox, uint &uidValidity, QList<uint> &uids) const\n{\n    if (stream.status() != QDataStream::Ok) {\n        qDebug() << \"drag-and-drop: stream failed:\" << stream.status();\n        return false;\n    }\n\n    Imap::Mailbox::TreeItemMailbox *mboxPtr = m_model->findMailboxByName(mailbox);\n    if (!mboxPtr) {\n        qDebug() << \"drag-and-drop: mailbox not found\";\n        return false;\n    }\n\n    if (uids.size() < 1) {\n        qDebug() << \"drag-and-drop: no UIDs passed\";\n        return false;\n    }\n    if (!uidValidity) {\n        qDebug() << \"drag-and-drop: invalid UIDVALIDITY\";\n        return false;\n    }\n\n    return true;\n}\n\n/** @short Handle a drag-and-drop of a list of messages */\nbool MessageComposer::dropImapMessage(QDataStream &stream)\n{\n    stream.setVersion(QDataStream::Qt_4_6);\n    if (stream.atEnd()) {\n        qDebug() << \"drag-and-drop: cannot decode data: end of stream\";\n        return false;\n    }\n    QString mailbox;\n    uint uidValidity;\n    QList<uint> uids;\n    stream >> mailbox >> uidValidity >> uids;\n    if (!validateDropImapMessage(stream, mailbox, uidValidity, uids))\n        return false;\n    if (!stream.atEnd()) {\n        qDebug() << \"drag-and-drop: cannot decode data: too much data\";\n        return false;\n    }\n\n    WillDeleteAll<QList<AttachmentItem*>> items;\n    Q_FOREACH(const uint uid, uids) {\n        try {\n            items.d << new ImapMessageAttachmentItem(m_model, mailbox, uidValidity, uid);\n        } catch (Imap::UnknownMessageIndex &) {\n            return false;\n        }\n        items.d.last()->setContentDispositionMode(CDN_INLINE);\n    }\n    beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size() + uids.size() - 1);\n    Q_FOREACH(AttachmentItem *attachment, items.d) {\n        if (m_shouldPreload)\n            attachment->preload();\n        m_attachments << attachment;\n    }\n    items.d.clear();\n    endInsertRows();\n\n    return true;\n}\n\n/** @short Check that the data representing a single message part are correct */\nbool MessageComposer::validateDropImapPart(QDataStream &stream, QString &mailbox, uint &uidValidity, uint &uid, QString &trojitaPath) const\n{\n    stream >> mailbox >> uidValidity >> uid >> trojitaPath;\n    if (stream.status() != QDataStream::Ok) {\n        qDebug() << \"drag-and-drop: stream failed:\" << stream.status();\n        return false;\n    }\n    Imap::Mailbox::TreeItemMailbox *mboxPtr = m_model->findMailboxByName(mailbox);\n    if (!mboxPtr) {\n        qDebug() << \"drag-and-drop: mailbox not found\";\n        return false;\n    }\n\n    if (!uidValidity || !uid || trojitaPath.isEmpty()) {\n        qDebug() << \"drag-and-drop: invalid data\";\n        return false;\n    }\n    return true;\n}\n\n/** @short Handle a drag-adn-drop of a list of message parts */\nbool MessageComposer::dropImapPart(QDataStream &stream)\n{\n    stream.setVersion(QDataStream::Qt_4_6);\n    if (stream.atEnd()) {\n        qDebug() << \"drag-and-drop: cannot decode data: end of stream\";\n        return false;\n    }\n    QString mailbox;\n    uint uidValidity;\n    uint uid;\n    QString trojitaPath;\n    if (!validateDropImapPart(stream, mailbox, uidValidity, uid, trojitaPath))\n        return false;\n    if (!stream.atEnd()) {\n        qDebug() << \"drag-and-drop: cannot decode data: too much data\";\n        return false;\n    }\n\n    AttachmentItem *item;\n    try {\n        item = new ImapPartAttachmentItem(m_model, mailbox, uidValidity, uid, trojitaPath);\n    } catch (Imap::UnknownMessageIndex &) {\n        return false;\n    }\n\n    beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size());\n    m_attachments << item;\n    if (m_shouldPreload)\n        m_attachments.back()->preload();\n    endInsertRows();\n\n    return true;\n}\n\nQStringList MessageComposer::mimeTypes() const\n{\n    return QStringList() << xTrojitaMessageList << xTrojitaImapPart << xTrojitaAttachmentList << QLatin1String(\"text/uri-list\");\n}\n\nvoid MessageComposer::setFrom(const Imap::Message::MailAddress &from)\n{\n    m_from = from;\n}\n\nvoid MessageComposer::setRecipients(const QList<QPair<Composer::RecipientKind, Imap::Message::MailAddress> > &recipients)\n{\n    m_recipients = recipients;\n}\n\n/** @short Set the value for the In-Reply-To header as per RFC 5322, section 3.6.4\n\nThe expected values to be passed here do *not* contain the angle brackets. This is in accordance with\nthe very last sentence of that section which says that the angle brackets are not part of the msg-id.\n*/\nvoid MessageComposer::setInReplyTo(const QList<QByteArray> &inReplyTo)\n{\n    m_inReplyTo = inReplyTo;\n}\n\n/** @short Set the value for the References header as per RFC 5322, section 3.6.4\n\n@see setInReplyTo\n*/\nvoid MessageComposer::setReferences(const QList<QByteArray> &references)\n{\n    m_references = references;\n}\n\nvoid MessageComposer::setTimestamp(const QDateTime &timestamp)\n{\n    m_timestamp = timestamp;\n}\n\nvoid MessageComposer::setSubject(const QString &subject)\n{\n    m_subject = subject;\n}\n\nvoid MessageComposer::setOrganization(const QString &organization)\n{\n    m_organization = organization;\n}\n\nvoid MessageComposer::setText(const QString &text)\n{\n    m_text = text;\n}\n\nbool MessageComposer::isReadyForSerialization() const\n{\n    Q_FOREACH(const AttachmentItem *attachment, m_attachments) {\n        if (!attachment->isAvailableLocally())\n            return false;\n    }\n    return true;\n}\n\nQByteArray MessageComposer::generateMessageId(const Imap::Message::MailAddress &sender)\n{\n    if (sender.host.isEmpty()) {\n        // There's no usable domain, let's just bail out of here\n        return QByteArray();\n    }\n    return QUuid::createUuid()\n#if QT_VERSION >= 0x040800\n            .toByteArray()\n#else\n            .toString().toAscii()\n#endif\n            .replace(\"{\", \"\").replace(\"}\", \"\") + \"@\" + sender.host.toUtf8();\n}\n\n/** @short Generate a random enough MIME boundary */\nQByteArray MessageComposer::generateMimeBoundary()\n{\n    // Usage of \"=_\" is recommended by RFC2045 as it's guaranteed to never occur in a quoted-printable source\n    return QByteArray(\"trojita=_\") + QUuid::createUuid()\n#if QT_VERSION >= 0x040800\n            .toByteArray()\n#else\n            .toString().toAscii()\n#endif\n            .replace(\"{\", \"\").replace(\"}\", \"\");\n}\n\nQByteArray MessageComposer::encodeHeaderField(const QString &text)\n{\n    /* This encodes an \"unstructured\" header field */\n    return Imap::encodeRFC2047StringWithAsciiPrefix(text);\n}\n\nnamespace {\n\n/** @short Write a list of recipients into an output buffer */\nstatic void processListOfRecipientsIntoHeader(const QByteArray &prefix, const QList<QByteArray> &addresses, QByteArray &out)\n{\n    // Qt and STL are different, it looks like we cannot easily use something as simple as the ostream_iterator here :(\n    if (!addresses.isEmpty()) {\n        out.append(prefix);\n        for (int i = 0; i < addresses.size() - 1; ++i)\n            out.append(addresses[i]).append(\",\\r\\n \");\n        out.append(addresses.last()).append(\"\\r\\n\");\n    }\n}\n\n}\n\nvoid MessageComposer::writeCommonMessageBeginning(QIODevice *target, const QByteArray boundary) const\n{\n    // The From header\n    target->write(QByteArray(\"From: \").append(m_from.asMailHeader()).append(\"\\r\\n\"));\n\n    // All recipients\n    // Got to group the headers so that both of (To, Cc) are present at most once\n    QList<QByteArray> rcptTo, rcptCc;\n    for (auto it = m_recipients.begin(); it != m_recipients.end(); ++it) {\n        switch(it->first) {\n        case Composer::ADDRESS_TO:\n            rcptTo << it->second.asMailHeader();\n            break;\n        case Composer::ADDRESS_CC:\n            rcptCc << it->second.asMailHeader();\n            break;\n        case Composer::ADDRESS_BCC:\n            break;\n        case Composer::ADDRESS_FROM:\n        case Composer::ADDRESS_SENDER:\n        case Composer::ADDRESS_REPLY_TO:\n            // These should never ever be produced by Trojita for now\n            Q_ASSERT(false);\n            break;\n        }\n    }\n\n    QByteArray recipientHeaders;\n    processListOfRecipientsIntoHeader(\"To: \", rcptTo, recipientHeaders);\n    processListOfRecipientsIntoHeader(\"Cc: \", rcptCc, recipientHeaders);\n    target->write(recipientHeaders);\n\n    // Other message metadata\n    target->write(encodeHeaderField(QLatin1String(\"Subject: \") + m_subject).append(\"\\r\\n\").\n            append(\"Date: \").append(Imap::dateTimeToRfc2822(m_timestamp)).append(\"\\r\\n\").\n            append(\"User-Agent: \").append(\n                QString::fromUtf8(\"Trojita/%1; %2\")\n                .arg(Common::Application::version, Imap::Mailbox::systemPlatformVersion()).toUtf8()\n                ).append(\"\\r\\n\").\n            append(\"MIME-Version: 1.0\\r\\n\"));\n    QByteArray messageId = generateMessageId(m_from);\n    if (!messageId.isEmpty()) {\n        target->write(QByteArray(\"Message-ID: <\").append(messageId).append(\">\\r\\n\"));\n    }\n    writeHeaderWithMsgIds(target, QByteArray(\"In-Reply-To\"), m_inReplyTo);\n    writeHeaderWithMsgIds(target, QByteArray(\"References\"), m_references);\n    if (!m_organization.isEmpty()) {\n        target->write(encodeHeaderField(QLatin1String(\"Organization: \") + m_organization).append(\"\\r\\n\"));\n    }\n\n    // Headers depending on actual message body data\n    if (!m_attachments.isEmpty()) {\n        target->write(\"Content-Type: multipart/mixed;\\r\\n\\tboundary=\\\"\" + boundary + \"\\\"\\r\\n\"\n                      \"\\r\\nThis is a multipart/mixed message in MIME format.\\r\\n\\r\\n\"\n                      \"--\" + boundary + \"\\r\\n\");\n    }\n\n    target->write(\"Content-Type: text/plain; charset=utf-8; format=flowed\\r\\n\"\n                  \"Content-Transfer-Encoding: quoted-printable\\r\\n\"\n                  \"\\r\\n\");\n    target->write(Imap::quotedPrintableEncode(Imap::wrapFormatFlowed(m_text).toUtf8()));\n}\n\n/** @short Write a header consisting of a list of message-ids\n\nEmpty headers will not be produced, and the result is wrapped at an appropriate length.\n\nThe header name must not contain the colon, it is added automatically.\n*/\nvoid MessageComposer::writeHeaderWithMsgIds(QIODevice *target, const QByteArray &headerName,\n                                            const QList<QByteArray> &messageIds) const\n{\n    if (messageIds.isEmpty())\n        return;\n\n    target->write(headerName + \":\");\n    int charCount = headerName.length() + 1;\n    for (int i = 0; i < messageIds.size(); ++i) {\n        // Wrapping shall happen at 78 columns, three bytes are eaten by \"space < >\"\n        if (i != 0 && charCount != 0 && charCount + messageIds[i].length() > 78 - 3) {\n            // got to wrap the header to respect a reasonably small line size\n            charCount = 0;\n            target->write(\"\\r\\n\");\n        }\n        // and now just append one more item\n        target->write(\" <\" + messageIds[i] + \">\");\n        charCount += messageIds[i].length() + 3;\n    }\n    target->write(\"\\r\\n\");\n}\n\nbool MessageComposer::writeAttachmentHeader(QIODevice *target, QString *errorMessage, const AttachmentItem *attachment, const QByteArray &boundary) const\n{\n    if (!attachment->isAvailableLocally() && attachment->imapUrl().isEmpty()) {\n        *errorMessage = tr(\"Attachment %1 is not available\").arg(attachment->caption());\n        return false;\n    }\n    target->write(\"\\r\\n--\" + boundary + \"\\r\\n\"\n                  \"Content-Type: \" + attachment->mimeType() + \"\\r\\n\");\n    target->write(attachment->contentDispositionHeader());\n\n    switch (attachment->suggestedCTE()) {\n    case AttachmentItem::CTE_BASE64:\n        target->write(\"Content-Transfer-Encoding: base64\\r\\n\");\n        break;\n    case AttachmentItem::CTE_7BIT:\n        target->write(\"Content-Transfer-Encoding: 7bit\\r\\n\");\n        break;\n    case AttachmentItem::CTE_8BIT:\n        target->write(\"Content-Transfer-Encoding: 8bit\\r\\n\");\n        break;\n    case AttachmentItem::CTE_BINARY:\n        target->write(\"Content-Transfer-Encoding: binary\\r\\n\");\n        break;\n    }\n\n    target->write(\"\\r\\n\");\n    return true;\n}\n\nbool MessageComposer::writeAttachmentBody(QIODevice *target, QString *errorMessage, const AttachmentItem *attachment) const\n{\n    if (!attachment->isAvailableLocally()) {\n        *errorMessage = tr(\"Attachment %1 is not available\").arg(attachment->caption());\n        return false;\n    }\n    QSharedPointer<QIODevice> io = attachment->rawData();\n    if (!io) {\n        *errorMessage = tr(\"Attachment %1 disappeared\").arg(attachment->caption());\n        return false;\n    }\n    while (!io->atEnd()) {\n        switch (attachment->suggestedCTE()) {\n        case AttachmentItem::CTE_BASE64:\n            // Base64 maps 6bit chunks into a single byte. Output shall have no more than 76 characters per line\n            // (not counting the CRLF pair).\n            target->write(io->read(76*6/8).toBase64() + \"\\r\\n\");\n            break;\n        default:\n            target->write(io->readAll());\n        }\n    }\n    return true;\n}\n\nbool MessageComposer::asRawMessage(QIODevice *target, QString *errorMessage) const\n{\n    // We don't bother with checking that our boundary is not present in the individual parts. That's arguably wrong,\n    // but we don't have much choice if we ever plan to use CATENATE.  It also looks like this is exactly how other MUAs\n    // oeprate as well, so let's just join the universal dontcareism here.\n    QByteArray boundary(generateMimeBoundary());\n\n    writeCommonMessageBeginning(target, boundary);\n\n    if (!m_attachments.isEmpty()) {\n        Q_FOREACH(const AttachmentItem *attachment, m_attachments) {\n            if (!writeAttachmentHeader(target, errorMessage, attachment, boundary))\n                return false;\n            if (!writeAttachmentBody(target, errorMessage, attachment))\n                return false;\n        }\n        target->write(\"\\r\\n--\" + boundary + \"--\\r\\n\");\n    }\n    return true;\n}\n\nbool MessageComposer::asCatenateData(QList<Imap::Mailbox::CatenatePair> &target, QString *errorMessage) const\n{\n    using namespace Imap::Mailbox;\n    target.clear();\n    QByteArray boundary(generateMimeBoundary());\n    target.append(qMakePair(CATENATE_TEXT, QByteArray()));\n\n    // write the initial data\n    {\n        QBuffer io(&target.back().second);\n        io.open(QIODevice::ReadWrite);\n        writeCommonMessageBeginning(&io, boundary);\n    }\n\n    if (!m_attachments.isEmpty()) {\n        Q_FOREACH(const AttachmentItem *attachment, m_attachments) {\n            if (target.back().first != CATENATE_TEXT) {\n                target.append(qMakePair(CATENATE_TEXT, QByteArray()));\n            }\n            QBuffer io(&target.back().second);\n            io.open(QIODevice::Append);\n\n            if (!writeAttachmentHeader(&io, errorMessage, attachment, boundary))\n                return false;\n\n            QByteArray url = attachment->imapUrl();\n            if (url.isEmpty()) {\n                // Cannot use CATENATE here\n                if (!writeAttachmentBody(&io, errorMessage, attachment))\n                    return false;\n            } else {\n                target.append(qMakePair(CATENATE_URL, url));\n            }\n        }\n        if (target.back().first != CATENATE_TEXT) {\n            target.append(qMakePair(CATENATE_TEXT, QByteArray()));\n        }\n        QBuffer io(&target.back().second);\n        io.open(QIODevice::Append);\n        io.write(\"\\r\\n--\" + boundary + \"--\\r\\n\");\n    }\n    return true;\n}\n\nQDateTime MessageComposer::timestamp() const\n{\n    return m_timestamp;\n}\n\nQList<QByteArray> MessageComposer::inReplyTo() const\n{\n    return m_inReplyTo;\n}\n\nQList<QByteArray> MessageComposer::references() const\n{\n    return m_references;\n}\n\nQByteArray MessageComposer::rawFromAddress() const\n{\n    return m_from.asSMTPMailbox();\n}\n\nQList<QByteArray> MessageComposer::rawRecipientAddresses() const\n{\n    QList<QByteArray> res;\n\n    for (auto it = m_recipients.begin(); it != m_recipients.end(); ++it) {\n        res << it->second.asSMTPMailbox();\n    }\n\n    return res;\n}\n\nbool MessageComposer::addFileAttachment(const QString &path)\n{\n    beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size());\n    QScopedPointer<AttachmentItem> attachment(new FileAttachmentItem(path));\n    if (!attachment->isAvailableLocally())\n        return false;\n    if (m_shouldPreload)\n        attachment->preload();\n    m_attachments << attachment.take();\n    endInsertRows();\n    return true;\n}\n\nvoid MessageComposer::removeAttachment(const QModelIndex &index)\n{\n    if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n        return;\n\n    beginRemoveRows(QModelIndex(), index.row(), index.row());\n    delete m_attachments.takeAt(index.row());\n    endRemoveRows();\n}\n\nvoid MessageComposer::setAttachmentName(const QModelIndex &index, const QString &newName)\n{\n    if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n        return;\n\n    if (m_attachments[index.row()]->setPreferredFileName(newName))\n        emit dataChanged(index, index);\n}\n\nvoid MessageComposer::setAttachmentContentDisposition(const QModelIndex &index, const ContentDisposition disposition)\n{\n    if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n        return;\n\n    if (m_attachments[index.row()]->setContentDispositionMode(disposition))\n        emit dataChanged(index, index);\n}\n\nvoid MessageComposer::setPreloadEnabled(const bool preload)\n{\n    m_shouldPreload = preload;\n}\n\nvoid MessageComposer::setReplyingToMessage(const QModelIndex &index)\n{\n    m_replyingTo = index;\n}\n\nQModelIndex MessageComposer::replyingToMessage() const\n{\n    return m_replyingTo;\n}\n\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ataChanged(",
          "args": [
            "ndex,",
            "ndex)"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "handleDataChanged(c",
          "container": "ssageView",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/MessageView.cpp",
          "lines": "457-468",
          "snippet": "id MessageView::handleDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n{\n    Q_ASSERT(topLeft.row() == bottomRight.row() && topLeft.parent() == bottomRight.parent());\n    if (topLeft == message) {\n        if (viewer == emptyView && message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n            qDebug() << \"MessageView: message which was previously not loaded has just became available\";\n            setEmpty();\n            setMessage(topLeft);\n        }\n        tags->setTagList(message.data(Imap::Mailbox::RoleMessageFlags).toStringList());\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/MsgListModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Composer/SubjectMangling.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Window.h\"\n#",
            "include \"UserAgentWebPage.h\"\n#",
            "include \"TagListWidget.h\"\n#",
            "include \"Spinner.h\"\n#",
            "include \"SimplePartWidget.h\"\n#",
            "include \"PartWidgetFactory.h\"\n#",
            "include \"OverlayWidget.h\"\n#",
            "include \"ExternalElementsWidget.h\"\n#",
            "include \"EnvelopeView.h\"\n#",
            "include \"EmbeddedWebView.h\"\n#",
            "include \"ComposeWidget.h\"\n#",
            "include \"AbstractPartWidget.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include <QWebPage>",
            "include <QWebHitTestResult>\n#",
            "include <QWebHistory>\n#",
            "include <QWebFrame>\n#",
            "include <QVBoxLayout>\n#",
            "include <QUrl>\n#",
            "include <QTimer>\n#",
            "include <QSettings>\n#",
            "include <QProgressBar>\n#",
            "include <QMessageBox>\n#",
            "include <QMenu>\n#",
            "include <QKeyEvent>\n#",
            "include <QHeaderView>\n#",
            "include <QDesktopServices>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/MsgListModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Composer/SubjectMangling.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Window.h\"\n#\ninclude \"UserAgentWebPage.h\"\n#\ninclude \"TagListWidget.h\"\n#\ninclude \"Spinner.h\"\n#\ninclude \"SimplePartWidget.h\"\n#\ninclude \"PartWidgetFactory.h\"\n#\ninclude \"OverlayWidget.h\"\n#\ninclude \"ExternalElementsWidget.h\"\n#\ninclude \"EnvelopeView.h\"\n#\ninclude \"EmbeddedWebView.h\"\n#\ninclude \"ComposeWidget.h\"\n#\ninclude \"AbstractPartWidget.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude <QWebPage>\ninclude <QWebHitTestResult>\n#\ninclude <QWebHistory>\n#\ninclude <QWebFrame>\n#\ninclude <QVBoxLayout>\n#\ninclude <QUrl>\n#\ninclude <QTimer>\n#\ninclude <QSettings>\n#\ninclude <QProgressBar>\n#\ninclude <QMessageBox>\n#\ninclude <QMenu>\n#\ninclude <QKeyEvent>\n#\ninclude <QHeaderView>\n#\ninclude <QDesktopServices>\n#\ninclude <QDebug>\n#\n\nssageView {\n  id MessageView::handleDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n  {\n      Q_ASSERT(topLeft.row() == bottomRight.row() && topLeft.parent() == bottomRight.parent());\n      if (topLeft == message) {\n          if (viewer == emptyView && message.data(Imap::Mailbox::RoleIsFetched).toBool()) {\n              qDebug() << \"MessageView: message which was previously not loaded has just became available\";\n              setEmpty();\n              setMessage(topLeft);\n          }\n          tags->setTagList(message.data(Imap::Mailbox::RoleMessageFlags).toStringList());\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_attachments[index.row",
          "args": [
            "isposition)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_attachments[index.row",
          "args": [
            "ewName)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndRemoveRows(",
          "args": [],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.takeAt",
          "args": [
            "ndex.row())"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginRemoveRows(",
          "args": [
            "ModelIndex(),",
            "ndex.row(),",
            "ndex.row())"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment.take",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->preload",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->isAvailableLocally",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "ModelIndex(),",
            "_attachments.size(),",
            "_attachments.size())"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->second.asSMTPMailbox",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_recipients.end",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_recipients.begin",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_from.asSMTPMailbox",
          "args": [],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o.write",
          "args": [
            "\\r\\n--\" + boundary + \"--\\r\\n\")"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o.open",
          "args": [
            "IODevice::Append)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.back",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.append",
          "args": [
            "MakePair(CATENATE_TEXT, QByteArray()))"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ATENATE_TEXT,",
            "ByteArray())"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arget.back",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.append",
          "args": [
            "MakePair(CATENATE_URL, url))"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ATENATE_URL,",
            "rl)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteAttachmentBody(",
          "args": [
            "io,",
            "rrorMessage,",
            "ttachment)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.isEmpty",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->imapUrl",
          "args": [],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteAttachmentHeader(",
          "args": [
            "io,",
            "rrorMessage,",
            "ttachment,",
            "oundary)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o.open",
          "args": [
            "IODevice::Append)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.back",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.append",
          "args": [
            "MakePair(CATENATE_TEXT, QByteArray()))"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ATENATE_TEXT,",
            "ByteArray())"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.back",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.isEmpty",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteCommonMessageBeginning(",
          "args": [
            "io,",
            "oundary)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o.open",
          "args": [
            "IODevice::ReadWrite)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.back",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.append",
          "args": [
            "MakePair(CATENATE_TEXT, QByteArray()))"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakePair(",
          "args": [
            "ATENATE_TEXT,",
            "ByteArray())"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget.clear",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "\\r\\n--\" + boundary + \"--\\r\\n\")"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteAttachmentBody(",
          "args": [
            "arget,",
            "rrorMessage,",
            "ttachment)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteAttachmentHeader(",
          "args": [
            "arget,",
            "rrorMessage,",
            "ttachment,",
            "oundary)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.isEmpty",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteCommonMessageBeginning(",
          "args": [
            "arget,",
            "oundary)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "o->readAll())"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o->readAll",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "o->read(76*6/8).toBase64() + \"\\r\\n\")"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o->read",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o->read",
          "args": [
            "6*6/8)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->suggestedCTE",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o->atEnd",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ttachment->caption())"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "flags(",
          "container": "essageComposer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
          "lines": "96-105",
          "snippet": "t::ItemFlags MessageComposer::flags(const QModelIndex &index) const\n{\n    Qt::ItemFlags f = QAbstractListModel::flags(index);\n\n    if (index.isValid()) {\n        f |= Qt::ItemIsDragEnabled;\n    }\n    f |= Qt::ItemIsDropEnabled;\n    return f;\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Gui/IconLoader.h\"\n#",
            "include \"Composer/ComposerAttachments.h\"\n#",
            "include \"Common/Application.h\"\n#",
            "include <QUuid>\n#",
            "include <QUrl>\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QMimeData>\n#",
            "include <QBuffer>\n#",
            "include \"MessageComposer.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  t::ItemFlags MessageComposer::flags(const QModelIndex &index) const\n  {\n      Qt::ItemFlags f = QAbstractListModel::flags(index);\n  \n      if (index.isValid()) {\n          f |= Qt::ItemIsDragEnabled;\n      }\n      f |= Qt::ItemIsDropEnabled;\n      return f;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttachment->caption",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Attachment %1 disappeared\")"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "gotError(",
          "container": "ubmission",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/Submission.cpp",
          "lines": "297-303",
          "snippet": "oid Submission::gotError(const QString &error)\n{\n    if (m_model)\n        m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"Submission\"), QString::fromUtf8(\"gotError: %1\").arg(error));\n    changeConnectionState(STATE_FAILED);\n    emit failed(error);\n}",
          "includes": [
            "include \"MSA/SMTP.h\"",
            "include \"MSA/Sendmail.h\"\n#",
            "include \"Imap/Tasks/UidSubmitTask.h\"\n#",
            "include \"Imap/Tasks/GenUrlAuthTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"Composer/Submission.h\"\n#",
            "include <QSettings>\n#",
            "include <QBuffer>\n#",
            "include <QCoreApplication>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MSA/SMTP.h\"\ninclude \"MSA/Sendmail.h\"\n#\ninclude \"Imap/Tasks/UidSubmitTask.h\"\n#\ninclude \"Imap/Tasks/GenUrlAuthTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"Composer/Submission.h\"\n#\ninclude <QSettings>\n#\ninclude <QBuffer>\n#\ninclude <QCoreApplication>\n#\n\nubmission {\n  oid Submission::gotError(const QString &error)\n  {\n      if (m_model)\n          m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"Submission\"), QString::fromUtf8(\"gotError: %1\").arg(error));\n      changeConnectionState(STATE_FAILED);\n      emit failed(error);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttachment->rawData",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->caption",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->isAvailableLocally",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "\\r\\n\")"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "Content-Transfer-Encoding: binary\\r\\n\")"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "Content-Transfer-Encoding: 8bit\\r\\n\")"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "Content-Transfer-Encoding: 7bit\\r\\n\")"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "Content-Transfer-Encoding: base64\\r\\n\")"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->suggestedCTE",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "ttachment->contentDispositionHeader())"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->contentDispositionHeader",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "\\r\\n--\" + boundary + \"\\r\\n\"\n                  \"Content-Type: \" + attachment->mimeType() + \"\\r\\n\")"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->mimeType",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->caption",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->imapUrl",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->imapUrl",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->isAvailableLocally",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "\\r\\n\")"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageIds[i].length",
          "args": [],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "<\" + messageIds[i] + \">\")"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "\\r\\n\")"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageIds[i].length",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageIds.size",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaderName.length",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "eaderName + \":\")"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageIds.isEmpty",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "map::quotedPrintableEncode(Imap::wrapFormatFlowed(m_text).toUtf8()))"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::quotedPrintableEncode(",
          "args": [
            "map::wrapFormatFlowed(m_text).toUtf8())"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::wrapFormatFlowed",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::wrapFormatFlowed(",
          "args": [
            "_text)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "Content-Type: text/plain; charset=utf-8; format=flowed\\r\\n\"\n                  \"Content-Transfer-Encoding: quoted-printable\\r\\n\"\n                  \"\\r\\n\")"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "Content-Type: multipart/mixed;\\r\\n\\tboundary=\\\"\" + boundary + \"\\\"\\r\\n\"\n                      \"\\r\\nThis is a multipart/mixed message in MIME format.\\r\\n\\r\\n\"\n                      \"--\" + boundary + \"\\r\\n\")"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.isEmpty",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "ncodeHeaderField(QLatin1String(\"Organization: \") + m_organization).append(\"\\r\\n\"))"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "\\r\\n\")"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField(",
          "args": [
            "Latin1String(\"Organization: \") + m_organization)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Organization: \")"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_organization.isEmpty",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteHeaderWithMsgIds(",
          "args": [
            "arget,",
            "ByteArray(\"References\"),",
            "_references)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "References\")"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ontentDispositionToByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "47-58",
          "snippet": "ByteArray contentDispositionToByteArray(const ContentDisposition cdn)\n{\n    switch (cdn) {\n    case CDN_INLINE:\n        return \"inline\";\n    case CDN_ATTACHMENT:\n        return \"attachment\";\n    }\n    Q_ASSERT(false);\n    // failsafe from RFC 2183\n    return \"attachment\";\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nByteArray contentDispositionToByteArray(const ContentDisposition cdn)\n{\n    switch (cdn) {\n    case CDN_INLINE:\n        return \"inline\";\n    case CDN_ATTACHMENT:\n        return \"attachment\";\n    }\n    Q_ASSERT(false);\n    // failsafe from RFC 2183\n    return \"attachment\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "riteHeaderWithMsgIds(",
          "args": [
            "arget,",
            "ByteArray(\"In-Reply-To\"),",
            "_inReplyTo)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "ByteArray(\"Message-ID: <\").append(messageId).append(\">\\r\\n\"))"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageId.isEmpty",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enerateMessageId(",
          "args": [
            "_from)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "ncodeHeaderField(QLatin1String(\"Subject: \") + m_subject).append(\"\\r\\n\").\n            append(\"Date: \").append(Imap::dateTimeToRfc2822(m_timestamp)).append(\"\\r\\n\").\n            append(\"User-Agent: \").append(\n                QString::fromUtf8(\"Trojita/%1; %2\")\n                .arg(Common::Application::version, Imap::Mailbox::systemPlatformVersion()).toUtf8()\n                ).append(\"\\r\\n\").\n            append(\"MIME-Version: 1.0\\r\\n\"))"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "MIME-Version: 1.0\\r\\n\")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "\\r\\n\")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "String::fromUtf8(\"Trojita/%1; %2\")\n                .arg(Common::Application::version, Imap::Mailbox::systemPlatformVersion()).toUtf8()"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "ommon::Application::version,",
            "map::Mailbox::systemPlatformVersion())"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Mailbox::systemPlatformVersion(",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Trojita/%1; %2\")"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "User-Agent: \")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "\\r\\n\")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "map::dateTimeToRfc2822(m_timestamp))"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::dateTimeToRfc2822(",
          "args": [
            "_timestamp)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "Date: \")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField",
          "args": [
            "\\r\\n\")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeHeaderField(",
          "args": [
            "Latin1String(\"Subject: \") + m_subject)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Subject: \")"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "ecipientHeaders)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rocessListOfRecipientsIntoHeader(",
          "args": [
            "Cc: \",",
            "cptCc,",
            "ecipientHeaders)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rocessListOfRecipientsIntoHeader(",
          "args": [
            "To: \",",
            "cptTo,",
            "ecipientHeaders)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->second.asMailHeader",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->second.asMailHeader",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_recipients.end",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_recipients.begin",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arget->write",
          "args": [
            "ByteArray(\"From: \").append(m_from.asMailHeader()).append(\"\\r\\n\"))"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_from.asMailHeader",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "\\r\\n\")"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "ddresses.last())"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.last",
          "args": [],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            ",\\r\\n \")"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "ddresses[i])"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.size",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut.append",
          "args": [
            "refix)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddresses.isEmpty",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::encodeRFC2047StringWithAsciiPrefix(",
          "args": [
            "ext)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [
            "}\",",
            "\")"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [
            "{\",",
            "\")"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Uuid::createUuid(",
          "args": [],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ender.host.toUtf8",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [
            "}\",",
            "\")"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [
            "{\",",
            "\")"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x040800\n            .toByteArray",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Uuid::createUuid(",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ender.host.isEmpty",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->isAvailableLocally",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "text/uri-list\")"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.back",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.back",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "ModelIndex(),",
            "_attachments.size(),",
            "_attachments.size())"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.atEnd",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alidateDropImapPart(",
          "args": [
            "tream,",
            "ailbox,",
            "idValidity,",
            "id,",
            "rojitaPath)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.atEnd",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "DataStream::Qt_4_6)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rojitaPath.isEmpty",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->findMailboxByName",
          "args": [
            "ailbox)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.status",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "TrojitaQNAMDeclarativeWebView",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/QmlSupport/QNAMWebView/qdeclarativewebview.cpp",
          "lines": "309-312",
          "snippet": "TrojitaQNAMDeclarativeWebView::Status TrojitaQNAMDeclarativeWebView::status() const\n{\n    return d->status;\n}",
          "includes": [
            "#include \"qwebsettings.h\"",
            "#include \"qwebpage.h\"",
            "#include \"qwebframe.h\"",
            "#include \"qwebelement.h\"",
            "#include <QtGui/QPen>",
            "#include <QtGui/QMouseEvent>",
            "#include <QtGui/QKeyEvent>",
            "#include <QtGui/QGraphicsSceneMouseEvent>",
            "#include <QtGui/QApplication>",
            "#include <QtDeclarative/qdeclarative.h>",
            "#include <QtDeclarative/QDeclarativeEngine>",
            "#include <QtDeclarative/QDeclarativeContext>",
            "#include <QtCore/QFile>",
            "#include <QtCore/QEvent>",
            "#include <QtCore/QDebug>",
            "#include \"qdeclarativewebview_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "TrojitaQNAMDeclarativeWebView::Status status;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qwebsettings.h\"\n#include \"qwebpage.h\"\n#include \"qwebframe.h\"\n#include \"qwebelement.h\"\n#include <QtGui/QPen>\n#include <QtGui/QMouseEvent>\n#include <QtGui/QKeyEvent>\n#include <QtGui/QGraphicsSceneMouseEvent>\n#include <QtGui/QApplication>\n#include <QtDeclarative/qdeclarative.h>\n#include <QtDeclarative/QDeclarativeEngine>\n#include <QtDeclarative/QDeclarativeContext>\n#include <QtCore/QFile>\n#include <QtCore/QEvent>\n#include <QtCore/QDebug>\n#include \"qdeclarativewebview_p.h\"\n\nTrojitaQNAMDeclarativeWebView::Status status;\n\nTrojitaQNAMDeclarativeWebView {\n  TrojitaQNAMDeclarativeWebView::Status TrojitaQNAMDeclarativeWebView::status() const\n  {\n      return d->status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->preload",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_FOREACH(",
          "args": [
            "ttachmentItem *attachment,",
            "tems.d)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "_FOREACH(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/PartWidget.cpp",
          "lines": "209-216",
          "snippet": "_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"PartWidgetFactory.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"LoadablePartWidget.h\"\n#",
            "include \"EnvelopeView.h\"\n#",
            "include <QTabBar>",
            "include <QVBoxLayout>\n#",
            "include <QModelIndex>\n#",
            "include <QLabel>\n#",
            "include \"PartWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"PartWidgetFactory.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"LoadablePartWidget.h\"\n#\ninclude \"EnvelopeView.h\"\n#\ninclude <QTabBar>\ninclude <QVBoxLayout>\n#\ninclude <QModelIndex>\n#\ninclude <QLabel>\n#\ninclude \"PartWidget.h\"\n\n_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\"
        }
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "ModelIndex(),",
            "_attachments.size(),",
            "_attachments.size() + uids.size() - 1)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.size",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.d.last",
          "args": [
            "DN_INLINE)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.d.last",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.atEnd",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alidateDropImapMessage(",
          "args": [
            "tream,",
            "ailbox,",
            "idValidity,",
            "ids)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.atEnd",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "DataStream::Qt_4_6)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.size",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_model->findMailboxByName",
          "args": [
            "ailbox)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttachment->preload",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "ModelIndex(),",
            "_attachments.size(),",
            "_attachments.size() + items.d.size() - 1)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.d.size",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alidateDropImapPart(",
          "args": [
            "tream,",
            "ailbox,",
            "idValidity,",
            "id,",
            "rojitaPath)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.front",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.size",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alidateDropImapMessage(",
          "args": [
            "tream,",
            "ailbox,",
            "idValidity,",
            "ids)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.atEnd",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "DataStream::Qt_4_6)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            ")"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddFileAttachment(",
          "args": [
            "rl.path())"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.path",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "file\")"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.scheme",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.isLocalFile",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->urls",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->hasUrls",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ropImapPart(",
          "args": [
            "tream)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->data",
          "args": [
            "TrojitaImapPart)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->hasFormat",
          "args": [
            "TrojitaImapPart)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ropImapMessage(",
          "args": [
            "tream)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->data",
          "args": [
            "TrojitaMessageList)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->hasFormat",
          "args": [
            "TrojitaMessageList)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ropAttachmentList(",
          "args": [
            "tream)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->data",
          "args": [
            "TrojitaAttachmentList)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata->hasFormat",
          "args": [
            "TrojitaAttachmentList)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "arent)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ow)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  ool MessageComposer::dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent)\n  {\n      if (action == Qt::IgnoreAction)\n          return true;\n  \n      if (column > 0)\n          return false;\n  \n      if (!m_model)\n          return false;\n  \n      Q_UNUSED(row);\n      Q_UNUSED(parent);\n      // FIXME: would be cool to support attachment reshuffling and to respect the desired drop position\n  \n  \n      if (data->hasFormat(xTrojitaAttachmentList)) {\n          QByteArray encodedData = data->data(xTrojitaAttachmentList);\n          QDataStream stream(&encodedData, QIODevice::ReadOnly);\n          return dropAttachmentList(stream);\n      } else if (data->hasFormat(xTrojitaMessageList)) {\n          QByteArray encodedData = data->data(xTrojitaMessageList);\n          QDataStream stream(&encodedData, QIODevice::ReadOnly);\n          return dropImapMessage(stream);\n      } else if (data->hasFormat(xTrojitaImapPart)) {\n          QByteArray encodedData = data->data(xTrojitaImapPart);\n          QDataStream stream(&encodedData, QIODevice::ReadOnly);\n          return dropImapPart(stream);\n      } else if (data->hasUrls()) {\n          bool attached = false;\n          QList<QUrl> urls = data->urls();\n          foreach (const QUrl &url, urls) {\n  #if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n              if (url.isLocalFile()) {\n  #else\n              if (url.scheme() == QLatin1String(\"file\")) {\n  #endif\n                  // Careful here -- we definitely don't want the boolean evaluation shortcuts taking effect!\n                  // At the same time, any file being recognized and attached is enough to \"satisfy\" the drop\n                  attached = addFileAttachment(url.path()) || attached;\n              }\n          }\n          return attached;\n      } else {\n          return false;\n      }\n  }\n  \n  /** @short Container wrapper which calls qDeleteAll on all items which remain in the list at the time of destruction */\n  template <typename T>\n  class WillDeleteAll {\n  public:\n      T d;\n      ~WillDeleteAll() {\n          qDeleteAll(d);\n      }\n  };\n  \n  /** @short Handle a drag-and-drop of a list of attachments */\n  bool MessageComposer::dropAttachmentList(QDataStream &stream)\n  {\n      stream.setVersion(QDataStream::Qt_4_6);\n      if (stream.atEnd()) {\n          qDebug() << \"drag-and-drop: cannot decode data: end of stream\";\n          return false;\n      }\n      int num;\n      stream >> num;\n      if (stream.status() != QDataStream::Ok) {\n          qDebug() << \"drag-and-drop: stream failed:\" << stream.status();\n          return false;\n      }\n      if (num < 0) {\n          qDebug() << \"drag-and-drop: invalid number of items\";\n          return false;\n      }\n  \n      // A crude RAII here; there are many places where the validation might fail even though we have already allocated memory\n      WillDeleteAll<QList<AttachmentItem*>> items;\n  \n      for (int i = 0; i < num; ++i) {\n          int kind = -1;\n          stream >> kind;\n  \n          switch (kind) {\n          case AttachmentItem::ATTACHMENT_IMAP_MESSAGE:\n          {\n              QString mailbox;\n              uint uidValidity;\n              QList<uint> uids;\n              stream >> mailbox >> uidValidity >> uids;\n              if (!validateDropImapMessage(stream, mailbox, uidValidity, uids))\n                  return false;\n              if (uids.size() != 1) {\n                  qDebug() << \"drag-and-drop: malformed data for a single message in a mixed list: too many UIDs\";\n                  return false;\n              }\n              try {\n                  items.d << new ImapMessageAttachmentItem(m_model, mailbox, uidValidity, uids.front());\n              } catch (Imap::UnknownMessageIndex &) {\n                  return false;\n              }\n  \n              break;\n          }\n  \n          case AttachmentItem::ATTACHMENT_IMAP_PART:\n          {\n              QString mailbox;\n              uint uidValidity;\n              uint uid;\n              QString trojitaPath;\n              if (!validateDropImapPart(stream, mailbox, uidValidity, uid, trojitaPath))\n                  return false;\n              try {\n                  items.d << new ImapPartAttachmentItem(m_model, mailbox, uidValidity, uid, trojitaPath);\n              } catch (Imap::UnknownMessageIndex &) {\n                  return false;\n              }\n  \n              break;\n          }\n  \n          case AttachmentItem::ATTACHMENT_FILE:\n          {\n              QString fileName;\n              stream >> fileName;\n              items.d << new FileAttachmentItem(fileName);\n              break;\n          }\n  \n          default:\n              qDebug() << \"drag-and-drop: invalid kind of attachment\";\n              return false;\n          }\n      }\n  \n      beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size() + items.d.size() - 1);\n      Q_FOREACH(AttachmentItem *attachment, items.d) {\n          if (m_shouldPreload)\n              attachment->preload();\n          m_attachments << attachment;\n      }\n      items.d.clear();\n      endInsertRows();\n  \n      return true;\n  }\n  \n  /** @short Check that the data representing a list of messages is correct */\n  bool MessageComposer::validateDropImapMessage(QDataStream &stream, QString &mailbox, uint &uidValidity, QList<uint> &uids) const\n  {\n      if (stream.status() != QDataStream::Ok) {\n          qDebug() << \"drag-and-drop: stream failed:\" << stream.status();\n          return false;\n      }\n  \n      Imap::Mailbox::TreeItemMailbox *mboxPtr = m_model->findMailboxByName(mailbox);\n      if (!mboxPtr) {\n          qDebug() << \"drag-and-drop: mailbox not found\";\n          return false;\n      }\n  \n      if (uids.size() < 1) {\n          qDebug() << \"drag-and-drop: no UIDs passed\";\n          return false;\n      }\n      if (!uidValidity) {\n          qDebug() << \"drag-and-drop: invalid UIDVALIDITY\";\n          return false;\n      }\n  \n      return true;\n  }\n  \n  /** @short Handle a drag-and-drop of a list of messages */\n  bool MessageComposer::dropImapMessage(QDataStream &stream)\n  {\n      stream.setVersion(QDataStream::Qt_4_6);\n      if (stream.atEnd()) {\n          qDebug() << \"drag-and-drop: cannot decode data: end of stream\";\n          return false;\n      }\n      QString mailbox;\n      uint uidValidity;\n      QList<uint> uids;\n      stream >> mailbox >> uidValidity >> uids;\n      if (!validateDropImapMessage(stream, mailbox, uidValidity, uids))\n          return false;\n      if (!stream.atEnd()) {\n          qDebug() << \"drag-and-drop: cannot decode data: too much data\";\n          return false;\n      }\n  \n      WillDeleteAll<QList<AttachmentItem*>> items;\n      Q_FOREACH(const uint uid, uids) {\n          try {\n              items.d << new ImapMessageAttachmentItem(m_model, mailbox, uidValidity, uid);\n          } catch (Imap::UnknownMessageIndex &) {\n              return false;\n          }\n          items.d.last()->setContentDispositionMode(CDN_INLINE);\n      }\n      beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size() + uids.size() - 1);\n      Q_FOREACH(AttachmentItem *attachment, items.d) {\n          if (m_shouldPreload)\n              attachment->preload();\n          m_attachments << attachment;\n      }\n      items.d.clear();\n      endInsertRows();\n  \n      return true;\n  }\n  \n  /** @short Check that the data representing a single message part are correct */\n  bool MessageComposer::validateDropImapPart(QDataStream &stream, QString &mailbox, uint &uidValidity, uint &uid, QString &trojitaPath) const\n  {\n      stream >> mailbox >> uidValidity >> uid >> trojitaPath;\n      if (stream.status() != QDataStream::Ok) {\n          qDebug() << \"drag-and-drop: stream failed:\" << stream.status();\n          return false;\n      }\n      Imap::Mailbox::TreeItemMailbox *mboxPtr = m_model->findMailboxByName(mailbox);\n      if (!mboxPtr) {\n          qDebug() << \"drag-and-drop: mailbox not found\";\n          return false;\n      }\n  \n      if (!uidValidity || !uid || trojitaPath.isEmpty()) {\n          qDebug() << \"drag-and-drop: invalid data\";\n          return false;\n      }\n      return true;\n  }\n  \n  /** @short Handle a drag-adn-drop of a list of message parts */\n  bool MessageComposer::dropImapPart(QDataStream &stream)\n  {\n      stream.setVersion(QDataStream::Qt_4_6);\n      if (stream.atEnd()) {\n          qDebug() << \"drag-and-drop: cannot decode data: end of stream\";\n          return false;\n      }\n      QString mailbox;\n      uint uidValidity;\n      uint uid;\n      QString trojitaPath;\n      if (!validateDropImapPart(stream, mailbox, uidValidity, uid, trojitaPath))\n          return false;\n      if (!stream.atEnd()) {\n          qDebug() << \"drag-and-drop: cannot decode data: too much data\";\n          return false;\n      }\n  \n      AttachmentItem *item;\n      try {\n          item = new ImapPartAttachmentItem(m_model, mailbox, uidValidity, uid, trojitaPath);\n      } catch (Imap::UnknownMessageIndex &) {\n          return false;\n      }\n  \n      beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size());\n      m_attachments << item;\n      if (m_shouldPreload)\n          m_attachments.back()->preload();\n      endInsertRows();\n  \n      return true;\n  }\n  \n  QStringList MessageComposer::mimeTypes() const\n  {\n      return QStringList() << xTrojitaMessageList << xTrojitaImapPart << xTrojitaAttachmentList << QLatin1String(\"text/uri-list\");\n  }\n  \n  void MessageComposer::setFrom(const Imap::Message::MailAddress &from)\n  {\n      m_from = from;\n  }\n  \n  void MessageComposer::setRecipients(const QList<QPair<Composer::RecipientKind, Imap::Message::MailAddress> > &recipients)\n  {\n      m_recipients = recipients;\n  }\n  \n  /** @short Set the value for the In-Reply-To header as per RFC 5322, section 3.6.4\n  \n  The expected values to be passed here do *not* contain the angle brackets. This is in accordance with\n  the very last sentence of that section which says that the angle brackets are not part of the msg-id.\n  */\n  void MessageComposer::setInReplyTo(const QList<QByteArray> &inReplyTo)\n  {\n      m_inReplyTo = inReplyTo;\n  }\n  \n  /** @short Set the value for the References header as per RFC 5322, section 3.6.4\n  \n  @see setInReplyTo\n  */\n  void MessageComposer::setReferences(const QList<QByteArray> &references)\n  {\n      m_references = references;\n  }\n  \n  void MessageComposer::setTimestamp(const QDateTime &timestamp)\n  {\n      m_timestamp = timestamp;\n  }\n  \n  void MessageComposer::setSubject(const QString &subject)\n  {\n      m_subject = subject;\n  }\n  \n  void MessageComposer::setOrganization(const QString &organization)\n  {\n      m_organization = organization;\n  }\n  \n  void MessageComposer::setText(const QString &text)\n  {\n      m_text = text;\n  }\n  \n  bool MessageComposer::isReadyForSerialization() const\n  {\n      Q_FOREACH(const AttachmentItem *attachment, m_attachments) {\n          if (!attachment->isAvailableLocally())\n              return false;\n      }\n      return true;\n  }\n  \n  QByteArray MessageComposer::generateMessageId(const Imap::Message::MailAddress &sender)\n  {\n      if (sender.host.isEmpty()) {\n          // There's no usable domain, let's just bail out of here\n          return QByteArray();\n      }\n      return QUuid::createUuid()\n  #if QT_VERSION >= 0x040800\n              .toByteArray()\n  #else\n              .toString().toAscii()\n  #endif\n              .replace(\"{\", \"\").replace(\"}\", \"\") + \"@\" + sender.host.toUtf8();\n  }\n  \n  /** @short Generate a random enough MIME boundary */\n  QByteArray MessageComposer::generateMimeBoundary()\n  {\n      // Usage of \"=_\" is recommended by RFC2045 as it's guaranteed to never occur in a quoted-printable source\n      return QByteArray(\"trojita=_\") + QUuid::createUuid()\n  #if QT_VERSION >= 0x040800\n              .toByteArray()\n  #else\n              .toString().toAscii()\n  #endif\n              .replace(\"{\", \"\").replace(\"}\", \"\");\n  }\n  \n  QByteArray MessageComposer::encodeHeaderField(const QString &text)\n  {\n      /* This encodes an \"unstructured\" header field */\n      return Imap::encodeRFC2047StringWithAsciiPrefix(text);\n  }\n  \n  namespace {\n  \n  /** @short Write a list of recipients into an output buffer */\n  static void processListOfRecipientsIntoHeader(const QByteArray &prefix, const QList<QByteArray> &addresses, QByteArray &out)\n  {\n      // Qt and STL are different, it looks like we cannot easily use something as simple as the ostream_iterator here :(\n      if (!addresses.isEmpty()) {\n          out.append(prefix);\n          for (int i = 0; i < addresses.size() - 1; ++i)\n              out.append(addresses[i]).append(\",\\r\\n \");\n          out.append(addresses.last()).append(\"\\r\\n\");\n      }\n  }\n  \n  }\n  \n  void MessageComposer::writeCommonMessageBeginning(QIODevice *target, const QByteArray boundary) const\n  {\n      // The From header\n      target->write(QByteArray(\"From: \").append(m_from.asMailHeader()).append(\"\\r\\n\"));\n  \n      // All recipients\n      // Got to group the headers so that both of (To, Cc) are present at most once\n      QList<QByteArray> rcptTo, rcptCc;\n      for (auto it = m_recipients.begin(); it != m_recipients.end(); ++it) {\n          switch(it->first) {\n          case Composer::ADDRESS_TO:\n              rcptTo << it->second.asMailHeader();\n              break;\n          case Composer::ADDRESS_CC:\n              rcptCc << it->second.asMailHeader();\n              break;\n          case Composer::ADDRESS_BCC:\n              break;\n          case Composer::ADDRESS_FROM:\n          case Composer::ADDRESS_SENDER:\n          case Composer::ADDRESS_REPLY_TO:\n              // These should never ever be produced by Trojita for now\n              Q_ASSERT(false);\n              break;\n          }\n      }\n  \n      QByteArray recipientHeaders;\n      processListOfRecipientsIntoHeader(\"To: \", rcptTo, recipientHeaders);\n      processListOfRecipientsIntoHeader(\"Cc: \", rcptCc, recipientHeaders);\n      target->write(recipientHeaders);\n  \n      // Other message metadata\n      target->write(encodeHeaderField(QLatin1String(\"Subject: \") + m_subject).append(\"\\r\\n\").\n              append(\"Date: \").append(Imap::dateTimeToRfc2822(m_timestamp)).append(\"\\r\\n\").\n              append(\"User-Agent: \").append(\n                  QString::fromUtf8(\"Trojita/%1; %2\")\n                  .arg(Common::Application::version, Imap::Mailbox::systemPlatformVersion()).toUtf8()\n                  ).append(\"\\r\\n\").\n              append(\"MIME-Version: 1.0\\r\\n\"));\n      QByteArray messageId = generateMessageId(m_from);\n      if (!messageId.isEmpty()) {\n          target->write(QByteArray(\"Message-ID: <\").append(messageId).append(\">\\r\\n\"));\n      }\n      writeHeaderWithMsgIds(target, QByteArray(\"In-Reply-To\"), m_inReplyTo);\n      writeHeaderWithMsgIds(target, QByteArray(\"References\"), m_references);\n      if (!m_organization.isEmpty()) {\n          target->write(encodeHeaderField(QLatin1String(\"Organization: \") + m_organization).append(\"\\r\\n\"));\n      }\n  \n      // Headers depending on actual message body data\n      if (!m_attachments.isEmpty()) {\n          target->write(\"Content-Type: multipart/mixed;\\r\\n\\tboundary=\\\"\" + boundary + \"\\\"\\r\\n\"\n                        \"\\r\\nThis is a multipart/mixed message in MIME format.\\r\\n\\r\\n\"\n                        \"--\" + boundary + \"\\r\\n\");\n      }\n  \n      target->write(\"Content-Type: text/plain; charset=utf-8; format=flowed\\r\\n\"\n                    \"Content-Transfer-Encoding: quoted-printable\\r\\n\"\n                    \"\\r\\n\");\n      target->write(Imap::quotedPrintableEncode(Imap::wrapFormatFlowed(m_text).toUtf8()));\n  }\n  \n  /** @short Write a header consisting of a list of message-ids\n  \n  Empty headers will not be produced, and the result is wrapped at an appropriate length.\n  \n  The header name must not contain the colon, it is added automatically.\n  */\n  void MessageComposer::writeHeaderWithMsgIds(QIODevice *target, const QByteArray &headerName,\n                                              const QList<QByteArray> &messageIds) const\n  {\n      if (messageIds.isEmpty())\n          return;\n  \n      target->write(headerName + \":\");\n      int charCount = headerName.length() + 1;\n      for (int i = 0; i < messageIds.size(); ++i) {\n          // Wrapping shall happen at 78 columns, three bytes are eaten by \"space < >\"\n          if (i != 0 && charCount != 0 && charCount + messageIds[i].length() > 78 - 3) {\n              // got to wrap the header to respect a reasonably small line size\n              charCount = 0;\n              target->write(\"\\r\\n\");\n          }\n          // and now just append one more item\n          target->write(\" <\" + messageIds[i] + \">\");\n          charCount += messageIds[i].length() + 3;\n      }\n      target->write(\"\\r\\n\");\n  }\n  \n  bool MessageComposer::writeAttachmentHeader(QIODevice *target, QString *errorMessage, const AttachmentItem *attachment, const QByteArray &boundary) const\n  {\n      if (!attachment->isAvailableLocally() && attachment->imapUrl().isEmpty()) {\n          *errorMessage = tr(\"Attachment %1 is not available\").arg(attachment->caption());\n          return false;\n      }\n      target->write(\"\\r\\n--\" + boundary + \"\\r\\n\"\n                    \"Content-Type: \" + attachment->mimeType() + \"\\r\\n\");\n      target->write(attachment->contentDispositionHeader());\n  \n      switch (attachment->suggestedCTE()) {\n      case AttachmentItem::CTE_BASE64:\n          target->write(\"Content-Transfer-Encoding: base64\\r\\n\");\n          break;\n      case AttachmentItem::CTE_7BIT:\n          target->write(\"Content-Transfer-Encoding: 7bit\\r\\n\");\n          break;\n      case AttachmentItem::CTE_8BIT:\n          target->write(\"Content-Transfer-Encoding: 8bit\\r\\n\");\n          break;\n      case AttachmentItem::CTE_BINARY:\n          target->write(\"Content-Transfer-Encoding: binary\\r\\n\");\n          break;\n      }\n  \n      target->write(\"\\r\\n\");\n      return true;\n  }\n  \n  bool MessageComposer::writeAttachmentBody(QIODevice *target, QString *errorMessage, const AttachmentItem *attachment) const\n  {\n      if (!attachment->isAvailableLocally()) {\n          *errorMessage = tr(\"Attachment %1 is not available\").arg(attachment->caption());\n          return false;\n      }\n      QSharedPointer<QIODevice> io = attachment->rawData();\n      if (!io) {\n          *errorMessage = tr(\"Attachment %1 disappeared\").arg(attachment->caption());\n          return false;\n      }\n      while (!io->atEnd()) {\n          switch (attachment->suggestedCTE()) {\n          case AttachmentItem::CTE_BASE64:\n              // Base64 maps 6bit chunks into a single byte. Output shall have no more than 76 characters per line\n              // (not counting the CRLF pair).\n              target->write(io->read(76*6/8).toBase64() + \"\\r\\n\");\n              break;\n          default:\n              target->write(io->readAll());\n          }\n      }\n      return true;\n  }\n  \n  bool MessageComposer::asRawMessage(QIODevice *target, QString *errorMessage) const\n  {\n      // We don't bother with checking that our boundary is not present in the individual parts. That's arguably wrong,\n      // but we don't have much choice if we ever plan to use CATENATE.  It also looks like this is exactly how other MUAs\n      // oeprate as well, so let's just join the universal dontcareism here.\n      QByteArray boundary(generateMimeBoundary());\n  \n      writeCommonMessageBeginning(target, boundary);\n  \n      if (!m_attachments.isEmpty()) {\n          Q_FOREACH(const AttachmentItem *attachment, m_attachments) {\n              if (!writeAttachmentHeader(target, errorMessage, attachment, boundary))\n                  return false;\n              if (!writeAttachmentBody(target, errorMessage, attachment))\n                  return false;\n          }\n          target->write(\"\\r\\n--\" + boundary + \"--\\r\\n\");\n      }\n      return true;\n  }\n  \n  bool MessageComposer::asCatenateData(QList<Imap::Mailbox::CatenatePair> &target, QString *errorMessage) const\n  {\n      using namespace Imap::Mailbox;\n      target.clear();\n      QByteArray boundary(generateMimeBoundary());\n      target.append(qMakePair(CATENATE_TEXT, QByteArray()));\n  \n      // write the initial data\n      {\n          QBuffer io(&target.back().second);\n          io.open(QIODevice::ReadWrite);\n          writeCommonMessageBeginning(&io, boundary);\n      }\n  \n      if (!m_attachments.isEmpty()) {\n          Q_FOREACH(const AttachmentItem *attachment, m_attachments) {\n              if (target.back().first != CATENATE_TEXT) {\n                  target.append(qMakePair(CATENATE_TEXT, QByteArray()));\n              }\n              QBuffer io(&target.back().second);\n              io.open(QIODevice::Append);\n  \n              if (!writeAttachmentHeader(&io, errorMessage, attachment, boundary))\n                  return false;\n  \n              QByteArray url = attachment->imapUrl();\n              if (url.isEmpty()) {\n                  // Cannot use CATENATE here\n                  if (!writeAttachmentBody(&io, errorMessage, attachment))\n                      return false;\n              } else {\n                  target.append(qMakePair(CATENATE_URL, url));\n              }\n          }\n          if (target.back().first != CATENATE_TEXT) {\n              target.append(qMakePair(CATENATE_TEXT, QByteArray()));\n          }\n          QBuffer io(&target.back().second);\n          io.open(QIODevice::Append);\n          io.write(\"\\r\\n--\" + boundary + \"--\\r\\n\");\n      }\n      return true;\n  }\n  \n  QDateTime MessageComposer::timestamp() const\n  {\n      return m_timestamp;\n  }\n  \n  QList<QByteArray> MessageComposer::inReplyTo() const\n  {\n      return m_inReplyTo;\n  }\n  \n  QList<QByteArray> MessageComposer::references() const\n  {\n      return m_references;\n  }\n  \n  QByteArray MessageComposer::rawFromAddress() const\n  {\n      return m_from.asSMTPMailbox();\n  }\n  \n  QList<QByteArray> MessageComposer::rawRecipientAddresses() const\n  {\n      QList<QByteArray> res;\n  \n      for (auto it = m_recipients.begin(); it != m_recipients.end(); ++it) {\n          res << it->second.asSMTPMailbox();\n      }\n  \n      return res;\n  }\n  \n  bool MessageComposer::addFileAttachment(const QString &path)\n  {\n      beginInsertRows(QModelIndex(), m_attachments.size(), m_attachments.size());\n      QScopedPointer<AttachmentItem> attachment(new FileAttachmentItem(path));\n      if (!attachment->isAvailableLocally())\n          return false;\n      if (m_shouldPreload)\n          attachment->preload();\n      m_attachments << attachment.take();\n      endInsertRows();\n      return true;\n  }\n  \n  void MessageComposer::removeAttachment(const QModelIndex &index)\n  {\n      if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n          return;\n  \n      beginRemoveRows(QModelIndex(), index.row(), index.row());\n      delete m_attachments.takeAt(index.row());\n      endRemoveRows();\n  }\n  \n  void MessageComposer::setAttachmentName(const QModelIndex &index, const QString &newName)\n  {\n      if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n          return;\n  \n      if (m_attachments[index.row()]->setPreferredFileName(newName))\n          emit dataChanged(index, index);\n  }\n  \n  void MessageComposer::setAttachmentContentDisposition(const QModelIndex &index, const ContentDisposition disposition)\n  {\n      if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n          return;\n  \n      if (m_attachments[index.row()]->setContentDispositionMode(disposition))\n          emit dataChanged(index, index);\n  }\n  \n  void MessageComposer::setPreloadEnabled(const bool preload)\n  {\n      m_shouldPreload = preload;\n  }\n  \n  void MessageComposer::setReplyingToMessage(const QModelIndex &index)\n  {\n      m_replyingTo = index;\n  }\n  \n  QModelIndex MessageComposer::replyingToMessage() const\n  {\n      return m_replyingTo;\n  }\n  \n  }\n}"
  },
  {
    "function_name": "flags(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "96-105",
    "snippet": "t::ItemFlags MessageComposer::flags(const QModelIndex &index) const\n{\n    Qt::ItemFlags f = QAbstractListModel::flags(index);\n\n    if (index.isValid()) {\n        f |= Qt::ItemIsDragEnabled;\n    }\n    f |= Qt::ItemIsDropEnabled;\n    return f;\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AbstractListModel::flags(",
          "args": [
            "ndex)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "flags(",
          "container": "essageComposer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
          "lines": "96-105",
          "snippet": "t::ItemFlags MessageComposer::flags(const QModelIndex &index) const\n{\n    Qt::ItemFlags f = QAbstractListModel::flags(index);\n\n    if (index.isValid()) {\n        f |= Qt::ItemIsDragEnabled;\n    }\n    f |= Qt::ItemIsDropEnabled;\n    return f;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  t::ItemFlags MessageComposer::flags(const QModelIndex &index) const\n  {\n      Qt::ItemFlags f = QAbstractListModel::flags(index);\n  \n      if (index.isValid()) {\n          f |= Qt::ItemIsDragEnabled;\n      }\n      f |= Qt::ItemIsDropEnabled;\n      return f;\n  }\n}"
  },
  {
    "function_name": "supportedDropActions(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "91-94",
    "snippet": "t::DropActions MessageComposer::supportedDropActions() const\n{\n    return Qt::CopyAction | Qt::MoveAction | Qt::LinkAction;\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  t::DropActions MessageComposer::supportedDropActions() const\n  {\n      return Qt::CopyAction | Qt::MoveAction | Qt::LinkAction;\n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "64-89",
    "snippet": "Variant MessageComposer::data(const QModelIndex &index, int role) const\n{\n    if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n        return QVariant();\n\n    switch (role) {\n    case Qt::DisplayRole:\n        return m_attachments[index.row()]->caption();\n    case Qt::ToolTipRole:\n        return m_attachments[index.row()]->tooltip();\n    case Qt::DecorationRole:\n    {\n        // This is more or less copy-pasted from Gui/AttachmentView.cpp. Unfortunately, sharing the implementation\n        // is not trivial due to the way how the static libraries are currently built.\n        QMimeType mimeType = QMimeDatabase().mimeTypeForName(m_attachments[index.row()]->mimeType());\n        if (mimeType.isValid() && !mimeType.isDefault()) {\n            return QIcon::fromTheme(mimeType.iconName(), Gui::loadIcon(QLatin1String(\"mail-attachment\")));\n        } else {\n            return Gui::loadIcon(QLatin1String(\"mail-attachment\"));\n        }\n    }\n    case Imap::Mailbox::RoleAttachmentContentDispositionMode:\n        return static_cast<int>(m_attachments[index.row()]->contentDispositionMode());\n    }\n    return QVariant();\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<int>",
          "args": [
            "_attachments[index.row()]->contentDispositionMode())"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments[index.row",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-attachment\"))"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-attachment\")"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Icon::fromTheme(",
          "args": [
            "imeType.iconName(),",
            "ui::loadIcon(QLatin1String(\"mail-attachment\")))"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui::loadIcon(",
          "args": [
            "Latin1String(\"mail-attachment\"))"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "mail-attachment\")"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeType.iconName",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "iconName",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "281-292",
          "snippet": "QString QMimeType::iconName() const\n{\n    QMimeDatabasePrivate::instance()->provider()->loadIcon(*d);\n    if (d->iconName.isEmpty()) {\n        // Make default icon name from the mimetype name\n        d->iconName = name();\n        const int slashindex = d->iconName.indexOf(QLatin1Char('/'));\n        if (slashindex != -1)\n            d->iconName[slashindex] = QLatin1Char('-');\n    }\n    return d->iconName;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::iconName() const\n  {\n      QMimeDatabasePrivate::instance()->provider()->loadIcon(*d);\n      if (d->iconName.isEmpty()) {\n          // Make default icon name from the mimetype name\n          d->iconName = name();\n          const int slashindex = d->iconName.indexOf(QLatin1Char('/'));\n          if (slashindex != -1)\n              d->iconName[slashindex] = QLatin1Char('-');\n      }\n      return d->iconName;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "imeType.isDefault",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "isDefault",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "199-202",
          "snippet": "bool QMimeType::isDefault() const\n{\n    return d->name == QMimeDatabasePrivate::instance()->defaultMimeType();\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  bool QMimeType::isDefault() const\n  {\n      return d->name == QMimeDatabasePrivate::instance()->defaultMimeType();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "imeType.isValid",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "189-192",
          "snippet": "bool QMimeType::isValid() const\n{\n    return !d->name.isEmpty();\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  bool QMimeType::isValid() const\n  {\n      return !d->name.isEmpty();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MimeDatabase",
          "args": [
            "_attachments[index.row()]->mimeType())"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForUrl",
          "container": "QMimeDatabase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimedatabase.cpp",
          "lines": "510-524",
          "snippet": "QMimeType QMimeDatabase::mimeTypeForUrl(const QUrl &url) const\n{\n#if QT_VERSION >= 0x040800\n    if (url.isLocalFile())\n#else\n    if (url.scheme().isEmpty())\n#endif\n        return mimeTypeForFile(url.toLocalFile());\n\n    const QString scheme = url.scheme();\n    if (scheme.startsWith(QLatin1String(\"http\")))\n        return mimeTypeForName(d->defaultMimeType());\n\n    return mimeTypeForFile(url.path());\n}",
          "includes": [
            "#include <functional>",
            "#include <algorithm>",
            "#include <QDebug>",
            "#include <QStack>",
            "#include <QUrl>",
            "#include <QBuffer>",
            "#include <QSet>",
            "#include <QFileInfo>",
            "#include <QFile>",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimedatabase.h\"",
            "#include <qplatformdefs.h> // always first"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <algorithm>\n#include <QDebug>\n#include <QStack>\n#include <QUrl>\n#include <QBuffer>\n#include <QSet>\n#include <QFileInfo>\n#include <QFile>\n#include \"qmimetype_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimedatabase.h\"\n#include <qplatformdefs.h> // always first\n\nQMimeDatabase {\n  QMimeType QMimeDatabase::mimeTypeForUrl(const QUrl &url) const\n  {\n  #if QT_VERSION >= 0x040800\n      if (url.isLocalFile())\n  #else\n      if (url.scheme().isEmpty())\n  #endif\n          return mimeTypeForFile(url.toLocalFile());\n  \n      const QString scheme = url.scheme();\n      if (scheme.startsWith(QLatin1String(\"http\")))\n          return mimeTypeForName(d->defaultMimeType());\n  \n      return mimeTypeForFile(url.path());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_attachments[index.row",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MimeDatabase(",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments[index.row",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments[index.row",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  Variant MessageComposer::data(const QModelIndex &index, int role) const\n  {\n      if (!index.isValid() || index.column() != 0 || index.row() < 0 || index.row() >= m_attachments.size())\n          return QVariant();\n  \n      switch (role) {\n      case Qt::DisplayRole:\n          return m_attachments[index.row()]->caption();\n      case Qt::ToolTipRole:\n          return m_attachments[index.row()]->tooltip();\n      case Qt::DecorationRole:\n      {\n          // This is more or less copy-pasted from Gui/AttachmentView.cpp. Unfortunately, sharing the implementation\n          // is not trivial due to the way how the static libraries are currently built.\n          QMimeType mimeType = QMimeDatabase().mimeTypeForName(m_attachments[index.row()]->mimeType());\n          if (mimeType.isValid() && !mimeType.isDefault()) {\n              return QIcon::fromTheme(mimeType.iconName(), Gui::loadIcon(QLatin1String(\"mail-attachment\")));\n          } else {\n              return Gui::loadIcon(QLatin1String(\"mail-attachment\"));\n          }\n      }\n      case Imap::Mailbox::RoleAttachmentContentDispositionMode:\n          return static_cast<int>(m_attachments[index.row()]->contentDispositionMode());\n      }\n      return QVariant();\n  }\n}"
  },
  {
    "function_name": "rowCount(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "59-62",
    "snippet": "nt MessageComposer::rowCount(const QModelIndex &parent) const\n{\n    return parent.isValid() ? 0 : m_attachments.size();\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_attachments.size",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  nt MessageComposer::rowCount(const QModelIndex &parent) const\n  {\n      return parent.isValid() ? 0 : m_attachments.size();\n  }\n}"
  },
  {
    "function_name": "~MessageComposer(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "54-57",
    "snippet": "essageComposer::~MessageComposer()\n{\n    qDeleteAll(m_attachments);\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "_attachments)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  essageComposer::~MessageComposer()\n  {\n      qDeleteAll(m_attachments);\n  }\n}"
  },
  {
    "function_name": "MessageComposer(",
    "container": "essageComposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/MessageComposer.cpp",
    "lines": "49-52",
    "snippet": "essageComposer::MessageComposer(Imap::Mailbox::Model *model, QObject *parent) :\n    QAbstractListModel(parent), m_model(model), m_shouldPreload(false)\n{\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Gui/IconLoader.h\"\n#",
      "include \"Composer/ComposerAttachments.h\"\n#",
      "include \"Common/Application.h\"\n#",
      "include <QUuid>\n#",
      "include <QUrl>\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QMimeData>\n#",
      "include <QBuffer>\n#",
      "include \"MessageComposer.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/IconLoader.h\"\n#\ninclude \"Composer/ComposerAttachments.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude <QUuid>\n#\ninclude <QUrl>\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QMimeData>\n#\ninclude <QBuffer>\n#\ninclude \"MessageComposer.h\"\n#\n\nessageComposer {\n  essageComposer::MessageComposer(Imap::Mailbox::Model *model, QObject *parent) :\n      QAbstractListModel(parent), m_model(model), m_shouldPreload(false)\n  {\n  }\n}"
  }
]