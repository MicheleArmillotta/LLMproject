[
  {
    "function_name": "currentSortOrder(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1426-1429",
    "snippet": "t::SortOrder ThreadingMsgListModel::currentSortOrder() const\n{\n    return m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  t::SortOrder ThreadingMsgListModel::currentSortOrder() const\n  {\n      return m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder;\n  }\n}"
  },
  {
    "function_name": "currentSortCriterium(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1421-1424",
    "snippet": "hreadingMsgListModel::SortCriterium ThreadingMsgListModel::currentSortCriterium() const\n{\n    return m_currentSortingCriteria;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  hreadingMsgListModel::SortCriterium ThreadingMsgListModel::currentSortCriterium() const\n  {\n      return m_currentSortingCriteria;\n  }\n}"
  },
  {
    "function_name": "currentSearchCondition(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1416-1419",
    "snippet": "StringList ThreadingMsgListModel::currentSearchCondition() const\n{\n    return m_currentSearchConditions;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  StringList ThreadingMsgListModel::currentSearchCondition() const\n  {\n      return m_currentSearchConditions;\n  }\n}"
  },
  {
    "function_name": "applySort(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1356-1414",
    "snippet": "oid ThreadingMsgListModel::applySort()\n{\n    if (!sourceModel()->rowCount()) {\n        // empty mailbox is a corner case and it's already sorted anyway\n        return;\n    }\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(realIndex.parent().parent().internalPointer()));\n    Q_ASSERT(mailbox);\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    QSet<uint> newlyUnreachable(threading[0].children.toSet());\n    threading[0].children.clear();\n#if QT_VERSION >= 0x040700\n    threading[0].children.reserve(m_currentSortResult.size());\n#endif\n\n    QSet<uint> allRootIds(threadedRootIds.toSet());\n\n    for (int i = 0; i < m_currentSortResult.size(); ++i) {\n        int offset = m_sortReverse ? m_currentSortResult.size() - 1 - i : i;\n        QList<TreeItemMessage *> messages = const_cast<Model*>(realModel)\n                ->findMessagesByUids(mailbox, QList<uint>() << m_currentSortResult[offset]);\n        if (messages.isEmpty()) {\n            // wrong UID, weird\n            continue;\n        }\n        Q_ASSERT(messages.size() == 1);\n        QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(messages.front());\n        Q_ASSERT(it != ptrToInternal.constEnd());\n        if (!allRootIds.contains(*it)) {\n            // not a thread root, so don't show it\n            continue;\n        }\n        threading[*it].offset = threading[0].children.size();\n        threading[0].children.append(*it);\n    }\n\n    // Now remove everything which is no longer reachable from the root of the thread mapping\n    // Start working on the top-level orphans\n    Q_FOREACH(const uint uid, threading[0].children) {\n        newlyUnreachable.remove(uid);\n    }\n    std::vector<uint> queue(newlyUnreachable.constBegin(), newlyUnreachable.constEnd());\n    for (std::vector<uint>::size_type i = 0; i < queue.size(); ++i) {\n        QHash<uint,ThreadNodeInfo>::iterator threadingIt = threading.find(queue[i]);\n        Q_ASSERT(threadingIt != threading.end());\n        queue.insert(queue.end(), threadingIt->children.constBegin(), threadingIt->children.constEnd());\n        threading.erase(threadingIt);\n    }\n\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase2(",
          "args": [],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase2(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1027-1050",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n{\n    Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n    QList<QModelIndex> updatedIndexes;\n    for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n        QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n        if (ptrIt == ptrToInternal.constEnd()) {\n            // That message is no longer there\n            updatedIndexes.append(QModelIndex());\n            continue;\n        }\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n        if (it == threading.constEnd()) {\n            // Filtering doesn't accept this index, let's declare it dead\n            updatedIndexes.append(QModelIndex());\n        } else {\n            updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n        }\n    }\n    Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n    changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n    oldPersistentIndexes.clear();\n    oldPtrs.clear();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n  {\n      Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n      QList<QModelIndex> updatedIndexes;\n      for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n          QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n          if (ptrIt == ptrToInternal.constEnd()) {\n              // That message is no longer there\n              updatedIndexes.append(QModelIndex());\n              continue;\n          }\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n          if (it == threading.constEnd()) {\n              // Filtering doesn't accept this index, let's declare it dead\n              updatedIndexes.append(QModelIndex());\n          } else {\n              updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n          }\n      }\n      Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n      changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n      oldPersistentIndexes.clear();\n      oldPtrs.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading.erase",
          "args": [
            "hreadingIt)"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueue.insert",
          "args": [
            "ueue.end(),",
            "hreadingIt->children.constBegin(),",
            "hreadingIt->children.constEnd())"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadingIt->children.constEnd",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadingIt->children.constBegin",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueue.end",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hreadingIt != threading.end())"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.find",
          "args": [
            "ueue[i])"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueue.size",
          "args": [],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewlyUnreachable.constEnd",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewlyUnreachable.constBegin",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewlyUnreachable.remove",
          "args": [
            "id)"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.append",
          "args": [
            "it)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.size",
          "args": [],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llRootIds.contains",
          "args": [
            "it)"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != ptrToInternal.constEnd())"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constEnd",
          "args": [],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constFind",
          "args": [
            "essages.front())"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.front",
          "args": [],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essages.size() == 1)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.size",
          "args": [],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.isEmpty",
          "args": [],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model*>",
          "args": [
            "ailbox,",
            "List<uint>() << m_currentSortResult[offset])"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<uint>",
          "args": [],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "currentSortOrder(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1426-1429",
          "snippet": "t::SortOrder ThreadingMsgListModel::currentSortOrder() const\n{\n    return m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  t::SortOrder ThreadingMsgListModel::currentSortOrder() const\n  {\n      return m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onst_cast<Model*>",
          "args": [
            "ealModel)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.size",
          "args": [],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.size",
          "args": [],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.toSet",
          "args": [],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.reserve",
          "args": [
            "_currentSortResult.size())"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.size",
          "args": [],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.clear",
          "args": [],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading[0].children.toSet",
          "args": [],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase1(",
          "args": [],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase1(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1005-1024",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n{\n    oldPersistentIndexes = persistentIndexList();\n    oldPtrs.clear();\n    Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n        // the index could get invalidated by the pruneTree() or something else manipulating our threading\n        bool isOk = idx.isValid() && threading.contains(idx.internalId());\n        if (!isOk) {\n            oldPtrs << 0;\n            continue;\n        }\n        QModelIndex translated = mapToSource(idx);\n        if (!translated.isValid()) {\n            // another stale item\n            oldPtrs << 0;\n            continue;\n        }\n        oldPtrs << translated.internalPointer();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n  {\n      oldPersistentIndexes = persistentIndexList();\n      oldPtrs.clear();\n      Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n          // the index could get invalidated by the pruneTree() or something else manipulating our threading\n          bool isOk = idx.isValid() && threading.contains(idx.internalId());\n          if (!isOk) {\n              oldPtrs << 0;\n              continue;\n          }\n          QModelIndex translated = mapToSource(idx);\n          if (!translated.isValid()) {\n              // another stale item\n              oldPtrs << 0;\n              continue;\n          }\n          oldPtrs << translated.internalPointer();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox*>",
          "args": [
            "tatic_cast<TreeItem*>(realIndex.parent().parent().internalPointer()))"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem*>",
          "args": [
            "ealIndex.parent().parent().internalPointer())"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealIndex.parent",
          "args": [],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel::realTreeItem(",
          "args": [
            "omeMessage,",
            "realModel,",
            "realIndex)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::applySort()\n  {\n      if (!sourceModel()->rowCount()) {\n          // empty mailbox is a corner case and it's already sorted anyway\n          return;\n      }\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(realIndex.parent().parent().internalPointer()));\n      Q_ASSERT(mailbox);\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      QSet<uint> newlyUnreachable(threading[0].children.toSet());\n      threading[0].children.clear();\n  #if QT_VERSION >= 0x040700\n      threading[0].children.reserve(m_currentSortResult.size());\n  #endif\n  \n      QSet<uint> allRootIds(threadedRootIds.toSet());\n  \n      for (int i = 0; i < m_currentSortResult.size(); ++i) {\n          int offset = m_sortReverse ? m_currentSortResult.size() - 1 - i : i;\n          QList<TreeItemMessage *> messages = const_cast<Model*>(realModel)\n                  ->findMessagesByUids(mailbox, QList<uint>() << m_currentSortResult[offset]);\n          if (messages.isEmpty()) {\n              // wrong UID, weird\n              continue;\n          }\n          Q_ASSERT(messages.size() == 1);\n          QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(messages.front());\n          Q_ASSERT(it != ptrToInternal.constEnd());\n          if (!allRootIds.contains(*it)) {\n              // not a thread root, so don't show it\n              continue;\n          }\n          threading[*it].offset = threading[0].children.size();\n          threading[0].children.append(*it);\n      }\n  \n      // Now remove everything which is no longer reachable from the root of the thread mapping\n      // Start working on the top-level orphans\n      Q_FOREACH(const uint uid, threading[0].children) {\n          newlyUnreachable.remove(uid);\n      }\n      std::vector<uint> queue(newlyUnreachable.constBegin(), newlyUnreachable.constEnd());\n      for (std::vector<uint>::size_type i = 0; i < queue.size(); ++i) {\n          QHash<uint,ThreadNodeInfo>::iterator threadingIt = threading.find(queue[i]);\n          Q_ASSERT(threadingIt != threading.end());\n          queue.insert(queue.end(), threadingIt->children.constBegin(), threadingIt->children.constEnd());\n          threading.erase(threadingIt);\n      }\n  \n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
  },
  {
    "function_name": "searchSortPreferenceImplementation(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1245-1354",
    "snippet": "ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n{\n    Q_ASSERT(sourceModel());\n    if (!sourceModel()->rowCount()) {\n        return false;\n    }\n\n    const Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n\n    bool hasDisplaySort = false;\n    bool hasSort = false;\n    if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n        hasDisplaySort = true;\n        hasSort = true;\n    } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n        // just the regular sort\n        hasSort = true;\n    }\n\n    m_sortReverse = order == Qt::DescendingOrder;\n    QStringList sortOptions;\n    switch (criterium) {\n    case SORT_ARRIVAL:\n        sortOptions << QLatin1String(\"ARRIVAL\");\n        break;\n    case SORT_CC:\n        sortOptions << QLatin1String(\"CC\");\n        break;\n    case SORT_DATE:\n        sortOptions << QLatin1String(\"DATE\");\n        break;\n    case SORT_FROM:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n        break;\n    case SORT_SIZE:\n        sortOptions << QLatin1String(\"SIZE\");\n        break;\n    case SORT_SUBJECT:\n        sortOptions << QLatin1String(\"SUBJECT\");\n        break;\n    case SORT_TO:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n        break;\n    case SORT_NONE:\n        if (m_sortTask && m_sortTask->isPersistent() &&\n                (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n            // Any change shall result in us killing that sort task\n            m_sortTask->cancelSortingUpdates();\n        }\n\n        m_currentSortingCriteria = criterium;\n\n        if (searchConditions.isEmpty()) {\n            // This operation is special, it will immediately restore the original shape of the mailbox\n            m_currentSearchConditions = searchConditions;\n            calculateNullSort();\n            applySort();\n            return true;\n        } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n            // We have to update our search conditions\n            m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                  QStringList());\n            connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n            connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n            connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                    this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n            m_currentSearchConditions = searchConditions;\n            m_searchValidity = RESULT_ASKED;\n        } else {\n            // A result of SEARCH has just arrived\n            Q_ASSERT(m_searchValidity == RESULT_FRESH);\n            applySort();\n        }\n\n        return true;\n    }\n\n    if (!hasSort) {\n        // sorting is completely unsupported\n        return false;\n    }\n\n    Q_ASSERT(!sortOptions.isEmpty());\n\n    if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n            m_searchValidity != RESULT_INVALIDATED) {\n        applySort();\n    } else {\n        m_currentSearchConditions = searchConditions;\n        m_currentSortingCriteria = criterium;\n        calculateNullSort();\n        applySort();\n\n        if (m_sortTask && m_sortTask->isPersistent())\n            m_sortTask->cancelSortingUpdates();\n\n        m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n        connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n        connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n        connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n        m_searchValidity = RESULT_ASKED;\n    }\n\n    return true;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_sortTask,",
            "IGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),",
            "his,",
            "LOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)))"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t))"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingIncrementalUpdate(",
          "args": [
            "map::Responses::ESearch::IncrementalContextData_t)"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingIncrementalUpdate(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "827-863",
          "snippet": "oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n{\n    for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n        switch (it->modification) {\n        case Responses::ESearch::ContextIncrementalItem::ADDTO:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                int offset = it->offset + i;\n                if (offset < 0 || offset >= m_currentSortResult.size()) {\n                    throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                }\n                m_currentSortResult.insert(offset, it->uids[i]);\n            }\n            break;\n\n        case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                if (it->offset == 0) {\n                    // When the offset is not given, we have to find it ourselves\n                    m_currentSortResult.removeOne(it->uids[i]);\n                } else {\n                    // We're given an offset, so let's make sure it is a correct one\n                    int offset = it->offset + i - 1;\n                    if (offset < 0 || offset >= m_currentSortResult.size()) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                    }\n                    if (m_currentSortResult[offset] != it->uids[i]) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                    }\n                    m_currentSortResult.removeAt(offset);\n                }\n            }\n            break;\n        }\n    }\n    m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n  {\n      for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n          switch (it->modification) {\n          case Responses::ESearch::ContextIncrementalItem::ADDTO:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  int offset = it->offset + i;\n                  if (offset < 0 || offset >= m_currentSortResult.size()) {\n                      throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                  }\n                  m_currentSortResult.insert(offset, it->uids[i]);\n              }\n              break;\n  \n          case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  if (it->offset == 0) {\n                      // When the offset is not given, we have to find it ourselves\n                      m_currentSortResult.removeOne(it->uids[i]);\n                  } else {\n                      // We're given an offset, so let's make sure it is a correct one\n                      int offset = it->offset + i - 1;\n                      if (offset < 0 || offset >= m_currentSortResult.size()) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                      }\n                      if (m_currentSortResult[offset] != it->uids[i]) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                      }\n                      m_currentSortResult.removeAt(offset);\n                  }\n              }\n              break;\n          }\n      }\n      m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t))"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncrementalSortUpdate(",
          "args": [
            "map::Responses::ESearch::IncrementalContextData_t)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_sortTask,",
            "IGNAL(sortingFailed()),",
            "his,",
            "LOT(slotSortingFailed()))"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingFailed())"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingFailed(",
          "args": [],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "814-825",
          "snippet": "oid ThreadingMsgListModel::slotSortingFailed()\n{\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n    m_sortTask = 0;\n    m_sortReverse = false;\n    calculateNullSort();\n    applySort();\n    emit sortingFailed();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingFailed()\n  {\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n  \n      m_sortTask = 0;\n      m_sortReverse = false;\n      calculateNullSort();\n      applySort();\n      emit sortingFailed();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ortingFailed())"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_sortTask,",
            "IGNAL(sortingAvailable(QList<uint>)),",
            "his,",
            "LOT(slotSortingAvailable(QList<uint>)))"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingAvailable(QList<uint>))"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingAvailable(",
          "args": [
            "List<uint>)"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "798-812",
          "snippet": "oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n{\n    if (!m_sortTask->isPersistent()) {\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n        m_sortTask = 0;\n    }\n\n    m_currentSortResult = uids;\n    if (m_searchValidity == RESULT_ASKED)\n        m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n  {\n      if (!m_sortTask->isPersistent()) {\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n  \n          m_sortTask = 0;\n      }\n  \n      m_currentSortResult = uids;\n      if (m_searchValidity == RESULT_ASKED)\n          m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ortingAvailable(QList<uint>))"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->m_taskFactory->createSortTask",
          "args": [
            "onst_cast<Model *>(realModel),",
            "ailboxIndex,",
            "earchConditions,",
            "ortOptions)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ealModel)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sortTask->cancelSortingUpdates",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sortTask->isPersistent",
          "args": [],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pplySort(",
          "args": [],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "applySort(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1356-1414",
          "snippet": "oid ThreadingMsgListModel::applySort()\n{\n    if (!sourceModel()->rowCount()) {\n        // empty mailbox is a corner case and it's already sorted anyway\n        return;\n    }\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(realIndex.parent().parent().internalPointer()));\n    Q_ASSERT(mailbox);\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    QSet<uint> newlyUnreachable(threading[0].children.toSet());\n    threading[0].children.clear();\n#if QT_VERSION >= 0x040700\n    threading[0].children.reserve(m_currentSortResult.size());\n#endif\n\n    QSet<uint> allRootIds(threadedRootIds.toSet());\n\n    for (int i = 0; i < m_currentSortResult.size(); ++i) {\n        int offset = m_sortReverse ? m_currentSortResult.size() - 1 - i : i;\n        QList<TreeItemMessage *> messages = const_cast<Model*>(realModel)\n                ->findMessagesByUids(mailbox, QList<uint>() << m_currentSortResult[offset]);\n        if (messages.isEmpty()) {\n            // wrong UID, weird\n            continue;\n        }\n        Q_ASSERT(messages.size() == 1);\n        QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(messages.front());\n        Q_ASSERT(it != ptrToInternal.constEnd());\n        if (!allRootIds.contains(*it)) {\n            // not a thread root, so don't show it\n            continue;\n        }\n        threading[*it].offset = threading[0].children.size();\n        threading[0].children.append(*it);\n    }\n\n    // Now remove everything which is no longer reachable from the root of the thread mapping\n    // Start working on the top-level orphans\n    Q_FOREACH(const uint uid, threading[0].children) {\n        newlyUnreachable.remove(uid);\n    }\n    std::vector<uint> queue(newlyUnreachable.constBegin(), newlyUnreachable.constEnd());\n    for (std::vector<uint>::size_type i = 0; i < queue.size(); ++i) {\n        QHash<uint,ThreadNodeInfo>::iterator threadingIt = threading.find(queue[i]);\n        Q_ASSERT(threadingIt != threading.end());\n        queue.insert(queue.end(), threadingIt->children.constBegin(), threadingIt->children.constEnd());\n        threading.erase(threadingIt);\n    }\n\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::applySort()\n  {\n      if (!sourceModel()->rowCount()) {\n          // empty mailbox is a corner case and it's already sorted anyway\n          return;\n      }\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(realIndex.parent().parent().internalPointer()));\n      Q_ASSERT(mailbox);\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      QSet<uint> newlyUnreachable(threading[0].children.toSet());\n      threading[0].children.clear();\n  #if QT_VERSION >= 0x040700\n      threading[0].children.reserve(m_currentSortResult.size());\n  #endif\n  \n      QSet<uint> allRootIds(threadedRootIds.toSet());\n  \n      for (int i = 0; i < m_currentSortResult.size(); ++i) {\n          int offset = m_sortReverse ? m_currentSortResult.size() - 1 - i : i;\n          QList<TreeItemMessage *> messages = const_cast<Model*>(realModel)\n                  ->findMessagesByUids(mailbox, QList<uint>() << m_currentSortResult[offset]);\n          if (messages.isEmpty()) {\n              // wrong UID, weird\n              continue;\n          }\n          Q_ASSERT(messages.size() == 1);\n          QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(messages.front());\n          Q_ASSERT(it != ptrToInternal.constEnd());\n          if (!allRootIds.contains(*it)) {\n              // not a thread root, so don't show it\n              continue;\n          }\n          threading[*it].offset = threading[0].children.size();\n          threading[0].children.append(*it);\n      }\n  \n      // Now remove everything which is no longer reachable from the root of the thread mapping\n      // Start working on the top-level orphans\n      Q_FOREACH(const uint uid, threading[0].children) {\n          newlyUnreachable.remove(uid);\n      }\n      std::vector<uint> queue(newlyUnreachable.constBegin(), newlyUnreachable.constEnd());\n      for (std::vector<uint>::size_type i = 0; i < queue.size(); ++i) {\n          QHash<uint,ThreadNodeInfo>::iterator threadingIt = threading.find(queue[i]);\n          Q_ASSERT(threadingIt != threading.end());\n          queue.insert(queue.end(), threadingIt->children.constBegin(), threadingIt->children.constEnd());\n          threading.erase(threadingIt);\n      }\n  \n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alculateNullSort(",
          "args": [],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "calculateNullSort(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "866-880",
          "snippet": "oid ThreadingMsgListModel::calculateNullSort()\n{\n    m_currentSortResult.clear();\n#if QT_VERSION >= 0x040700\n    m_currentSortResult.reserve(threadedRootIds.size());\n#endif\n    Q_FOREACH(const uint internalId, threadedRootIds) {\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(internalId);\n        if (it == threading.constEnd())\n            continue;\n        if (it->uid)\n            m_currentSortResult.append(it->uid);\n    }\n    m_searchValidity = RESULT_FRESH;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::calculateNullSort()\n  {\n      m_currentSortResult.clear();\n  #if QT_VERSION >= 0x040700\n      m_currentSortResult.reserve(threadedRootIds.size());\n  #endif\n      Q_FOREACH(const uint internalId, threadedRootIds) {\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(internalId);\n          if (it == threading.constEnd())\n              continue;\n          if (it->uid)\n              m_currentSortResult.append(it->uid);\n      }\n      m_searchValidity = RESULT_FRESH;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sortOptions.isEmpty())"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortOptions.isEmpty",
          "args": [],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_searchValidity == RESULT_FRESH)"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_sortTask,",
            "IGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),",
            "his,",
            "LOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)))"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t))"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t))"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncrementalSortUpdate(",
          "args": [
            "map::Responses::ESearch::IncrementalContextData_t)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_sortTask,",
            "IGNAL(sortingFailed()),",
            "his,",
            "LOT(slotSortingFailed()))"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingFailed())"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ortingFailed())"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_sortTask,",
            "IGNAL(sortingAvailable(QList<uint>)),",
            "his,",
            "LOT(slotSortingAvailable(QList<uint>)))"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingAvailable(QList<uint>))"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ortingAvailable(QList<uint>))"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->m_taskFactory->createSortTask",
          "args": [
            "onst_cast<Model *>(realModel),",
            "ailboxIndex,",
            "earchConditions,",
            "StringList())"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ealModel)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchConditions.isEmpty",
          "args": [],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sortTask->cancelSortingUpdates",
          "args": [],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_sortTask->isPersistent",
          "args": [],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "TO\")"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DISPLAYTO\")"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SUBJECT\")"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SIZE\")"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FROM\")"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DISPLAYFROM\")"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DATE\")"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CC\")"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ARRIVAL\")"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [
            "Latin1String(\"SORT\"))"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SORT\")"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [
            "Latin1String(\"SORT=DISPLAY\"))"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SORT=DISPLAY\")"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealIndex.parent",
          "args": [],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel::realTreeItem(",
          "args": [
            "omeMessage,",
            "realModel,",
            "realIndex)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ourceModel())"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n  {\n      Q_ASSERT(sourceModel());\n      if (!sourceModel()->rowCount()) {\n          return false;\n      }\n  \n      const Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n  \n      bool hasDisplaySort = false;\n      bool hasSort = false;\n      if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n          hasDisplaySort = true;\n          hasSort = true;\n      } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n          // just the regular sort\n          hasSort = true;\n      }\n  \n      m_sortReverse = order == Qt::DescendingOrder;\n      QStringList sortOptions;\n      switch (criterium) {\n      case SORT_ARRIVAL:\n          sortOptions << QLatin1String(\"ARRIVAL\");\n          break;\n      case SORT_CC:\n          sortOptions << QLatin1String(\"CC\");\n          break;\n      case SORT_DATE:\n          sortOptions << QLatin1String(\"DATE\");\n          break;\n      case SORT_FROM:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n          break;\n      case SORT_SIZE:\n          sortOptions << QLatin1String(\"SIZE\");\n          break;\n      case SORT_SUBJECT:\n          sortOptions << QLatin1String(\"SUBJECT\");\n          break;\n      case SORT_TO:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n          break;\n      case SORT_NONE:\n          if (m_sortTask && m_sortTask->isPersistent() &&\n                  (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n              // Any change shall result in us killing that sort task\n              m_sortTask->cancelSortingUpdates();\n          }\n  \n          m_currentSortingCriteria = criterium;\n  \n          if (searchConditions.isEmpty()) {\n              // This operation is special, it will immediately restore the original shape of the mailbox\n              m_currentSearchConditions = searchConditions;\n              calculateNullSort();\n              applySort();\n              return true;\n          } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n              // We have to update our search conditions\n              m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                    QStringList());\n              connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n              connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n              connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                      this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n              m_currentSearchConditions = searchConditions;\n              m_searchValidity = RESULT_ASKED;\n          } else {\n              // A result of SEARCH has just arrived\n              Q_ASSERT(m_searchValidity == RESULT_FRESH);\n              applySort();\n          }\n  \n          return true;\n      }\n  \n      if (!hasSort) {\n          // sorting is completely unsupported\n          return false;\n      }\n  \n      Q_ASSERT(!sortOptions.isEmpty());\n  \n      if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n              m_searchValidity != RESULT_INVALIDATED) {\n          applySort();\n      } else {\n          m_currentSearchConditions = searchConditions;\n          m_currentSortingCriteria = criterium;\n          calculateNullSort();\n          applySort();\n  \n          if (m_sortTask && m_sortTask->isPersistent())\n              m_sortTask->cancelSortingUpdates();\n  \n          m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n          connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n          connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n          connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                  this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n          m_searchValidity = RESULT_ASKED;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "setUserSearchingSortingPreference(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1238-1242",
    "snippet": "ool ThreadingMsgListModel::setUserSearchingSortingPreference(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n{\n    wantThreading(SKIP_SORT_SEARCH);\n    return searchSortPreferenceImplementation(searchConditions, criterium, order);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "earchSortPreferenceImplementation(",
          "args": [
            "earchConditions,",
            "riterium,",
            "rder)"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "searchSortPreferenceImplementation(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1245-1354",
          "snippet": "ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n{\n    Q_ASSERT(sourceModel());\n    if (!sourceModel()->rowCount()) {\n        return false;\n    }\n\n    const Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n\n    bool hasDisplaySort = false;\n    bool hasSort = false;\n    if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n        hasDisplaySort = true;\n        hasSort = true;\n    } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n        // just the regular sort\n        hasSort = true;\n    }\n\n    m_sortReverse = order == Qt::DescendingOrder;\n    QStringList sortOptions;\n    switch (criterium) {\n    case SORT_ARRIVAL:\n        sortOptions << QLatin1String(\"ARRIVAL\");\n        break;\n    case SORT_CC:\n        sortOptions << QLatin1String(\"CC\");\n        break;\n    case SORT_DATE:\n        sortOptions << QLatin1String(\"DATE\");\n        break;\n    case SORT_FROM:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n        break;\n    case SORT_SIZE:\n        sortOptions << QLatin1String(\"SIZE\");\n        break;\n    case SORT_SUBJECT:\n        sortOptions << QLatin1String(\"SUBJECT\");\n        break;\n    case SORT_TO:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n        break;\n    case SORT_NONE:\n        if (m_sortTask && m_sortTask->isPersistent() &&\n                (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n            // Any change shall result in us killing that sort task\n            m_sortTask->cancelSortingUpdates();\n        }\n\n        m_currentSortingCriteria = criterium;\n\n        if (searchConditions.isEmpty()) {\n            // This operation is special, it will immediately restore the original shape of the mailbox\n            m_currentSearchConditions = searchConditions;\n            calculateNullSort();\n            applySort();\n            return true;\n        } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n            // We have to update our search conditions\n            m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                  QStringList());\n            connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n            connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n            connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                    this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n            m_currentSearchConditions = searchConditions;\n            m_searchValidity = RESULT_ASKED;\n        } else {\n            // A result of SEARCH has just arrived\n            Q_ASSERT(m_searchValidity == RESULT_FRESH);\n            applySort();\n        }\n\n        return true;\n    }\n\n    if (!hasSort) {\n        // sorting is completely unsupported\n        return false;\n    }\n\n    Q_ASSERT(!sortOptions.isEmpty());\n\n    if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n            m_searchValidity != RESULT_INVALIDATED) {\n        applySort();\n    } else {\n        m_currentSearchConditions = searchConditions;\n        m_currentSortingCriteria = criterium;\n        calculateNullSort();\n        applySort();\n\n        if (m_sortTask && m_sortTask->isPersistent())\n            m_sortTask->cancelSortingUpdates();\n\n        m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n        connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n        connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n        connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n        m_searchValidity = RESULT_ASKED;\n    }\n\n    return true;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n  {\n      Q_ASSERT(sourceModel());\n      if (!sourceModel()->rowCount()) {\n          return false;\n      }\n  \n      const Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n  \n      bool hasDisplaySort = false;\n      bool hasSort = false;\n      if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n          hasDisplaySort = true;\n          hasSort = true;\n      } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n          // just the regular sort\n          hasSort = true;\n      }\n  \n      m_sortReverse = order == Qt::DescendingOrder;\n      QStringList sortOptions;\n      switch (criterium) {\n      case SORT_ARRIVAL:\n          sortOptions << QLatin1String(\"ARRIVAL\");\n          break;\n      case SORT_CC:\n          sortOptions << QLatin1String(\"CC\");\n          break;\n      case SORT_DATE:\n          sortOptions << QLatin1String(\"DATE\");\n          break;\n      case SORT_FROM:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n          break;\n      case SORT_SIZE:\n          sortOptions << QLatin1String(\"SIZE\");\n          break;\n      case SORT_SUBJECT:\n          sortOptions << QLatin1String(\"SUBJECT\");\n          break;\n      case SORT_TO:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n          break;\n      case SORT_NONE:\n          if (m_sortTask && m_sortTask->isPersistent() &&\n                  (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n              // Any change shall result in us killing that sort task\n              m_sortTask->cancelSortingUpdates();\n          }\n  \n          m_currentSortingCriteria = criterium;\n  \n          if (searchConditions.isEmpty()) {\n              // This operation is special, it will immediately restore the original shape of the mailbox\n              m_currentSearchConditions = searchConditions;\n              calculateNullSort();\n              applySort();\n              return true;\n          } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n              // We have to update our search conditions\n              m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                    QStringList());\n              connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n              connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n              connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                      this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n              m_currentSearchConditions = searchConditions;\n              m_searchValidity = RESULT_ASKED;\n          } else {\n              // A result of SEARCH has just arrived\n              Q_ASSERT(m_searchValidity == RESULT_FRESH);\n              applySort();\n          }\n  \n          return true;\n      }\n  \n      if (!hasSort) {\n          // sorting is completely unsupported\n          return false;\n      }\n  \n      Q_ASSERT(!sortOptions.isEmpty());\n  \n      if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n              m_searchValidity != RESULT_INVALIDATED) {\n          applySort();\n      } else {\n          m_currentSearchConditions = searchConditions;\n          m_currentSortingCriteria = criterium;\n          calculateNullSort();\n          applySort();\n  \n          if (m_sortTask && m_sortTask->isPersistent())\n              m_sortTask->cancelSortingUpdates();\n  \n          m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n          connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n          connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n          connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                  this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n          m_searchValidity = RESULT_ASKED;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [
            "KIP_SORT_SEARCH)"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "wantThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "503-568",
          "snippet": "oid ThreadingMsgListModel::wantThreading(const SkipSortSearch skipSortSearch)\n{\n    if (!sourceModel() || !sourceModel()->rowCount() || !m_shallBeThreading) {\n        updateNoThreading();\n        if (skipSortSearch == AUTO_SORT_SEARCH) {\n            searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n        }\n        return;\n    }\n\n    if (threadingInFlight) {\n        // Imagine the following scenario:\n        // <<< \"* 3 EXISTS\"\n        // Message 2 has unknown UID\n        // >>> \"y4 UID FETCH 66:* (FLAGS)\"\n        // >>> \"y5 UID THREAD REFS utf-8 ALL\"\n        // <<< \"* 3 FETCH (UID 66 FLAGS ())\"\n        // Got UID for seq# 3\n        // ThreadingMsgListModel::wantThreading: THREAD contains info about UID 1 (or higher), mailbox has 66\n        //    *** this is the interesting part ***\n        // <<< \"y4 OK fetch\"\n        // <<< \"* THREAD (1)(2)(66)\"\n        // <<< \"y5 OK thread\"\n        // >>> \"y6 UID THREAD REFS utf-8 ALL\"\n        //\n        // See, at the indicated (***) place, we already have an in-flight THREAD request and receive UID for newly arrived\n        // message.  We certainly don't want to ask for threading once again; it's better to wait a bit and only ask when the\n        // to-be-received THREAD does not contain all required UIDs.\n        if (skipSortSearch == AUTO_SORT_SEARCH) {\n            searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n        }\n        return;\n    }\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailbox = realIndex.parent().parent();\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(static_cast<TreeItem*>(realIndex.parent().internalPointer()));\n    Q_ASSERT(list);\n\n    // Something has happened and we want to process the THREAD response\n    QVector<Imap::Responses::ThreadingNode> mapping = realModel->cache()->messageThreading(mailbox.data(RoleMailboxName).toString());\n\n    // Find the UID of the last message in the mailbox\n    uint highestUidInMailbox = findHighestUidInMailbox(list);\n    uint highestUidInThreadingLowerBound = findHighEnoughNumber(mapping, highestUidInMailbox);\n\n    logTrace(QString::fromUtf8(\"ThreadingMsgListModel::wantThreading: THREAD contains info about UID %1 (or higher), mailbox has %2\")\n             .arg(QString::number(highestUidInThreadingLowerBound), QString::number(highestUidInMailbox)));\n\n    if (highestUidInThreadingLowerBound >= highestUidInMailbox) {\n        // There's no point asking for data at this point, we shall just apply threading\n        applyThreading(mapping);\n    } else {\n        // There's apparently at least one known UID whose threading info we do not know; that means that we have to ask the\n        // server here.\n        auto roughlyLastKnown = const_cast<Model*>(realModel)->findMessageOrNextOneByUid(list, highestUidInThreadingLowerBound);\n        if (list->m_children.end() - roughlyLastKnown >= 50 || roughlyLastKnown == list->m_children.begin()) {\n            askForThreading();\n        } else {\n            askForThreading(static_cast<TreeItemMessage*>(*roughlyLastKnown)->uid() + 1);\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::wantThreading(const SkipSortSearch skipSortSearch)\n  {\n      if (!sourceModel() || !sourceModel()->rowCount() || !m_shallBeThreading) {\n          updateNoThreading();\n          if (skipSortSearch == AUTO_SORT_SEARCH) {\n              searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n          }\n          return;\n      }\n  \n      if (threadingInFlight) {\n          // Imagine the following scenario:\n          // <<< \"* 3 EXISTS\"\n          // Message 2 has unknown UID\n          // >>> \"y4 UID FETCH 66:* (FLAGS)\"\n          // >>> \"y5 UID THREAD REFS utf-8 ALL\"\n          // <<< \"* 3 FETCH (UID 66 FLAGS ())\"\n          // Got UID for seq# 3\n          // ThreadingMsgListModel::wantThreading: THREAD contains info about UID 1 (or higher), mailbox has 66\n          //    *** this is the interesting part ***\n          // <<< \"y4 OK fetch\"\n          // <<< \"* THREAD (1)(2)(66)\"\n          // <<< \"y5 OK thread\"\n          // >>> \"y6 UID THREAD REFS utf-8 ALL\"\n          //\n          // See, at the indicated (***) place, we already have an in-flight THREAD request and receive UID for newly arrived\n          // message.  We certainly don't want to ask for threading once again; it's better to wait a bit and only ask when the\n          // to-be-received THREAD does not contain all required UIDs.\n          if (skipSortSearch == AUTO_SORT_SEARCH) {\n              searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n          }\n          return;\n      }\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailbox = realIndex.parent().parent();\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(static_cast<TreeItem*>(realIndex.parent().internalPointer()));\n      Q_ASSERT(list);\n  \n      // Something has happened and we want to process the THREAD response\n      QVector<Imap::Responses::ThreadingNode> mapping = realModel->cache()->messageThreading(mailbox.data(RoleMailboxName).toString());\n  \n      // Find the UID of the last message in the mailbox\n      uint highestUidInMailbox = findHighestUidInMailbox(list);\n      uint highestUidInThreadingLowerBound = findHighEnoughNumber(mapping, highestUidInMailbox);\n  \n      logTrace(QString::fromUtf8(\"ThreadingMsgListModel::wantThreading: THREAD contains info about UID %1 (or higher), mailbox has %2\")\n               .arg(QString::number(highestUidInThreadingLowerBound), QString::number(highestUidInMailbox)));\n  \n      if (highestUidInThreadingLowerBound >= highestUidInMailbox) {\n          // There's no point asking for data at this point, we shall just apply threading\n          applyThreading(mapping);\n      } else {\n          // There's apparently at least one known UID whose threading info we do not know; that means that we have to ask the\n          // server here.\n          auto roughlyLastKnown = const_cast<Model*>(realModel)->findMessageOrNextOneByUid(list, highestUidInThreadingLowerBound);\n          if (list->m_children.end() - roughlyLastKnown >= 50 || roughlyLastKnown == list->m_children.begin()) {\n              askForThreading();\n          } else {\n              askForThreading(static_cast<TreeItemMessage*>(*roughlyLastKnown)->uid() + 1);\n          }\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::setUserSearchingSortingPreference(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n  {\n      wantThreading(SKIP_SORT_SEARCH);\n      return searchSortPreferenceImplementation(searchConditions, criterium, order);\n  }\n}"
  },
  {
    "function_name": "setUserWantsThreading(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1228-1236",
    "snippet": "oid ThreadingMsgListModel::setUserWantsThreading(bool enable)\n{\n    m_shallBeThreading = enable;\n    if (m_shallBeThreading) {\n        wantThreading();\n    } else {\n        updateNoThreading();\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdateNoThreading(",
          "args": [],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "updateNoThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "433-501",
          "snippet": "oid ThreadingMsgListModel::updateNoThreading()\n{\n    threadingHelperLastId = 0;\n\n    if (!sourceModel()) {\n        // Maybe we got reset because the parent model is no longer here...\n        if (! threading.isEmpty()) {\n            beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n            threading.clear();\n            ptrToInternal.clear();\n            endRemoveRows();\n        }\n        unknownUids.clear();\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n\n    int upstreamMessages = sourceModel()->rowCount();\n    QList<uint> allIds;\n    QHash<uint,ThreadNodeInfo> newThreading;\n    QHash<void *,uint> newPtrToInternal;\n\n    if (upstreamMessages) {\n        // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n        // This improves the speed of the testSortingPerformance benchmark by 18%.\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n\n        for (int i = 0; i < upstreamMessages; ++i) {\n            TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n            Q_ASSERT(ptr);\n            ThreadNodeInfo node;\n            node.internalId = i + 1;\n            node.uid = ptr->uid();\n            node.ptr = ptr;\n            node.offset = i;\n            newThreading[node.internalId] = node;\n            allIds.append(node.internalId);\n            newPtrToInternal[node.ptr] = node.internalId;\n            if (!node.uid) {\n                unknownUids << ptr;\n            }\n        }\n    }\n\n    if (newThreading.size()) {\n        threading = newThreading;\n        ptrToInternal = newPtrToInternal;\n        threading[ 0 ].children = allIds;\n        threading[ 0 ].ptr = 0;\n        threadingHelperLastId = newThreading.size();\n        threadedRootIds = threading[0].children;\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updateNoThreading()\n  {\n      threadingHelperLastId = 0;\n  \n      if (!sourceModel()) {\n          // Maybe we got reset because the parent model is no longer here...\n          if (! threading.isEmpty()) {\n              beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n              threading.clear();\n              ptrToInternal.clear();\n              endRemoveRows();\n          }\n          unknownUids.clear();\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n  \n      int upstreamMessages = sourceModel()->rowCount();\n      QList<uint> allIds;\n      QHash<uint,ThreadNodeInfo> newThreading;\n      QHash<void *,uint> newPtrToInternal;\n  \n      if (upstreamMessages) {\n          // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n          // This improves the speed of the testSortingPerformance benchmark by 18%.\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n  \n          for (int i = 0; i < upstreamMessages; ++i) {\n              TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n              Q_ASSERT(ptr);\n              ThreadNodeInfo node;\n              node.internalId = i + 1;\n              node.uid = ptr->uid();\n              node.ptr = ptr;\n              node.offset = i;\n              newThreading[node.internalId] = node;\n              allIds.append(node.internalId);\n              newPtrToInternal[node.ptr] = node.internalId;\n              if (!node.uid) {\n                  unknownUids << ptr;\n              }\n          }\n      }\n  \n      if (newThreading.size()) {\n          threading = newThreading;\n          ptrToInternal = newPtrToInternal;\n          threading[ 0 ].children = allIds;\n          threading[ 0 ].ptr = 0;\n          threadingHelperLastId = newThreading.size();\n          threadedRootIds = threading[0].children;\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::setUserWantsThreading(bool enable)\n  {\n      m_shallBeThreading = enable;\n      if (m_shallBeThreading) {\n          wantThreading();\n      } else {\n          updateNoThreading();\n      }\n  }\n}"
  },
  {
    "function_name": "logTrace(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1205-1226",
    "snippet": "oid ThreadingMsgListModel::logTrace(const QString &message)\n{\n    if (!sourceModel()) {\n        qDebug() << message;\n        return;\n    }\n    QModelIndex idx = sourceModel()->index(0, 0);\n    if (!idx.isValid()) {\n        qDebug() << message;\n        return;\n    }\n\n    // Got to find out the real model and also translate the index to one belonging to a real Model\n    Q_ASSERT(idx.model());\n    const Model *realModel;\n    QModelIndex realIndex;\n    Model::realTreeItem(idx, &realModel, &realIndex);\n    Q_ASSERT(realModel);\n    QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n    const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n            QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ailboxIndex,",
            "ommon::LOG_OTHER,",
            "String::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()),",
            "essage)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "ailboxIndex.data(RoleMailboxName).toString())"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "ThreadingMsgListModel for %1\")"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ealModel)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ModelIndexList() << realIndex)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndexList(",
          "args": [],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ealModel)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ealModel)"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::realTreeItem(",
          "args": [
            "dx,",
            "realModel,",
            "realIndex)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "dx.model())"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx.model",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx.isValid",
          "args": [],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::logTrace(const QString &message)\n  {\n      if (!sourceModel()) {\n          qDebug() << message;\n          return;\n      }\n      QModelIndex idx = sourceModel()->index(0, 0);\n      if (!idx.isValid()) {\n          qDebug() << message;\n          return;\n      }\n  \n      // Got to find out the real model and also translate the index to one belonging to a real Model\n      Q_ASSERT(idx.model());\n      const Model *realModel;\n      QModelIndex realIndex;\n      Model::realTreeItem(idx, &realModel, &realIndex);\n      Q_ASSERT(realModel);\n      QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n      const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n              QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n  }\n}"
  },
  {
    "function_name": "threadContainsUnreadMessages(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1180-1199",
    "snippet": "ool ThreadingMsgListModel::threadContainsUnreadMessages(const uint root) const\n{\n    // FIXME: cache the value somewhere...\n    QList<uint> queue;\n    queue.append(root);\n    while (! queue.isEmpty()) {\n        uint current = queue.takeFirst();\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(current);\n        Q_ASSERT(it != threading.constEnd());\n        if (it->ptr) {\n            // Because of the delayed delete via pruneTree, we can hit a null pointer here\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(it->ptr);\n            Q_ASSERT(message);\n            if (! message->isMarkedAsRead())\n                return true;\n        }\n        queue.append(it->children);\n    }\n    return false;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueue.append",
          "args": [
            "t->children)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage->isMarkedAsRead",
          "args": [],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "isMarkedAsRead(",
          "container": "reeItemMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1195-1198",
          "snippet": "ool TreeItemMessage::isMarkedAsRead() const\n{\n    return m_flags.contains(FlagNames::seen);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMessage {\n  ool TreeItemMessage::isMarkedAsRead() const\n  {\n      return m_flags.contains(FlagNames::seen);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essage)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage *>",
          "args": [
            "t->ptr)"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != threading.constEnd())"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "urrent)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueue.takeFirst",
          "args": [],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueue.isEmpty",
          "args": [],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueue.append",
          "args": [
            "oot)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::threadContainsUnreadMessages(const uint root) const\n  {\n      // FIXME: cache the value somewhere...\n      QList<uint> queue;\n      queue.append(root);\n      while (! queue.isEmpty()) {\n          uint current = queue.takeFirst();\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(current);\n          Q_ASSERT(it != threading.constEnd());\n          if (it->ptr) {\n              // Because of the delayed delete via pruneTree, we can hit a null pointer here\n              TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(it->ptr);\n              Q_ASSERT(message);\n              if (! message->isMarkedAsRead())\n                  return true;\n          }\n          queue.append(it->children);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "supportedDropActions(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1175-1178",
    "snippet": "t::DropActions ThreadingMsgListModel::supportedDropActions() const\n{\n    return sourceModel() ? sourceModel()->supportedDropActions() : Qt::DropActions(0);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t::DropActions(",
          "args": [
            ")"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  t::DropActions ThreadingMsgListModel::supportedDropActions() const\n  {\n      return sourceModel() ? sourceModel()->supportedDropActions() : Qt::DropActions(0);\n  }\n}"
  },
  {
    "function_name": "mimeTypes(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1158-1161",
    "snippet": "StringList ThreadingMsgListModel::mimeTypes() const\n{\n    return sourceModel() ? sourceModel()->mimeTypes() : QStringList();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  StringList ThreadingMsgListModel::mimeTypes() const\n  {\n      return sourceModel() ? sourceModel()->mimeTypes() : QStringList();\n  }\n}"
  },
  {
    "function_name": "supportedCapabilities(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1153-1156",
    "snippet": "StringList ThreadingMsgListModel::supportedCapabilities()\n{\n    return QStringList() << QLatin1String(\"THREAD=REFS\") << QLatin1String(\"THREAD=REFERENCES\") << QLatin1String(\"THREAD=ORDEREDSUBJECT\");\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "THREAD=ORDEREDSUBJECT\")"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "THREAD=REFERENCES\")"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "THREAD=REFS\")"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  StringList ThreadingMsgListModel::supportedCapabilities()\n  {\n      return QStringList() << QLatin1String(\"THREAD=REFS\") << QLatin1String(\"THREAD=REFERENCES\") << QLatin1String(\"THREAD=ORDEREDSUBJECT\");\n  }\n}"
  },
  {
    "function_name": "pruneTree(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1052-1151",
    "snippet": "oid ThreadingMsgListModel::pruneTree()\n{\n    // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n    // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n    // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n    // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n    QList<uint> pending = threading.keys();\n    for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n        // Convert to the hashmap\n        // The \"it\" iterator point to the current node in the threading mapping\n        QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n        if (it == threading.end()) {\n            // We've already seen this node, that's due to promoting\n            ++id;\n            continue;\n        }\n\n        if (it->internalId == 0) {\n            // A special root item; we should not delete that one :)\n            ++id;\n            continue;\n        }\n        if (it->ptr) {\n            // regular and valid message -> skip\n            ++id;\n        } else {\n            // a fake one\n\n            // each node has a parent\n            QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n            Q_ASSERT(parent != threading.end());\n\n            // and the node itself has to be found in its parent's children\n            QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n            Q_ASSERT(childIt != parent->children.end());\n            // Check that its offset is correct\n            Q_ASSERT(childIt - parent->children.begin() == it->offset);\n\n            if (it->children.isEmpty()) {\n                // This is a leaf node, so we can just remove it\n                childIt = parent->children.erase(childIt);\n                threadedRootIds.removeOne(it->internalId);\n                threading.erase(it);\n                ++id;\n\n                // Update offsets of all further nodes, siblings to the one we've just deleted\n                while (childIt != parent->children.end()) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                    Q_ASSERT(sibling != threading.end());\n                    --sibling->offset;\n                    Q_ASSERT(sibling->offset >= 0);\n                    ++childIt;\n                }\n            } else {\n                // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                // to replace this node.\n                QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                Q_ASSERT(replaceWith != threading.end());\n\n                // Make sure that the offsets are still correct\n                Q_ASSERT(parent->children[it->offset] == it->internalId);\n\n                // Replace the node\n                replaceWith->offset = it->offset;\n                *childIt = it->children.first();\n                replaceWith->parent = parent->internalId;\n\n                // Now merge the lists of children\n                it->children.removeFirst();\n                replaceWith->children = replaceWith->children + it->children;\n\n                // Fix parent and offset information of all children of the replacement node\n                for (int i = 0; i < replaceWith->children.size(); ++i) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                    Q_ASSERT(sibling != threading.end());\n\n                    sibling->parent = replaceWith.key();\n                    sibling->offset = i;\n                }\n\n                if (parent->internalId == 0) {\n                    // Update the list of all thread roots\n                    QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                    if (rootIt != threadedRootIds.end())\n                        *rootIt = replaceWith->internalId;\n                }\n\n                // Now that all references are gone, remove the original node\n                threading.erase(it);\n\n                if (!replaceWith->ptr) {\n                    // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                    // because we've already processed the current item and are completely done with it. The worst which can\n                    // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                    *id = replaceWith.key();\n                }\n            }\n        }\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eplaceWith.key",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.erase",
          "args": [
            "t)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.end",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Find(",
          "args": [
            "hreadedRootIds.begin(),",
            "hreadedRootIds.end(),",
            "t->internalId)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.end",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.begin",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eplaceWith.key",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ibling != threading.end())"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.find",
          "args": [
            "eplaceWith->children[i])"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eplaceWith->children.size",
          "args": [],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->children.removeFirst",
          "args": [],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->children.first",
          "args": [],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arent->children[it->offset] == it->internalId)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "eplaceWith != threading.end())"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ibling->offset >= 0)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ibling != threading.end())"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent->children.end",
          "args": [],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.erase",
          "args": [
            "t)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.removeOne",
          "args": [
            "t->internalId)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent->children.erase",
          "args": [
            "hildIt)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->children.isEmpty",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hildIt - parent->children.begin() == it->offset)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent->children.begin",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hildIt != parent->children.end())"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent->children.end",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Find(",
          "args": [
            "arent->children.begin(),",
            "arent->children.end(),",
            "t->internalId)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent->children.end",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent->children.begin",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arent != threading.end())"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ending.end",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ending.begin",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.keys",
          "args": [],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::pruneTree()\n  {\n      // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n      // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n      // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n      // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n      QList<uint> pending = threading.keys();\n      for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n          // Convert to the hashmap\n          // The \"it\" iterator point to the current node in the threading mapping\n          QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n          if (it == threading.end()) {\n              // We've already seen this node, that's due to promoting\n              ++id;\n              continue;\n          }\n  \n          if (it->internalId == 0) {\n              // A special root item; we should not delete that one :)\n              ++id;\n              continue;\n          }\n          if (it->ptr) {\n              // regular and valid message -> skip\n              ++id;\n          } else {\n              // a fake one\n  \n              // each node has a parent\n              QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n              Q_ASSERT(parent != threading.end());\n  \n              // and the node itself has to be found in its parent's children\n              QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n              Q_ASSERT(childIt != parent->children.end());\n              // Check that its offset is correct\n              Q_ASSERT(childIt - parent->children.begin() == it->offset);\n  \n              if (it->children.isEmpty()) {\n                  // This is a leaf node, so we can just remove it\n                  childIt = parent->children.erase(childIt);\n                  threadedRootIds.removeOne(it->internalId);\n                  threading.erase(it);\n                  ++id;\n  \n                  // Update offsets of all further nodes, siblings to the one we've just deleted\n                  while (childIt != parent->children.end()) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                      Q_ASSERT(sibling != threading.end());\n                      --sibling->offset;\n                      Q_ASSERT(sibling->offset >= 0);\n                      ++childIt;\n                  }\n              } else {\n                  // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                  // to replace this node.\n                  QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                  Q_ASSERT(replaceWith != threading.end());\n  \n                  // Make sure that the offsets are still correct\n                  Q_ASSERT(parent->children[it->offset] == it->internalId);\n  \n                  // Replace the node\n                  replaceWith->offset = it->offset;\n                  *childIt = it->children.first();\n                  replaceWith->parent = parent->internalId;\n  \n                  // Now merge the lists of children\n                  it->children.removeFirst();\n                  replaceWith->children = replaceWith->children + it->children;\n  \n                  // Fix parent and offset information of all children of the replacement node\n                  for (int i = 0; i < replaceWith->children.size(); ++i) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                      Q_ASSERT(sibling != threading.end());\n  \n                      sibling->parent = replaceWith.key();\n                      sibling->offset = i;\n                  }\n  \n                  if (parent->internalId == 0) {\n                      // Update the list of all thread roots\n                      QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                      if (rootIt != threadedRootIds.end())\n                          *rootIt = replaceWith->internalId;\n                  }\n  \n                  // Now that all references are gone, remove the original node\n                  threading.erase(it);\n  \n                  if (!replaceWith->ptr) {\n                      // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                      // because we've already processed the current item and are completely done with it. The worst which can\n                      // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                      *id = replaceWith.key();\n                  }\n              }\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "updatePersistentIndexesPhase2(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1027-1050",
    "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n{\n    Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n    QList<QModelIndex> updatedIndexes;\n    for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n        QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n        if (ptrIt == ptrToInternal.constEnd()) {\n            // That message is no longer there\n            updatedIndexes.append(QModelIndex());\n            continue;\n        }\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n        if (it == threading.constEnd()) {\n            // Filtering doesn't accept this index, let's declare it dead\n            updatedIndexes.append(QModelIndex());\n        } else {\n            updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n        }\n    }\n    Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n    changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n    oldPersistentIndexes.clear();\n    oldPtrs.clear();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ldPtrs.clear",
          "args": [],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hangePersistentIndexList(",
          "args": [
            "ldPersistentIndexes,",
            "pdatedIndexes)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ldPersistentIndexes.size() == updatedIndexes.size())"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatedIndexes.size",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldPersistentIndexes.size",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatedIndexes.append",
          "args": [
            "reateIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId))"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "t->offset,",
            "ldPersistentIndexes[i].column(),",
            "t->internalId)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldPersistentIndexes[i].column",
          "args": [],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatedIndexes.append",
          "args": [
            "ModelIndex())"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "ptrIt)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatedIndexes.append",
          "args": [
            "ModelIndex())"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constEnd",
          "args": [],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constFind",
          "args": [
            "ldPtrs[i])"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldPersistentIndexes.size",
          "args": [],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ldPersistentIndexes.size() == oldPtrs.size())"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldPtrs.size",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldPersistentIndexes.size",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n  {\n      Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n      QList<QModelIndex> updatedIndexes;\n      for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n          QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n          if (ptrIt == ptrToInternal.constEnd()) {\n              // That message is no longer there\n              updatedIndexes.append(QModelIndex());\n              continue;\n          }\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n          if (it == threading.constEnd()) {\n              // Filtering doesn't accept this index, let's declare it dead\n              updatedIndexes.append(QModelIndex());\n          } else {\n              updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n          }\n      }\n      Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n      changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n      oldPersistentIndexes.clear();\n      oldPtrs.clear();\n  }\n}"
  },
  {
    "function_name": "updatePersistentIndexesPhase1(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "1005-1024",
    "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n{\n    oldPersistentIndexes = persistentIndexList();\n    oldPtrs.clear();\n    Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n        // the index could get invalidated by the pruneTree() or something else manipulating our threading\n        bool isOk = idx.isValid() && threading.contains(idx.internalId());\n        if (!isOk) {\n            oldPtrs << 0;\n            continue;\n        }\n        QModelIndex translated = mapToSource(idx);\n        if (!translated.isValid()) {\n            // another stale item\n            oldPtrs << 0;\n            continue;\n        }\n        oldPtrs << translated.internalPointer();\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ranslated.internalPointer",
          "args": [],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.isValid",
          "args": [],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "apToSource(",
          "args": [
            "dx)"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "mapToSource(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "232-253",
          "snippet": "ModelIndex ThreadingMsgListModel::mapToSource(const QModelIndex &proxyIndex) const\n{\n    if (!proxyIndex.isValid() || !proxyIndex.internalId())\n        return QModelIndex();\n\n    if (threading.isEmpty())\n        return QModelIndex();\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel());\n    Q_ASSERT(msgList);\n\n    QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(proxyIndex.internalId());\n    if (node == threading.constEnd())\n        return QModelIndex();\n\n    if (node->ptr) {\n        return msgList->createIndex(node->ptr->row(), proxyIndex.column(), node->ptr);\n    } else {\n        // it's a fake message\n        return QModelIndex();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::mapToSource(const QModelIndex &proxyIndex) const\n  {\n      if (!proxyIndex.isValid() || !proxyIndex.internalId())\n          return QModelIndex();\n  \n      if (threading.isEmpty())\n          return QModelIndex();\n  \n      Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel());\n      Q_ASSERT(msgList);\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(proxyIndex.internalId());\n      if (node == threading.constEnd())\n          return QModelIndex();\n  \n      if (node->ptr) {\n          return msgList->createIndex(node->ptr->row(), proxyIndex.column(), node->ptr);\n      } else {\n          // it's a fake message\n          return QModelIndex();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading.contains",
          "args": [
            "dx.internalId())"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx.internalId",
          "args": [],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldPtrs.clear",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ersistentIndexList(",
          "args": [],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n  {\n      oldPersistentIndexes = persistentIndexList();\n      oldPtrs.clear();\n      Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n          // the index could get invalidated by the pruneTree() or something else manipulating our threading\n          bool isOk = idx.isValid() && threading.contains(idx.internalId());\n          if (!isOk) {\n              oldPtrs << 0;\n              continue;\n          }\n          QModelIndex translated = mapToSource(idx);\n          if (!translated.isValid()) {\n              // another stale item\n              oldPtrs << 0;\n              continue;\n          }\n          oldPtrs << translated.internalPointer();\n      }\n  }\n}"
  },
  {
    "function_name": "registerThreading(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "967-1002",
    "snippet": "oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n{\n    Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n        uint nodeId;\n        QHash<uint,void *>::const_iterator ptrIt;\n        if (node.num == 0 ||\n                (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n            // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n            // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n            // expunged after the untagged THREAD was received, but before the tagged OK.\n            // We cannot just ignore this node, though, because it might have some children which we would otherwise\n            // simply hide.\n            // The ptrIt which is initialized by the condition is used in the else branch.\n            ThreadNodeInfo fake;\n            fake.internalId = ++threadingHelperLastId;\n            fake.parent = parentId;\n            Q_ASSERT(threading.contains(parentId));\n            // The child will be registered to the list of parent's children after the if/else branch\n            threading[ fake.internalId ] = fake;\n            nodeId = fake.internalId;\n        } else {\n            QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n            // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n            // That is however non-issue, as we pre-create nodes for all messages beforehand.\n            Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n            nodeId = *nodeIt;\n            // This is needed for the incremental stuff\n            threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n        }\n        threading[nodeId].offset = threading[parentId].children.size();\n        threading[ parentId ].children.append(nodeId);\n        threading[ nodeId ].parent = parentId;\n        usedNodes.insert(nodeId);\n        registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "egisterThreading(",
          "args": [
            "ode.children,",
            "odeId,",
            "idToPtr,",
            "sedNodes)"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "registerThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "967-1002",
          "snippet": "oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n{\n    Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n        uint nodeId;\n        QHash<uint,void *>::const_iterator ptrIt;\n        if (node.num == 0 ||\n                (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n            // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n            // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n            // expunged after the untagged THREAD was received, but before the tagged OK.\n            // We cannot just ignore this node, though, because it might have some children which we would otherwise\n            // simply hide.\n            // The ptrIt which is initialized by the condition is used in the else branch.\n            ThreadNodeInfo fake;\n            fake.internalId = ++threadingHelperLastId;\n            fake.parent = parentId;\n            Q_ASSERT(threading.contains(parentId));\n            // The child will be registered to the list of parent's children after the if/else branch\n            threading[ fake.internalId ] = fake;\n            nodeId = fake.internalId;\n        } else {\n            QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n            // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n            // That is however non-issue, as we pre-create nodes for all messages beforehand.\n            Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n            nodeId = *nodeIt;\n            // This is needed for the incremental stuff\n            threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n        }\n        threading[nodeId].offset = threading[parentId].children.size();\n        threading[ parentId ].children.append(nodeId);\n        threading[ nodeId ].parent = parentId;\n        usedNodes.insert(nodeId);\n        registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sedNodes.insert",
          "args": [
            "odeId)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[ parentId ].children.append",
          "args": [
            "odeId)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[parentId].children.size",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem*>",
          "args": [
            "ptrIt)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odeIt != ptrToInternal.constEnd())"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constEnd",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constFind",
          "args": [
            "ptrIt)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hreading.contains(parentId))"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.contains",
          "args": [
            "arentId)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idToPtr.constEnd",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idToPtr.find",
          "args": [
            "ode.num)"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n  {\n      Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n          uint nodeId;\n          QHash<uint,void *>::const_iterator ptrIt;\n          if (node.num == 0 ||\n                  (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n              // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n              // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n              // expunged after the untagged THREAD was received, but before the tagged OK.\n              // We cannot just ignore this node, though, because it might have some children which we would otherwise\n              // simply hide.\n              // The ptrIt which is initialized by the condition is used in the else branch.\n              ThreadNodeInfo fake;\n              fake.internalId = ++threadingHelperLastId;\n              fake.parent = parentId;\n              Q_ASSERT(threading.contains(parentId));\n              // The child will be registered to the list of parent's children after the if/else branch\n              threading[ fake.internalId ] = fake;\n              nodeId = fake.internalId;\n          } else {\n              QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n              // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n              // That is however non-issue, as we pre-create nodes for all messages beforehand.\n              Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n              nodeId = *nodeIt;\n              // This is needed for the incremental stuff\n              threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n          }\n          threading[nodeId].offset = threading[parentId].children.size();\n          threading[ parentId ].children.append(nodeId);\n          threading[ nodeId ].parent = parentId;\n          usedNodes.insert(nodeId);\n          registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n      }\n  }\n}"
  },
  {
    "function_name": "applyThreading(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "882-965",
    "snippet": "oid ThreadingMsgListModel::applyThreading(const QVector<Imap::Responses::ThreadingNode> &mapping)\n{\n    if (! unknownUids.isEmpty()) {\n        // Some messages have UID zero, which means that they weren't loaded yet. Too bad.\n        logTrace(QString::fromUtf8(\"%1 messages have 0 UID\").arg(unknownUids.size()));\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n\n    updatePersistentIndexesPhase1();\n\n    threading.clear();\n    ptrToInternal.clear();\n    // Default-construct the root node\n    threading[ 0 ].ptr = 0;\n\n    // At first, initialize threading nodes for all messages which are right now available in the mailbox.\n    // We risk that we will have to delete some of them later on, but this is likely better than doing a lookup\n    // for each UID individually (remember, the THREAD response might contain UIDs in crazy order).\n    int upstreamMessages = sourceModel()->rowCount();\n    QHash<uint,void *> uidToPtrCache;\n    QSet<uint> usedNodes;\n    uidToPtrCache.reserve(upstreamMessages);\n    threading.reserve(upstreamMessages);\n    ptrToInternal.reserve(upstreamMessages);\n\n    if (upstreamMessages) {\n        // Work with pointers instead going through the MVC API for performance.\n        // This matters (at least that's what by benchmarks said).\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n        for (int i = 0; i < upstreamMessages; ++i) {\n            ThreadNodeInfo node;\n            node.uid = dynamic_cast<TreeItemMessage *>(list->m_children[i])->uid();\n            if (! node.uid) {\n                throw UnknownMessageIndex(\"Encountered a message with zero UID when threading. This is a bug in Trojita, sorry.\");\n            }\n\n            node.internalId = i + 1;\n            node.ptr = list->m_children[i];\n            uidToPtrCache[node.uid] = node.ptr;\n            threadingHelperLastId = node.internalId;\n            // We're creating a new node here\n            Q_ASSERT(!threading.contains(node.internalId));\n            threading[ node.internalId ] = node;\n            ptrToInternal[ node.ptr ] = node.internalId;\n        }\n    }\n\n    // Mark the root node as always present\n    usedNodes.insert(0);\n\n    // Set up parents and find the list of all used nodes\n    registerThreading(mapping, 0, uidToPtrCache, usedNodes);\n\n    // Now remove all messages which were not referenced in the THREAD response from our mapping\n    QHash<uint,ThreadNodeInfo>::iterator it = threading.begin();\n    while (it != threading.end()) {\n        if (usedNodes.contains(it.key())) {\n            // this message should be shown\n            ++it;\n        } else {\n            // this message is not included in the list of messages actually to be shown\n            ptrToInternal.remove(it->ptr);\n            it = threading.erase(it);\n        }\n    }\n    pruneTree();\n    updatePersistentIndexesPhase2();\n    if (rowCount())\n        threadedRootIds = threading[0].children;\n    emit layoutChanged();\n\n    // If the sorting was active before, we shall reactivate it now\n    searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "earchSortPreferenceImplementation(",
          "args": [
            "_currentSearchConditions,",
            "_currentSortingCriteria,",
            "_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder)"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "searchSortPreferenceImplementation(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1245-1354",
          "snippet": "ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n{\n    Q_ASSERT(sourceModel());\n    if (!sourceModel()->rowCount()) {\n        return false;\n    }\n\n    const Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n\n    bool hasDisplaySort = false;\n    bool hasSort = false;\n    if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n        hasDisplaySort = true;\n        hasSort = true;\n    } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n        // just the regular sort\n        hasSort = true;\n    }\n\n    m_sortReverse = order == Qt::DescendingOrder;\n    QStringList sortOptions;\n    switch (criterium) {\n    case SORT_ARRIVAL:\n        sortOptions << QLatin1String(\"ARRIVAL\");\n        break;\n    case SORT_CC:\n        sortOptions << QLatin1String(\"CC\");\n        break;\n    case SORT_DATE:\n        sortOptions << QLatin1String(\"DATE\");\n        break;\n    case SORT_FROM:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n        break;\n    case SORT_SIZE:\n        sortOptions << QLatin1String(\"SIZE\");\n        break;\n    case SORT_SUBJECT:\n        sortOptions << QLatin1String(\"SUBJECT\");\n        break;\n    case SORT_TO:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n        break;\n    case SORT_NONE:\n        if (m_sortTask && m_sortTask->isPersistent() &&\n                (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n            // Any change shall result in us killing that sort task\n            m_sortTask->cancelSortingUpdates();\n        }\n\n        m_currentSortingCriteria = criterium;\n\n        if (searchConditions.isEmpty()) {\n            // This operation is special, it will immediately restore the original shape of the mailbox\n            m_currentSearchConditions = searchConditions;\n            calculateNullSort();\n            applySort();\n            return true;\n        } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n            // We have to update our search conditions\n            m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                  QStringList());\n            connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n            connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n            connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                    this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n            m_currentSearchConditions = searchConditions;\n            m_searchValidity = RESULT_ASKED;\n        } else {\n            // A result of SEARCH has just arrived\n            Q_ASSERT(m_searchValidity == RESULT_FRESH);\n            applySort();\n        }\n\n        return true;\n    }\n\n    if (!hasSort) {\n        // sorting is completely unsupported\n        return false;\n    }\n\n    Q_ASSERT(!sortOptions.isEmpty());\n\n    if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n            m_searchValidity != RESULT_INVALIDATED) {\n        applySort();\n    } else {\n        m_currentSearchConditions = searchConditions;\n        m_currentSortingCriteria = criterium;\n        calculateNullSort();\n        applySort();\n\n        if (m_sortTask && m_sortTask->isPersistent())\n            m_sortTask->cancelSortingUpdates();\n\n        m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n        connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n        connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n        connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n        m_searchValidity = RESULT_ASKED;\n    }\n\n    return true;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n  {\n      Q_ASSERT(sourceModel());\n      if (!sourceModel()->rowCount()) {\n          return false;\n      }\n  \n      const Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n  \n      bool hasDisplaySort = false;\n      bool hasSort = false;\n      if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n          hasDisplaySort = true;\n          hasSort = true;\n      } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n          // just the regular sort\n          hasSort = true;\n      }\n  \n      m_sortReverse = order == Qt::DescendingOrder;\n      QStringList sortOptions;\n      switch (criterium) {\n      case SORT_ARRIVAL:\n          sortOptions << QLatin1String(\"ARRIVAL\");\n          break;\n      case SORT_CC:\n          sortOptions << QLatin1String(\"CC\");\n          break;\n      case SORT_DATE:\n          sortOptions << QLatin1String(\"DATE\");\n          break;\n      case SORT_FROM:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n          break;\n      case SORT_SIZE:\n          sortOptions << QLatin1String(\"SIZE\");\n          break;\n      case SORT_SUBJECT:\n          sortOptions << QLatin1String(\"SUBJECT\");\n          break;\n      case SORT_TO:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n          break;\n      case SORT_NONE:\n          if (m_sortTask && m_sortTask->isPersistent() &&\n                  (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n              // Any change shall result in us killing that sort task\n              m_sortTask->cancelSortingUpdates();\n          }\n  \n          m_currentSortingCriteria = criterium;\n  \n          if (searchConditions.isEmpty()) {\n              // This operation is special, it will immediately restore the original shape of the mailbox\n              m_currentSearchConditions = searchConditions;\n              calculateNullSort();\n              applySort();\n              return true;\n          } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n              // We have to update our search conditions\n              m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                    QStringList());\n              connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n              connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n              connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                      this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n              m_currentSearchConditions = searchConditions;\n              m_searchValidity = RESULT_ASKED;\n          } else {\n              // A result of SEARCH has just arrived\n              Q_ASSERT(m_searchValidity == RESULT_FRESH);\n              applySort();\n          }\n  \n          return true;\n      }\n  \n      if (!hasSort) {\n          // sorting is completely unsupported\n          return false;\n      }\n  \n      Q_ASSERT(!sortOptions.isEmpty());\n  \n      if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n              m_searchValidity != RESULT_INVALIDATED) {\n          applySort();\n      } else {\n          m_currentSearchConditions = searchConditions;\n          m_currentSortingCriteria = criterium;\n          calculateNullSort();\n          applySort();\n  \n          if (m_sortTask && m_sortTask->isPersistent())\n              m_sortTask->cancelSortingUpdates();\n  \n          m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n          connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n          connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n          connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                  this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n          m_searchValidity = RESULT_ASKED;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "owCount(",
          "args": [],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase2(",
          "args": [],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase2(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1027-1050",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n{\n    Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n    QList<QModelIndex> updatedIndexes;\n    for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n        QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n        if (ptrIt == ptrToInternal.constEnd()) {\n            // That message is no longer there\n            updatedIndexes.append(QModelIndex());\n            continue;\n        }\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n        if (it == threading.constEnd()) {\n            // Filtering doesn't accept this index, let's declare it dead\n            updatedIndexes.append(QModelIndex());\n        } else {\n            updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n        }\n    }\n    Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n    changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n    oldPersistentIndexes.clear();\n    oldPtrs.clear();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n  {\n      Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n      QList<QModelIndex> updatedIndexes;\n      for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n          QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n          if (ptrIt == ptrToInternal.constEnd()) {\n              // That message is no longer there\n              updatedIndexes.append(QModelIndex());\n              continue;\n          }\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n          if (it == threading.constEnd()) {\n              // Filtering doesn't accept this index, let's declare it dead\n              updatedIndexes.append(QModelIndex());\n          } else {\n              updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n          }\n      }\n      Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n      changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n      oldPersistentIndexes.clear();\n      oldPtrs.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runeTree(",
          "args": [],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "pruneTree(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1052-1151",
          "snippet": "oid ThreadingMsgListModel::pruneTree()\n{\n    // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n    // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n    // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n    // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n    QList<uint> pending = threading.keys();\n    for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n        // Convert to the hashmap\n        // The \"it\" iterator point to the current node in the threading mapping\n        QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n        if (it == threading.end()) {\n            // We've already seen this node, that's due to promoting\n            ++id;\n            continue;\n        }\n\n        if (it->internalId == 0) {\n            // A special root item; we should not delete that one :)\n            ++id;\n            continue;\n        }\n        if (it->ptr) {\n            // regular and valid message -> skip\n            ++id;\n        } else {\n            // a fake one\n\n            // each node has a parent\n            QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n            Q_ASSERT(parent != threading.end());\n\n            // and the node itself has to be found in its parent's children\n            QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n            Q_ASSERT(childIt != parent->children.end());\n            // Check that its offset is correct\n            Q_ASSERT(childIt - parent->children.begin() == it->offset);\n\n            if (it->children.isEmpty()) {\n                // This is a leaf node, so we can just remove it\n                childIt = parent->children.erase(childIt);\n                threadedRootIds.removeOne(it->internalId);\n                threading.erase(it);\n                ++id;\n\n                // Update offsets of all further nodes, siblings to the one we've just deleted\n                while (childIt != parent->children.end()) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                    Q_ASSERT(sibling != threading.end());\n                    --sibling->offset;\n                    Q_ASSERT(sibling->offset >= 0);\n                    ++childIt;\n                }\n            } else {\n                // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                // to replace this node.\n                QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                Q_ASSERT(replaceWith != threading.end());\n\n                // Make sure that the offsets are still correct\n                Q_ASSERT(parent->children[it->offset] == it->internalId);\n\n                // Replace the node\n                replaceWith->offset = it->offset;\n                *childIt = it->children.first();\n                replaceWith->parent = parent->internalId;\n\n                // Now merge the lists of children\n                it->children.removeFirst();\n                replaceWith->children = replaceWith->children + it->children;\n\n                // Fix parent and offset information of all children of the replacement node\n                for (int i = 0; i < replaceWith->children.size(); ++i) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                    Q_ASSERT(sibling != threading.end());\n\n                    sibling->parent = replaceWith.key();\n                    sibling->offset = i;\n                }\n\n                if (parent->internalId == 0) {\n                    // Update the list of all thread roots\n                    QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                    if (rootIt != threadedRootIds.end())\n                        *rootIt = replaceWith->internalId;\n                }\n\n                // Now that all references are gone, remove the original node\n                threading.erase(it);\n\n                if (!replaceWith->ptr) {\n                    // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                    // because we've already processed the current item and are completely done with it. The worst which can\n                    // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                    *id = replaceWith.key();\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::pruneTree()\n  {\n      // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n      // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n      // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n      // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n      QList<uint> pending = threading.keys();\n      for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n          // Convert to the hashmap\n          // The \"it\" iterator point to the current node in the threading mapping\n          QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n          if (it == threading.end()) {\n              // We've already seen this node, that's due to promoting\n              ++id;\n              continue;\n          }\n  \n          if (it->internalId == 0) {\n              // A special root item; we should not delete that one :)\n              ++id;\n              continue;\n          }\n          if (it->ptr) {\n              // regular and valid message -> skip\n              ++id;\n          } else {\n              // a fake one\n  \n              // each node has a parent\n              QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n              Q_ASSERT(parent != threading.end());\n  \n              // and the node itself has to be found in its parent's children\n              QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n              Q_ASSERT(childIt != parent->children.end());\n              // Check that its offset is correct\n              Q_ASSERT(childIt - parent->children.begin() == it->offset);\n  \n              if (it->children.isEmpty()) {\n                  // This is a leaf node, so we can just remove it\n                  childIt = parent->children.erase(childIt);\n                  threadedRootIds.removeOne(it->internalId);\n                  threading.erase(it);\n                  ++id;\n  \n                  // Update offsets of all further nodes, siblings to the one we've just deleted\n                  while (childIt != parent->children.end()) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                      Q_ASSERT(sibling != threading.end());\n                      --sibling->offset;\n                      Q_ASSERT(sibling->offset >= 0);\n                      ++childIt;\n                  }\n              } else {\n                  // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                  // to replace this node.\n                  QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                  Q_ASSERT(replaceWith != threading.end());\n  \n                  // Make sure that the offsets are still correct\n                  Q_ASSERT(parent->children[it->offset] == it->internalId);\n  \n                  // Replace the node\n                  replaceWith->offset = it->offset;\n                  *childIt = it->children.first();\n                  replaceWith->parent = parent->internalId;\n  \n                  // Now merge the lists of children\n                  it->children.removeFirst();\n                  replaceWith->children = replaceWith->children + it->children;\n  \n                  // Fix parent and offset information of all children of the replacement node\n                  for (int i = 0; i < replaceWith->children.size(); ++i) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                      Q_ASSERT(sibling != threading.end());\n  \n                      sibling->parent = replaceWith.key();\n                      sibling->offset = i;\n                  }\n  \n                  if (parent->internalId == 0) {\n                      // Update the list of all thread roots\n                      QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                      if (rootIt != threadedRootIds.end())\n                          *rootIt = replaceWith->internalId;\n                  }\n  \n                  // Now that all references are gone, remove the original node\n                  threading.erase(it);\n  \n                  if (!replaceWith->ptr) {\n                      // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                      // because we've already processed the current item and are completely done with it. The worst which can\n                      // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                      *id = replaceWith.key();\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading.erase",
          "args": [
            "t)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.remove",
          "args": [
            "t->ptr)"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sedNodes.contains",
          "args": [
            "t.key())"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.begin",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egisterThreading(",
          "args": [
            "apping,",
            ",",
            "idToPtrCache,",
            "sedNodes)"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "registerThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "967-1002",
          "snippet": "oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n{\n    Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n        uint nodeId;\n        QHash<uint,void *>::const_iterator ptrIt;\n        if (node.num == 0 ||\n                (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n            // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n            // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n            // expunged after the untagged THREAD was received, but before the tagged OK.\n            // We cannot just ignore this node, though, because it might have some children which we would otherwise\n            // simply hide.\n            // The ptrIt which is initialized by the condition is used in the else branch.\n            ThreadNodeInfo fake;\n            fake.internalId = ++threadingHelperLastId;\n            fake.parent = parentId;\n            Q_ASSERT(threading.contains(parentId));\n            // The child will be registered to the list of parent's children after the if/else branch\n            threading[ fake.internalId ] = fake;\n            nodeId = fake.internalId;\n        } else {\n            QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n            // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n            // That is however non-issue, as we pre-create nodes for all messages beforehand.\n            Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n            nodeId = *nodeIt;\n            // This is needed for the incremental stuff\n            threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n        }\n        threading[nodeId].offset = threading[parentId].children.size();\n        threading[ parentId ].children.append(nodeId);\n        threading[ nodeId ].parent = parentId;\n        usedNodes.insert(nodeId);\n        registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n  {\n      Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n          uint nodeId;\n          QHash<uint,void *>::const_iterator ptrIt;\n          if (node.num == 0 ||\n                  (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n              // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n              // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n              // expunged after the untagged THREAD was received, but before the tagged OK.\n              // We cannot just ignore this node, though, because it might have some children which we would otherwise\n              // simply hide.\n              // The ptrIt which is initialized by the condition is used in the else branch.\n              ThreadNodeInfo fake;\n              fake.internalId = ++threadingHelperLastId;\n              fake.parent = parentId;\n              Q_ASSERT(threading.contains(parentId));\n              // The child will be registered to the list of parent's children after the if/else branch\n              threading[ fake.internalId ] = fake;\n              nodeId = fake.internalId;\n          } else {\n              QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n              // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n              // That is however non-issue, as we pre-create nodes for all messages beforehand.\n              Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n              nodeId = *nodeIt;\n              // This is needed for the incremental stuff\n              threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n          }\n          threading[nodeId].offset = threading[parentId].children.size();\n          threading[ parentId ].children.append(nodeId);\n          threading[ nodeId ].parent = parentId;\n          usedNodes.insert(nodeId);\n          registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sedNodes.insert",
          "args": [
            ")"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "threading.contains(node.internalId))"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.contains",
          "args": [
            "ode.internalId)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownMessageIndex(",
          "args": [
            "Encountered a message with zero UID when threading. This is a bug in Trojita, sorry.\")"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage *>",
          "args": [],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "irstMessagePtr->parent())"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstMessagePtr->parent",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstMessagePtr == firstMessageIndex.internalPointer())"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstMessageIndex.internalPointer",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstMessagePtr)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::realTreeItem(",
          "args": [
            "irstMessageIndex,",
            "realModel)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstMessageIndex.isValid())"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstMessageIndex.isValid",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.reserve",
          "args": [
            "pstreamMessages)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.reserve",
          "args": [
            "pstreamMessages)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idToPtrCache.reserve",
          "args": [
            "pstreamMessages)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.clear",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase1(",
          "args": [],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase1(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1005-1024",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n{\n    oldPersistentIndexes = persistentIndexList();\n    oldPtrs.clear();\n    Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n        // the index could get invalidated by the pruneTree() or something else manipulating our threading\n        bool isOk = idx.isValid() && threading.contains(idx.internalId());\n        if (!isOk) {\n            oldPtrs << 0;\n            continue;\n        }\n        QModelIndex translated = mapToSource(idx);\n        if (!translated.isValid()) {\n            // another stale item\n            oldPtrs << 0;\n            continue;\n        }\n        oldPtrs << translated.internalPointer();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n  {\n      oldPersistentIndexes = persistentIndexList();\n      oldPtrs.clear();\n      Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n          // the index could get invalidated by the pruneTree() or something else manipulating our threading\n          bool isOk = idx.isValid() && threading.contains(idx.internalId());\n          if (!isOk) {\n              oldPtrs << 0;\n              continue;\n          }\n          QModelIndex translated = mapToSource(idx);\n          if (!translated.isValid()) {\n              // another stale item\n              oldPtrs << 0;\n              continue;\n          }\n          oldPtrs << translated.internalPointer();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "String::fromUtf8(\"%1 messages have 0 UID\").arg(unknownUids.size()))"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1205-1226",
          "snippet": "oid ThreadingMsgListModel::logTrace(const QString &message)\n{\n    if (!sourceModel()) {\n        qDebug() << message;\n        return;\n    }\n    QModelIndex idx = sourceModel()->index(0, 0);\n    if (!idx.isValid()) {\n        qDebug() << message;\n        return;\n    }\n\n    // Got to find out the real model and also translate the index to one belonging to a real Model\n    Q_ASSERT(idx.model());\n    const Model *realModel;\n    QModelIndex realIndex;\n    Model::realTreeItem(idx, &realModel, &realIndex);\n    Q_ASSERT(realModel);\n    QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n    const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n            QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::logTrace(const QString &message)\n  {\n      if (!sourceModel()) {\n          qDebug() << message;\n          return;\n      }\n      QModelIndex idx = sourceModel()->index(0, 0);\n      if (!idx.isValid()) {\n          qDebug() << message;\n          return;\n      }\n  \n      // Got to find out the real model and also translate the index to one belonging to a real Model\n      Q_ASSERT(idx.model());\n      const Model *realModel;\n      QModelIndex realIndex;\n      Model::realTreeItem(idx, &realModel, &realIndex);\n      Q_ASSERT(realModel);\n      QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n      const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n              QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "nknownUids.size())"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownUids.size",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "%1 messages have 0 UID\")"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownUids.isEmpty",
          "args": [],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::applyThreading(const QVector<Imap::Responses::ThreadingNode> &mapping)\n  {\n      if (! unknownUids.isEmpty()) {\n          // Some messages have UID zero, which means that they weren't loaded yet. Too bad.\n          logTrace(QString::fromUtf8(\"%1 messages have 0 UID\").arg(unknownUids.size()));\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n  \n      updatePersistentIndexesPhase1();\n  \n      threading.clear();\n      ptrToInternal.clear();\n      // Default-construct the root node\n      threading[ 0 ].ptr = 0;\n  \n      // At first, initialize threading nodes for all messages which are right now available in the mailbox.\n      // We risk that we will have to delete some of them later on, but this is likely better than doing a lookup\n      // for each UID individually (remember, the THREAD response might contain UIDs in crazy order).\n      int upstreamMessages = sourceModel()->rowCount();\n      QHash<uint,void *> uidToPtrCache;\n      QSet<uint> usedNodes;\n      uidToPtrCache.reserve(upstreamMessages);\n      threading.reserve(upstreamMessages);\n      ptrToInternal.reserve(upstreamMessages);\n  \n      if (upstreamMessages) {\n          // Work with pointers instead going through the MVC API for performance.\n          // This matters (at least that's what by benchmarks said).\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n          for (int i = 0; i < upstreamMessages; ++i) {\n              ThreadNodeInfo node;\n              node.uid = dynamic_cast<TreeItemMessage *>(list->m_children[i])->uid();\n              if (! node.uid) {\n                  throw UnknownMessageIndex(\"Encountered a message with zero UID when threading. This is a bug in Trojita, sorry.\");\n              }\n  \n              node.internalId = i + 1;\n              node.ptr = list->m_children[i];\n              uidToPtrCache[node.uid] = node.ptr;\n              threadingHelperLastId = node.internalId;\n              // We're creating a new node here\n              Q_ASSERT(!threading.contains(node.internalId));\n              threading[ node.internalId ] = node;\n              ptrToInternal[ node.ptr ] = node.internalId;\n          }\n      }\n  \n      // Mark the root node as always present\n      usedNodes.insert(0);\n  \n      // Set up parents and find the list of all used nodes\n      registerThreading(mapping, 0, uidToPtrCache, usedNodes);\n  \n      // Now remove all messages which were not referenced in the THREAD response from our mapping\n      QHash<uint,ThreadNodeInfo>::iterator it = threading.begin();\n      while (it != threading.end()) {\n          if (usedNodes.contains(it.key())) {\n              // this message should be shown\n              ++it;\n          } else {\n              // this message is not included in the list of messages actually to be shown\n              ptrToInternal.remove(it->ptr);\n              it = threading.erase(it);\n          }\n      }\n      pruneTree();\n      updatePersistentIndexesPhase2();\n      if (rowCount())\n          threadedRootIds = threading[0].children;\n      emit layoutChanged();\n  \n      // If the sorting was active before, we shall reactivate it now\n      searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n  }\n}"
  },
  {
    "function_name": "calculateNullSort(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "866-880",
    "snippet": "oid ThreadingMsgListModel::calculateNullSort()\n{\n    m_currentSortResult.clear();\n#if QT_VERSION >= 0x040700\n    m_currentSortResult.reserve(threadedRootIds.size());\n#endif\n    Q_FOREACH(const uint internalId, threadedRootIds) {\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(internalId);\n        if (it == threading.constEnd())\n            continue;\n        if (it->uid)\n            m_currentSortResult.append(it->uid);\n    }\n    m_searchValidity = RESULT_FRESH;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_currentSortResult.append",
          "args": [
            "t->uid)"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "nternalId)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.reserve",
          "args": [
            "hreadedRootIds.size())"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.size",
          "args": [],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.clear",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::calculateNullSort()\n  {\n      m_currentSortResult.clear();\n  #if QT_VERSION >= 0x040700\n      m_currentSortResult.reserve(threadedRootIds.size());\n  #endif\n      Q_FOREACH(const uint internalId, threadedRootIds) {\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(internalId);\n          if (it == threading.constEnd())\n              continue;\n          if (it->uid)\n              m_currentSortResult.append(it->uid);\n      }\n      m_searchValidity = RESULT_FRESH;\n  }\n}"
  },
  {
    "function_name": "slotSortingIncrementalUpdate(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "827-863",
    "snippet": "oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n{\n    for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n        switch (it->modification) {\n        case Responses::ESearch::ContextIncrementalItem::ADDTO:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                int offset = it->offset + i;\n                if (offset < 0 || offset >= m_currentSortResult.size()) {\n                    throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                }\n                m_currentSortResult.insert(offset, it->uids[i]);\n            }\n            break;\n\n        case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                if (it->offset == 0) {\n                    // When the offset is not given, we have to find it ourselves\n                    m_currentSortResult.removeOne(it->uids[i]);\n                } else {\n                    // We're given an offset, so let's make sure it is a correct one\n                    int offset = it->offset + i - 1;\n                    if (offset < 0 || offset >= m_currentSortResult.size()) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                    }\n                    if (m_currentSortResult[offset] != it->uids[i]) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                    }\n                    m_currentSortResult.removeAt(offset);\n                }\n            }\n            break;\n        }\n    }\n    m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.removeAt",
          "args": [
            "ffset)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxException(",
          "args": [
            "ESEARCH: REMOVEFROM UID mismatch\")"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "MailboxException(",
          "container": "ailboxException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Exceptions.cpp",
          "lines": "56-60",
          "snippet": "ailboxException::MailboxException(const char *const msg)\n{\n    m_msg = msg;\n    m_exceptionClass = \"MailboxException\";\n}",
          "includes": [
            "include \"Parser/Response.h\"",
            "include <QTextStream>\n#",
            "include \"Exceptions.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/Response.h\"\ninclude <QTextStream>\n#\ninclude \"Exceptions.h\"\n\nailboxException {\n  ailboxException::MailboxException(const char *const msg)\n  {\n      m_msg = msg;\n      m_exceptionClass = \"MailboxException\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_currentSortResult.size",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.removeOne",
          "args": [
            "t->uids[i])"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->uids.size",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.insert",
          "args": [
            "ffset,",
            "t->uids[i])"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.size",
          "args": [],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->uids.size",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdates.constEnd",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdates.constBegin",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n  {\n      for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n          switch (it->modification) {\n          case Responses::ESearch::ContextIncrementalItem::ADDTO:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  int offset = it->offset + i;\n                  if (offset < 0 || offset >= m_currentSortResult.size()) {\n                      throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                  }\n                  m_currentSortResult.insert(offset, it->uids[i]);\n              }\n              break;\n  \n          case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  if (it->offset == 0) {\n                      // When the offset is not given, we have to find it ourselves\n                      m_currentSortResult.removeOne(it->uids[i]);\n                  } else {\n                      // We're given an offset, so let's make sure it is a correct one\n                      int offset = it->offset + i - 1;\n                      if (offset < 0 || offset >= m_currentSortResult.size()) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                      }\n                      if (m_currentSortResult[offset] != it->uids[i]) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                      }\n                      m_currentSortResult.removeAt(offset);\n                  }\n              }\n              break;\n          }\n      }\n      m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
  },
  {
    "function_name": "slotSortingFailed(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "814-825",
    "snippet": "oid ThreadingMsgListModel::slotSortingFailed()\n{\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n    m_sortTask = 0;\n    m_sortReverse = false;\n    calculateNullSort();\n    applySort();\n    emit sortingFailed();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pplySort(",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "applySort(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1356-1414",
          "snippet": "oid ThreadingMsgListModel::applySort()\n{\n    if (!sourceModel()->rowCount()) {\n        // empty mailbox is a corner case and it's already sorted anyway\n        return;\n    }\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(realIndex.parent().parent().internalPointer()));\n    Q_ASSERT(mailbox);\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    QSet<uint> newlyUnreachable(threading[0].children.toSet());\n    threading[0].children.clear();\n#if QT_VERSION >= 0x040700\n    threading[0].children.reserve(m_currentSortResult.size());\n#endif\n\n    QSet<uint> allRootIds(threadedRootIds.toSet());\n\n    for (int i = 0; i < m_currentSortResult.size(); ++i) {\n        int offset = m_sortReverse ? m_currentSortResult.size() - 1 - i : i;\n        QList<TreeItemMessage *> messages = const_cast<Model*>(realModel)\n                ->findMessagesByUids(mailbox, QList<uint>() << m_currentSortResult[offset]);\n        if (messages.isEmpty()) {\n            // wrong UID, weird\n            continue;\n        }\n        Q_ASSERT(messages.size() == 1);\n        QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(messages.front());\n        Q_ASSERT(it != ptrToInternal.constEnd());\n        if (!allRootIds.contains(*it)) {\n            // not a thread root, so don't show it\n            continue;\n        }\n        threading[*it].offset = threading[0].children.size();\n        threading[0].children.append(*it);\n    }\n\n    // Now remove everything which is no longer reachable from the root of the thread mapping\n    // Start working on the top-level orphans\n    Q_FOREACH(const uint uid, threading[0].children) {\n        newlyUnreachable.remove(uid);\n    }\n    std::vector<uint> queue(newlyUnreachable.constBegin(), newlyUnreachable.constEnd());\n    for (std::vector<uint>::size_type i = 0; i < queue.size(); ++i) {\n        QHash<uint,ThreadNodeInfo>::iterator threadingIt = threading.find(queue[i]);\n        Q_ASSERT(threadingIt != threading.end());\n        queue.insert(queue.end(), threadingIt->children.constBegin(), threadingIt->children.constEnd());\n        threading.erase(threadingIt);\n    }\n\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::applySort()\n  {\n      if (!sourceModel()->rowCount()) {\n          // empty mailbox is a corner case and it's already sorted anyway\n          return;\n      }\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox*>(static_cast<TreeItem*>(realIndex.parent().parent().internalPointer()));\n      Q_ASSERT(mailbox);\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      QSet<uint> newlyUnreachable(threading[0].children.toSet());\n      threading[0].children.clear();\n  #if QT_VERSION >= 0x040700\n      threading[0].children.reserve(m_currentSortResult.size());\n  #endif\n  \n      QSet<uint> allRootIds(threadedRootIds.toSet());\n  \n      for (int i = 0; i < m_currentSortResult.size(); ++i) {\n          int offset = m_sortReverse ? m_currentSortResult.size() - 1 - i : i;\n          QList<TreeItemMessage *> messages = const_cast<Model*>(realModel)\n                  ->findMessagesByUids(mailbox, QList<uint>() << m_currentSortResult[offset]);\n          if (messages.isEmpty()) {\n              // wrong UID, weird\n              continue;\n          }\n          Q_ASSERT(messages.size() == 1);\n          QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(messages.front());\n          Q_ASSERT(it != ptrToInternal.constEnd());\n          if (!allRootIds.contains(*it)) {\n              // not a thread root, so don't show it\n              continue;\n          }\n          threading[*it].offset = threading[0].children.size();\n          threading[0].children.append(*it);\n      }\n  \n      // Now remove everything which is no longer reachable from the root of the thread mapping\n      // Start working on the top-level orphans\n      Q_FOREACH(const uint uid, threading[0].children) {\n          newlyUnreachable.remove(uid);\n      }\n      std::vector<uint> queue(newlyUnreachable.constBegin(), newlyUnreachable.constEnd());\n      for (std::vector<uint>::size_type i = 0; i < queue.size(); ++i) {\n          QHash<uint,ThreadNodeInfo>::iterator threadingIt = threading.find(queue[i]);\n          Q_ASSERT(threadingIt != threading.end());\n          queue.insert(queue.end(), threadingIt->children.constBegin(), threadingIt->children.constEnd());\n          threading.erase(threadingIt);\n      }\n  \n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alculateNullSort(",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "calculateNullSort(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "866-880",
          "snippet": "oid ThreadingMsgListModel::calculateNullSort()\n{\n    m_currentSortResult.clear();\n#if QT_VERSION >= 0x040700\n    m_currentSortResult.reserve(threadedRootIds.size());\n#endif\n    Q_FOREACH(const uint internalId, threadedRootIds) {\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(internalId);\n        if (it == threading.constEnd())\n            continue;\n        if (it->uid)\n            m_currentSortResult.append(it->uid);\n    }\n    m_searchValidity = RESULT_FRESH;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::calculateNullSort()\n  {\n      m_currentSortResult.clear();\n  #if QT_VERSION >= 0x040700\n      m_currentSortResult.reserve(threadedRootIds.size());\n  #endif\n      Q_FOREACH(const uint internalId, threadedRootIds) {\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(internalId);\n          if (it == threading.constEnd())\n              continue;\n          if (it->uid)\n              m_currentSortResult.append(it->uid);\n      }\n      m_searchValidity = RESULT_FRESH;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_sortTask,",
            ",",
            "his,",
            "LOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)))"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t))"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingIncrementalUpdate(",
          "args": [
            "map::Responses::ESearch::IncrementalContextData_t)"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingIncrementalUpdate(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "827-863",
          "snippet": "oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n{\n    for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n        switch (it->modification) {\n        case Responses::ESearch::ContextIncrementalItem::ADDTO:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                int offset = it->offset + i;\n                if (offset < 0 || offset >= m_currentSortResult.size()) {\n                    throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                }\n                m_currentSortResult.insert(offset, it->uids[i]);\n            }\n            break;\n\n        case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                if (it->offset == 0) {\n                    // When the offset is not given, we have to find it ourselves\n                    m_currentSortResult.removeOne(it->uids[i]);\n                } else {\n                    // We're given an offset, so let's make sure it is a correct one\n                    int offset = it->offset + i - 1;\n                    if (offset < 0 || offset >= m_currentSortResult.size()) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                    }\n                    if (m_currentSortResult[offset] != it->uids[i]) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                    }\n                    m_currentSortResult.removeAt(offset);\n                }\n            }\n            break;\n        }\n    }\n    m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n  {\n      for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n          switch (it->modification) {\n          case Responses::ESearch::ContextIncrementalItem::ADDTO:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  int offset = it->offset + i;\n                  if (offset < 0 || offset >= m_currentSortResult.size()) {\n                      throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                  }\n                  m_currentSortResult.insert(offset, it->uids[i]);\n              }\n              break;\n  \n          case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  if (it->offset == 0) {\n                      // When the offset is not given, we have to find it ourselves\n                      m_currentSortResult.removeOne(it->uids[i]);\n                  } else {\n                      // We're given an offset, so let's make sure it is a correct one\n                      int offset = it->offset + i - 1;\n                      if (offset < 0 || offset >= m_currentSortResult.size()) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                      }\n                      if (m_currentSortResult[offset] != it->uids[i]) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                      }\n                      m_currentSortResult.removeAt(offset);\n                  }\n              }\n              break;\n          }\n      }\n      m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_sortTask,",
            ",",
            "his,",
            "LOT(slotSortingFailed()))"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingFailed())"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingFailed(",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "814-825",
          "snippet": "oid ThreadingMsgListModel::slotSortingFailed()\n{\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n    m_sortTask = 0;\n    m_sortReverse = false;\n    calculateNullSort();\n    applySort();\n    emit sortingFailed();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_sortTask,",
            ",",
            "his,",
            "LOT(slotSortingAvailable(QList<uint>)))"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingAvailable(QList<uint>))"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingAvailable(",
          "args": [
            "List<uint>)"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "798-812",
          "snippet": "oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n{\n    if (!m_sortTask->isPersistent()) {\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n        m_sortTask = 0;\n    }\n\n    m_currentSortResult = uids;\n    if (m_searchValidity == RESULT_ASKED)\n        m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n  {\n      if (!m_sortTask->isPersistent()) {\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n  \n          m_sortTask = 0;\n      }\n  \n      m_currentSortResult = uids;\n      if (m_searchValidity == RESULT_ASKED)\n          m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingFailed()\n  {\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n  \n      m_sortTask = 0;\n      m_sortReverse = false;\n      calculateNullSort();\n      applySort();\n      emit sortingFailed();\n  }\n}"
  },
  {
    "function_name": "slotSortingAvailable(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "798-812",
    "snippet": "oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n{\n    if (!m_sortTask->isPersistent()) {\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n        m_sortTask = 0;\n    }\n\n    m_currentSortResult = uids;\n    if (m_searchValidity == RESULT_ASKED)\n        m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_sortTask,",
            ",",
            "his,",
            "LOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)))"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t))"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingIncrementalUpdate(",
          "args": [
            "map::Responses::ESearch::IncrementalContextData_t)"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingIncrementalUpdate(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "827-863",
          "snippet": "oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n{\n    for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n        switch (it->modification) {\n        case Responses::ESearch::ContextIncrementalItem::ADDTO:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                int offset = it->offset + i;\n                if (offset < 0 || offset >= m_currentSortResult.size()) {\n                    throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                }\n                m_currentSortResult.insert(offset, it->uids[i]);\n            }\n            break;\n\n        case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n            for (int i = 0; i < it->uids.size(); ++i)  {\n                if (it->offset == 0) {\n                    // When the offset is not given, we have to find it ourselves\n                    m_currentSortResult.removeOne(it->uids[i]);\n                } else {\n                    // We're given an offset, so let's make sure it is a correct one\n                    int offset = it->offset + i - 1;\n                    if (offset < 0 || offset >= m_currentSortResult.size()) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                    }\n                    if (m_currentSortResult[offset] != it->uids[i]) {\n                        throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                    }\n                    m_currentSortResult.removeAt(offset);\n                }\n            }\n            break;\n        }\n    }\n    m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingIncrementalUpdate(const Responses::ESearch::IncrementalContextData_t &updates)\n  {\n      for (Responses::ESearch::IncrementalContextData_t::const_iterator it = updates.constBegin(); it != updates.constEnd(); ++it) {\n          switch (it->modification) {\n          case Responses::ESearch::ContextIncrementalItem::ADDTO:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  int offset = it->offset + i;\n                  if (offset < 0 || offset >= m_currentSortResult.size()) {\n                      throw MailboxException(\"ESEARCH: ADDTO out of bounds\");\n                  }\n                  m_currentSortResult.insert(offset, it->uids[i]);\n              }\n              break;\n  \n          case Responses::ESearch::ContextIncrementalItem::REMOVEFROM:\n              for (int i = 0; i < it->uids.size(); ++i)  {\n                  if (it->offset == 0) {\n                      // When the offset is not given, we have to find it ourselves\n                      m_currentSortResult.removeOne(it->uids[i]);\n                  } else {\n                      // We're given an offset, so let's make sure it is a correct one\n                      int offset = it->offset + i - 1;\n                      if (offset < 0 || offset >= m_currentSortResult.size()) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM out of bounds\");\n                      }\n                      if (m_currentSortResult[offset] != it->uids[i]) {\n                          throw MailboxException(\"ESEARCH: REMOVEFROM UID mismatch\");\n                      }\n                      m_currentSortResult.removeAt(offset);\n                  }\n              }\n              break;\n          }\n      }\n      m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_sortTask,",
            ",",
            "his,",
            "LOT(slotSortingFailed()))"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingFailed())"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingFailed(",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "814-825",
          "snippet": "oid ThreadingMsgListModel::slotSortingFailed()\n{\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n    disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n    m_sortTask = 0;\n    m_sortReverse = false;\n    calculateNullSort();\n    applySort();\n    emit sortingFailed();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingFailed()\n  {\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n      disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n  \n      m_sortTask = 0;\n      m_sortReverse = false;\n      calculateNullSort();\n      applySort();\n      emit sortingFailed();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "_sortTask,",
            ",",
            "his,",
            "LOT(slotSortingAvailable(QList<uint>)))"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSortingAvailable(QList<uint>))"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSortingAvailable(",
          "args": [
            "List<uint>)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "slotSortingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "798-812",
          "snippet": "oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n{\n    if (!m_sortTask->isPersistent()) {\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n        disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n\n        m_sortTask = 0;\n    }\n\n    m_currentSortResult = uids;\n    if (m_searchValidity == RESULT_ASKED)\n        m_searchValidity = RESULT_FRESH;\n    wantThreading();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_sortTask->isPersistent",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotSortingAvailable(const QList<uint> &uids)\n  {\n      if (!m_sortTask->isPersistent()) {\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingAvailable(QList<uint>)));\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingFailed()));\n          disconnect(m_sortTask, 0, this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n  \n          m_sortTask = 0;\n      }\n  \n      m_currentSortResult = uids;\n      if (m_searchValidity == RESULT_ASKED)\n          m_searchValidity = RESULT_FRESH;\n      wantThreading();\n  }\n}"
  },
  {
    "function_name": "slotThreadingAvailable(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "774-796",
    "snippet": "oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n        const QStringList &searchCriteria,\n        const QVector<Imap::Responses::ThreadingNode> &mapping)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    const Model *model = 0;\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n\n    // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n    // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n    if (m_shallBeThreading)\n        wantThreading();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox.data(RoleMailboxName).toString(),",
            "apping)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox.data",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "ender(),",
            ",",
            "his,",
            "LOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)))"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotThreadingFailed(QModelIndex,QByteArray,QStringList))"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotThreadingFailed(",
          "args": [
            "ModelIndex,",
            "ByteArray,",
            "StringList)"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "slotThreadingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "758-772",
          "snippet": "oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    updateNoThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n  {\n      // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n      threadingInFlight = false;\n  \n      if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n          return;\n  \n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n  \n      updateNoThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ender(",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "sender(",
          "container": "neMessageModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/OneMessageModel.cpp",
          "lines": "134-137",
          "snippet": "VariantList OneMessageModel::sender() const\n{\n    return m_message.data(RoleMessageSender).toList();\n}",
          "includes": [
            "include \"SubtreeModel.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"FindInterestingPart.h\"\n#",
            "include \"kdeui-itemviews/kdescendantsproxymodel.h\"\n#",
            "include \"OneMessageModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"SubtreeModel.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"FindInterestingPart.h\"\n#\ninclude \"kdeui-itemviews/kdescendantsproxymodel.h\"\n#\ninclude \"OneMessageModel.h\"\n#\n\nneMessageModel {\n  VariantList OneMessageModel::sender() const\n  {\n      return m_message.data(RoleMessageSender).toList();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "ender(),",
            ",",
            "his,",
            "LOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)))"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>))"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotThreadingAvailable(",
          "args": [
            "ModelIndex,",
            "ByteArray,",
            "StringList,",
            "Vector<Imap::Responses::ThreadingNode>)"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "slotThreadingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "774-796",
          "snippet": "oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n        const QStringList &searchCriteria,\n        const QVector<Imap::Responses::ThreadingNode> &mapping)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    const Model *model = 0;\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n\n    // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n    // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n    if (m_shallBeThreading)\n        wantThreading();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "houldIgnoreThisThreadingResponse(",
          "args": [
            "ailbox,",
            "lgorithm,",
            "earchCriteria,",
            "model)"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "shouldIgnoreThisThreadingResponse(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "724-756",
          "snippet": "ool ThreadingMsgListModel::shouldIgnoreThisThreadingResponse(const QModelIndex &mailbox, const QByteArray &algorithm,\n        const QStringList &searchCriteria, const Model **realModel)\n{\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    if (!someMessage.isValid())\n        return true;\n    const Model *model;\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &model, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n    if (mailboxIndex != mailbox) {\n        // this is for another mailbox\n        return true;\n    }\n\n    if (algorithm != requestedAlgorithm) {\n        logTrace(QString::fromUtf8(\"Weird, asked for threading via %1 but got %2 instead -- ignoring\")\n                 .arg(QString::fromUtf8(requestedAlgorithm), QString::fromUtf8(algorithm)));\n        return true;\n    }\n\n    if (searchCriteria.size() != 1 || searchCriteria.front() != QLatin1String(\"ALL\")) {\n        QString buf;\n        QTextStream ss(&buf);\n        logTrace(QString::fromUtf8(\"Weird, requesting messages matching ALL, but got this instead: %1\")\n                 .arg(searchCriteria.join(QLatin1String(\", \"))));\n        return true;\n    }\n\n    if (realModel)\n        *realModel = model;\n    return false;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::shouldIgnoreThisThreadingResponse(const QModelIndex &mailbox, const QByteArray &algorithm,\n          const QStringList &searchCriteria, const Model **realModel)\n  {\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      if (!someMessage.isValid())\n          return true;\n      const Model *model;\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &model, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n      if (mailboxIndex != mailbox) {\n          // this is for another mailbox\n          return true;\n      }\n  \n      if (algorithm != requestedAlgorithm) {\n          logTrace(QString::fromUtf8(\"Weird, asked for threading via %1 but got %2 instead -- ignoring\")\n                   .arg(QString::fromUtf8(requestedAlgorithm), QString::fromUtf8(algorithm)));\n          return true;\n      }\n  \n      if (searchCriteria.size() != 1 || searchCriteria.front() != QLatin1String(\"ALL\")) {\n          QString buf;\n          QTextStream ss(&buf);\n          logTrace(QString::fromUtf8(\"Weird, requesting messages matching ALL, but got this instead: %1\")\n                   .arg(searchCriteria.join(QLatin1String(\", \"))));\n          return true;\n      }\n  \n      if (realModel)\n          *realModel = model;\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n          const QStringList &searchCriteria,\n          const QVector<Imap::Responses::ThreadingNode> &mapping)\n  {\n      // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n      threadingInFlight = false;\n  \n      const Model *model = 0;\n      if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n          return;\n  \n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n  \n      model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n  \n      // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n      // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n      if (m_shallBeThreading)\n          wantThreading();\n  }\n}"
  },
  {
    "function_name": "slotThreadingFailed(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "758-772",
    "snippet": "oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    updateNoThreading();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdateNoThreading(",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "updateNoThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "433-501",
          "snippet": "oid ThreadingMsgListModel::updateNoThreading()\n{\n    threadingHelperLastId = 0;\n\n    if (!sourceModel()) {\n        // Maybe we got reset because the parent model is no longer here...\n        if (! threading.isEmpty()) {\n            beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n            threading.clear();\n            ptrToInternal.clear();\n            endRemoveRows();\n        }\n        unknownUids.clear();\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n\n    int upstreamMessages = sourceModel()->rowCount();\n    QList<uint> allIds;\n    QHash<uint,ThreadNodeInfo> newThreading;\n    QHash<void *,uint> newPtrToInternal;\n\n    if (upstreamMessages) {\n        // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n        // This improves the speed of the testSortingPerformance benchmark by 18%.\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n\n        for (int i = 0; i < upstreamMessages; ++i) {\n            TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n            Q_ASSERT(ptr);\n            ThreadNodeInfo node;\n            node.internalId = i + 1;\n            node.uid = ptr->uid();\n            node.ptr = ptr;\n            node.offset = i;\n            newThreading[node.internalId] = node;\n            allIds.append(node.internalId);\n            newPtrToInternal[node.ptr] = node.internalId;\n            if (!node.uid) {\n                unknownUids << ptr;\n            }\n        }\n    }\n\n    if (newThreading.size()) {\n        threading = newThreading;\n        ptrToInternal = newPtrToInternal;\n        threading[ 0 ].children = allIds;\n        threading[ 0 ].ptr = 0;\n        threadingHelperLastId = newThreading.size();\n        threadedRootIds = threading[0].children;\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updateNoThreading()\n  {\n      threadingHelperLastId = 0;\n  \n      if (!sourceModel()) {\n          // Maybe we got reset because the parent model is no longer here...\n          if (! threading.isEmpty()) {\n              beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n              threading.clear();\n              ptrToInternal.clear();\n              endRemoveRows();\n          }\n          unknownUids.clear();\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n  \n      int upstreamMessages = sourceModel()->rowCount();\n      QList<uint> allIds;\n      QHash<uint,ThreadNodeInfo> newThreading;\n      QHash<void *,uint> newPtrToInternal;\n  \n      if (upstreamMessages) {\n          // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n          // This improves the speed of the testSortingPerformance benchmark by 18%.\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n  \n          for (int i = 0; i < upstreamMessages; ++i) {\n              TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n              Q_ASSERT(ptr);\n              ThreadNodeInfo node;\n              node.internalId = i + 1;\n              node.uid = ptr->uid();\n              node.ptr = ptr;\n              node.offset = i;\n              newThreading[node.internalId] = node;\n              allIds.append(node.internalId);\n              newPtrToInternal[node.ptr] = node.internalId;\n              if (!node.uid) {\n                  unknownUids << ptr;\n              }\n          }\n      }\n  \n      if (newThreading.size()) {\n          threading = newThreading;\n          ptrToInternal = newPtrToInternal;\n          threading[ 0 ].children = allIds;\n          threading[ 0 ].ptr = 0;\n          threadingHelperLastId = newThreading.size();\n          threadedRootIds = threading[0].children;\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "ender(),",
            ",",
            "his,",
            "LOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)))"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotThreadingFailed(QModelIndex,QByteArray,QStringList))"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotThreadingFailed(",
          "args": [
            "ModelIndex,",
            "ByteArray,",
            "StringList)"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "slotThreadingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "758-772",
          "snippet": "oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    updateNoThreading();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ender(",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "sender(",
          "container": "neMessageModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/OneMessageModel.cpp",
          "lines": "134-137",
          "snippet": "VariantList OneMessageModel::sender() const\n{\n    return m_message.data(RoleMessageSender).toList();\n}",
          "includes": [
            "include \"SubtreeModel.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"FindInterestingPart.h\"\n#",
            "include \"kdeui-itemviews/kdescendantsproxymodel.h\"\n#",
            "include \"OneMessageModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"SubtreeModel.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"FindInterestingPart.h\"\n#\ninclude \"kdeui-itemviews/kdescendantsproxymodel.h\"\n#\ninclude \"OneMessageModel.h\"\n#\n\nneMessageModel {\n  VariantList OneMessageModel::sender() const\n  {\n      return m_message.data(RoleMessageSender).toList();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isconnect(",
          "args": [
            "ender(),",
            ",",
            "his,",
            "LOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)))"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>))"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotThreadingAvailable(",
          "args": [
            "ModelIndex,",
            "ByteArray,",
            "StringList,",
            "Vector<Imap::Responses::ThreadingNode>)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "slotThreadingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "774-796",
          "snippet": "oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n        const QStringList &searchCriteria,\n        const QVector<Imap::Responses::ThreadingNode> &mapping)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    const Model *model = 0;\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n\n    // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n    // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n    if (m_shallBeThreading)\n        wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n          const QStringList &searchCriteria,\n          const QVector<Imap::Responses::ThreadingNode> &mapping)\n  {\n      // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n      threadingInFlight = false;\n  \n      const Model *model = 0;\n      if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n          return;\n  \n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n  \n      model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n  \n      // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n      // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n      if (m_shallBeThreading)\n          wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "houldIgnoreThisThreadingResponse(",
          "args": [
            "ailbox,",
            "lgorithm,",
            "earchCriteria)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n  {\n      // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n      threadingInFlight = false;\n  \n      if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n          return;\n  \n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n  \n      updateNoThreading();\n  }\n}"
  },
  {
    "function_name": "shouldIgnoreThisThreadingResponse(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "724-756",
    "snippet": "ool ThreadingMsgListModel::shouldIgnoreThisThreadingResponse(const QModelIndex &mailbox, const QByteArray &algorithm,\n        const QStringList &searchCriteria, const Model **realModel)\n{\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    if (!someMessage.isValid())\n        return true;\n    const Model *model;\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &model, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n    if (mailboxIndex != mailbox) {\n        // this is for another mailbox\n        return true;\n    }\n\n    if (algorithm != requestedAlgorithm) {\n        logTrace(QString::fromUtf8(\"Weird, asked for threading via %1 but got %2 instead -- ignoring\")\n                 .arg(QString::fromUtf8(requestedAlgorithm), QString::fromUtf8(algorithm)));\n        return true;\n    }\n\n    if (searchCriteria.size() != 1 || searchCriteria.front() != QLatin1String(\"ALL\")) {\n        QString buf;\n        QTextStream ss(&buf);\n        logTrace(QString::fromUtf8(\"Weird, requesting messages matching ALL, but got this instead: %1\")\n                 .arg(searchCriteria.join(QLatin1String(\", \"))));\n        return true;\n    }\n\n    if (realModel)\n        *realModel = model;\n    return false;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "String::fromUtf8(\"Weird, requesting messages matching ALL, but got this instead: %1\")\n                 .arg(searchCriteria.join(QLatin1String(\", \"))))"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1205-1226",
          "snippet": "oid ThreadingMsgListModel::logTrace(const QString &message)\n{\n    if (!sourceModel()) {\n        qDebug() << message;\n        return;\n    }\n    QModelIndex idx = sourceModel()->index(0, 0);\n    if (!idx.isValid()) {\n        qDebug() << message;\n        return;\n    }\n\n    // Got to find out the real model and also translate the index to one belonging to a real Model\n    Q_ASSERT(idx.model());\n    const Model *realModel;\n    QModelIndex realIndex;\n    Model::realTreeItem(idx, &realModel, &realIndex);\n    Q_ASSERT(realModel);\n    QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n    const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n            QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::logTrace(const QString &message)\n  {\n      if (!sourceModel()) {\n          qDebug() << message;\n          return;\n      }\n      QModelIndex idx = sourceModel()->index(0, 0);\n      if (!idx.isValid()) {\n          qDebug() << message;\n          return;\n      }\n  \n      // Got to find out the real model and also translate the index to one belonging to a real Model\n      Q_ASSERT(idx.model());\n      const Model *realModel;\n      QModelIndex realIndex;\n      Model::realTreeItem(idx, &realModel, &realIndex);\n      Q_ASSERT(realModel);\n      QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n      const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n              QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "earchCriteria.join(QLatin1String(\", \")))"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.join",
          "args": [
            "Latin1String(\", \"))"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ", \")"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Weird, requesting messages matching ALL, but got this instead: %1\")"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.front",
          "args": [],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.size",
          "args": [],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::fromUtf8(requestedAlgorithm),",
            "String::fromUtf8(algorithm))"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "lgorithm)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "equestedAlgorithm)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Weird, asked for threading via %1 but got %2 instead -- ignoring\")"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealIndex.parent",
          "args": [],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::Mailbox::Model::realTreeItem(",
          "args": [
            "omeMessage,",
            "model,",
            "realIndex)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omeMessage.isValid",
          "args": [],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::shouldIgnoreThisThreadingResponse(const QModelIndex &mailbox, const QByteArray &algorithm,\n          const QStringList &searchCriteria, const Model **realModel)\n  {\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      if (!someMessage.isValid())\n          return true;\n      const Model *model;\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &model, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n      if (mailboxIndex != mailbox) {\n          // this is for another mailbox\n          return true;\n      }\n  \n      if (algorithm != requestedAlgorithm) {\n          logTrace(QString::fromUtf8(\"Weird, asked for threading via %1 but got %2 instead -- ignoring\")\n                   .arg(QString::fromUtf8(requestedAlgorithm), QString::fromUtf8(algorithm)));\n          return true;\n      }\n  \n      if (searchCriteria.size() != 1 || searchCriteria.front() != QLatin1String(\"ALL\")) {\n          QString buf;\n          QTextStream ss(&buf);\n          logTrace(QString::fromUtf8(\"Weird, requesting messages matching ALL, but got this instead: %1\")\n                   .arg(searchCriteria.join(QLatin1String(\", \"))));\n          return true;\n      }\n  \n      if (realModel)\n          *realModel = model;\n      return false;\n  }\n}"
  },
  {
    "function_name": "slotIncrementalThreadingFailed(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "720-722",
    "snippet": "oid ThreadingMsgListModel::slotIncrementalThreadingFailed()\n{\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotIncrementalThreadingFailed()\n  {\n  }\n}"
  },
  {
    "function_name": "slotIncrementalThreadingAvailable(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "661-718",
    "snippet": "oid ThreadingMsgListModel::slotIncrementalThreadingAvailable(const Responses::ESearch::IncrementalThreadingData_t &data)\n{\n    // Preparation: get through to the real model\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    Q_ASSERT(someMessage.isValid());\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n    Q_ASSERT(mailboxIndex.isValid());\n\n    // First phase: remove all messages mentioned in the incremental responses from their original placement\n    QVector<uint> affectedUids;\n    for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n        gatherAllUidsFromThreadNode(affectedUids, it->thread);\n    }\n    qSort(affectedUids);\n    QList<TreeItemMessage*> affectedMessages = const_cast<Model*>(realModel)->\n            findMessagesByUids(static_cast<TreeItemMailbox*>(mailboxIndex.internalPointer()), affectedUids.toList());\n    QHash<uint,void *> uidToPtrCache;\n\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    for (QList<TreeItemMessage*>::const_iterator it = affectedMessages.constBegin(); it != affectedMessages.constEnd(); ++it) {\n        QHash<void *,uint>::const_iterator ptrMappingIt = ptrToInternal.constFind(*it);\n        Q_ASSERT(ptrMappingIt != ptrToInternal.constEnd());\n        QHash<uint,ThreadNodeInfo>::iterator threadIt = threading.find(*ptrMappingIt);\n        Q_ASSERT(threadIt != threading.end());\n        uidToPtrCache[(*it)->uid()] = threadIt->ptr;\n        threadIt->ptr = 0;\n    }\n    pruneTree();\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n\n    // Second phase: for each message whose UID is returned by the server, update the threading data\n    QSet<uint> usedNodes;\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n        registerThreading(it->thread, 0, uidToPtrCache, usedNodes);\n        int actualOffset = threading[0].children.size() - 1;\n        int expectedOffsetOfPrevious = threading[0].children.indexOf(it->previousThreadRoot);\n        if (actualOffset == expectedOffsetOfPrevious + 1) {\n            // it's on the correct position, yay!\n        } else {\n            // move the new subthread to a correct place\n            threading[0].children.insert(expectedOffsetOfPrevious + 1, threading[0].children.takeLast());\n            // push the rest (including the new arrival) forward\n            for (int i = expectedOffsetOfPrevious + 1; i < threading[0].children.size(); ++i) {\n                threading[threading[0].children[i]].offset = i;\n            }\n        }\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase2(",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase2(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1027-1050",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n{\n    Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n    QList<QModelIndex> updatedIndexes;\n    for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n        QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n        if (ptrIt == ptrToInternal.constEnd()) {\n            // That message is no longer there\n            updatedIndexes.append(QModelIndex());\n            continue;\n        }\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n        if (it == threading.constEnd()) {\n            // Filtering doesn't accept this index, let's declare it dead\n            updatedIndexes.append(QModelIndex());\n        } else {\n            updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n        }\n    }\n    Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n    changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n    oldPersistentIndexes.clear();\n    oldPtrs.clear();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n  {\n      Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n      QList<QModelIndex> updatedIndexes;\n      for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n          QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n          if (ptrIt == ptrToInternal.constEnd()) {\n              // That message is no longer there\n              updatedIndexes.append(QModelIndex());\n              continue;\n          }\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n          if (it == threading.constEnd()) {\n              // Filtering doesn't accept this index, let's declare it dead\n              updatedIndexes.append(QModelIndex());\n          } else {\n              updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n          }\n      }\n      Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n      changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n      oldPersistentIndexes.clear();\n      oldPtrs.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading[0].children.size",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.insert",
          "args": [
            "xpectedOffsetOfPrevious + 1,",
            "hreading[0].children.takeLast())"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.takeLast",
          "args": [],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.indexOf",
          "args": [
            "t->previousThreadRoot)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.size",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egisterThreading(",
          "args": [
            "t->thread,",
            ",",
            "idToPtrCache,",
            "sedNodes)"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "registerThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "967-1002",
          "snippet": "oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n{\n    Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n        uint nodeId;\n        QHash<uint,void *>::const_iterator ptrIt;\n        if (node.num == 0 ||\n                (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n            // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n            // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n            // expunged after the untagged THREAD was received, but before the tagged OK.\n            // We cannot just ignore this node, though, because it might have some children which we would otherwise\n            // simply hide.\n            // The ptrIt which is initialized by the condition is used in the else branch.\n            ThreadNodeInfo fake;\n            fake.internalId = ++threadingHelperLastId;\n            fake.parent = parentId;\n            Q_ASSERT(threading.contains(parentId));\n            // The child will be registered to the list of parent's children after the if/else branch\n            threading[ fake.internalId ] = fake;\n            nodeId = fake.internalId;\n        } else {\n            QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n            // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n            // That is however non-issue, as we pre-create nodes for all messages beforehand.\n            Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n            nodeId = *nodeIt;\n            // This is needed for the incremental stuff\n            threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n        }\n        threading[nodeId].offset = threading[parentId].children.size();\n        threading[ parentId ].children.append(nodeId);\n        threading[ nodeId ].parent = parentId;\n        usedNodes.insert(nodeId);\n        registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::registerThreading(const QVector<Imap::Responses::ThreadingNode> &mapping, uint parentId, const QHash<uint,void *> &uidToPtr, QSet<uint> &usedNodes)\n  {\n      Q_FOREACH(const Imap::Responses::ThreadingNode &node, mapping) {\n          uint nodeId;\n          QHash<uint,void *>::const_iterator ptrIt;\n          if (node.num == 0 ||\n                  (ptrIt = uidToPtr.find(node.num)) == uidToPtr.constEnd()) {\n              // Either this is an empty node, or the THREAD response references a UID which is no longer in the mailbox.\n              // This is a valid scenario; it can happen e.g. when reusing data from cache, or when a message got\n              // expunged after the untagged THREAD was received, but before the tagged OK.\n              // We cannot just ignore this node, though, because it might have some children which we would otherwise\n              // simply hide.\n              // The ptrIt which is initialized by the condition is used in the else branch.\n              ThreadNodeInfo fake;\n              fake.internalId = ++threadingHelperLastId;\n              fake.parent = parentId;\n              Q_ASSERT(threading.contains(parentId));\n              // The child will be registered to the list of parent's children after the if/else branch\n              threading[ fake.internalId ] = fake;\n              nodeId = fake.internalId;\n          } else {\n              QHash<void *,uint>::const_iterator nodeIt = ptrToInternal.constFind(*ptrIt);\n              // The following assert would fail if there was a node with a valid UID, but not in our ptrToInternal mapping.\n              // That is however non-issue, as we pre-create nodes for all messages beforehand.\n              Q_ASSERT(nodeIt != ptrToInternal.constEnd());\n              nodeId = *nodeIt;\n              // This is needed for the incremental stuff\n              threading[nodeId].ptr = static_cast<TreeItem*>(*ptrIt);\n          }\n          threading[nodeId].offset = threading[parentId].children.size();\n          threading[ parentId ].children.append(nodeId);\n          threading[ nodeId ].parent = parentId;\n          usedNodes.insert(nodeId);\n          registerThreading(node.children, nodeId, uidToPtr, usedNodes);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ata.constEnd",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata.constBegin",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase1(",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase1(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1005-1024",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n{\n    oldPersistentIndexes = persistentIndexList();\n    oldPtrs.clear();\n    Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n        // the index could get invalidated by the pruneTree() or something else manipulating our threading\n        bool isOk = idx.isValid() && threading.contains(idx.internalId());\n        if (!isOk) {\n            oldPtrs << 0;\n            continue;\n        }\n        QModelIndex translated = mapToSource(idx);\n        if (!translated.isValid()) {\n            // another stale item\n            oldPtrs << 0;\n            continue;\n        }\n        oldPtrs << translated.internalPointer();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n  {\n      oldPersistentIndexes = persistentIndexList();\n      oldPtrs.clear();\n      Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n          // the index could get invalidated by the pruneTree() or something else manipulating our threading\n          bool isOk = idx.isValid() && threading.contains(idx.internalId());\n          if (!isOk) {\n              oldPtrs << 0;\n              continue;\n          }\n          QModelIndex translated = mapToSource(idx);\n          if (!translated.isValid()) {\n              // another stale item\n              oldPtrs << 0;\n              continue;\n          }\n          oldPtrs << translated.internalPointer();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runeTree(",
          "args": [],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "pruneTree(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1052-1151",
          "snippet": "oid ThreadingMsgListModel::pruneTree()\n{\n    // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n    // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n    // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n    // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n    QList<uint> pending = threading.keys();\n    for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n        // Convert to the hashmap\n        // The \"it\" iterator point to the current node in the threading mapping\n        QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n        if (it == threading.end()) {\n            // We've already seen this node, that's due to promoting\n            ++id;\n            continue;\n        }\n\n        if (it->internalId == 0) {\n            // A special root item; we should not delete that one :)\n            ++id;\n            continue;\n        }\n        if (it->ptr) {\n            // regular and valid message -> skip\n            ++id;\n        } else {\n            // a fake one\n\n            // each node has a parent\n            QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n            Q_ASSERT(parent != threading.end());\n\n            // and the node itself has to be found in its parent's children\n            QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n            Q_ASSERT(childIt != parent->children.end());\n            // Check that its offset is correct\n            Q_ASSERT(childIt - parent->children.begin() == it->offset);\n\n            if (it->children.isEmpty()) {\n                // This is a leaf node, so we can just remove it\n                childIt = parent->children.erase(childIt);\n                threadedRootIds.removeOne(it->internalId);\n                threading.erase(it);\n                ++id;\n\n                // Update offsets of all further nodes, siblings to the one we've just deleted\n                while (childIt != parent->children.end()) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                    Q_ASSERT(sibling != threading.end());\n                    --sibling->offset;\n                    Q_ASSERT(sibling->offset >= 0);\n                    ++childIt;\n                }\n            } else {\n                // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                // to replace this node.\n                QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                Q_ASSERT(replaceWith != threading.end());\n\n                // Make sure that the offsets are still correct\n                Q_ASSERT(parent->children[it->offset] == it->internalId);\n\n                // Replace the node\n                replaceWith->offset = it->offset;\n                *childIt = it->children.first();\n                replaceWith->parent = parent->internalId;\n\n                // Now merge the lists of children\n                it->children.removeFirst();\n                replaceWith->children = replaceWith->children + it->children;\n\n                // Fix parent and offset information of all children of the replacement node\n                for (int i = 0; i < replaceWith->children.size(); ++i) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                    Q_ASSERT(sibling != threading.end());\n\n                    sibling->parent = replaceWith.key();\n                    sibling->offset = i;\n                }\n\n                if (parent->internalId == 0) {\n                    // Update the list of all thread roots\n                    QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                    if (rootIt != threadedRootIds.end())\n                        *rootIt = replaceWith->internalId;\n                }\n\n                // Now that all references are gone, remove the original node\n                threading.erase(it);\n\n                if (!replaceWith->ptr) {\n                    // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                    // because we've already processed the current item and are completely done with it. The worst which can\n                    // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                    *id = replaceWith.key();\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::pruneTree()\n  {\n      // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n      // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n      // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n      // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n      QList<uint> pending = threading.keys();\n      for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n          // Convert to the hashmap\n          // The \"it\" iterator point to the current node in the threading mapping\n          QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n          if (it == threading.end()) {\n              // We've already seen this node, that's due to promoting\n              ++id;\n              continue;\n          }\n  \n          if (it->internalId == 0) {\n              // A special root item; we should not delete that one :)\n              ++id;\n              continue;\n          }\n          if (it->ptr) {\n              // regular and valid message -> skip\n              ++id;\n          } else {\n              // a fake one\n  \n              // each node has a parent\n              QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n              Q_ASSERT(parent != threading.end());\n  \n              // and the node itself has to be found in its parent's children\n              QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n              Q_ASSERT(childIt != parent->children.end());\n              // Check that its offset is correct\n              Q_ASSERT(childIt - parent->children.begin() == it->offset);\n  \n              if (it->children.isEmpty()) {\n                  // This is a leaf node, so we can just remove it\n                  childIt = parent->children.erase(childIt);\n                  threadedRootIds.removeOne(it->internalId);\n                  threading.erase(it);\n                  ++id;\n  \n                  // Update offsets of all further nodes, siblings to the one we've just deleted\n                  while (childIt != parent->children.end()) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                      Q_ASSERT(sibling != threading.end());\n                      --sibling->offset;\n                      Q_ASSERT(sibling->offset >= 0);\n                      ++childIt;\n                  }\n              } else {\n                  // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                  // to replace this node.\n                  QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                  Q_ASSERT(replaceWith != threading.end());\n  \n                  // Make sure that the offsets are still correct\n                  Q_ASSERT(parent->children[it->offset] == it->internalId);\n  \n                  // Replace the node\n                  replaceWith->offset = it->offset;\n                  *childIt = it->children.first();\n                  replaceWith->parent = parent->internalId;\n  \n                  // Now merge the lists of children\n                  it->children.removeFirst();\n                  replaceWith->children = replaceWith->children + it->children;\n  \n                  // Fix parent and offset information of all children of the replacement node\n                  for (int i = 0; i < replaceWith->children.size(); ++i) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                      Q_ASSERT(sibling != threading.end());\n  \n                      sibling->parent = replaceWith.key();\n                      sibling->offset = i;\n                  }\n  \n                  if (parent->internalId == 0) {\n                      // Update the list of all thread roots\n                      QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                      if (rootIt != threadedRootIds.end())\n                          *rootIt = replaceWith->internalId;\n                  }\n  \n                  // Now that all references are gone, remove the original node\n                  threading.erase(it);\n  \n                  if (!replaceWith->ptr) {\n                      // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                      // because we've already processed the current item and are completely done with it. The worst which can\n                      // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                      *id = replaceWith.key();\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "*it)->uid",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "hreadIt != threading.end())"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.find",
          "args": [
            "ptrMappingIt)"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "trMappingIt != ptrToInternal.constEnd())"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constEnd",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constFind",
          "args": [
            "it)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffectedMessages.constEnd",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffectedMessages.constBegin",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model*>",
          "args": [
            "tatic_cast<TreeItemMailbox*>(mailboxIndex.internalPointer()),",
            "ffectedUids.toList())"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffectedUids.toList",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMailbox*>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model*>",
          "args": [
            "ealModel)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sort(",
          "args": [
            "ffectedUids)"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "handleSort(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "170-174",
          "snippet": "ool ImapTask::handleSort(const Imap::Responses::Sort *const resp)\n{\n    Q_UNUSED(resp);\n    return false;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  ool ImapTask::handleSort(const Imap::Responses::Sort *const resp)\n  {\n      Q_UNUSED(resp);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "atherAllUidsFromThreadNode(",
          "args": [
            "ffectedUids,",
            "t->thread)"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "atherAllUidsFromThreadNode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "653-659",
          "snippet": "tatic void gatherAllUidsFromThreadNode(QVector<uint> &uids, const QVector<Responses::ThreadingNode> &list)\n{\n    for (QVector<Responses::ThreadingNode>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n        uids.push_back(it->num);\n        gatherAllUidsFromThreadNode(uids, it->children);\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\ntatic void gatherAllUidsFromThreadNode(QVector<uint> &uids, const QVector<Responses::ThreadingNode> &list)\n{\n    for (QVector<Responses::ThreadingNode>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n        uids.push_back(it->num);\n        gatherAllUidsFromThreadNode(uids, it->children);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ata.constEnd",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata.constBegin",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.isValid())"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ealIndex.parent",
          "args": [],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::Mailbox::Model::realTreeItem(",
          "args": [
            "omeMessage,",
            "realModel,",
            "realIndex)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "omeMessage.isValid())"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotIncrementalThreadingAvailable(const Responses::ESearch::IncrementalThreadingData_t &data)\n  {\n      // Preparation: get through to the real model\n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      Q_ASSERT(someMessage.isValid());\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n      Q_ASSERT(mailboxIndex.isValid());\n  \n      // First phase: remove all messages mentioned in the incremental responses from their original placement\n      QVector<uint> affectedUids;\n      for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n          gatherAllUidsFromThreadNode(affectedUids, it->thread);\n      }\n      qSort(affectedUids);\n      QList<TreeItemMessage*> affectedMessages = const_cast<Model*>(realModel)->\n              findMessagesByUids(static_cast<TreeItemMailbox*>(mailboxIndex.internalPointer()), affectedUids.toList());\n      QHash<uint,void *> uidToPtrCache;\n  \n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      for (QList<TreeItemMessage*>::const_iterator it = affectedMessages.constBegin(); it != affectedMessages.constEnd(); ++it) {\n          QHash<void *,uint>::const_iterator ptrMappingIt = ptrToInternal.constFind(*it);\n          Q_ASSERT(ptrMappingIt != ptrToInternal.constEnd());\n          QHash<uint,ThreadNodeInfo>::iterator threadIt = threading.find(*ptrMappingIt);\n          Q_ASSERT(threadIt != threading.end());\n          uidToPtrCache[(*it)->uid()] = threadIt->ptr;\n          threadIt->ptr = 0;\n      }\n      pruneTree();\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  \n      // Second phase: for each message whose UID is returned by the server, update the threading data\n      QSet<uint> usedNodes;\n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n          registerThreading(it->thread, 0, uidToPtrCache, usedNodes);\n          int actualOffset = threading[0].children.size() - 1;\n          int expectedOffsetOfPrevious = threading[0].children.indexOf(it->previousThreadRoot);\n          if (actualOffset == expectedOffsetOfPrevious + 1) {\n              // it's on the correct position, yay!\n          } else {\n              // move the new subthread to a correct place\n              threading[0].children.insert(expectedOffsetOfPrevious + 1, threading[0].children.takeLast());\n              // push the rest (including the new arrival) forward\n              for (int i = expectedOffsetOfPrevious + 1; i < threading[0].children.size(); ++i) {\n                  threading[threading[0].children[i]].offset = i;\n              }\n          }\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
  },
  {
    "function_name": "atherAllUidsFromThreadNode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "653-659",
    "snippet": "tatic void gatherAllUidsFromThreadNode(QVector<uint> &uids, const QVector<Responses::ThreadingNode> &list)\n{\n    for (QVector<Responses::ThreadingNode>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n        uids.push_back(it->num);\n        gatherAllUidsFromThreadNode(uids, it->children);\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atherAllUidsFromThreadNode(",
          "args": [
            "ids,",
            "t->children)"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "atherAllUidsFromThreadNode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "653-659",
          "snippet": "tatic void gatherAllUidsFromThreadNode(QVector<uint> &uids, const QVector<Responses::ThreadingNode> &list)\n{\n    for (QVector<Responses::ThreadingNode>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n        uids.push_back(it->num);\n        gatherAllUidsFromThreadNode(uids, it->children);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ids.push_back",
          "args": [
            "t->num)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.constEnd",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.constBegin",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\ntatic void gatherAllUidsFromThreadNode(QVector<uint> &uids, const QVector<Responses::ThreadingNode> &list)\n{\n    for (QVector<Responses::ThreadingNode>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n        uids.push_back(it->num);\n        gatherAllUidsFromThreadNode(uids, it->children);\n    }\n}"
  },
  {
    "function_name": "askForThreading(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "610-650",
    "snippet": "oid ThreadingMsgListModel::askForThreading(const uint firstUnknownUid)\n{\n    Q_ASSERT(m_shallBeThreading);\n    Q_ASSERT(sourceModel());\n    Q_ASSERT(sourceModel()->rowCount());\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n\n    if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFS\"))) {\n        requestedAlgorithm = \"REFS\";\n    } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFERENCES\"))) {\n        requestedAlgorithm = \"REFERENCES\";\n    } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=ORDEREDSUBJECT\"))) {\n        requestedAlgorithm = \"ORDEREDSUBJECT\";\n    }\n\n    if (! requestedAlgorithm.isEmpty()) {\n        threadingInFlight = true;\n        ThreadTask *threadTask;\n        if (firstUnknownUid && realModel->capabilities().contains(QLatin1String(\"INCTHREAD\"))) {\n            threadTask = realModel->m_taskFactory->\n                    createIncrementalThreadTask(const_cast<Model *>(realModel), mailboxIndex, requestedAlgorithm,\n                                                                    QStringList() << \"INTHREAD\" << requestedAlgorithm << \"UID\" <<\n                                                                        Sequence::startingAt(firstUnknownUid).toByteArray());\n            connect(threadTask, SIGNAL(incrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)),\n                    this, SLOT(slotIncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)));\n            connect(threadTask, SIGNAL(failed(QString)), this, SLOT(slotIncrementalThreadingFailed()));\n        } else {\n            threadTask = realModel->m_taskFactory->createThreadTask(const_cast<Model *>(realModel), mailboxIndex,\n                                                                    requestedAlgorithm, QStringList() << QLatin1String(\"ALL\"));\n            connect(realModel, SIGNAL(threadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)),\n                    this, SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n            connect(realModel, SIGNAL(threadingFailed(QModelIndex,QByteArray,QStringList)),\n                    this, SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n        }\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ealModel,",
            "IGNAL(threadingFailed(QModelIndex,QByteArray,QStringList)),",
            "his,",
            "LOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)))"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotThreadingFailed(QModelIndex,QByteArray,QStringList))"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotThreadingFailed(",
          "args": [
            "ModelIndex,",
            "ByteArray,",
            "StringList)"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "slotThreadingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "758-772",
          "snippet": "oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    updateNoThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotThreadingFailed(const QModelIndex &mailbox, const QByteArray &algorithm, const QStringList &searchCriteria)\n  {\n      // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n      threadingInFlight = false;\n  \n      if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria))\n          return;\n  \n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n  \n      updateNoThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "hreadingFailed(QModelIndex,QByteArray,QStringList))"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ealModel,",
            "IGNAL(threadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)),",
            "his,",
            "LOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)))"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>))"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotThreadingAvailable(",
          "args": [
            "ModelIndex,",
            "ByteArray,",
            "StringList,",
            "Vector<Imap::Responses::ThreadingNode>)"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "slotThreadingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "774-796",
          "snippet": "oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n        const QStringList &searchCriteria,\n        const QVector<Imap::Responses::ThreadingNode> &mapping)\n{\n    // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n    threadingInFlight = false;\n\n    const Model *model = 0;\n    if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n        return;\n\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n    disconnect(sender(), 0, this,\n               SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n\n    model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n\n    // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n    // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n    if (m_shallBeThreading)\n        wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotThreadingAvailable(const QModelIndex &mailbox, const QByteArray &algorithm,\n          const QStringList &searchCriteria,\n          const QVector<Imap::Responses::ThreadingNode> &mapping)\n  {\n      // Better safe than sorry -- prevent infinite waiting to the maximal possible extent\n      threadingInFlight = false;\n  \n      const Model *model = 0;\n      if (shouldIgnoreThisThreadingResponse(mailbox, algorithm, searchCriteria, &model))\n          return;\n  \n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n      disconnect(sender(), 0, this,\n                 SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n  \n      model->cache()->setMessageThreading(mailbox.data(RoleMailboxName).toString(), mapping);\n  \n      // Indirect processing here -- the wantThreading() will check that the received response really contains everything we need\n      // and if it does, simply applyThreading() that.  If there's something missing, it will ask for the threading again.\n      if (m_shallBeThreading)\n          wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "hreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>))"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->m_taskFactory->createThreadTask",
          "args": [
            "onst_cast<Model *>(realModel),",
            "ailboxIndex,",
            "equestedAlgorithm,",
            "StringList() << QLatin1String(\"ALL\"))"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ealModel)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "hreadTask,",
            "IGNAL(failed(QString)),",
            "his,",
            "LOT(slotIncrementalThreadingFailed()))"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotIncrementalThreadingFailed())"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotIncrementalThreadingFailed(",
          "args": [],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "slotIncrementalThreadingFailed(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "720-722",
          "snippet": "oid ThreadingMsgListModel::slotIncrementalThreadingFailed()\n{\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotIncrementalThreadingFailed()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ailed(QString))"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailed(",
          "args": [
            "String)"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "authenticationFailed(const QS",
          "container": "w",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Window.cpp",
          "lines": "1103-1107",
          "snippet": "Window::authenticationFailed(const QString &message)\n{\n    m_ignoreStoredPassword = true;\n    QMessageBox::warning(this, tr(\"Login Failed\"), message);\n}\n\nvoid Ma",
          "includes": [
            "include \"Imap/Model/ModelTest/modeltest.h\"",
            "include \"ui_AboutDialog.h\"",
            "include \"ui_CreateMailboxDialog.h\"\n#",
            "include \"ShortcutHandler/ShortcutHandler.h\"",
            "include \"Window.h\"\n#",
            "include \"Util.h\"\n#",
            "include \"TaskProgressIndicator.h\"\n#",
            "include \"Streams/SocketFactory.h\"\n#",
            "include \"SimplePartWidget.h\"\n#",
            "include \"SettingsDialog.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include \"PasswordDialog.h\"\n#",
            "include \"OnePanelAtTimeWidget.h\"\n#",
            "include \"MsgListView.h\"\n#",
            "include \"MessageSourceWidget.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"MessageListWidget.h\"\n#",
            "include \"MailBoxTreeView.h\"\n#",
            "include \"IconLoader.h\"\n#",
            "include \"ComposeWidget.h\"\n#",
            "include \"CompleteMessageWidget.h\"\n#",
            "include \"Plugins/PluginManager.h\"\n#",
            "include \"MSA/SMTP.h\"\n#",
            "include \"MSA/Sendmail.h\"\n#",
            "include \"Imap/Network/FileDownloadManager.h\"\n#",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/ThreadingMsgListModel.h\"\n#",
            "include \"Imap/Model/PrettyMsgListModel.h\"\n#",
            "include \"Imap/Model/PrettyMailboxModel.h\"\n#",
            "include \"Imap/Model/NetworkWatcher.h\"\n#",
            "include \"Imap/Model/MsgListModel.h\"\n#",
            "include \"Imap/Model/ModelWatcher.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ImapAccess.h\"\n#",
            "include \"Composer/SenderIdentitiesModel.h\"\n#",
            "include \"Composer/Mailto.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/Application.h\"\n#",
            "include \"AbookAddressbook/be-contacts.h\"\n#",
            "include \"AbookAddressbook/AbookAddressbook.h\"\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QToolButton>\n#",
            "include <QToolBar>\n#",
            "include <QTextDocument>\n#",
            "include <QStatusBar>\n#",
            "include <QStackedWidget>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSplitter>\n#",
            "include <QProgressBar>\n#",
            "include <QMessageBox>\n#",
            "include <QMenuBar>\n#",
            "include <QItemSelectionModel>\n#",
            "include <QHeaderView>\n#",
            "include <QFileDialog>\n#",
            "include <QDockWidget>\n#",
            "include <QDir>\n#",
            "include <QDesktopWidget>\n#",
            "include <QDesktopServices>\n#",
            "include <QAuthenticator>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/ModelTest/modeltest.h\"\ninclude \"ui_AboutDialog.h\"\ninclude \"ui_CreateMailboxDialog.h\"\n#\ninclude \"ShortcutHandler/ShortcutHandler.h\"\ninclude \"Window.h\"\n#\ninclude \"Util.h\"\n#\ninclude \"TaskProgressIndicator.h\"\n#\ninclude \"Streams/SocketFactory.h\"\n#\ninclude \"SimplePartWidget.h\"\n#\ninclude \"SettingsDialog.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude \"PasswordDialog.h\"\n#\ninclude \"OnePanelAtTimeWidget.h\"\n#\ninclude \"MsgListView.h\"\n#\ninclude \"MessageSourceWidget.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"MessageListWidget.h\"\n#\ninclude \"MailBoxTreeView.h\"\n#\ninclude \"IconLoader.h\"\n#\ninclude \"ComposeWidget.h\"\n#\ninclude \"CompleteMessageWidget.h\"\n#\ninclude \"Plugins/PluginManager.h\"\n#\ninclude \"MSA/SMTP.h\"\n#\ninclude \"MSA/Sendmail.h\"\n#\ninclude \"Imap/Network/FileDownloadManager.h\"\n#\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/ThreadingMsgListModel.h\"\n#\ninclude \"Imap/Model/PrettyMsgListModel.h\"\n#\ninclude \"Imap/Model/PrettyMailboxModel.h\"\n#\ninclude \"Imap/Model/NetworkWatcher.h\"\n#\ninclude \"Imap/Model/MsgListModel.h\"\n#\ninclude \"Imap/Model/ModelWatcher.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ImapAccess.h\"\n#\ninclude \"Composer/SenderIdentitiesModel.h\"\n#\ninclude \"Composer/Mailto.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/Application.h\"\n#\ninclude \"AbookAddressbook/be-contacts.h\"\n#\ninclude \"AbookAddressbook/AbookAddressbook.h\"\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QToolButton>\n#\ninclude <QToolBar>\n#\ninclude <QTextDocument>\n#\ninclude <QStatusBar>\n#\ninclude <QStackedWidget>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSplitter>\n#\ninclude <QProgressBar>\n#\ninclude <QMessageBox>\n#\ninclude <QMenuBar>\n#\ninclude <QItemSelectionModel>\n#\ninclude <QHeaderView>\n#\ninclude <QFileDialog>\n#\ninclude <QDockWidget>\n#\ninclude <QDir>\n#\ninclude <QDesktopWidget>\n#\ninclude <QDesktopServices>\n#\ninclude <QAuthenticator>\n#\n\nw {\n  Window::authenticationFailed(const QString &message)\n  {\n      m_ignoreStoredPassword = true;\n      QMessageBox::warning(this, tr(\"Login Failed\"), message);\n  }\n  \n  void Ma\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "hreadTask,",
            "IGNAL(incrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)),",
            "his,",
            "LOT(slotIncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)))"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotIncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t))"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotIncrementalThreadingAvailable(",
          "args": [
            "esponses::ESearch::IncrementalThreadingData_t)"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "slotIncrementalThreadingAvailable(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "661-718",
          "snippet": "oid ThreadingMsgListModel::slotIncrementalThreadingAvailable(const Responses::ESearch::IncrementalThreadingData_t &data)\n{\n    // Preparation: get through to the real model\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    Q_ASSERT(someMessage.isValid());\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n    Q_ASSERT(mailboxIndex.isValid());\n\n    // First phase: remove all messages mentioned in the incremental responses from their original placement\n    QVector<uint> affectedUids;\n    for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n        gatherAllUidsFromThreadNode(affectedUids, it->thread);\n    }\n    qSort(affectedUids);\n    QList<TreeItemMessage*> affectedMessages = const_cast<Model*>(realModel)->\n            findMessagesByUids(static_cast<TreeItemMailbox*>(mailboxIndex.internalPointer()), affectedUids.toList());\n    QHash<uint,void *> uidToPtrCache;\n\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    for (QList<TreeItemMessage*>::const_iterator it = affectedMessages.constBegin(); it != affectedMessages.constEnd(); ++it) {\n        QHash<void *,uint>::const_iterator ptrMappingIt = ptrToInternal.constFind(*it);\n        Q_ASSERT(ptrMappingIt != ptrToInternal.constEnd());\n        QHash<uint,ThreadNodeInfo>::iterator threadIt = threading.find(*ptrMappingIt);\n        Q_ASSERT(threadIt != threading.end());\n        uidToPtrCache[(*it)->uid()] = threadIt->ptr;\n        threadIt->ptr = 0;\n    }\n    pruneTree();\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n\n    // Second phase: for each message whose UID is returned by the server, update the threading data\n    QSet<uint> usedNodes;\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n        registerThreading(it->thread, 0, uidToPtrCache, usedNodes);\n        int actualOffset = threading[0].children.size() - 1;\n        int expectedOffsetOfPrevious = threading[0].children.indexOf(it->previousThreadRoot);\n        if (actualOffset == expectedOffsetOfPrevious + 1) {\n            // it's on the correct position, yay!\n        } else {\n            // move the new subthread to a correct place\n            threading[0].children.insert(expectedOffsetOfPrevious + 1, threading[0].children.takeLast());\n            // push the rest (including the new arrival) forward\n            for (int i = expectedOffsetOfPrevious + 1; i < threading[0].children.size(); ++i) {\n                threading[threading[0].children[i]].offset = i;\n            }\n        }\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::slotIncrementalThreadingAvailable(const Responses::ESearch::IncrementalThreadingData_t &data)\n  {\n      // Preparation: get through to the real model\n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      Q_ASSERT(someMessage.isValid());\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n      Q_ASSERT(mailboxIndex.isValid());\n  \n      // First phase: remove all messages mentioned in the incremental responses from their original placement\n      QVector<uint> affectedUids;\n      for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n          gatherAllUidsFromThreadNode(affectedUids, it->thread);\n      }\n      qSort(affectedUids);\n      QList<TreeItemMessage*> affectedMessages = const_cast<Model*>(realModel)->\n              findMessagesByUids(static_cast<TreeItemMailbox*>(mailboxIndex.internalPointer()), affectedUids.toList());\n      QHash<uint,void *> uidToPtrCache;\n  \n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      for (QList<TreeItemMessage*>::const_iterator it = affectedMessages.constBegin(); it != affectedMessages.constEnd(); ++it) {\n          QHash<void *,uint>::const_iterator ptrMappingIt = ptrToInternal.constFind(*it);\n          Q_ASSERT(ptrMappingIt != ptrToInternal.constEnd());\n          QHash<uint,ThreadNodeInfo>::iterator threadIt = threading.find(*ptrMappingIt);\n          Q_ASSERT(threadIt != threading.end());\n          uidToPtrCache[(*it)->uid()] = threadIt->ptr;\n          threadIt->ptr = 0;\n      }\n      pruneTree();\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  \n      // Second phase: for each message whose UID is returned by the server, update the threading data\n      QSet<uint> usedNodes;\n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      for (Responses::ESearch::IncrementalThreadingData_t::const_iterator it = data.constBegin(); it != data.constEnd(); ++it) {\n          registerThreading(it->thread, 0, uidToPtrCache, usedNodes);\n          int actualOffset = threading[0].children.size() - 1;\n          int expectedOffsetOfPrevious = threading[0].children.indexOf(it->previousThreadRoot);\n          if (actualOffset == expectedOffsetOfPrevious + 1) {\n              // it's on the correct position, yay!\n          } else {\n              // move the new subthread to a correct place\n              threading[0].children.insert(expectedOffsetOfPrevious + 1, threading[0].children.takeLast());\n              // push the rest (including the new arrival) forward\n              for (int i = expectedOffsetOfPrevious + 1; i < threading[0].children.size(); ++i) {\n                  threading[threading[0].children[i]].offset = i;\n              }\n          }\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t))"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->m_taskFactory->\n                    createIncrementalThreadTask",
          "args": [
            "onst_cast<Model *>(realModel),",
            "ailboxIndex,",
            "equestedAlgorithm,",
            "StringList() << \"INTHREAD\" << requestedAlgorithm << \"UID\" <<\n                                                                        Sequence::startingAt(firstUnknownUid).toByteArray())"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::startingAt",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::startingAt(",
          "args": [
            "irstUnknownUid)"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "startingAt(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "35-41",
          "snippet": "equence Sequence::startingAt(const uint lo)\n{\n    Sequence res(lo);\n    res.lo = lo;\n    res.kind = UNLIMITED;\n    return res;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  equence Sequence::startingAt(const uint lo)\n  {\n      Sequence res(lo);\n      res.lo = lo;\n      res.kind = UNLIMITED;\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model *>",
          "args": [
            "ealModel)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [
            "Latin1String(\"INCTHREAD\"))"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INCTHREAD\")"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedAlgorithm.isEmpty",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [
            "Latin1String(\"THREAD=ORDEREDSUBJECT\"))"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "THREAD=ORDEREDSUBJECT\")"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [
            "Latin1String(\"THREAD=REFERENCES\"))"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "THREAD=REFERENCES\")"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [
            "Latin1String(\"THREAD=REFS\"))"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "THREAD=REFS\")"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->capabilities",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealIndex.parent",
          "args": [],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::Mailbox::Model::realTreeItem(",
          "args": [
            "omeMessage,",
            "realModel,",
            "realIndex)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ourceModel()->rowCount())"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ourceModel())"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_shallBeThreading)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::askForThreading(const uint firstUnknownUid)\n  {\n      Q_ASSERT(m_shallBeThreading);\n      Q_ASSERT(sourceModel());\n      Q_ASSERT(sourceModel()->rowCount());\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n  \n      if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFS\"))) {\n          requestedAlgorithm = \"REFS\";\n      } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFERENCES\"))) {\n          requestedAlgorithm = \"REFERENCES\";\n      } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=ORDEREDSUBJECT\"))) {\n          requestedAlgorithm = \"ORDEREDSUBJECT\";\n      }\n  \n      if (! requestedAlgorithm.isEmpty()) {\n          threadingInFlight = true;\n          ThreadTask *threadTask;\n          if (firstUnknownUid && realModel->capabilities().contains(QLatin1String(\"INCTHREAD\"))) {\n              threadTask = realModel->m_taskFactory->\n                      createIncrementalThreadTask(const_cast<Model *>(realModel), mailboxIndex, requestedAlgorithm,\n                                                                      QStringList() << \"INTHREAD\" << requestedAlgorithm << \"UID\" <<\n                                                                          Sequence::startingAt(firstUnknownUid).toByteArray());\n              connect(threadTask, SIGNAL(incrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)),\n                      this, SLOT(slotIncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)));\n              connect(threadTask, SIGNAL(failed(QString)), this, SLOT(slotIncrementalThreadingFailed()));\n          } else {\n              threadTask = realModel->m_taskFactory->createThreadTask(const_cast<Model *>(realModel), mailboxIndex,\n                                                                      requestedAlgorithm, QStringList() << QLatin1String(\"ALL\"));\n              connect(realModel, SIGNAL(threadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)),\n                      this, SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n              connect(realModel, SIGNAL(threadingFailed(QModelIndex,QByteArray,QStringList)),\n                      this, SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "findHighEnoughNumber(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "579-608",
    "snippet": "int ThreadingMsgListModel::findHighEnoughNumber(const QVector<Responses::ThreadingNode> &mapping, uint marker)\n{\n    if (mapping.isEmpty())\n        return 0;\n\n    // Find the highest UID for which we have the threading info\n    uint highestUidInThreadingLowerBound = 0;\n\n    // If the threading already contains everything we need, we could have a higher chance of finding the high enough UID at the\n    // end of the list.  On the other hand, in case when the cached THREAD response does not cintain everything we need, we're out\n    // of luck, we have absolutely no guarantee about relative greatness of parent/child/siblings in the tree.\n    // Searching backward could lead to faster lookups, but we cannot avoid a full lookup in the bad case.\n    for (int i = mapping.size() - 1; i >= 0; --i) {\n        if (highestUidInThreadingLowerBound < mapping[i].num) {\n            highestUidInThreadingLowerBound = mapping[i].num;\n\n            if (highestUidInThreadingLowerBound >= marker) {\n                // There's no point going further, we already know that we shall ask for threading\n                return highestUidInThreadingLowerBound;\n            }\n        }\n\n        // OK, we have to consult our children\n        highestUidInThreadingLowerBound = qMax(highestUidInThreadingLowerBound, findHighEnoughNumber(mapping[i].children, marker));\n        if (highestUidInThreadingLowerBound >= marker) {\n            return highestUidInThreadingLowerBound;\n        }\n    }\n    return highestUidInThreadingLowerBound;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            "ighestUidInThreadingLowerBound,",
            "indHighEnoughNumber(mapping[i].children, marker))"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indHighEnoughNumber(",
          "args": [
            "apping[i].children,",
            "arker)"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "findHighEnoughNumber(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "579-608",
          "snippet": "int ThreadingMsgListModel::findHighEnoughNumber(const QVector<Responses::ThreadingNode> &mapping, uint marker)\n{\n    if (mapping.isEmpty())\n        return 0;\n\n    // Find the highest UID for which we have the threading info\n    uint highestUidInThreadingLowerBound = 0;\n\n    // If the threading already contains everything we need, we could have a higher chance of finding the high enough UID at the\n    // end of the list.  On the other hand, in case when the cached THREAD response does not cintain everything we need, we're out\n    // of luck, we have absolutely no guarantee about relative greatness of parent/child/siblings in the tree.\n    // Searching backward could lead to faster lookups, but we cannot avoid a full lookup in the bad case.\n    for (int i = mapping.size() - 1; i >= 0; --i) {\n        if (highestUidInThreadingLowerBound < mapping[i].num) {\n            highestUidInThreadingLowerBound = mapping[i].num;\n\n            if (highestUidInThreadingLowerBound >= marker) {\n                // There's no point going further, we already know that we shall ask for threading\n                return highestUidInThreadingLowerBound;\n            }\n        }\n\n        // OK, we have to consult our children\n        highestUidInThreadingLowerBound = qMax(highestUidInThreadingLowerBound, findHighEnoughNumber(mapping[i].children, marker));\n        if (highestUidInThreadingLowerBound >= marker) {\n            return highestUidInThreadingLowerBound;\n        }\n    }\n    return highestUidInThreadingLowerBound;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "apping.size",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apping.isEmpty",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  int ThreadingMsgListModel::findHighEnoughNumber(const QVector<Responses::ThreadingNode> &mapping, uint marker)\n  {\n      if (mapping.isEmpty())\n          return 0;\n  \n      // Find the highest UID for which we have the threading info\n      uint highestUidInThreadingLowerBound = 0;\n  \n      // If the threading already contains everything we need, we could have a higher chance of finding the high enough UID at the\n      // end of the list.  On the other hand, in case when the cached THREAD response does not cintain everything we need, we're out\n      // of luck, we have absolutely no guarantee about relative greatness of parent/child/siblings in the tree.\n      // Searching backward could lead to faster lookups, but we cannot avoid a full lookup in the bad case.\n      for (int i = mapping.size() - 1; i >= 0; --i) {\n          if (highestUidInThreadingLowerBound < mapping[i].num) {\n              highestUidInThreadingLowerBound = mapping[i].num;\n  \n              if (highestUidInThreadingLowerBound >= marker) {\n                  // There's no point going further, we already know that we shall ask for threading\n                  return highestUidInThreadingLowerBound;\n              }\n          }\n  \n          // OK, we have to consult our children\n          highestUidInThreadingLowerBound = qMax(highestUidInThreadingLowerBound, findHighEnoughNumber(mapping[i].children, marker));\n          if (highestUidInThreadingLowerBound >= marker) {\n              return highestUidInThreadingLowerBound;\n          }\n      }\n      return highestUidInThreadingLowerBound;\n  }\n}"
  },
  {
    "function_name": "findHighestUidInMailbox(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "570-577",
    "snippet": "int ThreadingMsgListModel::findHighestUidInMailbox(TreeItemMsgList *list)\n{\n    uint highestUidInMailbox = 0;\n    for (int i = sourceModel()->rowCount() - 1; i > -1 && !highestUidInMailbox; --i) {\n        highestUidInMailbox = dynamic_cast<TreeItemMessage*>(list->m_children[i])->uid();\n    }\n    return highestUidInMailbox;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage*>",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMessage*>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  int ThreadingMsgListModel::findHighestUidInMailbox(TreeItemMsgList *list)\n  {\n      uint highestUidInMailbox = 0;\n      for (int i = sourceModel()->rowCount() - 1; i > -1 && !highestUidInMailbox; --i) {\n          highestUidInMailbox = dynamic_cast<TreeItemMessage*>(list->m_children[i])->uid();\n      }\n      return highestUidInMailbox;\n  }\n}"
  },
  {
    "function_name": "wantThreading(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "503-568",
    "snippet": "oid ThreadingMsgListModel::wantThreading(const SkipSortSearch skipSortSearch)\n{\n    if (!sourceModel() || !sourceModel()->rowCount() || !m_shallBeThreading) {\n        updateNoThreading();\n        if (skipSortSearch == AUTO_SORT_SEARCH) {\n            searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n        }\n        return;\n    }\n\n    if (threadingInFlight) {\n        // Imagine the following scenario:\n        // <<< \"* 3 EXISTS\"\n        // Message 2 has unknown UID\n        // >>> \"y4 UID FETCH 66:* (FLAGS)\"\n        // >>> \"y5 UID THREAD REFS utf-8 ALL\"\n        // <<< \"* 3 FETCH (UID 66 FLAGS ())\"\n        // Got UID for seq# 3\n        // ThreadingMsgListModel::wantThreading: THREAD contains info about UID 1 (or higher), mailbox has 66\n        //    *** this is the interesting part ***\n        // <<< \"y4 OK fetch\"\n        // <<< \"* THREAD (1)(2)(66)\"\n        // <<< \"y5 OK thread\"\n        // >>> \"y6 UID THREAD REFS utf-8 ALL\"\n        //\n        // See, at the indicated (***) place, we already have an in-flight THREAD request and receive UID for newly arrived\n        // message.  We certainly don't want to ask for threading once again; it's better to wait a bit and only ask when the\n        // to-be-received THREAD does not contain all required UIDs.\n        if (skipSortSearch == AUTO_SORT_SEARCH) {\n            searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n        }\n        return;\n    }\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailbox = realIndex.parent().parent();\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(static_cast<TreeItem*>(realIndex.parent().internalPointer()));\n    Q_ASSERT(list);\n\n    // Something has happened and we want to process the THREAD response\n    QVector<Imap::Responses::ThreadingNode> mapping = realModel->cache()->messageThreading(mailbox.data(RoleMailboxName).toString());\n\n    // Find the UID of the last message in the mailbox\n    uint highestUidInMailbox = findHighestUidInMailbox(list);\n    uint highestUidInThreadingLowerBound = findHighEnoughNumber(mapping, highestUidInMailbox);\n\n    logTrace(QString::fromUtf8(\"ThreadingMsgListModel::wantThreading: THREAD contains info about UID %1 (or higher), mailbox has %2\")\n             .arg(QString::number(highestUidInThreadingLowerBound), QString::number(highestUidInMailbox)));\n\n    if (highestUidInThreadingLowerBound >= highestUidInMailbox) {\n        // There's no point asking for data at this point, we shall just apply threading\n        applyThreading(mapping);\n    } else {\n        // There's apparently at least one known UID whose threading info we do not know; that means that we have to ask the\n        // server here.\n        auto roughlyLastKnown = const_cast<Model*>(realModel)->findMessageOrNextOneByUid(list, highestUidInThreadingLowerBound);\n        if (list->m_children.end() - roughlyLastKnown >= 50 || roughlyLastKnown == list->m_children.begin()) {\n            askForThreading();\n        } else {\n            askForThreading(static_cast<TreeItemMessage*>(*roughlyLastKnown)->uid() + 1);\n        }\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skForThreading(",
          "args": [
            "tatic_cast<TreeItemMessage*>(*roughlyLastKnown)->uid() + 1)"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "askForThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "610-650",
          "snippet": "oid ThreadingMsgListModel::askForThreading(const uint firstUnknownUid)\n{\n    Q_ASSERT(m_shallBeThreading);\n    Q_ASSERT(sourceModel());\n    Q_ASSERT(sourceModel()->rowCount());\n\n    const Imap::Mailbox::Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n\n    if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFS\"))) {\n        requestedAlgorithm = \"REFS\";\n    } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFERENCES\"))) {\n        requestedAlgorithm = \"REFERENCES\";\n    } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=ORDEREDSUBJECT\"))) {\n        requestedAlgorithm = \"ORDEREDSUBJECT\";\n    }\n\n    if (! requestedAlgorithm.isEmpty()) {\n        threadingInFlight = true;\n        ThreadTask *threadTask;\n        if (firstUnknownUid && realModel->capabilities().contains(QLatin1String(\"INCTHREAD\"))) {\n            threadTask = realModel->m_taskFactory->\n                    createIncrementalThreadTask(const_cast<Model *>(realModel), mailboxIndex, requestedAlgorithm,\n                                                                    QStringList() << \"INTHREAD\" << requestedAlgorithm << \"UID\" <<\n                                                                        Sequence::startingAt(firstUnknownUid).toByteArray());\n            connect(threadTask, SIGNAL(incrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)),\n                    this, SLOT(slotIncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)));\n            connect(threadTask, SIGNAL(failed(QString)), this, SLOT(slotIncrementalThreadingFailed()));\n        } else {\n            threadTask = realModel->m_taskFactory->createThreadTask(const_cast<Model *>(realModel), mailboxIndex,\n                                                                    requestedAlgorithm, QStringList() << QLatin1String(\"ALL\"));\n            connect(realModel, SIGNAL(threadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)),\n                    this, SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n            connect(realModel, SIGNAL(threadingFailed(QModelIndex,QByteArray,QStringList)),\n                    this, SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::askForThreading(const uint firstUnknownUid)\n  {\n      Q_ASSERT(m_shallBeThreading);\n      Q_ASSERT(sourceModel());\n      Q_ASSERT(sourceModel()->rowCount());\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n  \n      if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFS\"))) {\n          requestedAlgorithm = \"REFS\";\n      } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=REFERENCES\"))) {\n          requestedAlgorithm = \"REFERENCES\";\n      } else if (realModel->capabilities().contains(QLatin1String(\"THREAD=ORDEREDSUBJECT\"))) {\n          requestedAlgorithm = \"ORDEREDSUBJECT\";\n      }\n  \n      if (! requestedAlgorithm.isEmpty()) {\n          threadingInFlight = true;\n          ThreadTask *threadTask;\n          if (firstUnknownUid && realModel->capabilities().contains(QLatin1String(\"INCTHREAD\"))) {\n              threadTask = realModel->m_taskFactory->\n                      createIncrementalThreadTask(const_cast<Model *>(realModel), mailboxIndex, requestedAlgorithm,\n                                                                      QStringList() << \"INTHREAD\" << requestedAlgorithm << \"UID\" <<\n                                                                          Sequence::startingAt(firstUnknownUid).toByteArray());\n              connect(threadTask, SIGNAL(incrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)),\n                      this, SLOT(slotIncrementalThreadingAvailable(Responses::ESearch::IncrementalThreadingData_t)));\n              connect(threadTask, SIGNAL(failed(QString)), this, SLOT(slotIncrementalThreadingFailed()));\n          } else {\n              threadTask = realModel->m_taskFactory->createThreadTask(const_cast<Model *>(realModel), mailboxIndex,\n                                                                      requestedAlgorithm, QStringList() << QLatin1String(\"ALL\"));\n              connect(realModel, SIGNAL(threadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)),\n                      this, SLOT(slotThreadingAvailable(QModelIndex,QByteArray,QStringList,QVector<Imap::Responses::ThreadingNode>)));\n              connect(realModel, SIGNAL(threadingFailed(QModelIndex,QByteArray,QStringList)),\n                      this, SLOT(slotThreadingFailed(QModelIndex,QByteArray,QStringList)));\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage*>",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage*>",
          "args": [
            "roughlyLastKnown)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skForThreading(",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.begin",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.end",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model*>",
          "args": [
            "ist,",
            "ighestUidInThreadingLowerBound)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Model*>",
          "args": [
            "ealModel)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pplyThreading(",
          "args": [
            "apping)"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "applyThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "882-965",
          "snippet": "oid ThreadingMsgListModel::applyThreading(const QVector<Imap::Responses::ThreadingNode> &mapping)\n{\n    if (! unknownUids.isEmpty()) {\n        // Some messages have UID zero, which means that they weren't loaded yet. Too bad.\n        logTrace(QString::fromUtf8(\"%1 messages have 0 UID\").arg(unknownUids.size()));\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n\n    updatePersistentIndexesPhase1();\n\n    threading.clear();\n    ptrToInternal.clear();\n    // Default-construct the root node\n    threading[ 0 ].ptr = 0;\n\n    // At first, initialize threading nodes for all messages which are right now available in the mailbox.\n    // We risk that we will have to delete some of them later on, but this is likely better than doing a lookup\n    // for each UID individually (remember, the THREAD response might contain UIDs in crazy order).\n    int upstreamMessages = sourceModel()->rowCount();\n    QHash<uint,void *> uidToPtrCache;\n    QSet<uint> usedNodes;\n    uidToPtrCache.reserve(upstreamMessages);\n    threading.reserve(upstreamMessages);\n    ptrToInternal.reserve(upstreamMessages);\n\n    if (upstreamMessages) {\n        // Work with pointers instead going through the MVC API for performance.\n        // This matters (at least that's what by benchmarks said).\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n        for (int i = 0; i < upstreamMessages; ++i) {\n            ThreadNodeInfo node;\n            node.uid = dynamic_cast<TreeItemMessage *>(list->m_children[i])->uid();\n            if (! node.uid) {\n                throw UnknownMessageIndex(\"Encountered a message with zero UID when threading. This is a bug in Trojita, sorry.\");\n            }\n\n            node.internalId = i + 1;\n            node.ptr = list->m_children[i];\n            uidToPtrCache[node.uid] = node.ptr;\n            threadingHelperLastId = node.internalId;\n            // We're creating a new node here\n            Q_ASSERT(!threading.contains(node.internalId));\n            threading[ node.internalId ] = node;\n            ptrToInternal[ node.ptr ] = node.internalId;\n        }\n    }\n\n    // Mark the root node as always present\n    usedNodes.insert(0);\n\n    // Set up parents and find the list of all used nodes\n    registerThreading(mapping, 0, uidToPtrCache, usedNodes);\n\n    // Now remove all messages which were not referenced in the THREAD response from our mapping\n    QHash<uint,ThreadNodeInfo>::iterator it = threading.begin();\n    while (it != threading.end()) {\n        if (usedNodes.contains(it.key())) {\n            // this message should be shown\n            ++it;\n        } else {\n            // this message is not included in the list of messages actually to be shown\n            ptrToInternal.remove(it->ptr);\n            it = threading.erase(it);\n        }\n    }\n    pruneTree();\n    updatePersistentIndexesPhase2();\n    if (rowCount())\n        threadedRootIds = threading[0].children;\n    emit layoutChanged();\n\n    // If the sorting was active before, we shall reactivate it now\n    searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::applyThreading(const QVector<Imap::Responses::ThreadingNode> &mapping)\n  {\n      if (! unknownUids.isEmpty()) {\n          // Some messages have UID zero, which means that they weren't loaded yet. Too bad.\n          logTrace(QString::fromUtf8(\"%1 messages have 0 UID\").arg(unknownUids.size()));\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n  \n      updatePersistentIndexesPhase1();\n  \n      threading.clear();\n      ptrToInternal.clear();\n      // Default-construct the root node\n      threading[ 0 ].ptr = 0;\n  \n      // At first, initialize threading nodes for all messages which are right now available in the mailbox.\n      // We risk that we will have to delete some of them later on, but this is likely better than doing a lookup\n      // for each UID individually (remember, the THREAD response might contain UIDs in crazy order).\n      int upstreamMessages = sourceModel()->rowCount();\n      QHash<uint,void *> uidToPtrCache;\n      QSet<uint> usedNodes;\n      uidToPtrCache.reserve(upstreamMessages);\n      threading.reserve(upstreamMessages);\n      ptrToInternal.reserve(upstreamMessages);\n  \n      if (upstreamMessages) {\n          // Work with pointers instead going through the MVC API for performance.\n          // This matters (at least that's what by benchmarks said).\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n          for (int i = 0; i < upstreamMessages; ++i) {\n              ThreadNodeInfo node;\n              node.uid = dynamic_cast<TreeItemMessage *>(list->m_children[i])->uid();\n              if (! node.uid) {\n                  throw UnknownMessageIndex(\"Encountered a message with zero UID when threading. This is a bug in Trojita, sorry.\");\n              }\n  \n              node.internalId = i + 1;\n              node.ptr = list->m_children[i];\n              uidToPtrCache[node.uid] = node.ptr;\n              threadingHelperLastId = node.internalId;\n              // We're creating a new node here\n              Q_ASSERT(!threading.contains(node.internalId));\n              threading[ node.internalId ] = node;\n              ptrToInternal[ node.ptr ] = node.internalId;\n          }\n      }\n  \n      // Mark the root node as always present\n      usedNodes.insert(0);\n  \n      // Set up parents and find the list of all used nodes\n      registerThreading(mapping, 0, uidToPtrCache, usedNodes);\n  \n      // Now remove all messages which were not referenced in the THREAD response from our mapping\n      QHash<uint,ThreadNodeInfo>::iterator it = threading.begin();\n      while (it != threading.end()) {\n          if (usedNodes.contains(it.key())) {\n              // this message should be shown\n              ++it;\n          } else {\n              // this message is not included in the list of messages actually to be shown\n              ptrToInternal.remove(it->ptr);\n              it = threading.erase(it);\n          }\n      }\n      pruneTree();\n      updatePersistentIndexesPhase2();\n      if (rowCount())\n          threadedRootIds = threading[0].children;\n      emit layoutChanged();\n  \n      // If the sorting was active before, we shall reactivate it now\n      searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ogTrace(",
          "args": [
            "String::fromUtf8(\"ThreadingMsgListModel::wantThreading: THREAD contains info about UID %1 (or higher), mailbox has %2\")\n             .arg(QString::number(highestUidInThreadingLowerBound), QString::number(highestUidInMailbox)))"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "logTrace(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1205-1226",
          "snippet": "oid ThreadingMsgListModel::logTrace(const QString &message)\n{\n    if (!sourceModel()) {\n        qDebug() << message;\n        return;\n    }\n    QModelIndex idx = sourceModel()->index(0, 0);\n    if (!idx.isValid()) {\n        qDebug() << message;\n        return;\n    }\n\n    // Got to find out the real model and also translate the index to one belonging to a real Model\n    Q_ASSERT(idx.model());\n    const Model *realModel;\n    QModelIndex realIndex;\n    Model::realTreeItem(idx, &realModel, &realIndex);\n    Q_ASSERT(realModel);\n    QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n    const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n            QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::logTrace(const QString &message)\n  {\n      if (!sourceModel()) {\n          qDebug() << message;\n          return;\n      }\n      QModelIndex idx = sourceModel()->index(0, 0);\n      if (!idx.isValid()) {\n          qDebug() << message;\n          return;\n      }\n  \n      // Got to find out the real model and also translate the index to one belonging to a real Model\n      Q_ASSERT(idx.model());\n      const Model *realModel;\n      QModelIndex realIndex;\n      Model::realTreeItem(idx, &realModel, &realIndex);\n      Q_ASSERT(realModel);\n      QModelIndex mailboxIndex = const_cast<Model *>(realModel)->findMailboxForItems(QModelIndexList() << realIndex);\n      const_cast<Model *>(realModel)->logTrace(mailboxIndex, Common::LOG_OTHER,\n              QString::fromUtf8(\"ThreadingMsgListModel for %1\").arg(mailboxIndex.data(RoleMailboxName).toString()), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(highestUidInThreadingLowerBound),",
            "String::number(highestUidInMailbox))"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ighestUidInMailbox)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ighestUidInThreadingLowerBound)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "ThreadingMsgListModel::wantThreading: THREAD contains info about UID %1 (or higher), mailbox has %2\")"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indHighEnoughNumber(",
          "args": [
            "apping,",
            "ighestUidInMailbox)"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "findHighEnoughNumber(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "579-608",
          "snippet": "int ThreadingMsgListModel::findHighEnoughNumber(const QVector<Responses::ThreadingNode> &mapping, uint marker)\n{\n    if (mapping.isEmpty())\n        return 0;\n\n    // Find the highest UID for which we have the threading info\n    uint highestUidInThreadingLowerBound = 0;\n\n    // If the threading already contains everything we need, we could have a higher chance of finding the high enough UID at the\n    // end of the list.  On the other hand, in case when the cached THREAD response does not cintain everything we need, we're out\n    // of luck, we have absolutely no guarantee about relative greatness of parent/child/siblings in the tree.\n    // Searching backward could lead to faster lookups, but we cannot avoid a full lookup in the bad case.\n    for (int i = mapping.size() - 1; i >= 0; --i) {\n        if (highestUidInThreadingLowerBound < mapping[i].num) {\n            highestUidInThreadingLowerBound = mapping[i].num;\n\n            if (highestUidInThreadingLowerBound >= marker) {\n                // There's no point going further, we already know that we shall ask for threading\n                return highestUidInThreadingLowerBound;\n            }\n        }\n\n        // OK, we have to consult our children\n        highestUidInThreadingLowerBound = qMax(highestUidInThreadingLowerBound, findHighEnoughNumber(mapping[i].children, marker));\n        if (highestUidInThreadingLowerBound >= marker) {\n            return highestUidInThreadingLowerBound;\n        }\n    }\n    return highestUidInThreadingLowerBound;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  int ThreadingMsgListModel::findHighEnoughNumber(const QVector<Responses::ThreadingNode> &mapping, uint marker)\n  {\n      if (mapping.isEmpty())\n          return 0;\n  \n      // Find the highest UID for which we have the threading info\n      uint highestUidInThreadingLowerBound = 0;\n  \n      // If the threading already contains everything we need, we could have a higher chance of finding the high enough UID at the\n      // end of the list.  On the other hand, in case when the cached THREAD response does not cintain everything we need, we're out\n      // of luck, we have absolutely no guarantee about relative greatness of parent/child/siblings in the tree.\n      // Searching backward could lead to faster lookups, but we cannot avoid a full lookup in the bad case.\n      for (int i = mapping.size() - 1; i >= 0; --i) {\n          if (highestUidInThreadingLowerBound < mapping[i].num) {\n              highestUidInThreadingLowerBound = mapping[i].num;\n  \n              if (highestUidInThreadingLowerBound >= marker) {\n                  // There's no point going further, we already know that we shall ask for threading\n                  return highestUidInThreadingLowerBound;\n              }\n          }\n  \n          // OK, we have to consult our children\n          highestUidInThreadingLowerBound = qMax(highestUidInThreadingLowerBound, findHighEnoughNumber(mapping[i].children, marker));\n          if (highestUidInThreadingLowerBound >= marker) {\n              return highestUidInThreadingLowerBound;\n          }\n      }\n      return highestUidInThreadingLowerBound;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "indHighestUidInMailbox(",
          "args": [
            "ist)"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "findHighestUidInMailbox(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "570-577",
          "snippet": "int ThreadingMsgListModel::findHighestUidInMailbox(TreeItemMsgList *list)\n{\n    uint highestUidInMailbox = 0;\n    for (int i = sourceModel()->rowCount() - 1; i > -1 && !highestUidInMailbox; --i) {\n        highestUidInMailbox = dynamic_cast<TreeItemMessage*>(list->m_children[i])->uid();\n    }\n    return highestUidInMailbox;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  int ThreadingMsgListModel::findHighestUidInMailbox(TreeItemMsgList *list)\n  {\n      uint highestUidInMailbox = 0;\n      for (int i = sourceModel()->rowCount() - 1; i > -1 && !highestUidInMailbox; --i) {\n          highestUidInMailbox = dynamic_cast<TreeItemMessage*>(list->m_children[i])->uid();\n      }\n      return highestUidInMailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ealModel->cache",
          "args": [
            "ailbox.data(RoleMailboxName).toString())"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox.data",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealModel->cache",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList*>",
          "args": [
            "tatic_cast<TreeItem*>(realIndex.parent().internalPointer()))"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem*>",
          "args": [
            "ealIndex.parent().internalPointer())"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ealIndex.parent",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::Mailbox::Model::realTreeItem(",
          "args": [
            "omeMessage,",
            "realModel,",
            "realIndex)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchSortPreferenceImplementation(",
          "args": [
            "_currentSearchConditions,",
            "_currentSortingCriteria,",
            "_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder)"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "searchSortPreferenceImplementation(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1245-1354",
          "snippet": "ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n{\n    Q_ASSERT(sourceModel());\n    if (!sourceModel()->rowCount()) {\n        return false;\n    }\n\n    const Model *realModel;\n    QModelIndex someMessage = sourceModel()->index(0,0);\n    QModelIndex realIndex;\n    Model::realTreeItem(someMessage, &realModel, &realIndex);\n    QModelIndex mailboxIndex = realIndex.parent().parent();\n\n    bool hasDisplaySort = false;\n    bool hasSort = false;\n    if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n        hasDisplaySort = true;\n        hasSort = true;\n    } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n        // just the regular sort\n        hasSort = true;\n    }\n\n    m_sortReverse = order == Qt::DescendingOrder;\n    QStringList sortOptions;\n    switch (criterium) {\n    case SORT_ARRIVAL:\n        sortOptions << QLatin1String(\"ARRIVAL\");\n        break;\n    case SORT_CC:\n        sortOptions << QLatin1String(\"CC\");\n        break;\n    case SORT_DATE:\n        sortOptions << QLatin1String(\"DATE\");\n        break;\n    case SORT_FROM:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n        break;\n    case SORT_SIZE:\n        sortOptions << QLatin1String(\"SIZE\");\n        break;\n    case SORT_SUBJECT:\n        sortOptions << QLatin1String(\"SUBJECT\");\n        break;\n    case SORT_TO:\n        sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n        break;\n    case SORT_NONE:\n        if (m_sortTask && m_sortTask->isPersistent() &&\n                (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n            // Any change shall result in us killing that sort task\n            m_sortTask->cancelSortingUpdates();\n        }\n\n        m_currentSortingCriteria = criterium;\n\n        if (searchConditions.isEmpty()) {\n            // This operation is special, it will immediately restore the original shape of the mailbox\n            m_currentSearchConditions = searchConditions;\n            calculateNullSort();\n            applySort();\n            return true;\n        } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n            // We have to update our search conditions\n            m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                  QStringList());\n            connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n            connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n            connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                    this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n            m_currentSearchConditions = searchConditions;\n            m_searchValidity = RESULT_ASKED;\n        } else {\n            // A result of SEARCH has just arrived\n            Q_ASSERT(m_searchValidity == RESULT_FRESH);\n            applySort();\n        }\n\n        return true;\n    }\n\n    if (!hasSort) {\n        // sorting is completely unsupported\n        return false;\n    }\n\n    Q_ASSERT(!sortOptions.isEmpty());\n\n    if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n            m_searchValidity != RESULT_INVALIDATED) {\n        applySort();\n    } else {\n        m_currentSearchConditions = searchConditions;\n        m_currentSortingCriteria = criterium;\n        calculateNullSort();\n        applySort();\n\n        if (m_sortTask && m_sortTask->isPersistent())\n            m_sortTask->cancelSortingUpdates();\n\n        m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n        connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n        connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n        connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n        m_searchValidity = RESULT_ASKED;\n    }\n\n    return true;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::searchSortPreferenceImplementation(const QStringList &searchConditions, const SortCriterium criterium, const Qt::SortOrder order)\n  {\n      Q_ASSERT(sourceModel());\n      if (!sourceModel()->rowCount()) {\n          return false;\n      }\n  \n      const Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailboxIndex = realIndex.parent().parent();\n  \n      bool hasDisplaySort = false;\n      bool hasSort = false;\n      if (realModel->capabilities().contains(QLatin1String(\"SORT=DISPLAY\"))) {\n          hasDisplaySort = true;\n          hasSort = true;\n      } else if (realModel->capabilities().contains(QLatin1String(\"SORT\"))) {\n          // just the regular sort\n          hasSort = true;\n      }\n  \n      m_sortReverse = order == Qt::DescendingOrder;\n      QStringList sortOptions;\n      switch (criterium) {\n      case SORT_ARRIVAL:\n          sortOptions << QLatin1String(\"ARRIVAL\");\n          break;\n      case SORT_CC:\n          sortOptions << QLatin1String(\"CC\");\n          break;\n      case SORT_DATE:\n          sortOptions << QLatin1String(\"DATE\");\n          break;\n      case SORT_FROM:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYFROM\") : QLatin1String(\"FROM\"));\n          break;\n      case SORT_SIZE:\n          sortOptions << QLatin1String(\"SIZE\");\n          break;\n      case SORT_SUBJECT:\n          sortOptions << QLatin1String(\"SUBJECT\");\n          break;\n      case SORT_TO:\n          sortOptions << (hasDisplaySort ? QLatin1String(\"DISPLAYTO\") : QLatin1String(\"TO\"));\n          break;\n      case SORT_NONE:\n          if (m_sortTask && m_sortTask->isPersistent() &&\n                  (m_currentSearchConditions != searchConditions || m_currentSortingCriteria != criterium)) {\n              // Any change shall result in us killing that sort task\n              m_sortTask->cancelSortingUpdates();\n          }\n  \n          m_currentSortingCriteria = criterium;\n  \n          if (searchConditions.isEmpty()) {\n              // This operation is special, it will immediately restore the original shape of the mailbox\n              m_currentSearchConditions = searchConditions;\n              calculateNullSort();\n              applySort();\n              return true;\n          } else if (searchConditions != m_currentSearchConditions || m_searchValidity != RESULT_FRESH) {\n              // We have to update our search conditions\n              m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions,\n                                                                    QStringList());\n              connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n              connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n              connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                      this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n              m_currentSearchConditions = searchConditions;\n              m_searchValidity = RESULT_ASKED;\n          } else {\n              // A result of SEARCH has just arrived\n              Q_ASSERT(m_searchValidity == RESULT_FRESH);\n              applySort();\n          }\n  \n          return true;\n      }\n  \n      if (!hasSort) {\n          // sorting is completely unsupported\n          return false;\n      }\n  \n      Q_ASSERT(!sortOptions.isEmpty());\n  \n      if (m_currentSortingCriteria == criterium && m_currentSearchConditions == searchConditions &&\n              m_searchValidity != RESULT_INVALIDATED) {\n          applySort();\n      } else {\n          m_currentSearchConditions = searchConditions;\n          m_currentSortingCriteria = criterium;\n          calculateNullSort();\n          applySort();\n  \n          if (m_sortTask && m_sortTask->isPersistent())\n              m_sortTask->cancelSortingUpdates();\n  \n          m_sortTask = realModel->m_taskFactory->createSortTask(const_cast<Model *>(realModel), mailboxIndex, searchConditions, sortOptions);\n          connect(m_sortTask, SIGNAL(sortingAvailable(QList<uint>)), this, SLOT(slotSortingAvailable(QList<uint>)));\n          connect(m_sortTask, SIGNAL(sortingFailed()), this, SLOT(slotSortingFailed()));\n          connect(m_sortTask, SIGNAL(incrementalSortUpdate(Imap::Responses::ESearch::IncrementalContextData_t)),\n                  this, SLOT(slotSortingIncrementalUpdate(Imap::Responses::ESearch::IncrementalContextData_t)));\n          m_searchValidity = RESULT_ASKED;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdateNoThreading(",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "updateNoThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "433-501",
          "snippet": "oid ThreadingMsgListModel::updateNoThreading()\n{\n    threadingHelperLastId = 0;\n\n    if (!sourceModel()) {\n        // Maybe we got reset because the parent model is no longer here...\n        if (! threading.isEmpty()) {\n            beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n            threading.clear();\n            ptrToInternal.clear();\n            endRemoveRows();\n        }\n        unknownUids.clear();\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n\n    int upstreamMessages = sourceModel()->rowCount();\n    QList<uint> allIds;\n    QHash<uint,ThreadNodeInfo> newThreading;\n    QHash<void *,uint> newPtrToInternal;\n\n    if (upstreamMessages) {\n        // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n        // This improves the speed of the testSortingPerformance benchmark by 18%.\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n\n        for (int i = 0; i < upstreamMessages; ++i) {\n            TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n            Q_ASSERT(ptr);\n            ThreadNodeInfo node;\n            node.internalId = i + 1;\n            node.uid = ptr->uid();\n            node.ptr = ptr;\n            node.offset = i;\n            newThreading[node.internalId] = node;\n            allIds.append(node.internalId);\n            newPtrToInternal[node.ptr] = node.internalId;\n            if (!node.uid) {\n                unknownUids << ptr;\n            }\n        }\n    }\n\n    if (newThreading.size()) {\n        threading = newThreading;\n        ptrToInternal = newPtrToInternal;\n        threading[ 0 ].children = allIds;\n        threading[ 0 ].ptr = 0;\n        threadingHelperLastId = newThreading.size();\n        threadedRootIds = threading[0].children;\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updateNoThreading()\n  {\n      threadingHelperLastId = 0;\n  \n      if (!sourceModel()) {\n          // Maybe we got reset because the parent model is no longer here...\n          if (! threading.isEmpty()) {\n              beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n              threading.clear();\n              ptrToInternal.clear();\n              endRemoveRows();\n          }\n          unknownUids.clear();\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n  \n      int upstreamMessages = sourceModel()->rowCount();\n      QList<uint> allIds;\n      QHash<uint,ThreadNodeInfo> newThreading;\n      QHash<void *,uint> newPtrToInternal;\n  \n      if (upstreamMessages) {\n          // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n          // This improves the speed of the testSortingPerformance benchmark by 18%.\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n  \n          for (int i = 0; i < upstreamMessages; ++i) {\n              TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n              Q_ASSERT(ptr);\n              ThreadNodeInfo node;\n              node.internalId = i + 1;\n              node.uid = ptr->uid();\n              node.ptr = ptr;\n              node.offset = i;\n              newThreading[node.internalId] = node;\n              allIds.append(node.internalId);\n              newPtrToInternal[node.ptr] = node.internalId;\n              if (!node.uid) {\n                  unknownUids << ptr;\n              }\n          }\n      }\n  \n      if (newThreading.size()) {\n          threading = newThreading;\n          ptrToInternal = newPtrToInternal;\n          threading[ 0 ].children = allIds;\n          threading[ 0 ].ptr = 0;\n          threadingHelperLastId = newThreading.size();\n          threadedRootIds = threading[0].children;\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::wantThreading(const SkipSortSearch skipSortSearch)\n  {\n      if (!sourceModel() || !sourceModel()->rowCount() || !m_shallBeThreading) {\n          updateNoThreading();\n          if (skipSortSearch == AUTO_SORT_SEARCH) {\n              searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n          }\n          return;\n      }\n  \n      if (threadingInFlight) {\n          // Imagine the following scenario:\n          // <<< \"* 3 EXISTS\"\n          // Message 2 has unknown UID\n          // >>> \"y4 UID FETCH 66:* (FLAGS)\"\n          // >>> \"y5 UID THREAD REFS utf-8 ALL\"\n          // <<< \"* 3 FETCH (UID 66 FLAGS ())\"\n          // Got UID for seq# 3\n          // ThreadingMsgListModel::wantThreading: THREAD contains info about UID 1 (or higher), mailbox has 66\n          //    *** this is the interesting part ***\n          // <<< \"y4 OK fetch\"\n          // <<< \"* THREAD (1)(2)(66)\"\n          // <<< \"y5 OK thread\"\n          // >>> \"y6 UID THREAD REFS utf-8 ALL\"\n          //\n          // See, at the indicated (***) place, we already have an in-flight THREAD request and receive UID for newly arrived\n          // message.  We certainly don't want to ask for threading once again; it's better to wait a bit and only ask when the\n          // to-be-received THREAD does not contain all required UIDs.\n          if (skipSortSearch == AUTO_SORT_SEARCH) {\n              searchSortPreferenceImplementation(m_currentSearchConditions, m_currentSortingCriteria, m_sortReverse ? Qt::DescendingOrder : Qt::AscendingOrder);\n          }\n          return;\n      }\n  \n      const Imap::Mailbox::Model *realModel;\n      QModelIndex someMessage = sourceModel()->index(0,0);\n      QModelIndex realIndex;\n      Imap::Mailbox::Model::realTreeItem(someMessage, &realModel, &realIndex);\n      QModelIndex mailbox = realIndex.parent().parent();\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(static_cast<TreeItem*>(realIndex.parent().internalPointer()));\n      Q_ASSERT(list);\n  \n      // Something has happened and we want to process the THREAD response\n      QVector<Imap::Responses::ThreadingNode> mapping = realModel->cache()->messageThreading(mailbox.data(RoleMailboxName).toString());\n  \n      // Find the UID of the last message in the mailbox\n      uint highestUidInMailbox = findHighestUidInMailbox(list);\n      uint highestUidInThreadingLowerBound = findHighEnoughNumber(mapping, highestUidInMailbox);\n  \n      logTrace(QString::fromUtf8(\"ThreadingMsgListModel::wantThreading: THREAD contains info about UID %1 (or higher), mailbox has %2\")\n               .arg(QString::number(highestUidInThreadingLowerBound), QString::number(highestUidInMailbox)));\n  \n      if (highestUidInThreadingLowerBound >= highestUidInMailbox) {\n          // There's no point asking for data at this point, we shall just apply threading\n          applyThreading(mapping);\n      } else {\n          // There's apparently at least one known UID whose threading info we do not know; that means that we have to ask the\n          // server here.\n          auto roughlyLastKnown = const_cast<Model*>(realModel)->findMessageOrNextOneByUid(list, highestUidInThreadingLowerBound);\n          if (list->m_children.end() - roughlyLastKnown >= 50 || roughlyLastKnown == list->m_children.begin()) {\n              askForThreading();\n          } else {\n              askForThreading(static_cast<TreeItemMessage*>(*roughlyLastKnown)->uid() + 1);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "updateNoThreading(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "433-501",
    "snippet": "oid ThreadingMsgListModel::updateNoThreading()\n{\n    threadingHelperLastId = 0;\n\n    if (!sourceModel()) {\n        // Maybe we got reset because the parent model is no longer here...\n        if (! threading.isEmpty()) {\n            beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n            threading.clear();\n            ptrToInternal.clear();\n            endRemoveRows();\n        }\n        unknownUids.clear();\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n\n    int upstreamMessages = sourceModel()->rowCount();\n    QList<uint> allIds;\n    QHash<uint,ThreadNodeInfo> newThreading;\n    QHash<void *,uint> newPtrToInternal;\n\n    if (upstreamMessages) {\n        // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n        // This improves the speed of the testSortingPerformance benchmark by 18%.\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n\n        for (int i = 0; i < upstreamMessages; ++i) {\n            TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n            Q_ASSERT(ptr);\n            ThreadNodeInfo node;\n            node.internalId = i + 1;\n            node.uid = ptr->uid();\n            node.ptr = ptr;\n            node.offset = i;\n            newThreading[node.internalId] = node;\n            allIds.append(node.internalId);\n            newPtrToInternal[node.ptr] = node.internalId;\n            if (!node.uid) {\n                unknownUids << ptr;\n            }\n        }\n    }\n\n    if (newThreading.size()) {\n        threading = newThreading;\n        ptrToInternal = newPtrToInternal;\n        threading[ 0 ].children = allIds;\n        threading[ 0 ].ptr = 0;\n        threadingHelperLastId = newThreading.size();\n        threadedRootIds = threading[0].children;\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase2(",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase2(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1027-1050",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n{\n    Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n    QList<QModelIndex> updatedIndexes;\n    for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n        QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n        if (ptrIt == ptrToInternal.constEnd()) {\n            // That message is no longer there\n            updatedIndexes.append(QModelIndex());\n            continue;\n        }\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n        if (it == threading.constEnd()) {\n            // Filtering doesn't accept this index, let's declare it dead\n            updatedIndexes.append(QModelIndex());\n        } else {\n            updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n        }\n    }\n    Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n    changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n    oldPersistentIndexes.clear();\n    oldPtrs.clear();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n  {\n      Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n      QList<QModelIndex> updatedIndexes;\n      for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n          QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n          if (ptrIt == ptrToInternal.constEnd()) {\n              // That message is no longer there\n              updatedIndexes.append(QModelIndex());\n              continue;\n          }\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n          if (it == threading.constEnd()) {\n              // Filtering doesn't accept this index, let's declare it dead\n              updatedIndexes.append(QModelIndex());\n          } else {\n              updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n          }\n      }\n      Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n      changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n      oldPersistentIndexes.clear();\n      oldPtrs.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ewThreading.size",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewThreading.size",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llIds.append",
          "args": [
            "ode.internalId)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr->uid",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tr)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage*>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "irstMessagePtr->parent())"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstMessagePtr->parent",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstMessagePtr == firstMessageIndex.internalPointer())"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstMessageIndex.internalPointer",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstMessagePtr)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::realTreeItem(",
          "args": [
            "irstMessageIndex,",
            "realModel)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstMessageIndex.isValid())"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstMessageIndex.isValid",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "sourceModelDestroyed(",
          "container": "DescendantsProxyModelPrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/kdeui-itemviews/kdescendantsproxymodel.cpp",
          "lines": "968-971",
          "snippet": "oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n{\n  resetInternalData();\n}",
          "includes": [
            "include \"moc_kdescendantsproxymodel.cpp\"",
            "include \"kbihash_p.h\"",
            "include <QtCore/QTimer>",
            "include <QtCore/QStringList>\n#",
            "include \"kdescendantsproxymodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"moc_kdescendantsproxymodel.cpp\"\ninclude \"kbihash_p.h\"\ninclude <QtCore/QTimer>\ninclude <QtCore/QStringList>\n#\ninclude \"kdescendantsproxymodel.h\"\n\nDescendantsProxyModelPrivate {\n  oid KDescendantsProxyModelPrivate::sourceModelDestroyed()\n  {\n    resetInternalData();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.clear",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase1(",
          "args": [],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase1(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1005-1024",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n{\n    oldPersistentIndexes = persistentIndexList();\n    oldPtrs.clear();\n    Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n        // the index could get invalidated by the pruneTree() or something else manipulating our threading\n        bool isOk = idx.isValid() && threading.contains(idx.internalId());\n        if (!isOk) {\n            oldPtrs << 0;\n            continue;\n        }\n        QModelIndex translated = mapToSource(idx);\n        if (!translated.isValid()) {\n            // another stale item\n            oldPtrs << 0;\n            continue;\n        }\n        oldPtrs << translated.internalPointer();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n  {\n      oldPersistentIndexes = persistentIndexList();\n      oldPtrs.clear();\n      Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n          // the index could get invalidated by the pruneTree() or something else manipulating our threading\n          bool isOk = idx.isValid() && threading.contains(idx.internalId());\n          if (!isOk) {\n              oldPtrs << 0;\n              continue;\n          }\n          QModelIndex translated = mapToSource(idx);\n          if (!translated.isValid()) {\n              // another stale item\n              oldPtrs << 0;\n              continue;\n          }\n          oldPtrs << translated.internalPointer();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndRemoveRows(",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eginRemoveRows(",
          "args": [
            "ModelIndex(),",
            ",",
            "owCount() - 1)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owCount(",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.isEmpty",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updateNoThreading()\n  {\n      threadingHelperLastId = 0;\n  \n      if (!sourceModel()) {\n          // Maybe we got reset because the parent model is no longer here...\n          if (! threading.isEmpty()) {\n              beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n              threading.clear();\n              ptrToInternal.clear();\n              endRemoveRows();\n          }\n          unknownUids.clear();\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n  \n      int upstreamMessages = sourceModel()->rowCount();\n      QList<uint> allIds;\n      QHash<uint,ThreadNodeInfo> newThreading;\n      QHash<void *,uint> newPtrToInternal;\n  \n      if (upstreamMessages) {\n          // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n          // This improves the speed of the testSortingPerformance benchmark by 18%.\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n  \n          for (int i = 0; i < upstreamMessages; ++i) {\n              TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n              Q_ASSERT(ptr);\n              ThreadNodeInfo node;\n              node.internalId = i + 1;\n              node.uid = ptr->uid();\n              node.ptr = ptr;\n              node.offset = i;\n              newThreading[node.internalId] = node;\n              allIds.append(node.internalId);\n              newPtrToInternal[node.ptr] = node.internalId;\n              if (!node.uid) {\n                  unknownUids << ptr;\n              }\n          }\n      }\n  \n      if (newThreading.size()) {\n          threading = newThreading;\n          ptrToInternal = newPtrToInternal;\n          threading[ 0 ].children = allIds;\n          threading[ 0 ].ptr = 0;\n          threadingHelperLastId = newThreading.size();\n          threadedRootIds = threading[0].children;\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
  },
  {
    "function_name": "resetMe(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "412-431",
    "snippet": "oid ThreadingMsgListModel::resetMe()\n{\n    // Prevent possible recursion here\n    if (modelResetInProgress)\n        return;\n\n    modelResetInProgress = true;\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n    RESET_MODEL;\n    updateNoThreading();\n    modelResetInProgress = false;\n\n    if (m_shallBeThreading)\n        wantThreading();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdateNoThreading(",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "updateNoThreading(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "433-501",
          "snippet": "oid ThreadingMsgListModel::updateNoThreading()\n{\n    threadingHelperLastId = 0;\n\n    if (!sourceModel()) {\n        // Maybe we got reset because the parent model is no longer here...\n        if (! threading.isEmpty()) {\n            beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n            threading.clear();\n            ptrToInternal.clear();\n            endRemoveRows();\n        }\n        unknownUids.clear();\n        return;\n    }\n\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n\n    int upstreamMessages = sourceModel()->rowCount();\n    QList<uint> allIds;\n    QHash<uint,ThreadNodeInfo> newThreading;\n    QHash<void *,uint> newPtrToInternal;\n\n    if (upstreamMessages) {\n        // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n        // This improves the speed of the testSortingPerformance benchmark by 18%.\n        QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n        Q_ASSERT(firstMessageIndex.isValid());\n        const Model *realModel = 0;\n        TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n        Q_ASSERT(firstMessagePtr);\n        // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n        Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n        TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n        Q_ASSERT(list);\n\n        for (int i = 0; i < upstreamMessages; ++i) {\n            TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n            Q_ASSERT(ptr);\n            ThreadNodeInfo node;\n            node.internalId = i + 1;\n            node.uid = ptr->uid();\n            node.ptr = ptr;\n            node.offset = i;\n            newThreading[node.internalId] = node;\n            allIds.append(node.internalId);\n            newPtrToInternal[node.ptr] = node.internalId;\n            if (!node.uid) {\n                unknownUids << ptr;\n            }\n        }\n    }\n\n    if (newThreading.size()) {\n        threading = newThreading;\n        ptrToInternal = newPtrToInternal;\n        threading[ 0 ].children = allIds;\n        threading[ 0 ].ptr = 0;\n        threadingHelperLastId = newThreading.size();\n        threadedRootIds = threading[0].children;\n    }\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updateNoThreading()\n  {\n      threadingHelperLastId = 0;\n  \n      if (!sourceModel()) {\n          // Maybe we got reset because the parent model is no longer here...\n          if (! threading.isEmpty()) {\n              beginRemoveRows(QModelIndex(), 0, rowCount() - 1);\n              threading.clear();\n              ptrToInternal.clear();\n              endRemoveRows();\n          }\n          unknownUids.clear();\n          return;\n      }\n  \n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n  \n      int upstreamMessages = sourceModel()->rowCount();\n      QList<uint> allIds;\n      QHash<uint,ThreadNodeInfo> newThreading;\n      QHash<void *,uint> newPtrToInternal;\n  \n      if (upstreamMessages) {\n          // Prefer the direct pointer access instead of going through the MVC API -- similar to how applyThreading() works.\n          // This improves the speed of the testSortingPerformance benchmark by 18%.\n          QModelIndex firstMessageIndex = sourceModel()->index(0, 0);\n          Q_ASSERT(firstMessageIndex.isValid());\n          const Model *realModel = 0;\n          TreeItem *firstMessagePtr = Model::realTreeItem(firstMessageIndex, &realModel);\n          Q_ASSERT(firstMessagePtr);\n          // If the next asserts fails, it means that the implementation of MsgListModel has changed and uses its own pointers\n          Q_ASSERT(firstMessagePtr == firstMessageIndex.internalPointer());\n          TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(firstMessagePtr->parent());\n          Q_ASSERT(list);\n  \n          for (int i = 0; i < upstreamMessages; ++i) {\n              TreeItemMessage *ptr = static_cast<TreeItemMessage*>(list->m_children[i]);\n              Q_ASSERT(ptr);\n              ThreadNodeInfo node;\n              node.internalId = i + 1;\n              node.uid = ptr->uid();\n              node.ptr = ptr;\n              node.offset = i;\n              newThreading[node.internalId] = node;\n              allIds.append(node.internalId);\n              newPtrToInternal[node.ptr] = node.internalId;\n              if (!node.uid) {\n                  unknownUids << ptr;\n              }\n          }\n      }\n  \n      if (newThreading.size()) {\n          threading = newThreading;\n          ptrToInternal = newPtrToInternal;\n          threading[ 0 ].children = allIds;\n          threading[ 0 ].ptr = 0;\n          threadingHelperLastId = newThreading.size();\n          threadedRootIds = threading[0].children;\n      }\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_currentSortResult.clear",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::resetMe()\n  {\n      // Prevent possible recursion here\n      if (modelResetInProgress)\n          return;\n  \n      modelResetInProgress = true;\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n      m_currentSortResult.clear();\n      m_searchValidity = RESULT_INVALIDATED;\n      RESET_MODEL;\n      updateNoThreading();\n      modelResetInProgress = false;\n  \n      if (m_shallBeThreading)\n          wantThreading();\n  }\n}"
  },
  {
    "function_name": "handleRowsInserted(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "379-410",
    "snippet": "oid ThreadingMsgListModel::handleRowsInserted(const QModelIndex &parent, int start, int end)\n{\n    Q_ASSERT(!parent.isValid());\n\n    for (int i = start; i <= end; ++i) {\n        QModelIndex index = sourceModel()->index(i, 0);\n        uint uid = index.data(RoleMessageUid).toUInt();\n        ThreadNodeInfo node;\n        node.internalId = ++threadingHelperLastId;\n        node.uid = uid;\n        node.ptr = static_cast<TreeItem *>(index.internalPointer());\n        node.offset = threading[0].children.size();\n        threading[node.internalId] = node;\n        threading[0].children << node.internalId;\n        ptrToInternal[node.ptr] = node.internalId;\n        if (!node.uid) {\n            unknownUids << static_cast<TreeItem*>(index.internalPointer());\n        } else {\n            threadedRootIds.append(node.internalId);\n        }\n    }\n    endInsertRows();\n\n    if (!m_sortTask || !m_sortTask->isPersistent()) {\n        m_currentSortResult.clear();\n        if (m_searchValidity == RESULT_FRESH)\n            m_searchValidity = RESULT_INVALIDATED;\n    }\n\n    if (m_shallBeThreading)\n        wantThreading();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.clear",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_sortTask->isPersistent",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndInsertRows(",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreadedRootIds.append",
          "args": [
            "ode.internalId)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem*>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.size",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageUid)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ")"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "parent.isValid())"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::handleRowsInserted(const QModelIndex &parent, int start, int end)\n  {\n      Q_ASSERT(!parent.isValid());\n  \n      for (int i = start; i <= end; ++i) {\n          QModelIndex index = sourceModel()->index(i, 0);\n          uint uid = index.data(RoleMessageUid).toUInt();\n          ThreadNodeInfo node;\n          node.internalId = ++threadingHelperLastId;\n          node.uid = uid;\n          node.ptr = static_cast<TreeItem *>(index.internalPointer());\n          node.offset = threading[0].children.size();\n          threading[node.internalId] = node;\n          threading[0].children << node.internalId;\n          ptrToInternal[node.ptr] = node.internalId;\n          if (!node.uid) {\n              unknownUids << static_cast<TreeItem*>(index.internalPointer());\n          } else {\n              threadedRootIds.append(node.internalId);\n          }\n      }\n      endInsertRows();\n  \n      if (!m_sortTask || !m_sortTask->isPersistent()) {\n          m_currentSortResult.clear();\n          if (m_searchValidity == RESULT_FRESH)\n              m_searchValidity = RESULT_INVALIDATED;\n      }\n  \n      if (m_shallBeThreading)\n          wantThreading();\n  }\n}"
  },
  {
    "function_name": "handleRowsAboutToBeInserted(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "370-377",
    "snippet": "oid ThreadingMsgListModel::handleRowsAboutToBeInserted(const QModelIndex &parent, int start, int end)\n{\n    Q_ASSERT(!parent.isValid());\n\n    int myStart = threading[0].children.size();\n    int myEnd = myStart + (end - start);\n    beginInsertRows(QModelIndex(), myStart, myEnd);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eginInsertRows(",
          "args": [
            "ModelIndex(),",
            "yStart,",
            "yEnd)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading[0].children.size",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "parent.isValid())"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::handleRowsAboutToBeInserted(const QModelIndex &parent, int start, int end)\n  {\n      Q_ASSERT(!parent.isValid());\n  \n      int myStart = threading[0].children.size();\n      int myEnd = myStart + (end - start);\n      beginInsertRows(QModelIndex(), myStart, myEnd);\n  }\n}"
  },
  {
    "function_name": "delayedPrune(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "361-368",
    "snippet": "oid ThreadingMsgListModel::delayedPrune()\n{\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    pruneTree();\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase2(",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase2(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1027-1050",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n{\n    Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n    QList<QModelIndex> updatedIndexes;\n    for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n        QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n        if (ptrIt == ptrToInternal.constEnd()) {\n            // That message is no longer there\n            updatedIndexes.append(QModelIndex());\n            continue;\n        }\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n        if (it == threading.constEnd()) {\n            // Filtering doesn't accept this index, let's declare it dead\n            updatedIndexes.append(QModelIndex());\n        } else {\n            updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n        }\n    }\n    Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n    changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n    oldPersistentIndexes.clear();\n    oldPtrs.clear();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase2()\n  {\n      Q_ASSERT(oldPersistentIndexes.size() == oldPtrs.size());\n      QList<QModelIndex> updatedIndexes;\n      for (int i = 0; i < oldPersistentIndexes.size(); ++i) {\n          QHash<void *,uint>::const_iterator ptrIt = ptrToInternal.constFind(oldPtrs[i]);\n          if (ptrIt == ptrToInternal.constEnd()) {\n              // That message is no longer there\n              updatedIndexes.append(QModelIndex());\n              continue;\n          }\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(*ptrIt);\n          if (it == threading.constEnd()) {\n              // Filtering doesn't accept this index, let's declare it dead\n              updatedIndexes.append(QModelIndex());\n          } else {\n              updatedIndexes.append(createIndex(it->offset, oldPersistentIndexes[i].column(), it->internalId));\n          }\n      }\n      Q_ASSERT(oldPersistentIndexes.size() == updatedIndexes.size());\n      changePersistentIndexList(oldPersistentIndexes, updatedIndexes);\n      oldPersistentIndexes.clear();\n      oldPtrs.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runeTree(",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "pruneTree(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1052-1151",
          "snippet": "oid ThreadingMsgListModel::pruneTree()\n{\n    // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n    // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n    // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n    // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n    QList<uint> pending = threading.keys();\n    for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n        // Convert to the hashmap\n        // The \"it\" iterator point to the current node in the threading mapping\n        QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n        if (it == threading.end()) {\n            // We've already seen this node, that's due to promoting\n            ++id;\n            continue;\n        }\n\n        if (it->internalId == 0) {\n            // A special root item; we should not delete that one :)\n            ++id;\n            continue;\n        }\n        if (it->ptr) {\n            // regular and valid message -> skip\n            ++id;\n        } else {\n            // a fake one\n\n            // each node has a parent\n            QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n            Q_ASSERT(parent != threading.end());\n\n            // and the node itself has to be found in its parent's children\n            QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n            Q_ASSERT(childIt != parent->children.end());\n            // Check that its offset is correct\n            Q_ASSERT(childIt - parent->children.begin() == it->offset);\n\n            if (it->children.isEmpty()) {\n                // This is a leaf node, so we can just remove it\n                childIt = parent->children.erase(childIt);\n                threadedRootIds.removeOne(it->internalId);\n                threading.erase(it);\n                ++id;\n\n                // Update offsets of all further nodes, siblings to the one we've just deleted\n                while (childIt != parent->children.end()) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                    Q_ASSERT(sibling != threading.end());\n                    --sibling->offset;\n                    Q_ASSERT(sibling->offset >= 0);\n                    ++childIt;\n                }\n            } else {\n                // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                // to replace this node.\n                QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                Q_ASSERT(replaceWith != threading.end());\n\n                // Make sure that the offsets are still correct\n                Q_ASSERT(parent->children[it->offset] == it->internalId);\n\n                // Replace the node\n                replaceWith->offset = it->offset;\n                *childIt = it->children.first();\n                replaceWith->parent = parent->internalId;\n\n                // Now merge the lists of children\n                it->children.removeFirst();\n                replaceWith->children = replaceWith->children + it->children;\n\n                // Fix parent and offset information of all children of the replacement node\n                for (int i = 0; i < replaceWith->children.size(); ++i) {\n                    QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                    Q_ASSERT(sibling != threading.end());\n\n                    sibling->parent = replaceWith.key();\n                    sibling->offset = i;\n                }\n\n                if (parent->internalId == 0) {\n                    // Update the list of all thread roots\n                    QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                    if (rootIt != threadedRootIds.end())\n                        *rootIt = replaceWith->internalId;\n                }\n\n                // Now that all references are gone, remove the original node\n                threading.erase(it);\n\n                if (!replaceWith->ptr) {\n                    // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                    // because we've already processed the current item and are completely done with it. The worst which can\n                    // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                    *id = replaceWith.key();\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::pruneTree()\n  {\n      // Our mapping (threading) is completely unsorted, which means that we simply don't have any way of walking the tree from\n      // the top. Instead, we got to work with a random walk, processing nodes in an unspecified order.  If we iterated on the QHash\n      // directly, we'd hit an issue with iterator ordering (basically, we want to be able to say \"hey, I don't care at which point\n      // of the iteration I'm right now, the next node to process should be that one, and then we should resume with the rest\").\n      QList<uint> pending = threading.keys();\n      for (QList<uint>::iterator id = pending.begin(); id != pending.end(); /* nothing */) {\n          // Convert to the hashmap\n          // The \"it\" iterator point to the current node in the threading mapping\n          QHash<uint, ThreadNodeInfo>::iterator it = threading.find(*id);\n          if (it == threading.end()) {\n              // We've already seen this node, that's due to promoting\n              ++id;\n              continue;\n          }\n  \n          if (it->internalId == 0) {\n              // A special root item; we should not delete that one :)\n              ++id;\n              continue;\n          }\n          if (it->ptr) {\n              // regular and valid message -> skip\n              ++id;\n          } else {\n              // a fake one\n  \n              // each node has a parent\n              QHash<uint, ThreadNodeInfo>::iterator parent = threading.find(it->parent);\n              Q_ASSERT(parent != threading.end());\n  \n              // and the node itself has to be found in its parent's children\n              QList<uint>::iterator childIt = qFind(parent->children.begin(), parent->children.end(), it->internalId);\n              Q_ASSERT(childIt != parent->children.end());\n              // Check that its offset is correct\n              Q_ASSERT(childIt - parent->children.begin() == it->offset);\n  \n              if (it->children.isEmpty()) {\n                  // This is a leaf node, so we can just remove it\n                  childIt = parent->children.erase(childIt);\n                  threadedRootIds.removeOne(it->internalId);\n                  threading.erase(it);\n                  ++id;\n  \n                  // Update offsets of all further nodes, siblings to the one we've just deleted\n                  while (childIt != parent->children.end()) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(*childIt);\n                      Q_ASSERT(sibling != threading.end());\n                      --sibling->offset;\n                      Q_ASSERT(sibling->offset >= 0);\n                      ++childIt;\n                  }\n              } else {\n                  // This node has some children, so we can't just delete it. Instead of that, we promote its first child\n                  // to replace this node.\n                  QHash<uint, ThreadNodeInfo>::iterator replaceWith = threading.find(it->children.first());\n                  Q_ASSERT(replaceWith != threading.end());\n  \n                  // Make sure that the offsets are still correct\n                  Q_ASSERT(parent->children[it->offset] == it->internalId);\n  \n                  // Replace the node\n                  replaceWith->offset = it->offset;\n                  *childIt = it->children.first();\n                  replaceWith->parent = parent->internalId;\n  \n                  // Now merge the lists of children\n                  it->children.removeFirst();\n                  replaceWith->children = replaceWith->children + it->children;\n  \n                  // Fix parent and offset information of all children of the replacement node\n                  for (int i = 0; i < replaceWith->children.size(); ++i) {\n                      QHash<uint, ThreadNodeInfo>::iterator sibling = threading.find(replaceWith->children[i]);\n                      Q_ASSERT(sibling != threading.end());\n  \n                      sibling->parent = replaceWith.key();\n                      sibling->offset = i;\n                  }\n  \n                  if (parent->internalId == 0) {\n                      // Update the list of all thread roots\n                      QList<uint>::iterator rootIt = qFind(threadedRootIds.begin(), threadedRootIds.end(), it->internalId);\n                      if (rootIt != threadedRootIds.end())\n                          *rootIt = replaceWith->internalId;\n                  }\n  \n                  // Now that all references are gone, remove the original node\n                  threading.erase(it);\n  \n                  if (!replaceWith->ptr) {\n                      // If the just-promoted item is also a fake one, we'll have to visit it as well. This assignment is safe,\n                      // because we've already processed the current item and are completely done with it. The worst which can\n                      // happen is that we'll visit the same node twice, which is reasonably acceptable.\n                      *id = replaceWith.key();\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdatePersistentIndexesPhase1(",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "updatePersistentIndexesPhase1(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1005-1024",
          "snippet": "oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n{\n    oldPersistentIndexes = persistentIndexList();\n    oldPtrs.clear();\n    Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n        // the index could get invalidated by the pruneTree() or something else manipulating our threading\n        bool isOk = idx.isValid() && threading.contains(idx.internalId());\n        if (!isOk) {\n            oldPtrs << 0;\n            continue;\n        }\n        QModelIndex translated = mapToSource(idx);\n        if (!translated.isValid()) {\n            // another stale item\n            oldPtrs << 0;\n            continue;\n        }\n        oldPtrs << translated.internalPointer();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::updatePersistentIndexesPhase1()\n  {\n      oldPersistentIndexes = persistentIndexList();\n      oldPtrs.clear();\n      Q_FOREACH(const QModelIndex &idx, oldPersistentIndexes) {\n          // the index could get invalidated by the pruneTree() or something else manipulating our threading\n          bool isOk = idx.isValid() && threading.contains(idx.internalId());\n          if (!isOk) {\n              oldPtrs << 0;\n              continue;\n          }\n          QModelIndex translated = mapToSource(idx);\n          if (!translated.isValid()) {\n              // another stale item\n              oldPtrs << 0;\n              continue;\n          }\n          oldPtrs << translated.internalPointer();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::delayedPrune()\n  {\n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      pruneTree();\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
  },
  {
    "function_name": "handleRowsRemoved(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "352-359",
    "snippet": "oid ThreadingMsgListModel::handleRowsRemoved(const QModelIndex &parent, int start, int end)\n{\n    Q_ASSERT(!parent.isValid());\n    Q_UNUSED(start);\n    Q_UNUSED(end);\n    if (!m_delayedPrune->isActive())\n        m_delayedPrune->start();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_delayedPrune->start",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_delayedPrune->isActive",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "nd)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "tart)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "parent.isValid())"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::handleRowsRemoved(const QModelIndex &parent, int start, int end)\n  {\n      Q_ASSERT(!parent.isValid());\n      Q_UNUSED(start);\n      Q_UNUSED(end);\n      if (!m_delayedPrune->isActive())\n          m_delayedPrune->start();\n  }\n}"
  },
  {
    "function_name": "handleRowsAboutToBeRemoved(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "328-350",
    "snippet": "oid ThreadingMsgListModel::handleRowsAboutToBeRemoved(const QModelIndex &parent, int start, int end)\n{\n    Q_ASSERT(!parent.isValid());\n\n    for (int i = start; i <= end; ++i) {\n        QModelIndex index = sourceModel()->index(i, 0, parent);\n        Q_ASSERT(index.isValid());\n        QModelIndex translated = mapFromSource(index);\n\n        unknownUids.remove(static_cast<TreeItem*>(index.internalPointer()));\n\n        if (!translated.isValid()) {\n            // The index being removed wasn't visible in our mapping anyway\n            continue;\n        }\n\n        Q_ASSERT(translated.isValid());\n        QHash<uint,ThreadNodeInfo>::iterator it = threading.find(translated.internalId());\n        Q_ASSERT(it != threading.end());\n        it->uid = 0;\n        it->ptr = 0;\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != threading.end())"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.end",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.find",
          "args": [
            "ranslated.internalId())"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.internalId",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ranslated.isValid())"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.isValid",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nknownUids.remove",
          "args": [
            "tatic_cast<TreeItem*>(index.internalPointer()))"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem*>",
          "args": [
            "ndex.internalPointer())"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalPointer",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apFromSource(",
          "args": [
            "ndex)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "mapFromSource(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "255-276",
          "snippet": "ModelIndex ThreadingMsgListModel::mapFromSource(const QModelIndex &sourceIndex) const\n{\n    if (!sourceIndex.isValid())\n        return QModelIndex();\n\n    Q_ASSERT(sourceIndex.model() == sourceModel());\n\n    QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(sourceIndex.internalPointer());\n    if (it == ptrToInternal.constEnd())\n        return QModelIndex();\n\n    const uint internalId = *it;\n\n    QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(internalId);\n    if (node == threading.constEnd()) {\n        // The filtering criteria say that this index shall not be visible\n        return QModelIndex();\n    }\n    Q_ASSERT(node != threading.constEnd());\n\n    return createIndex(node->offset, sourceIndex.column(), internalId);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::mapFromSource(const QModelIndex &sourceIndex) const\n  {\n      if (!sourceIndex.isValid())\n          return QModelIndex();\n  \n      Q_ASSERT(sourceIndex.model() == sourceModel());\n  \n      QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(sourceIndex.internalPointer());\n      if (it == ptrToInternal.constEnd())\n          return QModelIndex();\n  \n      const uint internalId = *it;\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(internalId);\n      if (node == threading.constEnd()) {\n          // The filtering criteria say that this index shall not be visible\n          return QModelIndex();\n      }\n      Q_ASSERT(node != threading.constEnd());\n  \n      return createIndex(node->offset, sourceIndex.column(), internalId);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.isValid())"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            ",",
            ",",
            "arent)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "parent.isValid())"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::handleRowsAboutToBeRemoved(const QModelIndex &parent, int start, int end)\n  {\n      Q_ASSERT(!parent.isValid());\n  \n      for (int i = start; i <= end; ++i) {\n          QModelIndex index = sourceModel()->index(i, 0, parent);\n          Q_ASSERT(index.isValid());\n          QModelIndex translated = mapFromSource(index);\n  \n          unknownUids.remove(static_cast<TreeItem*>(index.internalPointer()));\n  \n          if (!translated.isValid()) {\n              // The index being removed wasn't visible in our mapping anyway\n              continue;\n          }\n  \n          Q_ASSERT(translated.isValid());\n          QHash<uint,ThreadNodeInfo>::iterator it = threading.find(translated.internalId());\n          Q_ASSERT(it != threading.end());\n          it->uid = 0;\n          it->ptr = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "flags(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "314-326",
    "snippet": "t::ItemFlags ThreadingMsgListModel::flags(const QModelIndex &index) const\n{\n    if (! index.isValid() || index.model() != this)\n        return Qt::NoItemFlags;\n\n    QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(index.internalId());\n    Q_ASSERT(it != threading.constEnd());\n    if (it->ptr && it->uid)\n        return Qt::ItemIsSelectable | Qt::ItemIsDragEnabled | Qt::ItemIsEnabled;\n\n    return Qt::NoItemFlags;\n\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != threading.constEnd())"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "ndex.internalId())"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalId",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  t::ItemFlags ThreadingMsgListModel::flags(const QModelIndex &index) const\n  {\n      if (! index.isValid() || index.model() != this)\n          return Qt::NoItemFlags;\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(index.internalId());\n      Q_ASSERT(it != threading.constEnd());\n      if (it->ptr && it->uid)\n          return Qt::ItemIsSelectable | Qt::ItemIsDragEnabled | Qt::ItemIsEnabled;\n  \n      return Qt::NoItemFlags;\n  \n  }\n}"
  },
  {
    "function_name": "data(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "278-312",
    "snippet": "Variant ThreadingMsgListModel::data(const QModelIndex &proxyIndex, int role) const\n{\n    if (! proxyIndex.isValid() || proxyIndex.model() != this)\n        return QVariant();\n\n    QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(proxyIndex.internalId());\n    Q_ASSERT(it != threading.constEnd());\n\n    if (it->ptr) {\n        // It's a real item which exists in the underlying model\n        if (role == RoleThreadRootWithUnreadMessages) {\n            if (proxyIndex.parent().isValid()) {\n                // We don't support this kind of questions for other messages than the roots of the threads.\n                // Other components, like the QML bindings, are however happy to request that, so let's just return\n                // a reasonable result instead of whinning about callers requesting useless stuff.\n                return false;\n            } else {\n                return threadContainsUnreadMessages(it->internalId);\n            }\n        } else {\n            return QAbstractProxyModel::data(proxyIndex, role);\n        }\n    }\n\n    switch (role) {\n    case Qt::DisplayRole:\n        if (proxyIndex.column() == 0)\n            return tr(\"[Message is missing]\");\n        break;\n    case Qt::ToolTipRole:\n        return tr(\"This thread refers to an extra message, but that message is not present in the \"\n                  \"selected mailbox, or is missing from the current search context.\");\n    }\n    return QVariant();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "This thread refers to an extra message, but that message is not present in the \"\n                  \"selected mailbox, or is missing from the current search context.\")"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roxyIndex.column",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbstractProxyModel::data(",
          "args": [
            "roxyIndex,",
            "ole)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "data(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "278-312",
          "snippet": "Variant ThreadingMsgListModel::data(const QModelIndex &proxyIndex, int role) const\n{\n    if (! proxyIndex.isValid() || proxyIndex.model() != this)\n        return QVariant();\n\n    QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(proxyIndex.internalId());\n    Q_ASSERT(it != threading.constEnd());\n\n    if (it->ptr) {\n        // It's a real item which exists in the underlying model\n        if (role == RoleThreadRootWithUnreadMessages) {\n            if (proxyIndex.parent().isValid()) {\n                // We don't support this kind of questions for other messages than the roots of the threads.\n                // Other components, like the QML bindings, are however happy to request that, so let's just return\n                // a reasonable result instead of whinning about callers requesting useless stuff.\n                return false;\n            } else {\n                return threadContainsUnreadMessages(it->internalId);\n            }\n        } else {\n            return QAbstractProxyModel::data(proxyIndex, role);\n        }\n    }\n\n    switch (role) {\n    case Qt::DisplayRole:\n        if (proxyIndex.column() == 0)\n            return tr(\"[Message is missing]\");\n        break;\n    case Qt::ToolTipRole:\n        return tr(\"This thread refers to an extra message, but that message is not present in the \"\n                  \"selected mailbox, or is missing from the current search context.\");\n    }\n    return QVariant();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "hreadContainsUnreadMessages(",
          "args": [
            "t->internalId)"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "threadContainsUnreadMessages(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "1180-1199",
          "snippet": "ool ThreadingMsgListModel::threadContainsUnreadMessages(const uint root) const\n{\n    // FIXME: cache the value somewhere...\n    QList<uint> queue;\n    queue.append(root);\n    while (! queue.isEmpty()) {\n        uint current = queue.takeFirst();\n        QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(current);\n        Q_ASSERT(it != threading.constEnd());\n        if (it->ptr) {\n            // Because of the delayed delete via pruneTree, we can hit a null pointer here\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(it->ptr);\n            Q_ASSERT(message);\n            if (! message->isMarkedAsRead())\n                return true;\n        }\n        queue.append(it->children);\n    }\n    return false;\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::threadContainsUnreadMessages(const uint root) const\n  {\n      // FIXME: cache the value somewhere...\n      QList<uint> queue;\n      queue.append(root);\n      while (! queue.isEmpty()) {\n          uint current = queue.takeFirst();\n          QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(current);\n          Q_ASSERT(it != threading.constEnd());\n          if (it->ptr) {\n              // Because of the delayed delete via pruneTree, we can hit a null pointer here\n              TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(it->ptr);\n              Q_ASSERT(message);\n              if (! message->isMarkedAsRead())\n                  return true;\n          }\n          queue.append(it->children);\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roxyIndex.parent",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != threading.constEnd())"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "roxyIndex.internalId())"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.internalId",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.model",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.isValid",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  Variant ThreadingMsgListModel::data(const QModelIndex &proxyIndex, int role) const\n  {\n      if (! proxyIndex.isValid() || proxyIndex.model() != this)\n          return QVariant();\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(proxyIndex.internalId());\n      Q_ASSERT(it != threading.constEnd());\n  \n      if (it->ptr) {\n          // It's a real item which exists in the underlying model\n          if (role == RoleThreadRootWithUnreadMessages) {\n              if (proxyIndex.parent().isValid()) {\n                  // We don't support this kind of questions for other messages than the roots of the threads.\n                  // Other components, like the QML bindings, are however happy to request that, so let's just return\n                  // a reasonable result instead of whinning about callers requesting useless stuff.\n                  return false;\n              } else {\n                  return threadContainsUnreadMessages(it->internalId);\n              }\n          } else {\n              return QAbstractProxyModel::data(proxyIndex, role);\n          }\n      }\n  \n      switch (role) {\n      case Qt::DisplayRole:\n          if (proxyIndex.column() == 0)\n              return tr(\"[Message is missing]\");\n          break;\n      case Qt::ToolTipRole:\n          return tr(\"This thread refers to an extra message, but that message is not present in the \"\n                    \"selected mailbox, or is missing from the current search context.\");\n      }\n      return QVariant();\n  }\n}"
  },
  {
    "function_name": "mapFromSource(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "255-276",
    "snippet": "ModelIndex ThreadingMsgListModel::mapFromSource(const QModelIndex &sourceIndex) const\n{\n    if (!sourceIndex.isValid())\n        return QModelIndex();\n\n    Q_ASSERT(sourceIndex.model() == sourceModel());\n\n    QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(sourceIndex.internalPointer());\n    if (it == ptrToInternal.constEnd())\n        return QModelIndex();\n\n    const uint internalId = *it;\n\n    QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(internalId);\n    if (node == threading.constEnd()) {\n        // The filtering criteria say that this index shall not be visible\n        return QModelIndex();\n    }\n    Q_ASSERT(node != threading.constEnd());\n\n    return createIndex(node->offset, sourceIndex.column(), internalId);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ode->offset,",
            "ourceIndex.column(),",
            "nternalId)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceIndex.column",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ode != threading.constEnd())"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "nternalId)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constEnd",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trToInternal.constFind",
          "args": [
            "ourceIndex.internalPointer())"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceIndex.internalPointer",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ourceIndex.model() == sourceModel())"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceIndex.model",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceIndex.isValid",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::mapFromSource(const QModelIndex &sourceIndex) const\n  {\n      if (!sourceIndex.isValid())\n          return QModelIndex();\n  \n      Q_ASSERT(sourceIndex.model() == sourceModel());\n  \n      QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(sourceIndex.internalPointer());\n      if (it == ptrToInternal.constEnd())\n          return QModelIndex();\n  \n      const uint internalId = *it;\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(internalId);\n      if (node == threading.constEnd()) {\n          // The filtering criteria say that this index shall not be visible\n          return QModelIndex();\n      }\n      Q_ASSERT(node != threading.constEnd());\n  \n      return createIndex(node->offset, sourceIndex.column(), internalId);\n  }\n}"
  },
  {
    "function_name": "mapToSource(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "232-253",
    "snippet": "ModelIndex ThreadingMsgListModel::mapToSource(const QModelIndex &proxyIndex) const\n{\n    if (!proxyIndex.isValid() || !proxyIndex.internalId())\n        return QModelIndex();\n\n    if (threading.isEmpty())\n        return QModelIndex();\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel());\n    Q_ASSERT(msgList);\n\n    QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(proxyIndex.internalId());\n    if (node == threading.constEnd())\n        return QModelIndex();\n\n    if (node->ptr) {\n        return msgList->createIndex(node->ptr->row(), proxyIndex.column(), node->ptr);\n    } else {\n        // it's a fake message\n        return QModelIndex();\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sgList->createIndex",
          "args": [
            "ode->ptr->row(),",
            "roxyIndex.column(),",
            "ode->ptr)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.column",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode->ptr->row",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "roxyIndex.internalId())"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.internalId",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sgList)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<Imap::Mailbox::MsgListModel *>",
          "args": [
            "ourceModel())"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.isEmpty",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.internalId",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxyIndex.isValid",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::mapToSource(const QModelIndex &proxyIndex) const\n  {\n      if (!proxyIndex.isValid() || !proxyIndex.internalId())\n          return QModelIndex();\n  \n      if (threading.isEmpty())\n          return QModelIndex();\n  \n      Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel());\n      Q_ASSERT(msgList);\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(proxyIndex.internalId());\n      if (node == threading.constEnd())\n          return QModelIndex();\n  \n      if (node->ptr) {\n          return msgList->createIndex(node->ptr->row(), proxyIndex.column(), node->ptr);\n      } else {\n          // it's a fake message\n          return QModelIndex();\n      }\n  }\n}"
  },
  {
    "function_name": "columnCount(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "224-230",
    "snippet": "nt ThreadingMsgListModel::columnCount(const QModelIndex &parent) const\n{\n    if (parent.isValid() && parent.column() != 0)\n        return 0;\n\n    return MsgListModel::COLUMN_COUNT;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arent.column",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  nt ThreadingMsgListModel::columnCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid() && parent.column() != 0)\n          return 0;\n  \n      return MsgListModel::COLUMN_COUNT;\n  }\n}"
  },
  {
    "function_name": "rowCount(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "213-222",
    "snippet": "nt ThreadingMsgListModel::rowCount(const QModelIndex &parent) const\n{\n    if (threading.isEmpty())\n        return 0;\n\n    if (parent.isValid() && parent.column() != 0)\n        return 0;\n\n    return threading.value(parent.internalId()).children.size();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hreading.value",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading.value",
          "args": [
            "arent.internalId())"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arent.internalId",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.column",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading.isEmpty",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  nt ThreadingMsgListModel::rowCount(const QModelIndex &parent) const\n  {\n      if (threading.isEmpty())\n          return 0;\n  \n      if (parent.isValid() && parent.column() != 0)\n          return 0;\n  \n      return threading.value(parent.internalId()).children.size();\n  }\n}"
  },
  {
    "function_name": "hasChildren(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "205-211",
    "snippet": "ool ThreadingMsgListModel::hasChildren(const QModelIndex &parent) const\n{\n    if (parent.isValid() && parent.column() != 0)\n        return false;\n\n    return ! threading.isEmpty() && ! threading.value(parent.internalId()).children.isEmpty();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hreading.value",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hreading.value",
          "args": [
            "arent.internalId())"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arent.internalId",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.isEmpty",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.column",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ool ThreadingMsgListModel::hasChildren(const QModelIndex &parent) const\n  {\n      if (parent.isValid() && parent.column() != 0)\n          return false;\n  \n      return ! threading.isEmpty() && ! threading.value(parent.internalId()).children.isEmpty();\n  }\n}"
  },
  {
    "function_name": "parent(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "180-203",
    "snippet": "ModelIndex ThreadingMsgListModel::parent(const QModelIndex &index) const\n{\n    if (! index.isValid() || index.model() != this)\n        return QModelIndex();\n\n    if (threading.isEmpty())\n        return QModelIndex();\n\n    if (index.row() < 0 || index.column() < 0 || index.column() >= MsgListModel::COLUMN_COUNT)\n        return QModelIndex();\n\n    QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(index.internalId());\n    if (node == threading.constEnd())\n        return QModelIndex();\n\n    QHash<uint,ThreadNodeInfo>::const_iterator parentNode = threading.constFind(node->parent);\n    Q_ASSERT(parentNode != threading.constEnd());\n    Q_ASSERT(parentNode->internalId == node->parent);\n\n    if (parentNode->internalId == 0)\n        return QModelIndex();\n\n    return createIndex(parentNode->offset, 0, parentNode->internalId);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "arentNode->offset,",
            ",",
            "arentNode->internalId)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arentNode->internalId == node->parent)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arentNode != threading.constEnd())"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "ode->parent)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "ndex.internalId())"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.internalId",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.column",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.row",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.isEmpty",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.model",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::parent(const QModelIndex &index) const\n  {\n      if (! index.isValid() || index.model() != this)\n          return QModelIndex();\n  \n      if (threading.isEmpty())\n          return QModelIndex();\n  \n      if (index.row() < 0 || index.column() < 0 || index.column() >= MsgListModel::COLUMN_COUNT)\n          return QModelIndex();\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(index.internalId());\n      if (node == threading.constEnd())\n          return QModelIndex();\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator parentNode = threading.constFind(node->parent);\n      Q_ASSERT(parentNode != threading.constEnd());\n      Q_ASSERT(parentNode->internalId == node->parent);\n  \n      if (parentNode->internalId == 0)\n          return QModelIndex();\n  \n      return createIndex(parentNode->offset, 0, parentNode->internalId);\n  }\n}"
  },
  {
    "function_name": "index(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "152-178",
    "snippet": "ModelIndex ThreadingMsgListModel::index(int row, int column, const QModelIndex &parent) const\n{\n    Q_ASSERT(!parent.isValid() || parent.model() == this);\n\n    if (threading.isEmpty()) {\n        // mapping not available yet\n        return QModelIndex();\n    }\n\n    if (row < 0 || column < 0 || column >= MsgListModel::COLUMN_COUNT)\n        return QModelIndex();\n\n    if (parent.isValid() && parent.column() != 0) {\n        // only the first column should have children\n        return QModelIndex();\n    }\n\n    uint parentId = parent.isValid() ? parent.internalId() : 0;\n\n    QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(parentId);\n    Q_ASSERT(it != threading.constEnd());\n\n    if (it->children.size() <= row)\n        return QModelIndex();\n\n    return createIndex(row, column, it->children[row]);\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reateIndex(",
          "args": [
            "ow,",
            "olumn,",
            "t->children[row])"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->children.size",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "t != threading.constEnd())"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constEnd",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.constFind",
          "args": [
            "arentId)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.internalId",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.isValid",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.column",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModelIndex(",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hreading.isEmpty",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "parent.isValid() || parent.model() == this)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent.model",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::index(int row, int column, const QModelIndex &parent) const\n  {\n      Q_ASSERT(!parent.isValid() || parent.model() == this);\n  \n      if (threading.isEmpty()) {\n          // mapping not available yet\n          return QModelIndex();\n      }\n  \n      if (row < 0 || column < 0 || column >= MsgListModel::COLUMN_COUNT)\n          return QModelIndex();\n  \n      if (parent.isValid() && parent.column() != 0) {\n          // only the first column should have children\n          return QModelIndex();\n      }\n  \n      uint parentId = parent.isValid() ? parent.internalId() : 0;\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator it = threading.constFind(parentId);\n      Q_ASSERT(it != threading.constEnd());\n  \n      if (it->children.size() <= row)\n          return QModelIndex();\n  \n      return createIndex(row, column, it->children[row]);\n  }\n}"
  },
  {
    "function_name": "handleDataChanged(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "120-150",
    "snippet": "oid ThreadingMsgListModel::handleDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n{\n    // We don't support updates which concern multiple rows at this time.\n    // Doing that would very likely require a completely different codepath due to threading...\n    Q_ASSERT(topLeft.parent() == bottomRight.parent());\n    Q_ASSERT(topLeft.row() == bottomRight.row());\n    QModelIndex translated = mapFromSource(topLeft);\n\n    emit dataChanged(translated, translated.sibling(translated.row(), bottomRight.column()));\n\n    // We provide funny data like \"does this thread contain unread messages?\". Now the original signal might mean that flags of a\n    // nested message have changed. In order to always be consistent, we have to find the thread root and emit dataChanged() on that\n    // as well.\n    QModelIndex rootCandidate = translated;\n    while (rootCandidate.parent().isValid()) {\n        rootCandidate = rootCandidate.parent();\n    }\n    if (rootCandidate != translated) {\n        // We're really an embedded message\n        emit dataChanged(rootCandidate, rootCandidate.sibling(rootCandidate.row(), bottomRight.column()));\n    }\n\n    QSet<TreeItem*>::iterator persistent = unknownUids.find(static_cast<TreeItem*>(topLeft.internalPointer()));\n    if (persistent != unknownUids.end()) {\n        // The message wasn't fully synced before, and now it is\n        persistent = unknownUids.erase(persistent);\n        if (unknownUids.isEmpty()) {\n            wantThreading();\n        }\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antThreading(",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownUids.isEmpty",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownUids.erase",
          "args": [
            "ersistent)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownUids.end",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nknownUids.find",
          "args": [
            "tatic_cast<TreeItem*>(topLeft.internalPointer()))"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem*>",
          "args": [
            "opLeft.internalPointer())"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLeft.internalPointer",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ootCandidate.sibling",
          "args": [
            "ootCandidate.row(),",
            "ottomRight.column())"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ottomRight.column",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ootCandidate.row",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ootCandidate.parent",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ranslated.sibling",
          "args": [
            "ranslated.row(),",
            "ottomRight.column())"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ottomRight.column",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ranslated.row",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apFromSource(",
          "args": [
            "opLeft)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "mapFromSource(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "255-276",
          "snippet": "ModelIndex ThreadingMsgListModel::mapFromSource(const QModelIndex &sourceIndex) const\n{\n    if (!sourceIndex.isValid())\n        return QModelIndex();\n\n    Q_ASSERT(sourceIndex.model() == sourceModel());\n\n    QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(sourceIndex.internalPointer());\n    if (it == ptrToInternal.constEnd())\n        return QModelIndex();\n\n    const uint internalId = *it;\n\n    QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(internalId);\n    if (node == threading.constEnd()) {\n        // The filtering criteria say that this index shall not be visible\n        return QModelIndex();\n    }\n    Q_ASSERT(node != threading.constEnd());\n\n    return createIndex(node->offset, sourceIndex.column(), internalId);\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  ModelIndex ThreadingMsgListModel::mapFromSource(const QModelIndex &sourceIndex) const\n  {\n      if (!sourceIndex.isValid())\n          return QModelIndex();\n  \n      Q_ASSERT(sourceIndex.model() == sourceModel());\n  \n      QHash<void *,uint>::const_iterator it = ptrToInternal.constFind(sourceIndex.internalPointer());\n      if (it == ptrToInternal.constEnd())\n          return QModelIndex();\n  \n      const uint internalId = *it;\n  \n      QHash<uint,ThreadNodeInfo>::const_iterator node = threading.constFind(internalId);\n      if (node == threading.constEnd()) {\n          // The filtering criteria say that this index shall not be visible\n          return QModelIndex();\n      }\n      Q_ASSERT(node != threading.constEnd());\n  \n      return createIndex(node->offset, sourceIndex.column(), internalId);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "opLeft.row() == bottomRight.row())"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ottomRight.row",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLeft.row",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "opLeft.parent() == bottomRight.parent())"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::handleDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n  {\n      // We don't support updates which concern multiple rows at this time.\n      // Doing that would very likely require a completely different codepath due to threading...\n      Q_ASSERT(topLeft.parent() == bottomRight.parent());\n      Q_ASSERT(topLeft.row() == bottomRight.row());\n      QModelIndex translated = mapFromSource(topLeft);\n  \n      emit dataChanged(translated, translated.sibling(translated.row(), bottomRight.column()));\n  \n      // We provide funny data like \"does this thread contain unread messages?\". Now the original signal might mean that flags of a\n      // nested message have changed. In order to always be consistent, we have to find the thread root and emit dataChanged() on that\n      // as well.\n      QModelIndex rootCandidate = translated;\n      while (rootCandidate.parent().isValid()) {\n          rootCandidate = rootCandidate.parent();\n      }\n      if (rootCandidate != translated) {\n          // We're really an embedded message\n          emit dataChanged(rootCandidate, rootCandidate.sibling(rootCandidate.row(), bottomRight.column()));\n      }\n  \n      QSet<TreeItem*>::iterator persistent = unknownUids.find(static_cast<TreeItem*>(topLeft.internalPointer()));\n      if (persistent != unknownUids.end()) {\n          // The message wasn't fully synced before, and now it is\n          persistent = unknownUids.erase(persistent);\n          if (unknownUids.isEmpty()) {\n              wantThreading();\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "headerData(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "111-118",
    "snippet": "Variant ThreadingMsgListModel::headerData(int section, Qt::Orientation orientation, int role) const\n{\n    if (sourceModel()) {\n        return sourceModel()->headerData(section, orientation, role);\n    } else {\n        return QVariant();\n    }\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel",
          "args": [
            "ection,",
            "rientation,",
            "ole)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ourceModel(",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  Variant ThreadingMsgListModel::headerData(int section, Qt::Orientation orientation, int role) const\n  {\n      if (sourceModel()) {\n          return sourceModel()->headerData(section, orientation, role);\n      } else {\n          return QVariant();\n      }\n  }\n}"
  },
  {
    "function_name": "setSourceModel(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "71-109",
    "snippet": "oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n{\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n\n    if (this->sourceModel()) {\n        // there's already something, so take care to disconnect all signals\n        this->sourceModel()->disconnect(this);\n    }\n\n    RESET_MODEL;\n\n    if (!sourceModel)\n        return;\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n    Q_ASSERT(msgList);\n    QAbstractProxyModel::setSourceModel(msgList);\n\n    // FIXME: will need to be expanded when Model supports more signals...\n    connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n    connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n    connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n            this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n    resetMe();\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esetMe(",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "resetMe(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "412-431",
          "snippet": "oid ThreadingMsgListModel::resetMe()\n{\n    // Prevent possible recursion here\n    if (modelResetInProgress)\n        return;\n\n    modelResetInProgress = true;\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n    RESET_MODEL;\n    updateNoThreading();\n    modelResetInProgress = false;\n\n    if (m_shallBeThreading)\n        wantThreading();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::resetMe()\n  {\n      // Prevent possible recursion here\n      if (modelResetInProgress)\n          return;\n  \n      modelResetInProgress = true;\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n      m_currentSortResult.clear();\n      m_searchValidity = RESULT_INVALIDATED;\n      RESET_MODEL;\n      updateNoThreading();\n      modelResetInProgress = false;\n  \n      if (m_shallBeThreading)\n          wantThreading();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ourceModel,",
            "IGNAL(layoutChanged()),",
            "his,",
            "IGNAL(layoutChanged()))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ayoutChanged())"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ayoutChanged(",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "layoutChanged(",
          "container": "odelWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelWatcher.cpp",
          "lines": "94-97",
          "snippet": "oid ModelWatcher::layoutChanged()\n{\n    qDebug() << sender()->objectName() << \"layoutChanged()\";\n}",
          "includes": [
            "include \"ModelWatcher.h\"",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ModelWatcher.h\"\ninclude <QDebug>\n#\n\nodelWatcher {\n  oid ModelWatcher::layoutChanged()\n  {\n      qDebug() << sender()->objectName() << \"layoutChanged()\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ayoutChanged())"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ourceModel,",
            "IGNAL(layoutAboutToBeChanged()),",
            "his,",
            "IGNAL(layoutAboutToBeChanged()))"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ayoutAboutToBeChanged())"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ayoutAboutToBeChanged(",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "layoutAboutToBeChanged(",
          "container": "odelWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelWatcher.cpp",
          "lines": "89-92",
          "snippet": "oid ModelWatcher::layoutAboutToBeChanged()\n{\n    qDebug() << sender()->objectName() << \"layoutAboutToBeChanged()\";\n}",
          "includes": [
            "include \"ModelWatcher.h\"",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ModelWatcher.h\"\ninclude <QDebug>\n#\n\nodelWatcher {\n  oid ModelWatcher::layoutAboutToBeChanged()\n  {\n      qDebug() << sender()->objectName() << \"layoutAboutToBeChanged()\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ayoutAboutToBeChanged())"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ourceModel,",
            "IGNAL(modelReset()),",
            "his,",
            "LOT(resetMe()))"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "esetMe())"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "odelReset())"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odelReset(",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "modelReset(",
          "container": "odelWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelWatcher.cpp",
          "lines": "104-107",
          "snippet": "oid ModelWatcher::modelReset()\n{\n    qDebug() << sender()->objectName() << \"modelReset()\";\n}",
          "includes": [
            "include \"ModelWatcher.h\"",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ModelWatcher.h\"\ninclude <QDebug>\n#\n\nodelWatcher {\n  oid ModelWatcher::modelReset()\n  {\n      qDebug() << sender()->objectName() << \"modelReset()\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AbstractProxyModel::setSourceModel(",
          "args": [
            "sgList)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "setSourceModel(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "71-109",
          "snippet": "oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n{\n    threading.clear();\n    ptrToInternal.clear();\n    unknownUids.clear();\n    threadedRootIds.clear();\n    m_currentSortResult.clear();\n    m_searchValidity = RESULT_INVALIDATED;\n\n    if (this->sourceModel()) {\n        // there's already something, so take care to disconnect all signals\n        this->sourceModel()->disconnect(this);\n    }\n\n    RESET_MODEL;\n\n    if (!sourceModel)\n        return;\n\n    Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n    Q_ASSERT(msgList);\n    QAbstractProxyModel::setSourceModel(msgList);\n\n    // FIXME: will need to be expanded when Model supports more signals...\n    connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n    connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n    connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n    connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n            this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n    connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n            this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n    resetMe();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sgList)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<Imap::Mailbox::MsgListModel *>",
          "args": [
            "ourceModel)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "his->sourceModel",
          "args": [
            "his)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "his->sourceModel",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "his->sourceModel",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_currentSortResult.clear",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::setSourceModel(QAbstractItemModel *sourceModel)\n  {\n      threading.clear();\n      ptrToInternal.clear();\n      unknownUids.clear();\n      threadedRootIds.clear();\n      m_currentSortResult.clear();\n      m_searchValidity = RESULT_INVALIDATED;\n  \n      if (this->sourceModel()) {\n          // there's already something, so take care to disconnect all signals\n          this->sourceModel()->disconnect(this);\n      }\n  \n      RESET_MODEL;\n  \n      if (!sourceModel)\n          return;\n  \n      Imap::Mailbox::MsgListModel *msgList = qobject_cast<Imap::Mailbox::MsgListModel *>(sourceModel);\n      Q_ASSERT(msgList);\n      QAbstractProxyModel::setSourceModel(msgList);\n  \n      // FIXME: will need to be expanded when Model supports more signals...\n      connect(sourceModel, SIGNAL(modelReset()), this, SLOT(resetMe()));\n      connect(sourceModel, SIGNAL(layoutAboutToBeChanged()), this, SIGNAL(layoutAboutToBeChanged()));\n      connect(sourceModel, SIGNAL(layoutChanged()), this, SIGNAL(layoutChanged()));\n      connect(sourceModel, SIGNAL(dataChanged(const QModelIndex &, const QModelIndex &)),\n              this, SLOT(handleDataChanged(const QModelIndex &, const QModelIndex &)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsRemoved(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsRemoved(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsAboutToBeInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsAboutToBeInserted(const QModelIndex &, int,int)));\n      connect(sourceModel, SIGNAL(rowsInserted(const QModelIndex &, int, int)),\n              this, SLOT(handleRowsInserted(const QModelIndex &, int,int)));\n      resetMe();\n  }\n}"
  },
  {
    "function_name": "ThreadingMsgListModel(",
    "container": "hreadingMsgListModel",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "60-69",
    "snippet": "hreadingMsgListModel::ThreadingMsgListModel(QObject *parent):\n    QAbstractProxyModel(parent), threadingHelperLastId(0), modelResetInProgress(false), threadingInFlight(false),\n    m_shallBeThreading(false), m_sortTask(0), m_sortReverse(false), m_currentSortingCriteria(SORT_NONE),\n    m_searchValidity(RESULT_INVALIDATED)\n{\n    m_delayedPrune = new QTimer(this);\n    m_delayedPrune->setSingleShot(true);\n    m_delayedPrune->setInterval(0);\n    connect(m_delayedPrune, SIGNAL(timeout()), this, SLOT(delayedPrune()));\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "_delayedPrune,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(delayedPrune()))"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "elayedPrune())"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedPrune(",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "delayedPrune(",
          "container": "hreadingMsgListModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "361-368",
          "snippet": "oid ThreadingMsgListModel::delayedPrune()\n{\n    emit layoutAboutToBeChanged();\n    updatePersistentIndexesPhase1();\n    pruneTree();\n    updatePersistentIndexesPhase2();\n    emit layoutChanged();\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"MsgListModel.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/ThreadTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include <QDebug>\n#",
            "include <QBuffer>\n#",
            "include <algorithm>\n#",
            "include \"ThreadingMsgListModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  oid ThreadingMsgListModel::delayedPrune()\n  {\n      emit layoutAboutToBeChanged();\n      updatePersistentIndexesPhase1();\n      pruneTree();\n      updatePersistentIndexesPhase2();\n      emit layoutChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_delayedPrune->setInterval",
          "args": [
            ")"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_delayedPrune->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nhreadingMsgListModel {\n  hreadingMsgListModel::ThreadingMsgListModel(QObject *parent):\n      QAbstractProxyModel(parent), threadingHelperLastId(0), modelResetInProgress(false), threadingInFlight(false),\n      m_shallBeThreading(false), m_sortTask(0), m_sortReverse(false), m_currentSortingCriteria(SORT_NONE),\n      m_searchValidity(RESULT_INVALIDATED)\n  {\n      m_delayedPrune = new QTimer(this);\n      m_delayedPrune->setSingleShot(true);\n      m_delayedPrune->setInterval(0);\n      connect(m_delayedPrune, SIGNAL(timeout()), this, SLOT(delayedPrune()));\n  }\n}"
  },
  {
    "function_name": "umpThreadNodeInfo(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
    "lines": "38-51",
    "snippet": "ByteArray dumpThreadNodeInfo(const QHash<uint,ThreadNodeInfo> &mapping, const uint nodeId, const uint offset)\n{\n    QByteArray res;\n    QByteArray prefix(offset, ' ');\n    QTextStream ss(&res);\n    Q_ASSERT(mapping.contains(nodeId));\n    const ThreadNodeInfo &node = mapping[nodeId];\n    ss << prefix << \"ThreadNodeInfo intId \" << node.internalId << \" UID \" << node.uid << \" ptr \" << node.ptr <<\n          \" parentIntId \" << node.parent << \"\\n\";\n    Q_FOREACH(const uint childId, node.children) {\n        ss << dumpThreadNodeInfo(mapping, childId, offset + 1);\n    }\n    return res;\n}",
    "includes": [
      "include \"QAIM_reset.h\"",
      "include \"MsgListModel.h\"\n#",
      "include \"MailboxTree.h\"\n#",
      "include \"ItemRoles.h\"\n#",
      "include \"Imap/Tasks/ThreadTask.h\"\n#",
      "include \"Imap/Tasks/SortTask.h\"\n#",
      "include <QDebug>\n#",
      "include <QBuffer>\n#",
      "include <algorithm>\n#",
      "include \"ThreadingMsgListModel.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umpThreadNodeInfo(",
          "args": [
            "apping,",
            "hildId,",
            "ffset + 1)"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "umpThreadNodeInfo(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ThreadingMsgListModel.cpp",
          "lines": "38-51",
          "snippet": "ByteArray dumpThreadNodeInfo(const QHash<uint,ThreadNodeInfo> &mapping, const uint nodeId, const uint offset)\n{\n    QByteArray res;\n    QByteArray prefix(offset, ' ');\n    QTextStream ss(&res);\n    Q_ASSERT(mapping.contains(nodeId));\n    const ThreadNodeInfo &node = mapping[nodeId];\n    ss << prefix << \"ThreadNodeInfo intId \" << node.internalId << \" UID \" << node.uid << \" ptr \" << node.ptr <<\n          \" parentIntId \" << node.parent << \"\\n\";\n    Q_FOREACH(const uint childId, node.children) {\n        ss << dumpThreadNodeInfo(mapping, childId, offset + 1);\n    }\n    return res;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "apping.contains(nodeId))"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apping.contains",
          "args": [
            "odeId)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"MsgListModel.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/ThreadTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude <QDebug>\n#\ninclude <QBuffer>\n#\ninclude <algorithm>\n#\ninclude \"ThreadingMsgListModel.h\"\n#\n\nByteArray dumpThreadNodeInfo(const QHash<uint,ThreadNodeInfo> &mapping, const uint nodeId, const uint offset)\n{\n    QByteArray res;\n    QByteArray prefix(offset, ' ');\n    QTextStream ss(&res);\n    Q_ASSERT(mapping.contains(nodeId));\n    const ThreadNodeInfo &node = mapping[nodeId];\n    ss << prefix << \"ThreadNodeInfo intId \" << node.internalId << \" UID \" << node.uid << \" ptr \" << node.ptr <<\n          \" parentIntId \" << node.parent << \"\\n\";\n    Q_FOREACH(const uint childId, node.children) {\n        ss << dumpThreadNodeInfo(mapping, childId, offset + 1);\n    }\n    return res;\n}"
  }
]