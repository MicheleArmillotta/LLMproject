[
  {
    "function_name": "mailboxName(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "866-869",
    "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox.isEmpty",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
  },
  {
    "function_name": "setRenewalThreshold(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "857-860",
    "snippet": "oid SQLCache::setRenewalThreshold(const int days)\n{\n    m_updateAccessIfOlder = days;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setRenewalThreshold(const int days)\n  {\n      m_updateAccessIfOlder = days;\n  }\n}"
  },
  {
    "function_name": "timeToCommit(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "846-855",
    "snippet": "oid SQLCache::timeToCommit()\n{\n    if (inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Commit\";\n#endif\n        inTransaction = false;\n        db.commit();\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b.commit",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::timeToCommit()\n  {\n      if (inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Commit\";\n  #endif\n          inTransaction = false;\n          db.commit();\n      }\n  }\n}"
  },
  {
    "function_name": "touchingDB(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "833-844",
    "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ooMuchTimeWithoutCommit->start",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.transaction",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedCommit->start",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
  },
  {
    "function_name": "setMessageThreading(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "815-831",
    "snippet": "oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting threading for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << threading;\n    querySetMessageThreading.bindValue(1, qCompress(buf));\n    if (! querySetMessageThreading.exec()) {\n        emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n    }\n\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetMessageThreading failed\"),",
            "uerySetMessageThreading)"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageThreading.exec",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageThreading.bindValue",
          "args": [
            ",",
            "Compress(buf))"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Compress(",
          "args": [
            "uf)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessageThreading.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting threading for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << threading;\n      querySetMessageThreading.bindValue(1, qCompress(buf));\n      if (! querySetMessageThreading.exec()) {\n          emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n      }\n  \n  }\n}"
  },
  {
    "function_name": "messageThreading(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "799-813",
    "snippet": "Vector<Imap::Responses::ThreadingNode> SQLCache::messageThreading(const QString &mailbox)\n{\n    QVector<Imap::Responses::ThreadingNode> res;\n    queryMessageThreading.bindValue(0, mailboxName(mailbox));\n    if (! queryMessageThreading.exec()) {\n        emitError(tr(\"Query queryMessageThreading failed\"), queryMessageThreading);\n        return res;\n    }\n    if (queryMessageThreading.first()) {\n        QDataStream stream(qUncompress(queryMessageThreading.value(0).toByteArray()));\n        stream.setVersion(streamVersion);\n        stream >> res;\n    }\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Uncompress(",
          "args": [
            "ueryMessageThreading.value(0).toByteArray())"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessageThreading.value",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageThreading.value",
          "args": [
            ")"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageThreading.first",
          "args": [],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryMessageThreading failed\"),",
            "ueryMessageThreading)"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageThreading.exec",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageThreading.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  Vector<Imap::Responses::ThreadingNode> SQLCache::messageThreading(const QString &mailbox)\n  {\n      QVector<Imap::Responses::ThreadingNode> res;\n      queryMessageThreading.bindValue(0, mailboxName(mailbox));\n      if (! queryMessageThreading.exec()) {\n          emitError(tr(\"Query queryMessageThreading failed\"), queryMessageThreading);\n          return res;\n      }\n      if (queryMessageThreading.first()) {\n          QDataStream stream(qUncompress(queryMessageThreading.value(0).toByteArray()));\n          stream.setVersion(streamVersion);\n          stream >> res;\n      }\n      return res;\n  }\n}"
  },
  {
    "function_name": "forgetMessagePart(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "785-797",
    "snippet": "oid SQLCache::forgetMessagePart(const QString &mailbox, const uint uid, const QString &partId)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Forgetting message part\" << partId << uid << mailbox;\n#endif\n    touchingDB();\n    queryForgetMessagePart.bindValue(0, mailboxName(mailbox));\n    queryForgetMessagePart.bindValue(1, uid);\n    queryForgetMessagePart.bindValue(2, partId);\n    if (! queryForgetMessagePart.exec()) {\n        emitError(tr(\"Query queryForgetMessagePart failed\"), queryForgetMessagePart);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryForgetMessagePart failed\"),",
            "ueryForgetMessagePart)"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryForgetMessagePart.exec",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryForgetMessagePart.bindValue",
          "args": [
            ",",
            "artId)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryForgetMessagePart.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryForgetMessagePart.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::forgetMessagePart(const QString &mailbox, const uint uid, const QString &partId)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Forgetting message part\" << partId << uid << mailbox;\n  #endif\n      touchingDB();\n      queryForgetMessagePart.bindValue(0, mailboxName(mailbox));\n      queryForgetMessagePart.bindValue(1, uid);\n      queryForgetMessagePart.bindValue(2, partId);\n      if (! queryForgetMessagePart.exec()) {\n          emitError(tr(\"Query queryForgetMessagePart failed\"), queryForgetMessagePart);\n      }\n  }\n}"
  },
  {
    "function_name": "setMsgPart(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "770-783",
    "snippet": "oid SQLCache::setMsgPart(const QString &mailbox, const uint uid, const QString &partId, const QByteArray &data)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Saving message part\" << partId << uid << mailbox;\n#endif\n    touchingDB();\n    querySetMessagePart.bindValue(0, mailboxName(mailbox));\n    querySetMessagePart.bindValue(1, uid);\n    querySetMessagePart.bindValue(2, partId);\n    querySetMessagePart.bindValue(3, qCompress(data));\n    if (! querySetMessagePart.exec()) {\n        emitError(tr(\"Query querySetMessagePart failed\"), querySetMessagePart);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetMessagePart failed\"),",
            "uerySetMessagePart)"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessagePart.exec",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessagePart.bindValue",
          "args": [
            ",",
            "Compress(data))"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Compress(",
          "args": [
            "ata)"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessagePart.bindValue",
          "args": [
            ",",
            "artId)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessagePart.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessagePart.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMsgPart(const QString &mailbox, const uint uid, const QString &partId, const QByteArray &data)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Saving message part\" << partId << uid << mailbox;\n  #endif\n      touchingDB();\n      querySetMessagePart.bindValue(0, mailboxName(mailbox));\n      querySetMessagePart.bindValue(1, uid);\n      querySetMessagePart.bindValue(2, partId);\n      querySetMessagePart.bindValue(3, qCompress(data));\n      if (! querySetMessagePart.exec()) {\n          emitError(tr(\"Query querySetMessagePart failed\"), querySetMessagePart);\n      }\n  }\n}"
  },
  {
    "function_name": "messagePart(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "753-768",
    "snippet": "ByteArray SQLCache::messagePart(const QString &mailbox, const uint uid, const QString &partId) const\n{\n    QByteArray res;\n    queryMessagePart.bindValue(0, mailboxName(mailbox));\n    queryMessagePart.bindValue(1, uid);\n    queryMessagePart.bindValue(2, partId);\n    if (! queryMessagePart.exec()) {\n        emitError(tr(\"Query queryMessagePart failed\"), queryMessagePart);\n        return res;\n    }\n    if (queryMessagePart.first()) {\n        res = qUncompress(queryMessagePart.value(0).toByteArray());\n        queryMessagePart.finish();\n    }\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueryMessagePart.finish",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Uncompress(",
          "args": [
            "ueryMessagePart.value(0).toByteArray())"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.value",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.value",
          "args": [
            ")"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.first",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryMessagePart failed\"),",
            "ueryMessagePart)"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.exec",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.bindValue",
          "args": [
            ",",
            "artId)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessagePart.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ByteArray SQLCache::messagePart(const QString &mailbox, const uint uid, const QString &partId) const\n  {\n      QByteArray res;\n      queryMessagePart.bindValue(0, mailboxName(mailbox));\n      queryMessagePart.bindValue(1, uid);\n      queryMessagePart.bindValue(2, partId);\n      if (! queryMessagePart.exec()) {\n          emitError(tr(\"Query queryMessagePart failed\"), queryMessagePart);\n          return res;\n      }\n      if (queryMessagePart.first()) {\n          res = qUncompress(queryMessagePart.value(0).toByteArray());\n          queryMessagePart.finish();\n      }\n      return res;\n  }\n}"
  },
  {
    "function_name": "setMessageMetadata(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "732-751",
    "snippet": "oid SQLCache::setMessageMetadata(const QString &mailbox, const uint uid, const MessageDataBundle &metadata)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting message metadata for\" << uid << mailbox;\n#endif\n    touchingDB();\n    // Order of values: mailbox, uid, data\n    querySetMessageMetadata.bindValue(0, mailboxName(mailbox));\n    querySetMessageMetadata.bindValue(1, uid);\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << metadata.envelope << metadata.internalDate << metadata.size << metadata.serializedBodyStructure\n           << metadata.hdrReferences << metadata.hdrListPost << metadata.hdrListPostNo;\n    querySetMessageMetadata.bindValue(2, qCompress(buf));\n    querySetMessageMetadata.bindValue(3, accessingThresholdDate.daysTo(QDate::currentDate()));\n    if (! querySetMessageMetadata.exec()) {\n        emitError(tr(\"Query querySetMessageMetadata failed\"), querySetMessageMetadata);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetMessageMetadata failed\"),",
            "uerySetMessageMetadata)"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageMetadata.exec",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageMetadata.bindValue",
          "args": [
            ",",
            "ccessingThresholdDate.daysTo(QDate::currentDate()))"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessingThresholdDate.daysTo",
          "args": [
            "Date::currentDate())"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Date::currentDate(",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessageMetadata.bindValue",
          "args": [
            ",",
            "Compress(buf))"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Compress(",
          "args": [
            "uf)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessageMetadata.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessageMetadata.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageMetadata(const QString &mailbox, const uint uid, const MessageDataBundle &metadata)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting message metadata for\" << uid << mailbox;\n  #endif\n      touchingDB();\n      // Order of values: mailbox, uid, data\n      querySetMessageMetadata.bindValue(0, mailboxName(mailbox));\n      querySetMessageMetadata.bindValue(1, uid);\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << metadata.envelope << metadata.internalDate << metadata.size << metadata.serializedBodyStructure\n             << metadata.hdrReferences << metadata.hdrListPost << metadata.hdrListPostNo;\n      querySetMessageMetadata.bindValue(2, qCompress(buf));\n      querySetMessageMetadata.bindValue(3, accessingThresholdDate.daysTo(QDate::currentDate()));\n      if (! querySetMessageMetadata.exec()) {\n          emitError(tr(\"Query querySetMessageMetadata failed\"), querySetMessageMetadata);\n      }\n  }\n}"
  },
  {
    "function_name": "messageMetadata(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "699-730",
    "snippet": "bstractCache::MessageDataBundle SQLCache::messageMetadata(const QString &mailbox, uint uid) const\n{\n    AbstractCache::MessageDataBundle res;\n    queryMessageMetadata.bindValue(0, mailboxName(mailbox));\n    queryMessageMetadata.bindValue(1, uid);\n    if (! queryMessageMetadata.exec()) {\n        emitError(tr(\"Query queryMessageMetadata failed\"), queryMessageMetadata);\n        return res;\n    }\n    if (queryMessageMetadata.first()) {\n        res.uid = uid;\n        QDataStream stream(qUncompress(queryMessageMetadata.value(0).toByteArray()));\n        stream.setVersion(streamVersion);\n        stream >> res.envelope >> res.internalDate >> res.size >> res.serializedBodyStructure >> res.hdrReferences\n                  >> res.hdrListPost >> res.hdrListPostNo;\n\n        if (m_updateAccessIfOlder) {\n            int lastAccessTimestamp = queryMessageMetadata.value(1).toInt();\n            int currentDiff = accessingThresholdDate.daysTo(QDate::currentDate());\n            if (lastAccessTimestamp < currentDiff - m_updateAccessIfOlder) {\n                queryAccessMessageMetadata.bindValue(0, currentDiff);\n                queryAccessMessageMetadata.bindValue(1, mailboxName(mailbox));\n                queryAccessMessageMetadata.bindValue(2, uid);\n                if (!queryAccessMessageMetadata.exec()) {\n                    emitError(tr(\"Query queryAccessMessageMetadata failed\"), queryAccessMessageMetadata);\n                }\n            }\n        }\n    }\n    // \"Not found\" is not an error here\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryAccessMessageMetadata failed\"),",
            "ueryAccessMessageMetadata)"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryAccessMessageMetadata.exec",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryAccessMessageMetadata.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryAccessMessageMetadata.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryAccessMessageMetadata.bindValue",
          "args": [
            ",",
            "urrentDiff)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccessingThresholdDate.daysTo",
          "args": [
            "Date::currentDate())"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Date::currentDate(",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessageMetadata.value",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageMetadata.value",
          "args": [
            ")"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Uncompress(",
          "args": [
            "ueryMessageMetadata.value(0).toByteArray())"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessageMetadata.first",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageMetadata.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessageMetadata.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  bstractCache::MessageDataBundle SQLCache::messageMetadata(const QString &mailbox, uint uid) const\n  {\n      AbstractCache::MessageDataBundle res;\n      queryMessageMetadata.bindValue(0, mailboxName(mailbox));\n      queryMessageMetadata.bindValue(1, uid);\n      if (! queryMessageMetadata.exec()) {\n          emitError(tr(\"Query queryMessageMetadata failed\"), queryMessageMetadata);\n          return res;\n      }\n      if (queryMessageMetadata.first()) {\n          res.uid = uid;\n          QDataStream stream(qUncompress(queryMessageMetadata.value(0).toByteArray()));\n          stream.setVersion(streamVersion);\n          stream >> res.envelope >> res.internalDate >> res.size >> res.serializedBodyStructure >> res.hdrReferences\n                    >> res.hdrListPost >> res.hdrListPostNo;\n  \n          if (m_updateAccessIfOlder) {\n              int lastAccessTimestamp = queryMessageMetadata.value(1).toInt();\n              int currentDiff = accessingThresholdDate.daysTo(QDate::currentDate());\n              if (lastAccessTimestamp < currentDiff - m_updateAccessIfOlder) {\n                  queryAccessMessageMetadata.bindValue(0, currentDiff);\n                  queryAccessMessageMetadata.bindValue(1, mailboxName(mailbox));\n                  queryAccessMessageMetadata.bindValue(2, uid);\n                  if (!queryAccessMessageMetadata.exec()) {\n                      emitError(tr(\"Query queryAccessMessageMetadata failed\"), queryAccessMessageMetadata);\n                  }\n              }\n          }\n      }\n      // \"Not found\" is not an error here\n      return res;\n  }\n}"
  },
  {
    "function_name": "setMsgFlags(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "681-697",
    "snippet": "oid SQLCache::setMsgFlags(const QString &mailbox, const uint uid, const QStringList &flags)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Updating flags for\" << mailbox << uid;\n#endif\n    touchingDB();\n    querySetMessageFlags.bindValue(0, mailboxName(mailbox));\n    querySetMessageFlags.bindValue(1, uid);\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << flags;\n    querySetMessageFlags.bindValue(2, buf);\n    if (! querySetMessageFlags.exec()) {\n        emitError(tr(\"Query querySetMessageFlags failed\"), querySetMessageFlags);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetMessageFlags failed\"),",
            "uerySetMessageFlags)"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageFlags.exec",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageFlags.bindValue",
          "args": [
            ",",
            "uf)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessageFlags.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMessageFlags.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMsgFlags(const QString &mailbox, const uint uid, const QStringList &flags)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Updating flags for\" << mailbox << uid;\n  #endif\n      touchingDB();\n      querySetMessageFlags.bindValue(0, mailboxName(mailbox));\n      querySetMessageFlags.bindValue(1, uid);\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << flags;\n      querySetMessageFlags.bindValue(2, buf);\n      if (! querySetMessageFlags.exec()) {\n          emitError(tr(\"Query querySetMessageFlags failed\"), querySetMessageFlags);\n      }\n  }\n}"
  },
  {
    "function_name": "msgFlags(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "663-679",
    "snippet": "StringList SQLCache::msgFlags(const QString &mailbox, const uint uid) const\n{\n    QStringList res;\n    queryMessageFlags.bindValue(0, mailboxName(mailbox));\n    queryMessageFlags.bindValue(1, uid);\n    if (! queryMessageFlags.exec()) {\n        emitError(tr(\"Query queryMessageFlags failed\"), queryMessageFlags);\n        return res;\n    }\n    if (queryMessageFlags.first()) {\n        QDataStream stream(queryMessageFlags.value(0).toByteArray());\n        stream.setVersion(streamVersion);\n        stream >> res;\n    }\n    // \"Not found\" is not an error here\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessageFlags.value",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageFlags.value",
          "args": [
            ")"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageFlags.first",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryMessageFlags failed\"),",
            "ueryMessageFlags)"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageFlags.exec",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMessageFlags.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMessageFlags.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  StringList SQLCache::msgFlags(const QString &mailbox, const uint uid) const\n  {\n      QStringList res;\n      queryMessageFlags.bindValue(0, mailboxName(mailbox));\n      queryMessageFlags.bindValue(1, uid);\n      if (! queryMessageFlags.exec()) {\n          emitError(tr(\"Query queryMessageFlags failed\"), queryMessageFlags);\n          return res;\n      }\n      if (queryMessageFlags.first()) {\n          QDataStream stream(queryMessageFlags.value(0).toByteArray());\n          stream.setVersion(streamVersion);\n          stream >> res;\n      }\n      // \"Not found\" is not an error here\n      return res;\n  }\n}"
  },
  {
    "function_name": "clearMessage(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "640-661",
    "snippet": "oid SQLCache::clearMessage(const QString mailbox, uint uid)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Clearing message\" << uid << \"from\" << mailbox;\n#endif\n    touchingDB();\n    queryClearMessage1.bindValue(0, mailboxName(mailbox));\n    queryClearMessage1.bindValue(1, uid);\n    queryClearMessage2.bindValue(0, mailboxName(mailbox));\n    queryClearMessage2.bindValue(1, uid);\n    queryClearMessage3.bindValue(0, mailboxName(mailbox));\n    queryClearMessage3.bindValue(1, uid);\n    if (! queryClearMessage1.exec()) {\n        emitError(tr(\"Query queryClearMessage1 failed\"), queryClearMessage1);\n    }\n    if (! queryClearMessage2.exec()) {\n        emitError(tr(\"Query queryClearMessage2 failed\"), queryClearMessage2);\n    }\n    if (! queryClearMessage3.exec()) {\n        emitError(tr(\"Query queryClearMessage3 failed\"), queryClearMessage3);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryClearMessage3 failed\"),",
            "ueryClearMessage3)"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearMessage3.exec",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearMessage3.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryClearMessage3.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearMessage2.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryClearMessage2.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryClearMessage1.bindValue",
          "args": [
            ",",
            "id)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryClearMessage1.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::clearMessage(const QString mailbox, uint uid)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Clearing message\" << uid << \"from\" << mailbox;\n  #endif\n      touchingDB();\n      queryClearMessage1.bindValue(0, mailboxName(mailbox));\n      queryClearMessage1.bindValue(1, uid);\n      queryClearMessage2.bindValue(0, mailboxName(mailbox));\n      queryClearMessage2.bindValue(1, uid);\n      queryClearMessage3.bindValue(0, mailboxName(mailbox));\n      queryClearMessage3.bindValue(1, uid);\n      if (! queryClearMessage1.exec()) {\n          emitError(tr(\"Query queryClearMessage1 failed\"), queryClearMessage1);\n      }\n      if (! queryClearMessage2.exec()) {\n          emitError(tr(\"Query queryClearMessage2 failed\"), queryClearMessage2);\n      }\n      if (! queryClearMessage3.exec()) {\n          emitError(tr(\"Query queryClearMessage3 failed\"), queryClearMessage3);\n      }\n  }\n}"
  },
  {
    "function_name": "clearAllMessages(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "615-638",
    "snippet": "oid SQLCache::clearAllMessages(const QString &mailbox)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Clearing all messages from\" << mailbox;\n#endif\n    touchingDB();\n    queryClearAllMessages1.bindValue(0, mailboxName(mailbox));\n    queryClearAllMessages2.bindValue(0, mailboxName(mailbox));\n    queryClearAllMessages3.bindValue(0, mailboxName(mailbox));\n    queryClearAllMessages4.bindValue(0, mailboxName(mailbox));\n    if (! queryClearAllMessages1.exec()) {\n        emitError(tr(\"Query queryClearAllMessages1 failed\"), queryClearAllMessages1);\n    }\n    if (! queryClearAllMessages2.exec()) {\n        emitError(tr(\"Query queryClearAllMessages2 failed\"), queryClearAllMessages2);\n    }\n    if (! queryClearAllMessages3.exec()) {\n        emitError(tr(\"Query queryClearAllMessages3 failed\"), queryClearAllMessages3);\n    }\n    if (! queryClearAllMessages4.exec()) {\n        emitError(tr(\"Query queryClearAllMessages4 failed\"), queryClearAllMessages4);\n    }\n    clearUidMapping(mailbox);\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "learUidMapping(",
          "args": [
            "ailbox)"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "clearUidMapping(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "603-613",
          "snippet": "oid SQLCache::clearUidMapping(const QString &mailbox)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Clearing UID mapping for\" << mailbox;\n#endif\n    touchingDB();\n    queryClearUidMapping.bindValue(0, mailboxName(mailbox));\n    if (! queryClearUidMapping.exec()) {\n        emitError(tr(\"Query queryClearUidMapping failed\"), queryClearUidMapping);\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::clearUidMapping(const QString &mailbox)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Clearing UID mapping for\" << mailbox;\n  #endif\n      touchingDB();\n      queryClearUidMapping.bindValue(0, mailboxName(mailbox));\n      if (! queryClearUidMapping.exec()) {\n          emitError(tr(\"Query queryClearUidMapping failed\"), queryClearUidMapping);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryClearAllMessages4 failed\"),",
            "ueryClearAllMessages4)"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearAllMessages4.exec",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearAllMessages4.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearAllMessages3.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryClearAllMessages2.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryClearAllMessages1.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::clearAllMessages(const QString &mailbox)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Clearing all messages from\" << mailbox;\n  #endif\n      touchingDB();\n      queryClearAllMessages1.bindValue(0, mailboxName(mailbox));\n      queryClearAllMessages2.bindValue(0, mailboxName(mailbox));\n      queryClearAllMessages3.bindValue(0, mailboxName(mailbox));\n      queryClearAllMessages4.bindValue(0, mailboxName(mailbox));\n      if (! queryClearAllMessages1.exec()) {\n          emitError(tr(\"Query queryClearAllMessages1 failed\"), queryClearAllMessages1);\n      }\n      if (! queryClearAllMessages2.exec()) {\n          emitError(tr(\"Query queryClearAllMessages2 failed\"), queryClearAllMessages2);\n      }\n      if (! queryClearAllMessages3.exec()) {\n          emitError(tr(\"Query queryClearAllMessages3 failed\"), queryClearAllMessages3);\n      }\n      if (! queryClearAllMessages4.exec()) {\n          emitError(tr(\"Query queryClearAllMessages4 failed\"), queryClearAllMessages4);\n      }\n      clearUidMapping(mailbox);\n  }\n}"
  },
  {
    "function_name": "clearUidMapping(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "603-613",
    "snippet": "oid SQLCache::clearUidMapping(const QString &mailbox)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Clearing UID mapping for\" << mailbox;\n#endif\n    touchingDB();\n    queryClearUidMapping.bindValue(0, mailboxName(mailbox));\n    if (! queryClearUidMapping.exec()) {\n        emitError(tr(\"Query queryClearUidMapping failed\"), queryClearUidMapping);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryClearUidMapping failed\"),",
            "ueryClearUidMapping)"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearUidMapping.exec",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryClearUidMapping.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::clearUidMapping(const QString &mailbox)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Clearing UID mapping for\" << mailbox;\n  #endif\n      touchingDB();\n      queryClearUidMapping.bindValue(0, mailboxName(mailbox));\n      if (! queryClearUidMapping.exec()) {\n          emitError(tr(\"Query queryClearUidMapping failed\"), queryClearUidMapping);\n      }\n  }\n}"
  },
  {
    "function_name": "setUidMapping(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "586-601",
    "snippet": "oid SQLCache::setUidMapping(const QString &mailbox, const QList<uint> &seqToUid)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting UID mapping for\" << mailbox;\n#endif\n    touchingDB();\n    querySetUidMapping.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << seqToUid;\n    querySetUidMapping.bindValue(1, qCompress(buf));\n    if (! querySetUidMapping.exec()) {\n        emitError(tr(\"Query querySetUidMapping failed\"), querySetUidMapping);\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetUidMapping failed\"),",
            "uerySetUidMapping)"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetUidMapping.exec",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetUidMapping.bindValue",
          "args": [
            ",",
            "Compress(buf))"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Compress(",
          "args": [
            "uf)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetUidMapping.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setUidMapping(const QString &mailbox, const QList<uint> &seqToUid)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting UID mapping for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetUidMapping.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << seqToUid;\n      querySetUidMapping.bindValue(1, qCompress(buf));\n      if (! querySetUidMapping.exec()) {\n          emitError(tr(\"Query querySetUidMapping failed\"), querySetUidMapping);\n      }\n  }\n}"
  },
  {
    "function_name": "uidMapping(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "569-584",
    "snippet": "List<uint> SQLCache::uidMapping(const QString &mailbox) const\n{\n    QList<uint> res;\n    queryUidMapping.bindValue(0, mailboxName(mailbox));\n    if (! queryUidMapping.exec()) {\n        emitError(tr(\"Query queryUidMapping failed\"), queryUidMapping);\n        return res;\n    }\n    if (queryUidMapping.first()) {\n        QDataStream stream(qUncompress(queryUidMapping.value(0).toByteArray()));\n        stream.setVersion(streamVersion);\n        stream >> res;\n    }\n    // \"No data present\" doesn't necessarily imply a problem -- it simply might not be there yet :)\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Uncompress(",
          "args": [
            "ueryUidMapping.value(0).toByteArray())"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryUidMapping.value",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryUidMapping.value",
          "args": [
            ")"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryUidMapping.first",
          "args": [],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryUidMapping failed\"),",
            "ueryUidMapping)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryUidMapping.exec",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryUidMapping.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  List<uint> SQLCache::uidMapping(const QString &mailbox) const\n  {\n      QList<uint> res;\n      queryUidMapping.bindValue(0, mailboxName(mailbox));\n      if (! queryUidMapping.exec()) {\n          emitError(tr(\"Query queryUidMapping failed\"), queryUidMapping);\n          return res;\n      }\n      if (queryUidMapping.first()) {\n          QDataStream stream(qUncompress(queryUidMapping.value(0).toByteArray()));\n          stream.setVersion(streamVersion);\n          stream >> res;\n      }\n      // \"No data present\" doesn't necessarily imply a problem -- it simply might not be there yet :)\n      return res;\n  }\n}"
  },
  {
    "function_name": "setMailboxSyncState(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "551-567",
    "snippet": "oid SQLCache::setMailboxSyncState(const QString &mailbox, const SyncState &state)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting sync state for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMailboxSyncState.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << state;\n    querySetMailboxSyncState.bindValue(1, buf);\n    if (! querySetMailboxSyncState.exec()) {\n        emitError(tr(\"Query querySetMailboxSyncState failed\"), querySetMailboxSyncState);\n        return;\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetMailboxSyncState failed\"),",
            "uerySetMailboxSyncState)"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMailboxSyncState.exec",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMailboxSyncState.bindValue",
          "args": [
            ",",
            "uf)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetMailboxSyncState.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMailboxSyncState(const QString &mailbox, const SyncState &state)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting sync state for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMailboxSyncState.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << state;\n      querySetMailboxSyncState.bindValue(1, buf);\n      if (! querySetMailboxSyncState.exec()) {\n          emitError(tr(\"Query querySetMailboxSyncState failed\"), querySetMailboxSyncState);\n          return;\n      }\n  }\n}"
  },
  {
    "function_name": "mailboxSyncState(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "534-549",
    "snippet": "yncState SQLCache::mailboxSyncState(const QString &mailbox) const\n{\n    SyncState res;\n    queryMailboxSyncState.bindValue(0, mailboxName(mailbox));\n    if (! queryMailboxSyncState.exec()) {\n        emitError(tr(\"Query queryMailboxSyncState failed\"), queryMailboxSyncState);\n        return res;\n    }\n    if (queryMailboxSyncState.first()) {\n        QDataStream stream(queryMailboxSyncState.value(0).toByteArray());\n        stream.setVersion(streamVersion);\n        stream >> res;\n    }\n    // \"No data present\" doesn't necessarily imply a problem -- it simply might not be there yet :)\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryMailboxSyncState.value",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMailboxSyncState.value",
          "args": [
            ")"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMailboxSyncState.first",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryMailboxSyncState failed\"),",
            "ueryMailboxSyncState)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMailboxSyncState.exec",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryMailboxSyncState.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  yncState SQLCache::mailboxSyncState(const QString &mailbox) const\n  {\n      SyncState res;\n      queryMailboxSyncState.bindValue(0, mailboxName(mailbox));\n      if (! queryMailboxSyncState.exec()) {\n          emitError(tr(\"Query queryMailboxSyncState failed\"), queryMailboxSyncState);\n          return res;\n      }\n      if (queryMailboxSyncState.first()) {\n          QDataStream stream(queryMailboxSyncState.value(0).toByteArray());\n          stream.setVersion(streamVersion);\n          stream >> res;\n      }\n      // \"No data present\" doesn't necessarily imply a problem -- it simply might not be there yet :)\n      return res;\n  }\n}"
  },
  {
    "function_name": "setChildMailboxes(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "502-532",
    "snippet": "oid SQLCache::setChildMailboxes(const QString &mailbox, const QList<MailboxMetadata> &data)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting child mailboxes for\" << mailbox;\n#endif\n    touchingDB();\n    QVariantList mailboxFields, parentFields, separatorFields, flagsFelds;\n    Q_FOREACH(const MailboxMetadata& item, data) {\n        mailboxFields << item.mailbox;\n        parentFields << mailboxName(mailbox);\n        separatorFields << item.separator;\n        QByteArray buf;\n        QDataStream stream(&buf, QIODevice::ReadWrite);\n        stream.setVersion(streamVersion);\n        stream << item.flags;\n        flagsFelds << buf;\n    }\n    queryRemoveChildMailboxes.bindValue(0, mailboxName(mailbox));\n    if (!queryRemoveChildMailboxes.exec()) {\n        emitError(tr(\"Query queryRemoveChildMailboxes failed\"), queryRemoveChildMailboxes);\n        return;\n    }\n    querySetChildMailboxes.bindValue(0, mailboxFields);\n    querySetChildMailboxes.bindValue(1, parentFields);\n    querySetChildMailboxes.bindValue(2, separatorFields);\n    querySetChildMailboxes.bindValue(3, flagsFelds);\n    if (! querySetChildMailboxes.execBatch()) {\n        emitError(tr(\"Query querySetChildMailboxes failed\"), querySetChildMailboxes);\n        return;\n    }\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query querySetChildMailboxes failed\"),",
            "uerySetChildMailboxes)"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetChildMailboxes.execBatch",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetChildMailboxes.bindValue",
          "args": [
            ",",
            "lagsFelds)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetChildMailboxes.bindValue",
          "args": [
            ",",
            "eparatorFields)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetChildMailboxes.bindValue",
          "args": [
            ",",
            "arentFields)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uerySetChildMailboxes.bindValue",
          "args": [
            ",",
            "ailboxFields)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryRemoveChildMailboxes.exec",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryRemoveChildMailboxes.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ouchingDB(",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "touchingDB(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "833-844",
          "snippet": "oid SQLCache::touchingDB()\n{\n    delayedCommit->start();\n    if (! inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Starting transaction\";\n#endif\n        inTransaction = true;\n        db.transaction();\n        tooMuchTimeWithoutCommit->start();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::touchingDB()\n  {\n      delayedCommit->start();\n      if (! inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Starting transaction\";\n  #endif\n          inTransaction = true;\n          db.transaction();\n          tooMuchTimeWithoutCommit->start();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setChildMailboxes(const QString &mailbox, const QList<MailboxMetadata> &data)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting child mailboxes for\" << mailbox;\n  #endif\n      touchingDB();\n      QVariantList mailboxFields, parentFields, separatorFields, flagsFelds;\n      Q_FOREACH(const MailboxMetadata& item, data) {\n          mailboxFields << item.mailbox;\n          parentFields << mailboxName(mailbox);\n          separatorFields << item.separator;\n          QByteArray buf;\n          QDataStream stream(&buf, QIODevice::ReadWrite);\n          stream.setVersion(streamVersion);\n          stream << item.flags;\n          flagsFelds << buf;\n      }\n      queryRemoveChildMailboxes.bindValue(0, mailboxName(mailbox));\n      if (!queryRemoveChildMailboxes.exec()) {\n          emitError(tr(\"Query queryRemoveChildMailboxes failed\"), queryRemoveChildMailboxes);\n          return;\n      }\n      querySetChildMailboxes.bindValue(0, mailboxFields);\n      querySetChildMailboxes.bindValue(1, parentFields);\n      querySetChildMailboxes.bindValue(2, separatorFields);\n      querySetChildMailboxes.bindValue(3, flagsFelds);\n      if (! querySetChildMailboxes.execBatch()) {\n          emitError(tr(\"Query querySetChildMailboxes failed\"), querySetChildMailboxes);\n          return;\n      }\n  }\n}"
  },
  {
    "function_name": "childMailboxesFresh(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "492-500",
    "snippet": "ool SQLCache::childMailboxesFresh(const QString &mailbox) const\n{\n    queryChildMailboxesFresh.bindValue(0, mailboxName(mailbox));\n    if (! queryChildMailboxesFresh.exec()) {\n        emitError(tr(\"Query queryChildMailboxesFresh failed\"), queryChildMailboxesFresh);\n        return false;\n    }\n    return queryChildMailboxesFresh.first();\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueryChildMailboxesFresh.first",
          "args": [],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Query queryChildMailboxesFresh failed\"),",
            "ueryChildMailboxesFresh)"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxesFresh.exec",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxesFresh.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ool SQLCache::childMailboxesFresh(const QString &mailbox) const\n  {\n      queryChildMailboxesFresh.bindValue(0, mailboxName(mailbox));\n      if (! queryChildMailboxesFresh.exec()) {\n          emitError(tr(\"Query queryChildMailboxesFresh failed\"), queryChildMailboxesFresh);\n          return false;\n      }\n      return queryChildMailboxesFresh.first();\n  }\n}"
  },
  {
    "function_name": "childMailboxes(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "468-490",
    "snippet": "List<MailboxMetadata> SQLCache::childMailboxes(const QString &mailbox) const\n{\n    QList<MailboxMetadata> res;\n    queryChildMailboxes.bindValue(0, mailboxName(mailbox));\n    if (! queryChildMailboxes.exec()) {\n        emitError(tr(\"Query queryChildMailboxes failed\"), queryChildMailboxes);\n        return res;\n    }\n    while (queryChildMailboxes.next()) {\n        MailboxMetadata item;\n        item.mailbox = queryChildMailboxes.value(0).toString();\n        item.separator = queryChildMailboxes.value(1).toString();\n        QDataStream stream(queryChildMailboxes.value(2).toByteArray());\n        stream.setVersion(streamVersion);\n        stream >> item.flags;\n        if (stream.status() != QDataStream::Ok) {\n            emitError(tr(\"Corrupt data when reading child items for mailbox %1, line %2\").arg(mailbox, item.mailbox));\n            return QList<MailboxMetadata>();\n        }\n        res << item;\n    }\n    return res;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "List<MailboxMetadata>",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "numbersFetched(",
          "container": "reeItemMsgList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "957-960",
          "snippet": "ool TreeItemMsgList::numbersFetched() const\n{\n    return m_numberFetchingStatus == DONE;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMsgList {\n  ool TreeItemMsgList::numbersFetched() const\n  {\n      return m_numberFetchingStatus == DONE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Corrupt data when reading child items for mailbox %1, line %2\").arg(mailbox, item.mailbox))"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ailbox,",
            "tem.mailbox)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "setMessageThreading(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "815-831",
          "snippet": "oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"Setting threading for\" << mailbox;\n#endif\n    touchingDB();\n    querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n    QByteArray buf;\n    QDataStream stream(&buf, QIODevice::ReadWrite);\n    stream.setVersion(streamVersion);\n    stream << threading;\n    querySetMessageThreading.bindValue(1, qCompress(buf));\n    if (! querySetMessageThreading.exec()) {\n        emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n    }\n\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::setMessageThreading(const QString &mailbox, const QVector<Imap::Responses::ThreadingNode> &threading)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"Setting threading for\" << mailbox;\n  #endif\n      touchingDB();\n      querySetMessageThreading.bindValue(0, mailboxName(mailbox));\n      QByteArray buf;\n      QDataStream stream(&buf, QIODevice::ReadWrite);\n      stream.setVersion(streamVersion);\n      stream << threading;\n      querySetMessageThreading.bindValue(1, qCompress(buf));\n      if (! querySetMessageThreading.exec()) {\n          emitError(tr(\"Query querySetMessageThreading failed\"), querySetMessageThreading);\n      }\n  \n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tream.status",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "TrojitaQNAMDeclarativeWebView",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/QmlSupport/QNAMWebView/qdeclarativewebview.cpp",
          "lines": "309-312",
          "snippet": "TrojitaQNAMDeclarativeWebView::Status TrojitaQNAMDeclarativeWebView::status() const\n{\n    return d->status;\n}",
          "includes": [
            "#include \"qwebsettings.h\"",
            "#include \"qwebpage.h\"",
            "#include \"qwebframe.h\"",
            "#include \"qwebelement.h\"",
            "#include <QtGui/QPen>",
            "#include <QtGui/QMouseEvent>",
            "#include <QtGui/QKeyEvent>",
            "#include <QtGui/QGraphicsSceneMouseEvent>",
            "#include <QtGui/QApplication>",
            "#include <QtDeclarative/qdeclarative.h>",
            "#include <QtDeclarative/QDeclarativeEngine>",
            "#include <QtDeclarative/QDeclarativeContext>",
            "#include <QtCore/QFile>",
            "#include <QtCore/QEvent>",
            "#include <QtCore/QDebug>",
            "#include \"qdeclarativewebview_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "TrojitaQNAMDeclarativeWebView::Status status;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qwebsettings.h\"\n#include \"qwebpage.h\"\n#include \"qwebframe.h\"\n#include \"qwebelement.h\"\n#include <QtGui/QPen>\n#include <QtGui/QMouseEvent>\n#include <QtGui/QKeyEvent>\n#include <QtGui/QGraphicsSceneMouseEvent>\n#include <QtGui/QApplication>\n#include <QtDeclarative/qdeclarative.h>\n#include <QtDeclarative/QDeclarativeEngine>\n#include <QtDeclarative/QDeclarativeContext>\n#include <QtCore/QFile>\n#include <QtCore/QEvent>\n#include <QtCore/QDebug>\n#include \"qdeclarativewebview_p.h\"\n\nTrojitaQNAMDeclarativeWebView::Status status;\n\nTrojitaQNAMDeclarativeWebView {\n  TrojitaQNAMDeclarativeWebView::Status TrojitaQNAMDeclarativeWebView::status() const\n  {\n      return d->status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tream.setVersion",
          "args": [
            "treamVersion)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxes.value",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxes.value",
          "args": [
            ")"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxes.next",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxes.exec",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "217-242",
          "snippet": "bool XSqlQuery::exec()\n{\n  bool returnValue = false;\n\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    if (lastError().isValid())\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n\n    returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n  }\n  else\n    returnValue = QSqlQuery::exec();\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec()\n  {\n    bool returnValue = false;\n  \n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      if (lastError().isValid())\n        ((XSqlResultHelper*)result())->setLastError(QSqlError());\n  \n      returnValue = ((XSqlResultHelper*)result())->XSqlResultHelper::exec();\n    }\n    else\n      returnValue = QSqlQuery::exec();\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueryChildMailboxes.bindValue",
          "args": [
            ",",
            "ailboxName(mailbox))"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxName(",
          "args": [
            "ailbox)"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "mailboxName(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "866-869",
          "snippet": "String SQLCache::mailboxName(const QString &mailbox)\n{\n    return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  String SQLCache::mailboxName(const QString &mailbox)\n  {\n      return mailbox.isEmpty() ? QLatin1String(\"\") : mailbox;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  List<MailboxMetadata> SQLCache::childMailboxes(const QString &mailbox) const\n  {\n      QList<MailboxMetadata> res;\n      queryChildMailboxes.bindValue(0, mailboxName(mailbox));\n      if (! queryChildMailboxes.exec()) {\n          emitError(tr(\"Query queryChildMailboxes failed\"), queryChildMailboxes);\n          return res;\n      }\n      while (queryChildMailboxes.next()) {\n          MailboxMetadata item;\n          item.mailbox = queryChildMailboxes.value(0).toString();\n          item.separator = queryChildMailboxes.value(1).toString();\n          QDataStream stream(queryChildMailboxes.value(2).toByteArray());\n          stream.setVersion(streamVersion);\n          stream >> item.flags;\n          if (stream.status() != QDataStream::Ok) {\n              emitError(tr(\"Corrupt data when reading child items for mailbox %1, line %2\").arg(mailbox, item.mailbox));\n              return QList<MailboxMetadata>();\n          }\n          res << item;\n      }\n      return res;\n  }\n}"
  },
  {
    "function_name": "emitError(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "462-466",
    "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
  },
  {
    "function_name": "emitError(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "457-460",
    "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "String::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()))"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "essage,",
            "atabase.lastError().text())"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atabase.lastError",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atabase.lastError",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "SQLCache: DB Error: %1: %2\")"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
  },
  {
    "function_name": "emitError(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "452-455",
    "snippet": "oid SQLCache::emitError(const QString &message, const QSqlQuery &query) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: Query Error: %1: %2\").arg(message, query.lastError().text()));\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "String::fromUtf8(\"SQLCache: Query Error: %1: %2\").arg(message, query.lastError().text()))"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "essage,",
            "uery.lastError().text())"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uery.lastError",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uery.lastError",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "SQLCache: Query Error: %1: %2\")"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlQuery &query) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: Query Error: %1: %2\").arg(message, query.lastError().text()));\n  }\n}"
  },
  {
    "function_name": "prepareQueries(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "286-450",
    "snippet": "ool SQLCache::prepareQueries()\n{\n    queryChildMailboxes = QSqlQuery(db);\n    if (! queryChildMailboxes.prepare(\"SELECT mailbox, separator, flags FROM child_mailboxes WHERE parent = ?\")) {\n        emitError(tr(\"Failed to prepare queryChildMailboxes\"), queryChildMailboxes);\n        return false;\n    }\n\n    queryChildMailboxesFresh = QSqlQuery(db);\n    if (! queryChildMailboxesFresh.prepare(QLatin1String(\"SELECT mailbox FROM child_mailboxes WHERE parent = ? LIMIT 1\"))) {\n        emitError(tr(\"Failed to prepare queryChildMailboxesFresh\"), queryChildMailboxesFresh);\n        return false;\n    }\n\n    queryRemoveChildMailboxes = QSqlQuery(db);\n    if (!queryRemoveChildMailboxes.prepare(QLatin1String(\"DELETE FROM child_mailboxes WHERE parent = ?\"))) {\n        emitError(tr(\"Failed to prepare queryRemoveChildMailboxes\"), queryRemoveChildMailboxes);\n        return false;\n    }\n\n    querySetChildMailboxes = QSqlQuery(db);\n    if (! querySetChildMailboxes.prepare(QLatin1String(\"INSERT OR REPLACE INTO child_mailboxes ( mailbox, parent, separator, flags ) VALUES (?, ?, ?, ?)\"))) {\n        emitError(tr(\"Failed to prepare querySetChildMailboxes\"), querySetChildMailboxes);\n        return false;\n    }\n\n    queryMailboxSyncState = QSqlQuery(db);\n    if (! queryMailboxSyncState.prepare(QLatin1String(\"SELECT sync_state FROM mailbox_sync_state WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMailboxSyncState\"), queryMailboxSyncState);\n        return false;\n    }\n\n    querySetMailboxSyncState = QSqlQuery(db);\n    if (! querySetMailboxSyncState.prepare(QLatin1String(\"INSERT OR REPLACE INTO mailbox_sync_state \"\n                                           \"( mailbox, sync_state ) \"\n                                           \"VALUES ( ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMailboxSyncState\"), querySetMailboxSyncState);\n        return false;\n    }\n\n    queryUidMapping = QSqlQuery(db);\n    if (! queryUidMapping.prepare(QLatin1String(\"SELECT mapping FROM uid_mapping WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryUidMapping\"), queryUidMapping);\n        return false;\n    }\n\n    querySetUidMapping = QSqlQuery(db);\n    if (! querySetUidMapping.prepare(QLatin1String(\"INSERT OR REPLACE INTO uid_mapping (mailbox, mapping) VALUES  ( ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetUidMapping\"), querySetUidMapping);\n        return false;\n    }\n\n    queryClearUidMapping = QSqlQuery(db);\n    if (! queryClearUidMapping.prepare(QLatin1String(\"DELETE FROM uid_mapping WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearUidMapping\"), queryClearUidMapping);\n        return false;\n    }\n\n    queryMessageMetadata = QSqlQuery(db);\n    if (! queryMessageMetadata.prepare(QLatin1String(\"SELECT data, lastAccessDate FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessageMetadata\"), queryMessageMetadata);\n        return false;\n    }\n\n    queryAccessMessageMetadata = QSqlQuery(db);\n    if (!queryAccessMessageMetadata.prepare(QLatin1String(\"UPDATE msg_metadata SET lastAccessDate = ? WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryAccssMessageMetadata\"), queryAccessMessageMetadata);\n        return false;\n    }\n\n    querySetMessageMetadata = QSqlQuery(db);\n    if (! querySetMessageMetadata.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_metadata ( mailbox, uid, data, lastAccessDate ) VALUES ( ?, ?, ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMessageMetadata\"), querySetMessageMetadata);\n        return false;\n    }\n\n    queryMessageFlags = QSqlQuery(db);\n    if (! queryMessageFlags.prepare(QLatin1String(\"SELECT flags FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessageFlags\"), queryMessageFlags);\n        return false;\n    }\n\n    querySetMessageFlags = QSqlQuery(db);\n    if (! querySetMessageFlags.prepare(QLatin1String(\"INSERT OR REPLACE INTO flags ( mailbox, uid, flags ) VALUES ( ?, ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMessageFlags\"), querySetMessageFlags);\n        return false;\n    }\n\n    queryClearAllMessages1 = QSqlQuery(db);\n    if (! queryClearAllMessages1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages1\"), queryClearAllMessages1);\n        return false;\n    }\n\n    queryClearAllMessages2 = QSqlQuery(db);\n    if (! queryClearAllMessages2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages2\"), queryClearAllMessages2);\n        return false;\n    }\n\n    queryClearAllMessages3 = QSqlQuery(db);\n    if (! queryClearAllMessages3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages3\"), queryClearAllMessages3);\n        return false;\n    }\n\n    queryClearAllMessages4 = QSqlQuery(db);\n    if (! queryClearAllMessages4.prepare(QLatin1String(\"DELETE FROM msg_threading WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages4\"), queryClearAllMessages4);\n        return false;\n    }\n\n    queryClearMessage1 = QSqlQuery(db);\n    if (! queryClearMessage1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearMessage1\"), queryClearMessage1);\n        return false;\n    }\n\n    queryClearMessage2 = QSqlQuery(db);\n    if (! queryClearMessage2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearMessage2\"), queryClearMessage2);\n        return false;\n    }\n\n    queryClearMessage3 = QSqlQuery(db);\n    if (! queryClearMessage3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearMessage3\"), queryClearMessage3);\n        return false;\n    }\n\n    queryMessagePart = QSqlQuery(db);\n    if (! queryMessagePart.prepare(QLatin1String(\"SELECT data FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessagePart\"), queryMessagePart);\n        return false;\n    }\n\n    querySetMessagePart = QSqlQuery(db);\n    if (! querySetMessagePart.prepare(QLatin1String(\"INSERT OR REPLACE INTO parts ( mailbox, uid, part_id, data ) VALUES (?, ?, ?, ?)\"))) {\n        emitError(tr(\"Failed to prepare querySetMessagePart\"), querySetMessagePart);\n        return false;\n    }\n\n    queryForgetMessagePart = QSqlQuery(db);\n    if (! queryForgetMessagePart.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n        emitError(tr(\"Failed to prepare queryForgetMessagePart\"), queryForgetMessagePart);\n        return false;\n    }\n\n    queryMessageThreading = QSqlQuery(db);\n    if (! queryMessageThreading.prepare(QLatin1String(\"SELECT threading FROM msg_threading WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessageThreading\"), queryMessageThreading);\n        return false;\n    }\n\n    querySetMessageThreading = QSqlQuery(db);\n    if (! querySetMessageThreading.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_threading (mailbox, threading) VALUES  ( ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMessageThreading\"), querySetMessageThreading);\n        return false;\n    }\n\n#ifdef CACHE_DEBUG\n    qDebug() << \"SQLCache::_prepareQueries() succeeded\";\n#endif\n    return true;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Failed to prepare querySetMessageThreading\"),",
            "uerySetMessageThreading)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uerySetMessageThreading.prepare",
          "args": [
            "Latin1String(\"INSERT OR REPLACE INTO msg_threading (mailbox, threading) VALUES  ( ?, ? )\"))"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "prepare",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "257-291",
          "snippet": "bool XSqlQuery::prepare(const QString &pSql)\n{\n  bool ret;\n  if(_data && _data->_emulatePrepare)\n  {\n// In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n// caused several problems with all our code and the way it worked so this is a modified copy\n// of their code to use the implemented prepare if we have that option set so we can use the method\n// that works best in the case we are using it for.\n    ((XSqlResultHelper*)result())->setActive(false);\n    ((XSqlResultHelper*)result())->setLastError(QSqlError());\n    ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n    if (!driver()) {\n      qWarning(\"XSqlQuery::prepare: no driver\");\n      return false;\n    }\n    if (!driver()->isOpen() || driver()->isOpenError()) {\n      qWarning(\"XSqlQuery::prepare: database not open\");\n      return false;\n    }\n    if (pSql.isEmpty()) {\n      qWarning(\"XSqlQuery::prepare: empty query\");\n      return false;\n    }\n#ifdef QT_DEBUG_SQL\n    qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n#endif\n    ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n  }\n  else\n    ret = QSqlQuery::prepare(pSql);\n  if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n    bindValue(\":firstnullfix\", QVariant());\n  return ret;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::prepare(const QString &pSql)\n  {\n    bool ret;\n    if(_data && _data->_emulatePrepare)\n    {\n  // In 4.4.1 Qt started supporting true prepared queries on the PostgreSQL driver and this\n  // caused several problems with all our code and the way it worked so this is a modified copy\n  // of their code to use the implemented prepare if we have that option set so we can use the method\n  // that works best in the case we are using it for.\n      ((XSqlResultHelper*)result())->setActive(false);\n      ((XSqlResultHelper*)result())->setLastError(QSqlError());\n      ((XSqlResultHelper*)result())->setAt(QSql::BeforeFirstRow);\n      if (!driver()) {\n        qWarning(\"XSqlQuery::prepare: no driver\");\n        return false;\n      }\n      if (!driver()->isOpen() || driver()->isOpenError()) {\n        qWarning(\"XSqlQuery::prepare: database not open\");\n        return false;\n      }\n      if (pSql.isEmpty()) {\n        qWarning(\"XSqlQuery::prepare: empty query\");\n        return false;\n      }\n  #ifdef QT_DEBUG_SQL\n      qDebug(\"\\n XSqlQuery::prepare: %s\", query.toLocal8Bit().constData());\n  #endif\n      ret = ((XSqlResultHelper*)result())->XSqlResultHelper::savePrepare(pSql);\n    }\n    else\n      ret = QSqlQuery::prepare(pSql);\n    if(ret && ((driver() && !driver()->hasFeature(QSqlDriver::PreparedQueries)) || (_data && _data->_emulatePrepare)))\n      bindValue(\":firstnullfix\", QVariant());\n    return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO msg_threading (mailbox, threading) VALUES  ( ?, ? )\")"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT threading FROM msg_threading WHERE mailbox = ?\")"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\")"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO parts ( mailbox, uid, part_id, data ) VALUES (?, ?, ?, ?)\")"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT data FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\")"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM parts WHERE mailbox = ? AND uid = ?\")"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM flags WHERE mailbox = ? AND uid = ?\")"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM msg_metadata WHERE mailbox = ? AND uid = ?\")"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM msg_threading WHERE mailbox = ?\")"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM parts WHERE mailbox = ?\")"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM flags WHERE mailbox = ?\")"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM msg_metadata WHERE mailbox = ?\")"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO flags ( mailbox, uid, flags ) VALUES ( ?, ?, ? )\")"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT flags FROM flags WHERE mailbox = ? AND uid = ?\")"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO msg_metadata ( mailbox, uid, data, lastAccessDate ) VALUES ( ?, ?, ?, ? )\")"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE msg_metadata SET lastAccessDate = ? WHERE mailbox = ? AND uid = ?\")"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT data, lastAccessDate FROM msg_metadata WHERE mailbox = ? AND uid = ?\")"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM uid_mapping WHERE mailbox = ?\")"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO uid_mapping (mailbox, mapping) VALUES  ( ?, ? )\")"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT mapping FROM uid_mapping WHERE mailbox = ?\")"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO mailbox_sync_state \"\n                                           \"( mailbox, sync_state ) \"\n                                           \"VALUES ( ?, ? )\")"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT sync_state FROM mailbox_sync_state WHERE mailbox = ?\")"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT OR REPLACE INTO child_mailboxes ( mailbox, parent, separator, flags ) VALUES (?, ?, ?, ?)\")"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DELETE FROM child_mailboxes WHERE parent = ?\")"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT mailbox FROM child_mailboxes WHERE parent = ? LIMIT 1\")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlQuery(",
          "args": [
            "b)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ool SQLCache::prepareQueries()\n  {\n      queryChildMailboxes = QSqlQuery(db);\n      if (! queryChildMailboxes.prepare(\"SELECT mailbox, separator, flags FROM child_mailboxes WHERE parent = ?\")) {\n          emitError(tr(\"Failed to prepare queryChildMailboxes\"), queryChildMailboxes);\n          return false;\n      }\n  \n      queryChildMailboxesFresh = QSqlQuery(db);\n      if (! queryChildMailboxesFresh.prepare(QLatin1String(\"SELECT mailbox FROM child_mailboxes WHERE parent = ? LIMIT 1\"))) {\n          emitError(tr(\"Failed to prepare queryChildMailboxesFresh\"), queryChildMailboxesFresh);\n          return false;\n      }\n  \n      queryRemoveChildMailboxes = QSqlQuery(db);\n      if (!queryRemoveChildMailboxes.prepare(QLatin1String(\"DELETE FROM child_mailboxes WHERE parent = ?\"))) {\n          emitError(tr(\"Failed to prepare queryRemoveChildMailboxes\"), queryRemoveChildMailboxes);\n          return false;\n      }\n  \n      querySetChildMailboxes = QSqlQuery(db);\n      if (! querySetChildMailboxes.prepare(QLatin1String(\"INSERT OR REPLACE INTO child_mailboxes ( mailbox, parent, separator, flags ) VALUES (?, ?, ?, ?)\"))) {\n          emitError(tr(\"Failed to prepare querySetChildMailboxes\"), querySetChildMailboxes);\n          return false;\n      }\n  \n      queryMailboxSyncState = QSqlQuery(db);\n      if (! queryMailboxSyncState.prepare(QLatin1String(\"SELECT sync_state FROM mailbox_sync_state WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMailboxSyncState\"), queryMailboxSyncState);\n          return false;\n      }\n  \n      querySetMailboxSyncState = QSqlQuery(db);\n      if (! querySetMailboxSyncState.prepare(QLatin1String(\"INSERT OR REPLACE INTO mailbox_sync_state \"\n                                             \"( mailbox, sync_state ) \"\n                                             \"VALUES ( ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMailboxSyncState\"), querySetMailboxSyncState);\n          return false;\n      }\n  \n      queryUidMapping = QSqlQuery(db);\n      if (! queryUidMapping.prepare(QLatin1String(\"SELECT mapping FROM uid_mapping WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryUidMapping\"), queryUidMapping);\n          return false;\n      }\n  \n      querySetUidMapping = QSqlQuery(db);\n      if (! querySetUidMapping.prepare(QLatin1String(\"INSERT OR REPLACE INTO uid_mapping (mailbox, mapping) VALUES  ( ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetUidMapping\"), querySetUidMapping);\n          return false;\n      }\n  \n      queryClearUidMapping = QSqlQuery(db);\n      if (! queryClearUidMapping.prepare(QLatin1String(\"DELETE FROM uid_mapping WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearUidMapping\"), queryClearUidMapping);\n          return false;\n      }\n  \n      queryMessageMetadata = QSqlQuery(db);\n      if (! queryMessageMetadata.prepare(QLatin1String(\"SELECT data, lastAccessDate FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessageMetadata\"), queryMessageMetadata);\n          return false;\n      }\n  \n      queryAccessMessageMetadata = QSqlQuery(db);\n      if (!queryAccessMessageMetadata.prepare(QLatin1String(\"UPDATE msg_metadata SET lastAccessDate = ? WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryAccssMessageMetadata\"), queryAccessMessageMetadata);\n          return false;\n      }\n  \n      querySetMessageMetadata = QSqlQuery(db);\n      if (! querySetMessageMetadata.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_metadata ( mailbox, uid, data, lastAccessDate ) VALUES ( ?, ?, ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMessageMetadata\"), querySetMessageMetadata);\n          return false;\n      }\n  \n      queryMessageFlags = QSqlQuery(db);\n      if (! queryMessageFlags.prepare(QLatin1String(\"SELECT flags FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessageFlags\"), queryMessageFlags);\n          return false;\n      }\n  \n      querySetMessageFlags = QSqlQuery(db);\n      if (! querySetMessageFlags.prepare(QLatin1String(\"INSERT OR REPLACE INTO flags ( mailbox, uid, flags ) VALUES ( ?, ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMessageFlags\"), querySetMessageFlags);\n          return false;\n      }\n  \n      queryClearAllMessages1 = QSqlQuery(db);\n      if (! queryClearAllMessages1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages1\"), queryClearAllMessages1);\n          return false;\n      }\n  \n      queryClearAllMessages2 = QSqlQuery(db);\n      if (! queryClearAllMessages2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages2\"), queryClearAllMessages2);\n          return false;\n      }\n  \n      queryClearAllMessages3 = QSqlQuery(db);\n      if (! queryClearAllMessages3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages3\"), queryClearAllMessages3);\n          return false;\n      }\n  \n      queryClearAllMessages4 = QSqlQuery(db);\n      if (! queryClearAllMessages4.prepare(QLatin1String(\"DELETE FROM msg_threading WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages4\"), queryClearAllMessages4);\n          return false;\n      }\n  \n      queryClearMessage1 = QSqlQuery(db);\n      if (! queryClearMessage1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearMessage1\"), queryClearMessage1);\n          return false;\n      }\n  \n      queryClearMessage2 = QSqlQuery(db);\n      if (! queryClearMessage2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearMessage2\"), queryClearMessage2);\n          return false;\n      }\n  \n      queryClearMessage3 = QSqlQuery(db);\n      if (! queryClearMessage3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearMessage3\"), queryClearMessage3);\n          return false;\n      }\n  \n      queryMessagePart = QSqlQuery(db);\n      if (! queryMessagePart.prepare(QLatin1String(\"SELECT data FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessagePart\"), queryMessagePart);\n          return false;\n      }\n  \n      querySetMessagePart = QSqlQuery(db);\n      if (! querySetMessagePart.prepare(QLatin1String(\"INSERT OR REPLACE INTO parts ( mailbox, uid, part_id, data ) VALUES (?, ?, ?, ?)\"))) {\n          emitError(tr(\"Failed to prepare querySetMessagePart\"), querySetMessagePart);\n          return false;\n      }\n  \n      queryForgetMessagePart = QSqlQuery(db);\n      if (! queryForgetMessagePart.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n          emitError(tr(\"Failed to prepare queryForgetMessagePart\"), queryForgetMessagePart);\n          return false;\n      }\n  \n      queryMessageThreading = QSqlQuery(db);\n      if (! queryMessageThreading.prepare(QLatin1String(\"SELECT threading FROM msg_threading WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessageThreading\"), queryMessageThreading);\n          return false;\n      }\n  \n      querySetMessageThreading = QSqlQuery(db);\n      if (! querySetMessageThreading.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_threading (mailbox, threading) VALUES  ( ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMessageThreading\"), querySetMessageThreading);\n          return false;\n      }\n  \n  #ifdef CACHE_DEBUG\n      qDebug() << \"SQLCache::_prepareQueries() succeeded\";\n  #endif\n      return true;\n  }\n}"
  },
  {
    "function_name": "createTables(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "227-284",
    "snippet": "ool SQLCache::createTables()\n{\n    QSqlQuery q(QString(), db);\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE trojita ( version STRING NOT NULL )\"))) {\n        emitError(tr(\"Failed to prepare table structures\"), q);\n        return false;\n    }\n    if (! q.exec(QLatin1String(\"INSERT INTO trojita ( version ) VALUES ( 6 )\"))) {\n        emitError(tr(\"Can't store version info\"), q);\n        return false;\n    }\n    if (! q.exec(QLatin1String(\n                     \"CREATE TABLE child_mailboxes ( \"\n                     \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                     \"parent STRING NOT NULL, \"\n                     \"separator STRING, \"\n                     \"flags BINARY\"\n                     \")\"\n                 ))) {\n        emitError(tr(\"Can't create table child_mailboxes\"));\n        return false;\n    }\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE uid_mapping ( \"\n                               \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                               \"mapping BINARY\"\n                               \" )\"))) {\n        emitError(tr(\"Can't create table uid_mapping\"), q);\n        return false;\n    }\n\n    TROJITA_SQL_CACHE_CREATE_MSG_METADATA;\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE flags (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"flags BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid)\"\n                               \")\"))) {\n        emitError(tr(\"Can't create table flags\"), q);\n    }\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE parts (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"part_id BINARY, \"\n                               \"data BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid, part_id)\"\n                               \")\"))) {\n        emitError(tr(\"Can't create table parts\"), q);\n    }\n\n    TROJITA_SQL_CACHE_CREATE_THREADING;\n    TROJITA_SQL_CACHE_CREATE_SYNC_STATE;\n\n    return true;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Can't create table parts\"),",
            ")"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "457-460",
          "snippet": "oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n{\n    emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message, const QSqlDatabase &database) const\n  {\n      emitError(QString::fromUtf8(\"SQLCache: DB Error: %1: %2\").arg(message, database.lastError().text()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".exec",
          "args": [
            "Latin1String(\"CREATE TABLE parts (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"part_id BINARY, \"\n                               \"data BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid, part_id)\"\n                               \")\"))"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "244-255",
          "snippet": "bool XSqlQuery::exec(const QString &pSql)\n{\n  bool returnValue = QSqlQuery::exec(pSql);\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec(const QString &pSql)\n  {\n    bool returnValue = QSqlQuery::exec(pSql);\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CREATE TABLE parts (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"part_id BINARY, \"\n                               \"data BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid, part_id)\"\n                               \")\")"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CREATE TABLE flags (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"flags BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid)\"\n                               \")\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CREATE TABLE uid_mapping ( \"\n                               \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                               \"mapping BINARY\"\n                               \" )\")"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CREATE TABLE child_mailboxes ( \"\n                     \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                     \"parent STRING NOT NULL, \"\n                     \"separator STRING, \"\n                     \"flags BINARY\"\n                     \")\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "INSERT INTO trojita ( version ) VALUES ( 6 )\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CREATE TABLE trojita ( version STRING NOT NULL )\")"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ool SQLCache::createTables()\n  {\n      QSqlQuery q(QString(), db);\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE trojita ( version STRING NOT NULL )\"))) {\n          emitError(tr(\"Failed to prepare table structures\"), q);\n          return false;\n      }\n      if (! q.exec(QLatin1String(\"INSERT INTO trojita ( version ) VALUES ( 6 )\"))) {\n          emitError(tr(\"Can't store version info\"), q);\n          return false;\n      }\n      if (! q.exec(QLatin1String(\n                       \"CREATE TABLE child_mailboxes ( \"\n                       \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                       \"parent STRING NOT NULL, \"\n                       \"separator STRING, \"\n                       \"flags BINARY\"\n                       \")\"\n                   ))) {\n          emitError(tr(\"Can't create table child_mailboxes\"));\n          return false;\n      }\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE uid_mapping ( \"\n                                 \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                                 \"mapping BINARY\"\n                                 \" )\"))) {\n          emitError(tr(\"Can't create table uid_mapping\"), q);\n          return false;\n      }\n  \n      TROJITA_SQL_CACHE_CREATE_MSG_METADATA;\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE flags (\"\n                                 \"mailbox STRING NOT NULL, \"\n                                 \"uid INT NOT NULL, \"\n                                 \"flags BINARY, \"\n                                 \"PRIMARY KEY (mailbox, uid)\"\n                                 \")\"))) {\n          emitError(tr(\"Can't create table flags\"), q);\n      }\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE parts (\"\n                                 \"mailbox STRING NOT NULL, \"\n                                 \"uid INT NOT NULL, \"\n                                 \"part_id BINARY, \"\n                                 \"data BINARY, \"\n                                 \"PRIMARY KEY (mailbox, uid, part_id)\"\n                                 \")\"))) {\n          emitError(tr(\"Can't create table parts\"), q);\n      }\n  \n      TROJITA_SQL_CACHE_CREATE_THREADING;\n      TROJITA_SQL_CACHE_CREATE_SYNC_STATE;\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "open(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "132-225",
    "snippet": "ool SQLCache::open(const QString &name, const QString &fileName)\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"SQLCache::open()\";\n#endif\n    db = QSqlDatabase::addDatabase(QLatin1String(\"QSQLITE\"), name);\n    db.setDatabaseName(fileName);\n\n    bool ok = db.open();\n    if (! ok) {\n        emitError(tr(\"Can't open database\"), db);\n        return false;\n    }\n\n    Common::SqlTransactionAutoAborter txn(&db);\n\n    QSqlRecord trojitaNames = db.record(QLatin1String(\"trojita\"));\n    if (! trojitaNames.contains(QLatin1String(\"version\"))) {\n        if (! createTables())\n            return false;\n    }\n\n    QSqlQuery q(QString(), db);\n\n    if (! q.exec(QLatin1String(\"SELECT version FROM trojita\"))) {\n        emitError(tr(\"Failed to verify version\"), q);\n        return false;\n    }\n\n    if (! q.first()) {\n        // we could probably relax this...\n        emitError(tr(\"Can't determine version info\"), q);\n        return false;\n    }\n\n    uint version = q.value(0).toUInt();\n    if (version == 1) {\n        TROJITA_SQL_CACHE_CREATE_THREADING\n        version = 2;\n        if (! q.exec(QLatin1String(\"UPDATE trojita SET version = 2;\"))) {\n            emitError(tr(\"Failed to update cache DB scheme from v1 to v2\"), q);\n            return false;\n        }\n    }\n\n    if (version == 2 || version == 3) {\n        // There's no difference in table layout between v3 and v4, but the mailbox_sync_state has changed due to the new\n        // HIGHESTMODSEQ in Mailbox::SyncState, which is why we throw away the old data unconditionally\n        if (!q.exec(QLatin1String(\"DROP TABLE mailbox_sync_state;\"))) {\n            emitError(tr(\"Failed to drop old table mailbox_sync_state\"));\n            return false;\n        }\n        TROJITA_SQL_CACHE_CREATE_SYNC_STATE;\n        version = 4;\n        if (! q.exec(QLatin1String(\"UPDATE trojita SET version = 4;\"))) {\n            emitError(tr(\"Failed to update cache DB scheme from v2/v3 to v4\"), q);\n            return false;\n        }\n    }\n\n    if (version == 4 || version == 5) {\n        // No difference in table structure between v4 and v5, but the data stored in msg_metadata is different; the UID\n        // got removed and INTERNALDATE was added.\n        // V6 has added the References and List-Post headers (i.e. a change in the structure of the blobs stored in the DB,\n        // but transparent on the SQL level), and also changed the DB structure by adding a date specifying how recently\n        // a given message was accessed (which was needed for cache lifetime management).\n        if (!q.exec(QLatin1String(\"DROP TABLE msg_metadata;\"))) {\n            emitError(tr(\"Failed to drop old table msg_metadata\"));\n            return false;\n        }\n        TROJITA_SQL_CACHE_CREATE_MSG_METADATA;\n        version = 6;\n        if (! q.exec(QLatin1String(\"UPDATE trojita SET version = 6;\"))) {\n            emitError(tr(\"Failed to update cache DB scheme from v4/v5 to v6\"), q);\n            return false;\n        }\n    }\n\n    if (version != 6) {\n        emitError(tr(\"Unknown version\"));\n        return false;\n    }\n\n    txn.commit();\n\n    if (! prepareQueries()) {\n        return false;\n    }\n    init();\n#ifdef CACHE_DEBUG\n    qDebug() << \"SQLCache::open() succeeded\";\n#endif\n    return true;\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit(",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "init(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "67-93",
          "snippet": "oid SQLCache::init()\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"SQLCache::init()\";\n#endif\n    if (delayedCommit)\n        delayedCommit->deleteLater();\n    Q_ASSERT(parent());\n    bool ok;\n    int num;\n    delayedCommit = new QTimer(this);\n    num = parent()->property(\"trojita-sqlcache-commit-delay\").toInt(&ok);\n    if (! ok)\n        num = 10000;\n    delayedCommit->setInterval(num);\n    delayedCommit->setObjectName(QString::fromUtf8(\"delayedCommit-%1\").arg(objectName()));\n    connect(delayedCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n    if (tooMuchTimeWithoutCommit)\n        tooMuchTimeWithoutCommit->deleteLater();\n    tooMuchTimeWithoutCommit = new QTimer(this);\n    num = parent()->property(\"trojita-sqlcache-commit-period\").toInt(&ok);\n    if (! ok)\n        num = 60000;\n    tooMuchTimeWithoutCommit->setInterval(num);\n    tooMuchTimeWithoutCommit->setObjectName(QString::fromUtf8(\"tooMuchTimeWithoutCommit-%1\").arg(objectName()));\n    connect(tooMuchTimeWithoutCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::init()\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"SQLCache::init()\";\n  #endif\n      if (delayedCommit)\n          delayedCommit->deleteLater();\n      Q_ASSERT(parent());\n      bool ok;\n      int num;\n      delayedCommit = new QTimer(this);\n      num = parent()->property(\"trojita-sqlcache-commit-delay\").toInt(&ok);\n      if (! ok)\n          num = 10000;\n      delayedCommit->setInterval(num);\n      delayedCommit->setObjectName(QString::fromUtf8(\"delayedCommit-%1\").arg(objectName()));\n      connect(delayedCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n      if (tooMuchTimeWithoutCommit)\n          tooMuchTimeWithoutCommit->deleteLater();\n      tooMuchTimeWithoutCommit = new QTimer(this);\n      num = parent()->property(\"trojita-sqlcache-commit-period\").toInt(&ok);\n      if (! ok)\n          num = 60000;\n      tooMuchTimeWithoutCommit->setInterval(num);\n      tooMuchTimeWithoutCommit->setObjectName(QString::fromUtf8(\"tooMuchTimeWithoutCommit-%1\").arg(objectName()));\n      connect(tooMuchTimeWithoutCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "repareQueries(",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "prepareQueries(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "286-450",
          "snippet": "ool SQLCache::prepareQueries()\n{\n    queryChildMailboxes = QSqlQuery(db);\n    if (! queryChildMailboxes.prepare(\"SELECT mailbox, separator, flags FROM child_mailboxes WHERE parent = ?\")) {\n        emitError(tr(\"Failed to prepare queryChildMailboxes\"), queryChildMailboxes);\n        return false;\n    }\n\n    queryChildMailboxesFresh = QSqlQuery(db);\n    if (! queryChildMailboxesFresh.prepare(QLatin1String(\"SELECT mailbox FROM child_mailboxes WHERE parent = ? LIMIT 1\"))) {\n        emitError(tr(\"Failed to prepare queryChildMailboxesFresh\"), queryChildMailboxesFresh);\n        return false;\n    }\n\n    queryRemoveChildMailboxes = QSqlQuery(db);\n    if (!queryRemoveChildMailboxes.prepare(QLatin1String(\"DELETE FROM child_mailboxes WHERE parent = ?\"))) {\n        emitError(tr(\"Failed to prepare queryRemoveChildMailboxes\"), queryRemoveChildMailboxes);\n        return false;\n    }\n\n    querySetChildMailboxes = QSqlQuery(db);\n    if (! querySetChildMailboxes.prepare(QLatin1String(\"INSERT OR REPLACE INTO child_mailboxes ( mailbox, parent, separator, flags ) VALUES (?, ?, ?, ?)\"))) {\n        emitError(tr(\"Failed to prepare querySetChildMailboxes\"), querySetChildMailboxes);\n        return false;\n    }\n\n    queryMailboxSyncState = QSqlQuery(db);\n    if (! queryMailboxSyncState.prepare(QLatin1String(\"SELECT sync_state FROM mailbox_sync_state WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMailboxSyncState\"), queryMailboxSyncState);\n        return false;\n    }\n\n    querySetMailboxSyncState = QSqlQuery(db);\n    if (! querySetMailboxSyncState.prepare(QLatin1String(\"INSERT OR REPLACE INTO mailbox_sync_state \"\n                                           \"( mailbox, sync_state ) \"\n                                           \"VALUES ( ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMailboxSyncState\"), querySetMailboxSyncState);\n        return false;\n    }\n\n    queryUidMapping = QSqlQuery(db);\n    if (! queryUidMapping.prepare(QLatin1String(\"SELECT mapping FROM uid_mapping WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryUidMapping\"), queryUidMapping);\n        return false;\n    }\n\n    querySetUidMapping = QSqlQuery(db);\n    if (! querySetUidMapping.prepare(QLatin1String(\"INSERT OR REPLACE INTO uid_mapping (mailbox, mapping) VALUES  ( ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetUidMapping\"), querySetUidMapping);\n        return false;\n    }\n\n    queryClearUidMapping = QSqlQuery(db);\n    if (! queryClearUidMapping.prepare(QLatin1String(\"DELETE FROM uid_mapping WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearUidMapping\"), queryClearUidMapping);\n        return false;\n    }\n\n    queryMessageMetadata = QSqlQuery(db);\n    if (! queryMessageMetadata.prepare(QLatin1String(\"SELECT data, lastAccessDate FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessageMetadata\"), queryMessageMetadata);\n        return false;\n    }\n\n    queryAccessMessageMetadata = QSqlQuery(db);\n    if (!queryAccessMessageMetadata.prepare(QLatin1String(\"UPDATE msg_metadata SET lastAccessDate = ? WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryAccssMessageMetadata\"), queryAccessMessageMetadata);\n        return false;\n    }\n\n    querySetMessageMetadata = QSqlQuery(db);\n    if (! querySetMessageMetadata.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_metadata ( mailbox, uid, data, lastAccessDate ) VALUES ( ?, ?, ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMessageMetadata\"), querySetMessageMetadata);\n        return false;\n    }\n\n    queryMessageFlags = QSqlQuery(db);\n    if (! queryMessageFlags.prepare(QLatin1String(\"SELECT flags FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessageFlags\"), queryMessageFlags);\n        return false;\n    }\n\n    querySetMessageFlags = QSqlQuery(db);\n    if (! querySetMessageFlags.prepare(QLatin1String(\"INSERT OR REPLACE INTO flags ( mailbox, uid, flags ) VALUES ( ?, ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMessageFlags\"), querySetMessageFlags);\n        return false;\n    }\n\n    queryClearAllMessages1 = QSqlQuery(db);\n    if (! queryClearAllMessages1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages1\"), queryClearAllMessages1);\n        return false;\n    }\n\n    queryClearAllMessages2 = QSqlQuery(db);\n    if (! queryClearAllMessages2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages2\"), queryClearAllMessages2);\n        return false;\n    }\n\n    queryClearAllMessages3 = QSqlQuery(db);\n    if (! queryClearAllMessages3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages3\"), queryClearAllMessages3);\n        return false;\n    }\n\n    queryClearAllMessages4 = QSqlQuery(db);\n    if (! queryClearAllMessages4.prepare(QLatin1String(\"DELETE FROM msg_threading WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearAllMessages4\"), queryClearAllMessages4);\n        return false;\n    }\n\n    queryClearMessage1 = QSqlQuery(db);\n    if (! queryClearMessage1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearMessage1\"), queryClearMessage1);\n        return false;\n    }\n\n    queryClearMessage2 = QSqlQuery(db);\n    if (! queryClearMessage2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearMessage2\"), queryClearMessage2);\n        return false;\n    }\n\n    queryClearMessage3 = QSqlQuery(db);\n    if (! queryClearMessage3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ?\"))) {\n        emitError(tr(\"Failed to prepare queryClearMessage3\"), queryClearMessage3);\n        return false;\n    }\n\n    queryMessagePart = QSqlQuery(db);\n    if (! queryMessagePart.prepare(QLatin1String(\"SELECT data FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessagePart\"), queryMessagePart);\n        return false;\n    }\n\n    querySetMessagePart = QSqlQuery(db);\n    if (! querySetMessagePart.prepare(QLatin1String(\"INSERT OR REPLACE INTO parts ( mailbox, uid, part_id, data ) VALUES (?, ?, ?, ?)\"))) {\n        emitError(tr(\"Failed to prepare querySetMessagePart\"), querySetMessagePart);\n        return false;\n    }\n\n    queryForgetMessagePart = QSqlQuery(db);\n    if (! queryForgetMessagePart.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n        emitError(tr(\"Failed to prepare queryForgetMessagePart\"), queryForgetMessagePart);\n        return false;\n    }\n\n    queryMessageThreading = QSqlQuery(db);\n    if (! queryMessageThreading.prepare(QLatin1String(\"SELECT threading FROM msg_threading WHERE mailbox = ?\"))) {\n        emitError(tr(\"Failed to prepare queryMessageThreading\"), queryMessageThreading);\n        return false;\n    }\n\n    querySetMessageThreading = QSqlQuery(db);\n    if (! querySetMessageThreading.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_threading (mailbox, threading) VALUES  ( ?, ? )\"))) {\n        emitError(tr(\"Failed to prepare querySetMessageThreading\"), querySetMessageThreading);\n        return false;\n    }\n\n#ifdef CACHE_DEBUG\n    qDebug() << \"SQLCache::_prepareQueries() succeeded\";\n#endif\n    return true;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ool SQLCache::prepareQueries()\n  {\n      queryChildMailboxes = QSqlQuery(db);\n      if (! queryChildMailboxes.prepare(\"SELECT mailbox, separator, flags FROM child_mailboxes WHERE parent = ?\")) {\n          emitError(tr(\"Failed to prepare queryChildMailboxes\"), queryChildMailboxes);\n          return false;\n      }\n  \n      queryChildMailboxesFresh = QSqlQuery(db);\n      if (! queryChildMailboxesFresh.prepare(QLatin1String(\"SELECT mailbox FROM child_mailboxes WHERE parent = ? LIMIT 1\"))) {\n          emitError(tr(\"Failed to prepare queryChildMailboxesFresh\"), queryChildMailboxesFresh);\n          return false;\n      }\n  \n      queryRemoveChildMailboxes = QSqlQuery(db);\n      if (!queryRemoveChildMailboxes.prepare(QLatin1String(\"DELETE FROM child_mailboxes WHERE parent = ?\"))) {\n          emitError(tr(\"Failed to prepare queryRemoveChildMailboxes\"), queryRemoveChildMailboxes);\n          return false;\n      }\n  \n      querySetChildMailboxes = QSqlQuery(db);\n      if (! querySetChildMailboxes.prepare(QLatin1String(\"INSERT OR REPLACE INTO child_mailboxes ( mailbox, parent, separator, flags ) VALUES (?, ?, ?, ?)\"))) {\n          emitError(tr(\"Failed to prepare querySetChildMailboxes\"), querySetChildMailboxes);\n          return false;\n      }\n  \n      queryMailboxSyncState = QSqlQuery(db);\n      if (! queryMailboxSyncState.prepare(QLatin1String(\"SELECT sync_state FROM mailbox_sync_state WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMailboxSyncState\"), queryMailboxSyncState);\n          return false;\n      }\n  \n      querySetMailboxSyncState = QSqlQuery(db);\n      if (! querySetMailboxSyncState.prepare(QLatin1String(\"INSERT OR REPLACE INTO mailbox_sync_state \"\n                                             \"( mailbox, sync_state ) \"\n                                             \"VALUES ( ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMailboxSyncState\"), querySetMailboxSyncState);\n          return false;\n      }\n  \n      queryUidMapping = QSqlQuery(db);\n      if (! queryUidMapping.prepare(QLatin1String(\"SELECT mapping FROM uid_mapping WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryUidMapping\"), queryUidMapping);\n          return false;\n      }\n  \n      querySetUidMapping = QSqlQuery(db);\n      if (! querySetUidMapping.prepare(QLatin1String(\"INSERT OR REPLACE INTO uid_mapping (mailbox, mapping) VALUES  ( ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetUidMapping\"), querySetUidMapping);\n          return false;\n      }\n  \n      queryClearUidMapping = QSqlQuery(db);\n      if (! queryClearUidMapping.prepare(QLatin1String(\"DELETE FROM uid_mapping WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearUidMapping\"), queryClearUidMapping);\n          return false;\n      }\n  \n      queryMessageMetadata = QSqlQuery(db);\n      if (! queryMessageMetadata.prepare(QLatin1String(\"SELECT data, lastAccessDate FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessageMetadata\"), queryMessageMetadata);\n          return false;\n      }\n  \n      queryAccessMessageMetadata = QSqlQuery(db);\n      if (!queryAccessMessageMetadata.prepare(QLatin1String(\"UPDATE msg_metadata SET lastAccessDate = ? WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryAccssMessageMetadata\"), queryAccessMessageMetadata);\n          return false;\n      }\n  \n      querySetMessageMetadata = QSqlQuery(db);\n      if (! querySetMessageMetadata.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_metadata ( mailbox, uid, data, lastAccessDate ) VALUES ( ?, ?, ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMessageMetadata\"), querySetMessageMetadata);\n          return false;\n      }\n  \n      queryMessageFlags = QSqlQuery(db);\n      if (! queryMessageFlags.prepare(QLatin1String(\"SELECT flags FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessageFlags\"), queryMessageFlags);\n          return false;\n      }\n  \n      querySetMessageFlags = QSqlQuery(db);\n      if (! querySetMessageFlags.prepare(QLatin1String(\"INSERT OR REPLACE INTO flags ( mailbox, uid, flags ) VALUES ( ?, ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMessageFlags\"), querySetMessageFlags);\n          return false;\n      }\n  \n      queryClearAllMessages1 = QSqlQuery(db);\n      if (! queryClearAllMessages1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages1\"), queryClearAllMessages1);\n          return false;\n      }\n  \n      queryClearAllMessages2 = QSqlQuery(db);\n      if (! queryClearAllMessages2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages2\"), queryClearAllMessages2);\n          return false;\n      }\n  \n      queryClearAllMessages3 = QSqlQuery(db);\n      if (! queryClearAllMessages3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages3\"), queryClearAllMessages3);\n          return false;\n      }\n  \n      queryClearAllMessages4 = QSqlQuery(db);\n      if (! queryClearAllMessages4.prepare(QLatin1String(\"DELETE FROM msg_threading WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearAllMessages4\"), queryClearAllMessages4);\n          return false;\n      }\n  \n      queryClearMessage1 = QSqlQuery(db);\n      if (! queryClearMessage1.prepare(QLatin1String(\"DELETE FROM msg_metadata WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearMessage1\"), queryClearMessage1);\n          return false;\n      }\n  \n      queryClearMessage2 = QSqlQuery(db);\n      if (! queryClearMessage2.prepare(QLatin1String(\"DELETE FROM flags WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearMessage2\"), queryClearMessage2);\n          return false;\n      }\n  \n      queryClearMessage3 = QSqlQuery(db);\n      if (! queryClearMessage3.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ?\"))) {\n          emitError(tr(\"Failed to prepare queryClearMessage3\"), queryClearMessage3);\n          return false;\n      }\n  \n      queryMessagePart = QSqlQuery(db);\n      if (! queryMessagePart.prepare(QLatin1String(\"SELECT data FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessagePart\"), queryMessagePart);\n          return false;\n      }\n  \n      querySetMessagePart = QSqlQuery(db);\n      if (! querySetMessagePart.prepare(QLatin1String(\"INSERT OR REPLACE INTO parts ( mailbox, uid, part_id, data ) VALUES (?, ?, ?, ?)\"))) {\n          emitError(tr(\"Failed to prepare querySetMessagePart\"), querySetMessagePart);\n          return false;\n      }\n  \n      queryForgetMessagePart = QSqlQuery(db);\n      if (! queryForgetMessagePart.prepare(QLatin1String(\"DELETE FROM parts WHERE mailbox = ? AND uid = ? AND part_id = ?\"))) {\n          emitError(tr(\"Failed to prepare queryForgetMessagePart\"), queryForgetMessagePart);\n          return false;\n      }\n  \n      queryMessageThreading = QSqlQuery(db);\n      if (! queryMessageThreading.prepare(QLatin1String(\"SELECT threading FROM msg_threading WHERE mailbox = ?\"))) {\n          emitError(tr(\"Failed to prepare queryMessageThreading\"), queryMessageThreading);\n          return false;\n      }\n  \n      querySetMessageThreading = QSqlQuery(db);\n      if (! querySetMessageThreading.prepare(QLatin1String(\"INSERT OR REPLACE INTO msg_threading (mailbox, threading) VALUES  ( ?, ? )\"))) {\n          emitError(tr(\"Failed to prepare querySetMessageThreading\"), querySetMessageThreading);\n          return false;\n      }\n  \n  #ifdef CACHE_DEBUG\n      qDebug() << \"SQLCache::_prepareQueries() succeeded\";\n  #endif\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xn.commit",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [
            "r(\"Unknown version\"))"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "462-466",
          "snippet": "oid SQLCache::emitError(const QString &message) const\n{\n    qDebug() << message;\n    emit error(message);\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::emitError(const QString &message) const\n  {\n      qDebug() << message;\n      emit error(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".exec",
          "args": [
            "Latin1String(\"UPDATE trojita SET version = 6;\"))"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "exec",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "244-255",
          "snippet": "bool XSqlQuery::exec(const QString &pSql)\n{\n  bool returnValue = QSqlQuery::exec(pSql);\n\n  if (_data)\n    _data->_currRecord = record();\n\n  if(false == returnValue)\n    notifyErrorListeners(this);\n\n  return returnValue;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::exec(const QString &pSql)\n  {\n    bool returnValue = QSqlQuery::exec(pSql);\n  \n    if (_data)\n      _data->_currRecord = record();\n  \n    if(false == returnValue)\n      notifyErrorListeners(this);\n  \n    return returnValue;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE trojita SET version = 6;\")"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DROP TABLE msg_metadata;\")"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE trojita SET version = 4;\")"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "DROP TABLE mailbox_sync_state;\")"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE trojita SET version = 2;\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".value",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".value",
          "args": [
            ")"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".first",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT version FROM trojita\")"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reateTables(",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "createTables(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "227-284",
          "snippet": "ool SQLCache::createTables()\n{\n    QSqlQuery q(QString(), db);\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE trojita ( version STRING NOT NULL )\"))) {\n        emitError(tr(\"Failed to prepare table structures\"), q);\n        return false;\n    }\n    if (! q.exec(QLatin1String(\"INSERT INTO trojita ( version ) VALUES ( 6 )\"))) {\n        emitError(tr(\"Can't store version info\"), q);\n        return false;\n    }\n    if (! q.exec(QLatin1String(\n                     \"CREATE TABLE child_mailboxes ( \"\n                     \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                     \"parent STRING NOT NULL, \"\n                     \"separator STRING, \"\n                     \"flags BINARY\"\n                     \")\"\n                 ))) {\n        emitError(tr(\"Can't create table child_mailboxes\"));\n        return false;\n    }\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE uid_mapping ( \"\n                               \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                               \"mapping BINARY\"\n                               \" )\"))) {\n        emitError(tr(\"Can't create table uid_mapping\"), q);\n        return false;\n    }\n\n    TROJITA_SQL_CACHE_CREATE_MSG_METADATA;\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE flags (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"flags BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid)\"\n                               \")\"))) {\n        emitError(tr(\"Can't create table flags\"), q);\n    }\n\n    if (! q.exec(QLatin1String(\"CREATE TABLE parts (\"\n                               \"mailbox STRING NOT NULL, \"\n                               \"uid INT NOT NULL, \"\n                               \"part_id BINARY, \"\n                               \"data BINARY, \"\n                               \"PRIMARY KEY (mailbox, uid, part_id)\"\n                               \")\"))) {\n        emitError(tr(\"Can't create table parts\"), q);\n    }\n\n    TROJITA_SQL_CACHE_CREATE_THREADING;\n    TROJITA_SQL_CACHE_CREATE_SYNC_STATE;\n\n    return true;\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ool SQLCache::createTables()\n  {\n      QSqlQuery q(QString(), db);\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE trojita ( version STRING NOT NULL )\"))) {\n          emitError(tr(\"Failed to prepare table structures\"), q);\n          return false;\n      }\n      if (! q.exec(QLatin1String(\"INSERT INTO trojita ( version ) VALUES ( 6 )\"))) {\n          emitError(tr(\"Can't store version info\"), q);\n          return false;\n      }\n      if (! q.exec(QLatin1String(\n                       \"CREATE TABLE child_mailboxes ( \"\n                       \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                       \"parent STRING NOT NULL, \"\n                       \"separator STRING, \"\n                       \"flags BINARY\"\n                       \")\"\n                   ))) {\n          emitError(tr(\"Can't create table child_mailboxes\"));\n          return false;\n      }\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE uid_mapping ( \"\n                                 \"mailbox STRING NOT NULL PRIMARY KEY, \"\n                                 \"mapping BINARY\"\n                                 \" )\"))) {\n          emitError(tr(\"Can't create table uid_mapping\"), q);\n          return false;\n      }\n  \n      TROJITA_SQL_CACHE_CREATE_MSG_METADATA;\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE flags (\"\n                                 \"mailbox STRING NOT NULL, \"\n                                 \"uid INT NOT NULL, \"\n                                 \"flags BINARY, \"\n                                 \"PRIMARY KEY (mailbox, uid)\"\n                                 \")\"))) {\n          emitError(tr(\"Can't create table flags\"), q);\n      }\n  \n      if (! q.exec(QLatin1String(\"CREATE TABLE parts (\"\n                                 \"mailbox STRING NOT NULL, \"\n                                 \"uid INT NOT NULL, \"\n                                 \"part_id BINARY, \"\n                                 \"data BINARY, \"\n                                 \"PRIMARY KEY (mailbox, uid, part_id)\"\n                                 \")\"))) {\n          emitError(tr(\"Can't create table parts\"), q);\n      }\n  \n      TROJITA_SQL_CACHE_CREATE_THREADING;\n      TROJITA_SQL_CACHE_CREATE_SYNC_STATE;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rojitaNames.contains",
          "args": [
            "Latin1String(\"version\"))"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "version\")"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.record",
          "args": [
            "Latin1String(\"trojita\"))"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "trojita\")"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.open",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.setDatabaseName",
          "args": [
            "ileName)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SqlDatabase::addDatabase(",
          "args": [
            "Latin1String(\"QSQLITE\"),",
            "ame)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "QSQLITE\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  ool SQLCache::open(const QString &name, const QString &fileName)\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"SQLCache::open()\";\n  #endif\n      db = QSqlDatabase::addDatabase(QLatin1String(\"QSQLITE\"), name);\n      db.setDatabaseName(fileName);\n  \n      bool ok = db.open();\n      if (! ok) {\n          emitError(tr(\"Can't open database\"), db);\n          return false;\n      }\n  \n      Common::SqlTransactionAutoAborter txn(&db);\n  \n      QSqlRecord trojitaNames = db.record(QLatin1String(\"trojita\"));\n      if (! trojitaNames.contains(QLatin1String(\"version\"))) {\n          if (! createTables())\n              return false;\n      }\n  \n      QSqlQuery q(QString(), db);\n  \n      if (! q.exec(QLatin1String(\"SELECT version FROM trojita\"))) {\n          emitError(tr(\"Failed to verify version\"), q);\n          return false;\n      }\n  \n      if (! q.first()) {\n          // we could probably relax this...\n          emitError(tr(\"Can't determine version info\"), q);\n          return false;\n      }\n  \n      uint version = q.value(0).toUInt();\n      if (version == 1) {\n          TROJITA_SQL_CACHE_CREATE_THREADING\n          version = 2;\n          if (! q.exec(QLatin1String(\"UPDATE trojita SET version = 2;\"))) {\n              emitError(tr(\"Failed to update cache DB scheme from v1 to v2\"), q);\n              return false;\n          }\n      }\n  \n      if (version == 2 || version == 3) {\n          // There's no difference in table layout between v3 and v4, but the mailbox_sync_state has changed due to the new\n          // HIGHESTMODSEQ in Mailbox::SyncState, which is why we throw away the old data unconditionally\n          if (!q.exec(QLatin1String(\"DROP TABLE mailbox_sync_state;\"))) {\n              emitError(tr(\"Failed to drop old table mailbox_sync_state\"));\n              return false;\n          }\n          TROJITA_SQL_CACHE_CREATE_SYNC_STATE;\n          version = 4;\n          if (! q.exec(QLatin1String(\"UPDATE trojita SET version = 4;\"))) {\n              emitError(tr(\"Failed to update cache DB scheme from v2/v3 to v4\"), q);\n              return false;\n          }\n      }\n  \n      if (version == 4 || version == 5) {\n          // No difference in table structure between v4 and v5, but the data stored in msg_metadata is different; the UID\n          // got removed and INTERNALDATE was added.\n          // V6 has added the References and List-Post headers (i.e. a change in the structure of the blobs stored in the DB,\n          // but transparent on the SQL level), and also changed the DB structure by adding a date specifying how recently\n          // a given message was accessed (which was needed for cache lifetime management).\n          if (!q.exec(QLatin1String(\"DROP TABLE msg_metadata;\"))) {\n              emitError(tr(\"Failed to drop old table msg_metadata\"));\n              return false;\n          }\n          TROJITA_SQL_CACHE_CREATE_MSG_METADATA;\n          version = 6;\n          if (! q.exec(QLatin1String(\"UPDATE trojita SET version = 6;\"))) {\n              emitError(tr(\"Failed to update cache DB scheme from v4/v5 to v6\"), q);\n              return false;\n          }\n      }\n  \n      if (version != 6) {\n          emitError(tr(\"Unknown version\"));\n          return false;\n      }\n  \n      txn.commit();\n  \n      if (! prepareQueries()) {\n          return false;\n      }\n      init();\n  #ifdef CACHE_DEBUG\n      qDebug() << \"SQLCache::open() succeeded\";\n  #endif\n      return true;\n  }\n}"
  },
  {
    "function_name": "~SQLCache(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "95-100",
    "snippet": "QLCache::~SQLCache()\n{\n    timeToCommit();\n    db.close();\n    QSqlDatabase::removeDatabase(db.connectionName());\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SqlDatabase::removeDatabase(",
          "args": [
            "b.connectionName())"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.connectionName",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b.close",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeToCommit(",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "timeToCommit(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "846-855",
          "snippet": "oid SQLCache::timeToCommit()\n{\n    if (inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Commit\";\n#endif\n        inTransaction = false;\n        db.commit();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::timeToCommit()\n  {\n      if (inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Commit\";\n  #endif\n          inTransaction = false;\n          db.commit();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  QLCache::~SQLCache()\n  {\n      timeToCommit();\n      db.close();\n      QSqlDatabase::removeDatabase(db.connectionName());\n  }\n}"
  },
  {
    "function_name": "init(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "67-93",
    "snippet": "oid SQLCache::init()\n{\n#ifdef CACHE_DEBUG\n    qDebug() << \"SQLCache::init()\";\n#endif\n    if (delayedCommit)\n        delayedCommit->deleteLater();\n    Q_ASSERT(parent());\n    bool ok;\n    int num;\n    delayedCommit = new QTimer(this);\n    num = parent()->property(\"trojita-sqlcache-commit-delay\").toInt(&ok);\n    if (! ok)\n        num = 10000;\n    delayedCommit->setInterval(num);\n    delayedCommit->setObjectName(QString::fromUtf8(\"delayedCommit-%1\").arg(objectName()));\n    connect(delayedCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n    if (tooMuchTimeWithoutCommit)\n        tooMuchTimeWithoutCommit->deleteLater();\n    tooMuchTimeWithoutCommit = new QTimer(this);\n    num = parent()->property(\"trojita-sqlcache-commit-period\").toInt(&ok);\n    if (! ok)\n        num = 60000;\n    tooMuchTimeWithoutCommit->setInterval(num);\n    tooMuchTimeWithoutCommit->setObjectName(QString::fromUtf8(\"tooMuchTimeWithoutCommit-%1\").arg(objectName()));\n    connect(tooMuchTimeWithoutCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ooMuchTimeWithoutCommit,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(timeToCommit()))"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "imeToCommit())"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeToCommit(",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "timeToCommit(",
          "container": "QLCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
          "lines": "846-855",
          "snippet": "oid SQLCache::timeToCommit()\n{\n    if (inTransaction) {\n#ifdef CACHE_DEBUG\n        qDebug() << \"Commit\";\n#endif\n        inTransaction = false;\n        db.commit();\n    }\n}",
          "includes": [
            "include \"Common/SqlTransactionAutoAborter.h\"",
            "include <QTimer>\n#",
            "include <QSqlRecord>\n#",
            "include <QSqlError>\n#",
            "include \"SQLCache.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::timeToCommit()\n  {\n      if (inTransaction) {\n  #ifdef CACHE_DEBUG\n          qDebug() << \"Commit\";\n  #endif\n          inTransaction = false;\n          db.commit();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ooMuchTimeWithoutCommit->setObjectName",
          "args": [
            "String::fromUtf8(\"tooMuchTimeWithoutCommit-%1\").arg(objectName()))"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "bjectName())"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bjectName(",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "tooMuchTimeWithoutCommit-%1\")"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ooMuchTimeWithoutCommit->setInterval",
          "args": [
            "um)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arent",
          "args": [
            "ok)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "slotTaskGotReparented(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "255-261",
          "snippet": "oid TaskPresentationModel::slotTaskGotReparented(const ImapTask *const task)\n{\n    Q_UNUSED(task);\n    CHECK_TASK_TREE\n    RESET_MODEL;\n    CHECK_TASK_TREE\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  oid TaskPresentationModel::slotTaskGotReparented(const ImapTask *const task)\n  {\n      Q_UNUSED(task);\n      CHECK_TASK_TREE\n      RESET_MODEL;\n      CHECK_TASK_TREE\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arent(",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "findScrollParent(",
          "container": "mbeddedWebView",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/EmbeddedWebView.cpp",
          "lines": "178-212",
          "snippet": "oid EmbeddedWebView::findScrollParent()\n{\n    if (m_scrollParent)\n        m_scrollParent->removeEventFilter(this);\n    m_scrollParent = 0;\n    m_scrollParentPadding = 4;\n    QWidget *runner = this;\n    int left, top, right, bottom;\n    while (runner) {\n        runner->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);\n        runner->getContentsMargins(&left, &top, &right, &bottom);\n        m_scrollParentPadding += left + right + 4;\n        if (runner->layout()) {\n            runner->layout()->getContentsMargins(&left, &top, &right, &bottom);\n            m_scrollParentPadding += left + right;\n        }\n        QWidget *p = runner->parentWidget();\n        if (p && qobject_cast<MessageView*>(runner) && // is this a MessageView?\n            p->objectName() == \"qt_scrollarea_viewport\" && // in a viewport?\n            qobject_cast<QAbstractScrollArea*>(p->parentWidget())) { // that is used?\n            p->getContentsMargins(&left, &top, &right, &bottom);\n            m_scrollParentPadding += left + right + 4;\n            if (p->layout()) {\n                p->layout()->getContentsMargins(&left, &top, &right, &bottom);\n                m_scrollParentPadding += left + right;\n            }\n            m_scrollParent = p->parentWidget();\n            break; // then we have our actual message view\n        }\n        runner = p;\n    }\n    m_scrollParentPadding += style()->pixelMetric(QStyle::PM_ScrollBarExtent, 0, m_scrollParent);\n    if (m_scrollParent)\n        m_scrollParent->installEventFilter(this);\n}",
          "includes": [
            "include <QDebug>",
            "include <QWebHistory>",
            "include <QWebFrame>\n#",
            "include <QStyleFactory>\n#",
            "include <QStyle>\n#",
            "include <QNetworkReply>\n#",
            "include <QLayout>\n#",
            "include <QDesktopServices>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include <QAbstractScrollArea>\n#",
            "include \"Gui/Util.h\"",
            "include \"MessageView.h\"\n#",
            "include \"EmbeddedWebView.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QDebug>\ninclude <QWebHistory>\ninclude <QWebFrame>\n#\ninclude <QStyleFactory>\n#\ninclude <QStyle>\n#\ninclude <QNetworkReply>\n#\ninclude <QLayout>\n#\ninclude <QDesktopServices>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude <QAbstractScrollArea>\n#\ninclude \"Gui/Util.h\"\ninclude \"MessageView.h\"\n#\ninclude \"EmbeddedWebView.h\"\n#\n\nmbeddedWebView {\n  oid EmbeddedWebView::findScrollParent()\n  {\n      if (m_scrollParent)\n          m_scrollParent->removeEventFilter(this);\n      m_scrollParent = 0;\n      m_scrollParentPadding = 4;\n      QWidget *runner = this;\n      int left, top, right, bottom;\n      while (runner) {\n          runner->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);\n          runner->getContentsMargins(&left, &top, &right, &bottom);\n          m_scrollParentPadding += left + right + 4;\n          if (runner->layout()) {\n              runner->layout()->getContentsMargins(&left, &top, &right, &bottom);\n              m_scrollParentPadding += left + right;\n          }\n          QWidget *p = runner->parentWidget();\n          if (p && qobject_cast<MessageView*>(runner) && // is this a MessageView?\n              p->objectName() == \"qt_scrollarea_viewport\" && // in a viewport?\n              qobject_cast<QAbstractScrollArea*>(p->parentWidget())) { // that is used?\n              p->getContentsMargins(&left, &top, &right, &bottom);\n              m_scrollParentPadding += left + right + 4;\n              if (p->layout()) {\n                  p->layout()->getContentsMargins(&left, &top, &right, &bottom);\n                  m_scrollParentPadding += left + right;\n              }\n              m_scrollParent = p->parentWidget();\n              break; // then we have our actual message view\n          }\n          runner = p;\n      }\n      m_scrollParentPadding += style()->pixelMetric(QStyle::PM_ScrollBarExtent, 0, m_scrollParent);\n      if (m_scrollParent)\n          m_scrollParent->installEventFilter(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ooMuchTimeWithoutCommit->deleteLater",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "elayedCommit,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(timeToCommit()))"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "imeToCommit())"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedCommit->setObjectName",
          "args": [
            "String::fromUtf8(\"delayedCommit-%1\").arg(objectName()))"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "bjectName())"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bjectName(",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "delayedCommit-%1\")"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedCommit->setInterval",
          "args": [
            "um)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arent())"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedCommit->deleteLater",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  oid SQLCache::init()\n  {\n  #ifdef CACHE_DEBUG\n      qDebug() << \"SQLCache::init()\";\n  #endif\n      if (delayedCommit)\n          delayedCommit->deleteLater();\n      Q_ASSERT(parent());\n      bool ok;\n      int num;\n      delayedCommit = new QTimer(this);\n      num = parent()->property(\"trojita-sqlcache-commit-delay\").toInt(&ok);\n      if (! ok)\n          num = 10000;\n      delayedCommit->setInterval(num);\n      delayedCommit->setObjectName(QString::fromUtf8(\"delayedCommit-%1\").arg(objectName()));\n      connect(delayedCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n      if (tooMuchTimeWithoutCommit)\n          tooMuchTimeWithoutCommit->deleteLater();\n      tooMuchTimeWithoutCommit = new QTimer(this);\n      num = parent()->property(\"trojita-sqlcache-commit-period\").toInt(&ok);\n      if (! ok)\n          num = 60000;\n      tooMuchTimeWithoutCommit->setInterval(num);\n      tooMuchTimeWithoutCommit->setObjectName(QString::fromUtf8(\"tooMuchTimeWithoutCommit-%1\").arg(objectName()));\n      connect(tooMuchTimeWithoutCommit, SIGNAL(timeout()), this, SLOT(timeToCommit()));\n  }\n}"
  },
  {
    "function_name": "SQLCache(",
    "container": "QLCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SQLCache.cpp",
    "lines": "62-65",
    "snippet": "QLCache::SQLCache(QObject *parent):\n    AbstractCache(parent), delayedCommit(0), tooMuchTimeWithoutCommit(0), inTransaction(false), m_updateAccessIfOlder(0)\n{\n}",
    "includes": [
      "include \"Common/SqlTransactionAutoAborter.h\"",
      "include <QTimer>\n#",
      "include <QSqlRecord>\n#",
      "include <QSqlError>\n#",
      "include \"SQLCache.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Common/SqlTransactionAutoAborter.h\"\ninclude <QTimer>\n#\ninclude <QSqlRecord>\n#\ninclude <QSqlError>\n#\ninclude \"SQLCache.h\"\n#\n\nQLCache {\n  QLCache::SQLCache(QObject *parent):\n      AbstractCache(parent), delayedCommit(0), tooMuchTimeWithoutCommit(0), inTransaction(false), m_updateAccessIfOlder(0)\n  {\n  }\n}"
  }
]