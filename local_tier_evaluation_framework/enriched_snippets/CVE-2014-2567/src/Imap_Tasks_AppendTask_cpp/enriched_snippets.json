[
  {
    "function_name": "taskData(",
    "container": "ppendTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/AppendTask.cpp",
    "lines": "95-98",
    "snippet": "Variant AppendTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Uploading message\")) : QVariant();\n}",
    "includes": [
      "include \"GetAnyConnectionTask.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"AppendTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [
            "r(\"Uploading message\"))"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Uploading message\")"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "ppendTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/AppendTask.cpp",
          "lines": "65-93",
          "snippet": "ool AppendTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (resp->tag == tag) {\n\n        if (resp->kind == Responses::OK) {\n            if (resp->respCode == Responses::APPENDUID) {\n                const Responses::RespData<QPair<uint, Sequence> > *const respData =\n                        dynamic_cast<const Responses::RespData<QPair<uint, Sequence> >* const>(resp->respCodeData.data());\n                Q_ASSERT(respData);\n                QList<uint> uids = respData->data.second.toList();\n                if (uids.size() != 1) {\n                    log(\"APPENDUID: malformed data, cannot extract a single UID\");\n                } else {\n                    emit appendUid(respData->data.first, uids.front());\n                }\n            }\n            // nothing should be needed here\n            _completed();\n        } else {\n            _failed(resp->message);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}",
          "includes": [
            "include \"GetAnyConnectionTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"AppendTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"AppendTask.h\"\n#\n\nppendTask {\n  ool AppendTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (resp->tag == tag) {\n  \n          if (resp->kind == Responses::OK) {\n              if (resp->respCode == Responses::APPENDUID) {\n                  const Responses::RespData<QPair<uint, Sequence> > *const respData =\n                          dynamic_cast<const Responses::RespData<QPair<uint, Sequence> >* const>(resp->respCodeData.data());\n                  Q_ASSERT(respData);\n                  QList<uint> uids = respData->data.second.toList();\n                  if (uids.size() != 1) {\n                      log(\"APPENDUID: malformed data, cannot extract a single UID\");\n                  } else {\n                      emit appendUid(respData->data.first, uids.front());\n                  }\n              }\n              // nothing should be needed here\n              _completed();\n          } else {\n              _failed(resp->message);\n          }\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"AppendTask.h\"\n#\n\nppendTask {\n  Variant AppendTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Uploading message\")) : QVariant();\n  }\n}"
  },
  {
    "function_name": "handleStateHelper(",
    "container": "ppendTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/AppendTask.cpp",
    "lines": "65-93",
    "snippet": "ool AppendTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (resp->tag == tag) {\n\n        if (resp->kind == Responses::OK) {\n            if (resp->respCode == Responses::APPENDUID) {\n                const Responses::RespData<QPair<uint, Sequence> > *const respData =\n                        dynamic_cast<const Responses::RespData<QPair<uint, Sequence> >* const>(resp->respCodeData.data());\n                Q_ASSERT(respData);\n                QList<uint> uids = respData->data.second.toList();\n                if (uids.size() != 1) {\n                    log(\"APPENDUID: malformed data, cannot extract a single UID\");\n                } else {\n                    emit appendUid(respData->data.first, uids.front());\n                }\n            }\n            // nothing should be needed here\n            _completed();\n        } else {\n            _failed(resp->message);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "include \"GetAnyConnectionTask.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"AppendTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "esp->message)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ids.front",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "APPENDUID: malformed data, cannot extract a single UID\")"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ids.size",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "espData->data.second.toList",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "espData)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<QPair<uint, Sequence> >* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->respCodeData.data",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"AppendTask.h\"\n#\n\nppendTask {\n  ool AppendTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (resp->tag == tag) {\n  \n          if (resp->kind == Responses::OK) {\n              if (resp->respCode == Responses::APPENDUID) {\n                  const Responses::RespData<QPair<uint, Sequence> > *const respData =\n                          dynamic_cast<const Responses::RespData<QPair<uint, Sequence> >* const>(resp->respCodeData.data());\n                  Q_ASSERT(respData);\n                  QList<uint> uids = respData->data.second.toList();\n                  if (uids.size() != 1) {\n                      log(\"APPENDUID: malformed data, cannot extract a single UID\");\n                  } else {\n                      emit appendUid(respData->data.first, uids.front());\n                  }\n              }\n              // nothing should be needed here\n              _completed();\n          } else {\n              _failed(resp->message);\n          }\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "ppendTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/AppendTask.cpp",
    "lines": "50-63",
    "snippet": "oid AppendTask::perform()\n{\n    parser = conn->parser;\n    Q_ASSERT(parser);\n    markAsActiveTask();\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    if (data.isEmpty()) {\n        tag = parser->append(targetMailbox, rawMessageData, flags, timestamp);\n    } else {\n        tag = parser->appendCatenate(targetMailbox, data, flags, timestamp);\n    }\n}",
    "includes": [
      "include \"GetAnyConnectionTask.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"AppendTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->appendCatenate",
          "args": [
            "argetMailbox,",
            "ata,",
            "lags,",
            "imestamp)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "appendCatenate(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "269-294",
          "snippet": "ommandHandle Parser::appendCatenate(const QString &mailbox, const QList<Imap::Mailbox::CatenatePair> &data,\n                                     const QStringList &flags, const QDateTime &timestamp)\n{\n    Commands::Command command(\"APPEND\");\n    command << encodeImapFolderName(mailbox);\n    if (flags.count())\n        command << Commands::PartOfCommand(Commands::ATOM, \"(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\");\n    if (timestamp.isValid())\n        command << Commands::PartOfCommand(Imap::dateTimeToInternalDate(timestamp).toUtf8());\n    command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" CATENATE (\");\n    Q_FOREACH(const Imap::Mailbox::CatenatePair &item, data) {\n        switch (item.first) {\n        case Imap::Mailbox::CATENATE_TEXT:\n            command << Commands::PartOfCommand(Commands::ATOM, \"TEXT\");\n            command << Commands::PartOfCommand(Commands::LITERAL, item.second);\n            break;\n        case Imap::Mailbox::CATENATE_URL:\n            command << Commands::PartOfCommand(Commands::ATOM, \"URL\");\n            command << Commands::PartOfCommand(item.second);\n            break;\n        }\n    }\n    command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n\n    return queueCommand(command);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::appendCatenate(const QString &mailbox, const QList<Imap::Mailbox::CatenatePair> &data,\n                                       const QStringList &flags, const QDateTime &timestamp)\n  {\n      Commands::Command command(\"APPEND\");\n      command << encodeImapFolderName(mailbox);\n      if (flags.count())\n          command << Commands::PartOfCommand(Commands::ATOM, \"(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\");\n      if (timestamp.isValid())\n          command << Commands::PartOfCommand(Imap::dateTimeToInternalDate(timestamp).toUtf8());\n      command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" CATENATE (\");\n      Q_FOREACH(const Imap::Mailbox::CatenatePair &item, data) {\n          switch (item.first) {\n          case Imap::Mailbox::CATENATE_TEXT:\n              command << Commands::PartOfCommand(Commands::ATOM, \"TEXT\");\n              command << Commands::PartOfCommand(Commands::LITERAL, item.second);\n              break;\n          case Imap::Mailbox::CATENATE_URL:\n              command << Commands::PartOfCommand(Commands::ATOM, \"URL\");\n              command << Commands::PartOfCommand(item.second);\n              break;\n          }\n      }\n      command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n  \n      return queueCommand(command);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ata.isEmpty",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arser)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"AppendTask.h\"\n#\n\nppendTask {\n  oid AppendTask::perform()\n  {\n      parser = conn->parser;\n      Q_ASSERT(parser);\n      markAsActiveTask();\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      if (data.isEmpty()) {\n          tag = parser->append(targetMailbox, rawMessageData, flags, timestamp);\n      } else {\n          tag = parser->appendCatenate(targetMailbox, data, flags, timestamp);\n      }\n  }\n}"
  },
  {
    "function_name": "AppendTask(",
    "container": "ppendTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/AppendTask.cpp",
    "lines": "42-48",
    "snippet": "ppendTask::AppendTask(Model *model, const QString &targetMailbox, const QList<CatenatePair> &data, const QStringList &flags,\n                       const QDateTime &timestamp):\n    ImapTask(model), targetMailbox(targetMailbox), data(data), flags(flags), timestamp(timestamp)\n{\n    conn = model->m_taskFactory->createGetAnyConnectionTask(model);\n    conn->addDependentTask(this);\n}",
    "includes": [
      "include \"GetAnyConnectionTask.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"AppendTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createGetAnyConnectionTask",
          "args": [
            "odel)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"AppendTask.h\"\n#\n\nppendTask {\n  ppendTask::AppendTask(Model *model, const QString &targetMailbox, const QList<CatenatePair> &data, const QStringList &flags,\n                         const QDateTime &timestamp):\n      ImapTask(model), targetMailbox(targetMailbox), data(data), flags(flags), timestamp(timestamp)\n  {\n      conn = model->m_taskFactory->createGetAnyConnectionTask(model);\n      conn->addDependentTask(this);\n  }\n}"
  },
  {
    "function_name": "AppendTask(",
    "container": "ppendTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/AppendTask.cpp",
    "lines": "34-40",
    "snippet": "ppendTask::AppendTask(Model *model, const QString &targetMailbox, const QByteArray &rawMessageData, const QStringList &flags,\n                       const QDateTime &timestamp):\n    ImapTask(model), targetMailbox(targetMailbox), rawMessageData(rawMessageData), flags(flags), timestamp(timestamp)\n{\n    conn = model->m_taskFactory->createGetAnyConnectionTask(model);\n    conn->addDependentTask(this);\n}",
    "includes": [
      "include \"GetAnyConnectionTask.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"AppendTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createGetAnyConnectionTask",
          "args": [
            "odel)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"AppendTask.h\"\n#\n\nppendTask {\n  ppendTask::AppendTask(Model *model, const QString &targetMailbox, const QByteArray &rawMessageData, const QStringList &flags,\n                         const QDateTime &timestamp):\n      ImapTask(model), targetMailbox(targetMailbox), rawMessageData(rawMessageData), flags(flags), timestamp(timestamp)\n  {\n      conn = model->m_taskFactory->createGetAnyConnectionTask(model);\n      conn->addDependentTask(this);\n  }\n}"
  }
]