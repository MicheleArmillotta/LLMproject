[
  {
    "function_name": "signalSyncFailure(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "1190-1199",
    "snippet": "oid ObtainSynchronizedMailboxTask::signalSyncFailure(const QString &message)\n{\n    if (!mailboxIndex.isValid()) {\n        // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n        // Seems that there's nothing to report here.\n        return;\n    }\n\n    EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "odel,",
            "ailboxSyncFailed,",
            "_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()),",
            "_ARG(QString, message))"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "essage)"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "ailboxIndex.data(RoleMailboxName).toString())"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::signalSyncFailure(const QString &message)\n  {\n      if (!mailboxIndex.isValid()) {\n          // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n          // Seems that there's nothing to report here.\n          return;\n      }\n  \n      EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n  }\n}"
  },
  {
    "function_name": "taskData(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "1184-1187",
    "snippet": "Variant ObtainSynchronizedMailboxTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Synchronizing mailbox\")) : QVariant();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [
            "r(\"Synchronizing mailbox\"))"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Synchronizing mailbox\")"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "125-218",
          "snippet": "ool ObtainSynchronizedMailboxTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    if (handleResponseCodeInsideState(resp))\n        return true;\n\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    // We absolutely have to ignore the abort() request\n\n    if (resp->tag == selectCmd) {\n\n        if (resp->kind == Responses::OK) {\n            //qDebug() << \"received OK for selectCmd\";\n            Q_ASSERT(status == STATE_SELECTING);\n            finalizeSelect();\n        } else {\n            _failed(QLatin1String(\"SELECT failed: \") + resp->message);\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n        }\n        return true;\n    } else if (resp->tag == uidSyncingCmd) {\n\n        if (resp->kind == Responses::OK) {\n            // FIXME: move the finalizeSearch() here to support working with split SEARCH reposnes -- but beware of\n            // arrivals/expunges which happen while the UID SEARCH is in progres...\n            log(\"UIDs synchronized\", Common::LOG_MAILBOX_SYNC);\n            Q_ASSERT(status == STATE_SYNCING_FLAGS);\n            Q_ASSERT(mailboxIndex.isValid());   // FIXME\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            syncFlags(mailbox);\n        } else {\n            _failed(QLatin1String(\"UID syncing failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        return true;\n    } else if (resp->tag == flagsCmd) {\n\n        if (resp->kind == Responses::OK) {\n            //qDebug() << \"received OK for flagsCmd\";\n            Q_ASSERT(status == STATE_SYNCING_FLAGS);\n            Q_ASSERT(mailboxIndex.isValid());\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            status = STATE_DONE;\n            log(\"Flags synchronized\", Common::LOG_MAILBOX_SYNC);\n            notifyInterestingMessages(mailbox);\n            flagsCmd.clear();\n\n            if (newArrivalsFetch.isEmpty()) {\n                mailbox->saveSyncStateAndUids(model);\n                model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                _completed();\n            } else {\n                log(\"Pending new arrival fetching, not terminating yet\", Common::LOG_MAILBOX_SYNC);\n            }\n        } else {\n            status = STATE_DONE;\n            _failed(QLatin1String(\"Flags synchronization failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        return true;\n    } else if (newArrivalsFetch.contains(resp->tag)) {\n\n        if (resp->kind == Responses::OK) {\n            newArrivalsFetch.removeOne(resp->tag);\n\n            if (newArrivalsFetch.isEmpty() && status == STATE_DONE && flagsCmd.isEmpty()) {\n                Q_ASSERT(mailboxIndex.isValid());\n                TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n                Q_ASSERT(mailbox);\n                mailbox->saveSyncStateAndUids(model);\n                model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                _completed();\n            }\n        } else {\n            _failed(QLatin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        return true;\n\n    } else {\n        return false;\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      if (handleResponseCodeInsideState(resp))\n          return true;\n  \n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      // We absolutely have to ignore the abort() request\n  \n      if (resp->tag == selectCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              //qDebug() << \"received OK for selectCmd\";\n              Q_ASSERT(status == STATE_SELECTING);\n              finalizeSelect();\n          } else {\n              _failed(QLatin1String(\"SELECT failed: \") + resp->message);\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n          }\n          return true;\n      } else if (resp->tag == uidSyncingCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              // FIXME: move the finalizeSearch() here to support working with split SEARCH reposnes -- but beware of\n              // arrivals/expunges which happen while the UID SEARCH is in progres...\n              log(\"UIDs synchronized\", Common::LOG_MAILBOX_SYNC);\n              Q_ASSERT(status == STATE_SYNCING_FLAGS);\n              Q_ASSERT(mailboxIndex.isValid());   // FIXME\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              syncFlags(mailbox);\n          } else {\n              _failed(QLatin1String(\"UID syncing failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          return true;\n      } else if (resp->tag == flagsCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              //qDebug() << \"received OK for flagsCmd\";\n              Q_ASSERT(status == STATE_SYNCING_FLAGS);\n              Q_ASSERT(mailboxIndex.isValid());\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              status = STATE_DONE;\n              log(\"Flags synchronized\", Common::LOG_MAILBOX_SYNC);\n              notifyInterestingMessages(mailbox);\n              flagsCmd.clear();\n  \n              if (newArrivalsFetch.isEmpty()) {\n                  mailbox->saveSyncStateAndUids(model);\n                  model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                  _completed();\n              } else {\n                  log(\"Pending new arrival fetching, not terminating yet\", Common::LOG_MAILBOX_SYNC);\n              }\n          } else {\n              status = STATE_DONE;\n              _failed(QLatin1String(\"Flags synchronization failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          return true;\n      } else if (newArrivalsFetch.contains(resp->tag)) {\n  \n          if (resp->kind == Responses::OK) {\n              newArrivalsFetch.removeOne(resp->tag);\n  \n              if (newArrivalsFetch.isEmpty() && status == STATE_DONE && flagsCmd.isEmpty()) {\n                  Q_ASSERT(mailboxIndex.isValid());\n                  TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n                  Q_ASSERT(mailbox);\n                  mailbox->saveSyncStateAndUids(model);\n                  model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                  _completed();\n              }\n          } else {\n              _failed(QLatin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          return true;\n  \n      } else {\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  Variant ObtainSynchronizedMailboxTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Synchronizing mailbox\")) : QVariant();\n  }\n}"
  },
  {
    "function_name": "slotUnSelectCompleted(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "1178-1182",
    "snippet": "oid ObtainSynchronizedMailboxTask::slotUnSelectCompleted()\n{\n    // Now, just finish and signal a failure\n    _failed(\"Escaped from mailbox\");\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Escaped from mailbox\")"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::slotUnSelectCompleted()\n  {\n      // Now, just finish and signal a failure\n      _failed(\"Escaped from mailbox\");\n  }\n}"
  },
  {
    "function_name": "dieIfInvalidMailbox(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "1159-1176",
    "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nSelectTask->perform",
          "args": [],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "nSelectTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/UnSelectTask.cpp",
          "lines": "43-61",
          "snippet": "oid UnSelectTask::perform()\n{\n    markAsActiveTask(TASK_PREPEND);\n\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return;\n    }\n    // We really should ignore abort() -- we're a very important task\n\n    if (model->accessParser(parser).maintainingTask) {\n        model->accessParser(parser).maintainingTask->breakOrCancelPossibleIdle();\n    }\n    if (model->accessParser(parser).capabilities.contains(\"UNSELECT\")) {\n        unSelectTag = parser->unSelect();\n    } else {\n        doFakeSelect();\n    }\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include <QUuid>\n#",
            "include \"UnSelectTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude <QUuid>\n#\ninclude \"UnSelectTask.h\"\n#\n\nnSelectTask {\n  oid UnSelectTask::perform()\n  {\n      markAsActiveTask(TASK_PREPEND);\n  \n      if (_dead) {\n          _failed(\"Asked to die\");\n          return;\n      }\n      // We really should ignore abort() -- we're a very important task\n  \n      if (model->accessParser(parser).maintainingTask) {\n          model->accessParser(parser).maintainingTask->breakOrCancelPossibleIdle();\n      }\n      if (model->accessParser(parser).capabilities.contains(\"UNSELECT\")) {\n          unSelectTag = parser->unSelect();\n      } else {\n          doFakeSelect();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createUnSelectTask",
          "args": [
            "odel,",
            "his)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Mailbox disappeared\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "notifyInterestingMessages(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "1131-1157",
    "snippet": "oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n{\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    list->recalcVariousMessageCounts(model);\n    QModelIndex listIndex = list->toIndex(model);\n    Q_ASSERT(listIndex.isValid());\n    QModelIndex firstInterestingMessage = model->index(\n                // remember, the offset has one-based indexing\n                mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n    if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n            firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n        // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n        int offset = model->rowCount(listIndex) - 1;\n        log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n            .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                 QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n        firstInterestingMessage = model->index(offset, 0, listIndex);\n    } else {\n        log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n            .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                 firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                 ), Common::LOG_MAILBOX_SYNC);\n    }\n    emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailbox->toIndex",
          "args": [
            "odel)"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "String::fromUtf8(\"First interesting message at %1 (%2)\")\n            .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                 firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                 ),",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(mailbox->syncState.unSeenOffset()),",
            "irstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [
            "Latin1String(\", \"))"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ", \")"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [
            "oleMessageFlags)"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ailbox->syncState.unSeenOffset())"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.unSeenOffset",
          "args": [],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "First interesting message at %1 (%2)\")"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->index",
          "args": [
            "ffset,",
            ",",
            "istIndex)"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "index(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "51-87",
          "snippet": "ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n{\n    if (column != 0)\n        return QModelIndex();\n    if (row < 0)\n        return QModelIndex();\n\n    if (parent.isValid()) {\n        // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // The parent is a ParserState\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            if (row >= parserState.activeTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, parserState.activeTasks.at(row));\n            }\n        } else {\n            // The parent is a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            if (row >= task->dependentTasks.size()) {\n                return QModelIndex();\n            } else {\n                return createIndex(row, 0, task->dependentTasks.at(row));\n            }\n        }\n    } else {\n        // So this is about a ParserState -- fair enough\n        if (row >= m_model->m_parsers.size()) {\n            return QModelIndex();\n        } else {\n            return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n        }\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  ModelIndex TaskPresentationModel::index(int row, int column, const QModelIndex &parent) const\n  {\n      if (column != 0)\n          return QModelIndex();\n      if (row < 0)\n          return QModelIndex();\n  \n      if (parent.isValid()) {\n          // Parent is a valid index, so the child is definitely an ImapTask. The parent could still be a ParserState, though.\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // The parent is a ParserState\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              if (row >= parserState.activeTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, parserState.activeTasks.at(row));\n              }\n          } else {\n              // The parent is a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              if (row >= task->dependentTasks.size()) {\n                  return QModelIndex();\n              } else {\n                  return createIndex(row, 0, task->dependentTasks.at(row));\n              }\n          }\n      } else {\n          // So this is about a ParserState -- fair enough\n          if (row >= m_model->m_parsers.size()) {\n              return QModelIndex();\n          } else {\n              return createIndex(row, 0, m_model->m_parsers.keys().at(row));\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "irstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),",
            "String::number(offset))"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ffset)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [
            "Latin1String(\", \"))"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ", \")"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [
            "oleMessageFlags)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->rowCount",
          "args": [
            "istIndex)"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "rowCount(",
          "container": "askPresentationModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/TaskPresentationModel.cpp",
          "lines": "134-153",
          "snippet": "nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n{\n    if (parent.isValid()) {\n        // This is where it starts to get complicated -- we're somewhere inside the tree\n        if (parent.data(RoleTaskIsParserState).toBool()) {\n            // A child of the top level item, ie. a ParserState object\n            Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n            ParserState &parserState = m_model->accessParser(parser);\n            return parserState.activeTasks.size();\n        } else {\n            // It's a regular ImapTask\n            ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n            Q_ASSERT(task);\n            return task->dependentTasks.size();\n        }\n    } else {\n        // The top-level stuff children represent the list of active connections\n        return m_model->m_parsers.size();\n    }\n}",
          "includes": [
            "include \"QAIM_reset.h\"",
            "include \"Model.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/UnSelectTask.h\"\n#",
            "include \"Imap/Tasks/SortTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/NoopTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"QAIM_reset.h\"\ninclude \"Model.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/UnSelectTask.h\"\n#\ninclude \"Imap/Tasks/SortTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/NoopTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\n\naskPresentationModel {\n  nt TaskPresentationModel::rowCount(const QModelIndex &parent) const\n  {\n      if (parent.isValid()) {\n          // This is where it starts to get complicated -- we're somewhere inside the tree\n          if (parent.data(RoleTaskIsParserState).toBool()) {\n              // A child of the top level item, ie. a ParserState object\n              Imap::Parser *parser = static_cast<Imap::Parser *>(parent.internalPointer());\n              ParserState &parserState = m_model->accessParser(parser);\n              return parserState.activeTasks.size();\n          } else {\n              // It's a regular ImapTask\n              ImapTask *task = static_cast<ImapTask *>(parent.internalPointer());\n              Q_ASSERT(task);\n              return task->dependentTasks.size();\n          }\n      } else {\n          // The top-level stuff children represent the list of active connections\n          return m_model->m_parsers.size();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [
            "oleMessageIsMarkedRead)"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irstInterestingMessage.data",
          "args": [
            "oleMessageIsMarkedRecent)"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.unSeenOffset",
          "args": [],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.unSeenOffset",
          "args": [],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "istIndex.isValid())"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "istIndex.isValid",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist->toIndex",
          "args": [
            "odel)"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->recalcVariousMessageCounts",
          "args": [
            "odel)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "recalcVariousMessageCounts(",
          "container": "reeItemMsgList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "930-947",
          "snippet": "oid TreeItemMsgList::recalcVariousMessageCounts(Model *model)\n{\n    m_unreadMessageCount = 0;\n    m_recentMessageCount = 0;\n    for (int i = 0; i < m_children.size(); ++i) {\n        TreeItemMessage *message = static_cast<TreeItemMessage *>(m_children[i]);\n        if (!message->m_flagsHandled)\n            message->m_wasUnread = ! message->isMarkedAsRead();\n        message->m_flagsHandled = true;\n        if (! message->isMarkedAsRead())\n            ++m_unreadMessageCount;\n        if (message->isMarkedAsRecent())\n            ++m_recentMessageCount;\n    }\n    m_totalMessageCount = m_children.size();\n    m_numberFetchingStatus = DONE;\n    model->emitMessageCountChanged(static_cast<TreeItemMailbox *>(parent()));\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMsgList {\n  oid TreeItemMsgList::recalcVariousMessageCounts(Model *model)\n  {\n      m_unreadMessageCount = 0;\n      m_recentMessageCount = 0;\n      for (int i = 0; i < m_children.size(); ++i) {\n          TreeItemMessage *message = static_cast<TreeItemMessage *>(m_children[i]);\n          if (!message->m_flagsHandled)\n              message->m_wasUnread = ! message->isMarkedAsRead();\n          message->m_flagsHandled = true;\n          if (! message->isMarkedAsRead())\n              ++m_unreadMessageCount;\n          if (message->isMarkedAsRecent())\n              ++m_recentMessageCount;\n      }\n      m_totalMessageCount = m_children.size();\n      m_numberFetchingStatus = DONE;\n      model->emitMessageCountChanged(static_cast<TreeItemMailbox *>(parent()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<Imap::Mailbox::TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n  {\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      list->recalcVariousMessageCounts(model);\n      QModelIndex listIndex = list->toIndex(model);\n      Q_ASSERT(listIndex.isValid());\n      QModelIndex firstInterestingMessage = model->index(\n                  // remember, the offset has one-based indexing\n                  mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n      if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n              firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n          // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n          int offset = model->rowCount(listIndex) - 1;\n          log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n              .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                   QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n          firstInterestingMessage = model->index(offset, 0, listIndex);\n      } else {\n          log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n              .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                   firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                   ), Common::LOG_MAILBOX_SYNC);\n      }\n      emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n  }\n}"
  },
  {
    "function_name": "debugIdentification(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "1102-1129",
    "snippet": "String ObtainSynchronizedMailboxTask::debugIdentification() const\n{\n    if (! mailboxIndex.isValid())\n        return QLatin1String(\"[invalid mailboxIndex]\");\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n\n    QString statusStr;\n    switch (status) {\n    case STATE_WAIT_FOR_CONN:\n        statusStr = \"STATE_WAIT_FOR_CONN\";\n        break;\n    case STATE_SELECTING:\n        statusStr = \"STATE_SELECTING\";\n        break;\n    case STATE_SYNCING_UIDS:\n        statusStr = \"STATE_SYNCING_UIDS\";\n        break;\n    case STATE_SYNCING_FLAGS:\n        statusStr = \"STATE_SYNCING_FLAGS\";\n        break;\n    case STATE_DONE:\n        statusStr = \"STATE_DONE\";\n        break;\n    }\n    return QString::fromUtf8(\"%1 %2\").arg(statusStr, mailbox->mailbox());\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "tatusStr,",
            "ailbox->mailbox())"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "%1 %2\")"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "[invalid mailboxIndex]\")"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  String ObtainSynchronizedMailboxTask::debugIdentification() const\n  {\n      if (! mailboxIndex.isValid())\n          return QLatin1String(\"[invalid mailboxIndex]\");\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n  \n      QString statusStr;\n      switch (status) {\n      case STATE_WAIT_FOR_CONN:\n          statusStr = \"STATE_WAIT_FOR_CONN\";\n          break;\n      case STATE_SELECTING:\n          statusStr = \"STATE_SELECTING\";\n          break;\n      case STATE_SYNCING_UIDS:\n          statusStr = \"STATE_SYNCING_UIDS\";\n          break;\n      case STATE_SYNCING_FLAGS:\n          statusStr = \"STATE_SYNCING_FLAGS\";\n          break;\n      case STATE_DONE:\n          statusStr = \"STATE_DONE\";\n          break;\n      }\n      return QString::fromUtf8(\"%1 %2\").arg(statusStr, mailbox->mailbox());\n  }\n}"
  },
  {
    "function_name": "applyUids(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "997-1100",
    "snippet": "oid ObtainSynchronizedMailboxTask::applyUids(TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    QModelIndex parent = list->toIndex(model);\n    list->m_children.reserve(mailbox->syncState.exists());\n\n    int i = firstUnknownUidOffset;\n    while (i < uidMap.size() + static_cast<int>(firstUnknownUidOffset)) {\n        // Index inside the uidMap in which the UID of a message at offset i in the list->m_children can be found\n        int uidOffset = i - firstUnknownUidOffset;\n        Q_ASSERT(uidOffset >= 0);\n        Q_ASSERT(uidOffset < uidMap.size());\n\n        // For each UID which is really supposed to be there...\n\n        Q_ASSERT(i <= list->m_children.size());\n        if (i == list->m_children.size()) {\n            // now we're just adding new messages to the end of the list\n            const int futureTotalMessages = mailbox->syncState.exists();\n            model->beginInsertRows(parent, i, futureTotalMessages - 1);\n            for (/*nothing*/; i < futureTotalMessages; ++i) {\n                // Add all messages in one go\n                TreeItemMessage *msg = new TreeItemMessage(list);\n                msg->m_offset = i;\n                // We're iterating with i, so we got to update the uidOffset\n                uidOffset = i - firstUnknownUidOffset;\n                Q_ASSERT(uidOffset >= 0);\n                Q_ASSERT(uidOffset < uidMap.size());\n                msg->m_uid = uidMap[uidOffset];\n                list->m_children << msg;\n            }\n            model->endInsertRows();\n            Q_ASSERT(i == list->m_children.size());\n            Q_ASSERT(i == futureTotalMessages);\n        } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == uidMap[uidOffset]) {\n            // If the UID of the \"current message\" matches, we're okay\n            static_cast<TreeItemMessage *>(list->m_children[i])->m_offset = i;\n            ++i;\n        } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == 0) {\n            // If the UID of the \"current message\" is zero, replace that with this message\n            TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n            msg->m_uid = uidMap[uidOffset];\n            msg->m_offset = i;\n            QModelIndex idx = model->createIndex(i, 0, msg);\n            emit model->dataChanged(idx, idx);\n            if (msg->accessFetchStatus() == TreeItem::LOADING) {\n                // We've got to ask for the message metadata once again; the first attempt happened when the UID was still zero,\n                // so this is our chance\n                model->askForMsgMetadata(msg, Model::PRELOAD_PER_POLICY);\n            }\n            ++i;\n        } else {\n            // We've got an UID mismatch\n            int pos = i;\n            while (pos < list->m_children.size()) {\n                // Remove any messages which have non-zero UID which is at the same time different than the UID we want to add\n                // The key idea here is that IMAP guarantees that each and every new message will have greater UID than any\n                // other message already in the mailbox. Just for the sake of completeness, should an evil server send us a\n                // malformed response, we wouldn't care (or notice at this point), we'd just \"needlessly\" delete many \"innocent\"\n                // messages due to that one out-of-place arrival -- but we'd still remain correct and not crash.\n                TreeItemMessage *otherMessage = static_cast<TreeItemMessage*>(list->m_children[pos]);\n                if (otherMessage->m_uid != 0 && otherMessage->m_uid != uidMap[uidOffset]) {\n                    model->cache()->clearMessage(mailbox->mailbox(), otherMessage->uid());\n                    ++pos;\n                } else {\n                    break;\n                }\n            }\n            Q_ASSERT(pos > i);\n            model->beginRemoveRows(parent, i, pos - 1);\n            TreeItemChildrenList removedItems = list->m_children.mid(i, pos - i);\n            list->m_children.erase(list->m_children.begin() + i, list->m_children.begin() + pos);\n            model->endRemoveRows();\n            // the m_offset of all subsequent messages will be updated later, at the time *they* are processed\n            qDeleteAll(removedItems);\n            if (i == list->m_children.size()) {\n                // We're asked to add messages to the end of the list. That's something that's already implemented above,\n                // so let's reuse that code. That's why we do *not* want to increment the counter here.\n            } else {\n                Q_ASSERT(i < list->m_children.size());\n                // But this case is also already implemented above, so we won't touch the counter from here, either,\n                // and let the existing code do its job\n            }\n        }\n    }\n\n    if (i != list->m_children.size()) {\n        // remove items at the end\n        model->beginRemoveRows(parent, i, list->m_children.size() - 1);\n        TreeItemChildrenList removedItems = list->m_children.mid(i);\n        list->m_children.erase(list->m_children.begin() + i, list->m_children.end());\n        model->endRemoveRows();\n        qDeleteAll(removedItems);\n    }\n\n    uidMap.clear();\n\n    list->m_totalMessageCount = list->m_children.size();\n    list->setFetchStatus(TreeItem::DONE);\n\n    model->emitMessageCountChanged(mailbox);\n    model->changeConnectionState(parser, CONN_STATE_SELECTED);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->emitMessageCountChanged",
          "args": [
            "ailbox)"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "emitMessageCountChanged(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "495-501",
          "snippet": "oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    QModelIndex msgListIndex = list->toIndex(this);\n    emit dataChanged(msgListIndex, msgListIndex);\n    emit messageCountPossiblyChanged(mailbox->toIndex(this));\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      QModelIndex msgListIndex = list->toIndex(this);\n      emit dataChanged(msgListIndex, msgListIndex);\n      emit messageCountPossiblyChanged(mailbox->toIndex(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.clear",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "emovedItems)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->endRemoveRows",
          "args": [],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.erase",
          "args": [
            "ist->m_children.begin() + i,",
            "ist->m_children.end())"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.end",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.begin",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.mid",
          "args": [
            ")"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->beginRemoveRows",
          "args": [
            "arent,",
            ",",
            "ist->m_children.size() - 1)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "< list->m_children.size())"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "emovedItems)"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->endRemoveRows",
          "args": [],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.erase",
          "args": [
            "ist->m_children.begin() + i,",
            "ist->m_children.begin() + pos)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.begin",
          "args": [],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.begin",
          "args": [],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.mid",
          "args": [
            ",",
            "os - i)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->beginRemoveRows",
          "args": [
            "arent,",
            ",",
            "os - 1)"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "os > i)"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox(),",
            "therMessage->uid())"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "therMessage->uid",
          "args": [],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage*>",
          "args": [
            "ist->m_children[pos])"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->askForMsgMetadata",
          "args": [
            "sg,",
            "odel::PRELOAD_PER_POLICY)"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "askForMsgMetadata(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "911-996",
          "snippet": "oid Model::askForMsgMetadata(TreeItemMessage *item, const PreloadingMode preloadMode)\n{\n    Q_ASSERT(item->uid());\n    Q_ASSERT(!item->fetched());\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(item->parent());\n    Q_ASSERT(list);\n    TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(list->parent());\n    Q_ASSERT(mailboxPtr);\n\n    if (item->uid()) {\n        AbstractCache::MessageDataBundle data = cache()->messageMetadata(mailboxPtr->mailbox(), item->uid());\n        if (data.uid == item->uid()) {\n            item->data()->m_envelope = data.envelope;\n            item->data()->m_size = data.size;\n            item->data()->m_hdrReferences = data.hdrReferences;\n            item->data()->m_hdrListPost = data.hdrListPost;\n            item->data()->m_hdrListPostNo = data.hdrListPostNo;\n            QDataStream stream(&data.serializedBodyStructure, QIODevice::ReadOnly);\n            stream.setVersion(QDataStream::Qt_4_6);\n            QVariantList unserialized;\n            stream >> unserialized;\n            QSharedPointer<Message::AbstractMessage> abstractMessage;\n            try {\n                abstractMessage = Message::AbstractMessage::fromList(unserialized, QByteArray(), 0);\n            } catch (Imap::ParserException &e) {\n                qDebug() << \"Error when parsing cached BODYSTRUCTURE\" << e.what();\n            }\n            if (! abstractMessage) {\n                item->setFetchStatus(TreeItem::UNAVAILABLE);\n            } else {\n                auto newChildren = abstractMessage->createTreeItems(item);\n                if (item->m_children.isEmpty()) {\n                    TreeItemChildrenList oldChildren = item->setChildren(newChildren);\n                    Q_ASSERT(oldChildren.size() == 0);\n                } else {\n                    // The following assert guards against that crazy signal emitting we had when various askFor*()\n                    // functions were not delayed. If it gets hit, it means that someone tried to call this function\n                    // on an item which was already loaded.\n                    Q_ASSERT(item->m_children.isEmpty());\n                    item->setChildren(newChildren);\n                }\n                item->setFetchStatus(TreeItem::DONE);\n            }\n        }\n    }\n\n    switch (networkPolicy()) {\n    case NETWORK_OFFLINE:\n        if (item->accessFetchStatus() != TreeItem::DONE)\n            item->setFetchStatus(TreeItem::UNAVAILABLE);\n        break;\n    case NETWORK_EXPENSIVE:\n        if (item->accessFetchStatus() != TreeItem::DONE) {\n            item->setFetchStatus(TreeItem::LOADING);\n            findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n        }\n        break;\n    case NETWORK_ONLINE:\n    {\n        if (item->accessFetchStatus() != TreeItem::DONE) {\n            item->setFetchStatus(TreeItem::LOADING);\n            findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n        }\n\n        // preload\n        if (preloadMode != PRELOAD_PER_POLICY)\n            break;\n        bool ok;\n        int preload = property(\"trojita-imap-preload-msg-metadata\").toInt(&ok);\n        if (! ok)\n            preload = 50;\n        int order = item->row();\n        for (int i = qMax(0, order - preload); i < qMin(list->m_children.size(), order + preload); ++i) {\n            TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(list->m_children[i]);\n            Q_ASSERT(message);\n            if (item != message && !message->fetched() && !message->loading() && message->uid()) {\n                message->setFetchStatus(TreeItem::LOADING);\n                // cannot ask the KeepTask directly, that'd completely ignore the cache\n                // but we absolutely have to block the preload :)\n                askForMsgMetadata(message, PRELOAD_DISABLED);\n            }\n        }\n    }\n    break;\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::askForMsgMetadata(TreeItemMessage *item, const PreloadingMode preloadMode)\n  {\n      Q_ASSERT(item->uid());\n      Q_ASSERT(!item->fetched());\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(item->parent());\n      Q_ASSERT(list);\n      TreeItemMailbox *mailboxPtr = dynamic_cast<TreeItemMailbox *>(list->parent());\n      Q_ASSERT(mailboxPtr);\n  \n      if (item->uid()) {\n          AbstractCache::MessageDataBundle data = cache()->messageMetadata(mailboxPtr->mailbox(), item->uid());\n          if (data.uid == item->uid()) {\n              item->data()->m_envelope = data.envelope;\n              item->data()->m_size = data.size;\n              item->data()->m_hdrReferences = data.hdrReferences;\n              item->data()->m_hdrListPost = data.hdrListPost;\n              item->data()->m_hdrListPostNo = data.hdrListPostNo;\n              QDataStream stream(&data.serializedBodyStructure, QIODevice::ReadOnly);\n              stream.setVersion(QDataStream::Qt_4_6);\n              QVariantList unserialized;\n              stream >> unserialized;\n              QSharedPointer<Message::AbstractMessage> abstractMessage;\n              try {\n                  abstractMessage = Message::AbstractMessage::fromList(unserialized, QByteArray(), 0);\n              } catch (Imap::ParserException &e) {\n                  qDebug() << \"Error when parsing cached BODYSTRUCTURE\" << e.what();\n              }\n              if (! abstractMessage) {\n                  item->setFetchStatus(TreeItem::UNAVAILABLE);\n              } else {\n                  auto newChildren = abstractMessage->createTreeItems(item);\n                  if (item->m_children.isEmpty()) {\n                      TreeItemChildrenList oldChildren = item->setChildren(newChildren);\n                      Q_ASSERT(oldChildren.size() == 0);\n                  } else {\n                      // The following assert guards against that crazy signal emitting we had when various askFor*()\n                      // functions were not delayed. If it gets hit, it means that someone tried to call this function\n                      // on an item which was already loaded.\n                      Q_ASSERT(item->m_children.isEmpty());\n                      item->setChildren(newChildren);\n                  }\n                  item->setFetchStatus(TreeItem::DONE);\n              }\n          }\n      }\n  \n      switch (networkPolicy()) {\n      case NETWORK_OFFLINE:\n          if (item->accessFetchStatus() != TreeItem::DONE)\n              item->setFetchStatus(TreeItem::UNAVAILABLE);\n          break;\n      case NETWORK_EXPENSIVE:\n          if (item->accessFetchStatus() != TreeItem::DONE) {\n              item->setFetchStatus(TreeItem::LOADING);\n              findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n          }\n          break;\n      case NETWORK_ONLINE:\n      {\n          if (item->accessFetchStatus() != TreeItem::DONE) {\n              item->setFetchStatus(TreeItem::LOADING);\n              findTaskResponsibleFor(mailboxPtr)->requestEnvelopeDownload(item->uid());\n          }\n  \n          // preload\n          if (preloadMode != PRELOAD_PER_POLICY)\n              break;\n          bool ok;\n          int preload = property(\"trojita-imap-preload-msg-metadata\").toInt(&ok);\n          if (! ok)\n              preload = 50;\n          int order = item->row();\n          for (int i = qMax(0, order - preload); i < qMin(list->m_children.size(), order + preload); ++i) {\n              TreeItemMessage *message = dynamic_cast<TreeItemMessage *>(list->m_children[i]);\n              Q_ASSERT(message);\n              if (item != message && !message->fetched() && !message->loading() && message->uid()) {\n                  message->setFetchStatus(TreeItem::LOADING);\n                  // cannot ask the KeepTask directly, that'd completely ignore the cache\n                  // but we absolutely have to block the preload :)\n                  askForMsgMetadata(message, PRELOAD_DISABLED);\n              }\n          }\n      }\n      break;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg->accessFetchStatus",
          "args": [],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->createIndex",
          "args": [
            ",",
            ",",
            "sg)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage*>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "== futureTotalMessages)"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "== list->m_children.size())"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->endInsertRows",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "idOffset < uidMap.size())"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "idOffset >= 0)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->beginInsertRows",
          "args": [
            "arent,",
            ",",
            "utureTotalMessages - 1)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "<= list->m_children.size())"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "idOffset < uidMap.size())"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "idOffset >= 0)"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<int>",
          "args": [
            "irstUnknownUidOffset)"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.reserve",
          "args": [
            "ailbox->syncState.exists())"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->toIndex",
          "args": [
            "odel)"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::applyUids(TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      QModelIndex parent = list->toIndex(model);\n      list->m_children.reserve(mailbox->syncState.exists());\n  \n      int i = firstUnknownUidOffset;\n      while (i < uidMap.size() + static_cast<int>(firstUnknownUidOffset)) {\n          // Index inside the uidMap in which the UID of a message at offset i in the list->m_children can be found\n          int uidOffset = i - firstUnknownUidOffset;\n          Q_ASSERT(uidOffset >= 0);\n          Q_ASSERT(uidOffset < uidMap.size());\n  \n          // For each UID which is really supposed to be there...\n  \n          Q_ASSERT(i <= list->m_children.size());\n          if (i == list->m_children.size()) {\n              // now we're just adding new messages to the end of the list\n              const int futureTotalMessages = mailbox->syncState.exists();\n              model->beginInsertRows(parent, i, futureTotalMessages - 1);\n              for (/*nothing*/; i < futureTotalMessages; ++i) {\n                  // Add all messages in one go\n                  TreeItemMessage *msg = new TreeItemMessage(list);\n                  msg->m_offset = i;\n                  // We're iterating with i, so we got to update the uidOffset\n                  uidOffset = i - firstUnknownUidOffset;\n                  Q_ASSERT(uidOffset >= 0);\n                  Q_ASSERT(uidOffset < uidMap.size());\n                  msg->m_uid = uidMap[uidOffset];\n                  list->m_children << msg;\n              }\n              model->endInsertRows();\n              Q_ASSERT(i == list->m_children.size());\n              Q_ASSERT(i == futureTotalMessages);\n          } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == uidMap[uidOffset]) {\n              // If the UID of the \"current message\" matches, we're okay\n              static_cast<TreeItemMessage *>(list->m_children[i])->m_offset = i;\n              ++i;\n          } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == 0) {\n              // If the UID of the \"current message\" is zero, replace that with this message\n              TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n              msg->m_uid = uidMap[uidOffset];\n              msg->m_offset = i;\n              QModelIndex idx = model->createIndex(i, 0, msg);\n              emit model->dataChanged(idx, idx);\n              if (msg->accessFetchStatus() == TreeItem::LOADING) {\n                  // We've got to ask for the message metadata once again; the first attempt happened when the UID was still zero,\n                  // so this is our chance\n                  model->askForMsgMetadata(msg, Model::PRELOAD_PER_POLICY);\n              }\n              ++i;\n          } else {\n              // We've got an UID mismatch\n              int pos = i;\n              while (pos < list->m_children.size()) {\n                  // Remove any messages which have non-zero UID which is at the same time different than the UID we want to add\n                  // The key idea here is that IMAP guarantees that each and every new message will have greater UID than any\n                  // other message already in the mailbox. Just for the sake of completeness, should an evil server send us a\n                  // malformed response, we wouldn't care (or notice at this point), we'd just \"needlessly\" delete many \"innocent\"\n                  // messages due to that one out-of-place arrival -- but we'd still remain correct and not crash.\n                  TreeItemMessage *otherMessage = static_cast<TreeItemMessage*>(list->m_children[pos]);\n                  if (otherMessage->m_uid != 0 && otherMessage->m_uid != uidMap[uidOffset]) {\n                      model->cache()->clearMessage(mailbox->mailbox(), otherMessage->uid());\n                      ++pos;\n                  } else {\n                      break;\n                  }\n              }\n              Q_ASSERT(pos > i);\n              model->beginRemoveRows(parent, i, pos - 1);\n              TreeItemChildrenList removedItems = list->m_children.mid(i, pos - i);\n              list->m_children.erase(list->m_children.begin() + i, list->m_children.begin() + pos);\n              model->endRemoveRows();\n              // the m_offset of all subsequent messages will be updated later, at the time *they* are processed\n              qDeleteAll(removedItems);\n              if (i == list->m_children.size()) {\n                  // We're asked to add messages to the end of the list. That's something that's already implemented above,\n                  // so let's reuse that code. That's why we do *not* want to increment the counter here.\n              } else {\n                  Q_ASSERT(i < list->m_children.size());\n                  // But this case is also already implemented above, so we won't touch the counter from here, either,\n                  // and let the existing code do its job\n              }\n          }\n      }\n  \n      if (i != list->m_children.size()) {\n          // remove items at the end\n          model->beginRemoveRows(parent, i, list->m_children.size() - 1);\n          TreeItemChildrenList removedItems = list->m_children.mid(i);\n          list->m_children.erase(list->m_children.begin() + i, list->m_children.end());\n          model->endRemoveRows();\n          qDeleteAll(removedItems);\n      }\n  \n      uidMap.clear();\n  \n      list->m_totalMessageCount = list->m_children.size();\n      list->setFetchStatus(TreeItem::DONE);\n  \n      model->emitMessageCountChanged(mailbox);\n      model->changeConnectionState(parser, CONN_STATE_SELECTED);\n  }\n}"
  },
  {
    "function_name": "handleFetch(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "966-991",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleFetch(const Imap::Responses::Fetch *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    QList<TreeItemPart *> changedParts;\n    TreeItemMessage *changedMessage = 0;\n    mailbox->handleFetchResponse(model, *resp, changedParts, changedMessage, m_usingQresync);\n    if (changedMessage) {\n        QModelIndex index = changedMessage->toIndex(model);\n        emit model->dataChanged(index, index);\n        if (mailbox->syncState.uidNext() <= changedMessage->uid()) {\n            mailbox->syncState.setUidNext(changedMessage->uid() + 1);\n        }\n        // On the other hand, this one will be emitted at the very end\n        // model->emitMessageCountChanged(mailbox);\n    }\n    if (!changedParts.isEmpty() && !m_usingQresync) {\n        // On the other hand, with QRESYNC our code is ready to receive extra data that changes body parts...\n        qDebug() << \"Weird, FETCH when syncing has changed some body parts. We aren't ready for that.\";\n        log(QLatin1String(\"This response has changed some message parts. That should not have happened, as we're still syncing.\"));\n    }\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Latin1String(\"This response has changed some message parts. That should not have happened, as we're still syncing.\"))"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "This response has changed some message parts. That should not have happened, as we're still syncing.\")"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hangedParts.isEmpty",
          "args": [],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setUidNext",
          "args": [
            "hangedMessage->uid() + 1)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hangedMessage->uid",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hangedMessage->uid",
          "args": [],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidNext",
          "args": [],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hangedMessage->toIndex",
          "args": [
            "odel)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->handleFetchResponse",
          "args": [
            "odel,",
            "resp,",
            "hangedParts,",
            "hangedMessage,",
            "_usingQresync)"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "handleFetchResponse(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "336-551",
          "snippet": "oid TreeItemMailbox::handleFetchResponse(Model *const model,\n        const Responses::Fetch &response,\n        QList<TreeItemPart *> &changedParts,\n        TreeItemMessage *&changedMessage, bool usingQresync)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(m_children[0]);\n\n    Responses::Fetch::dataType::const_iterator uidRecord = response.data.find(\"UID\");\n\n    // Previously, we would ignore any FETCH responses until we are fully synced. This is rather hard do to \"properly\",\n    // though.\n    // What we want to achieve is to never store data into a \"wrong\" message. Theoretically, we are prone to just this\n    // in case the server sends us unsolicited data before we are fully synced. When this happens for flags, it's a pretty\n    // harmless operation as we're going to re-fetch the flags for the concerned part of mailbox anyway (even with CONDSTORE,\n    // and this is never an issue with QRESYNC).\n    // It's worse when the data refer to some immutable piece of information like the bodystructure or body parts.\n    // If that happens, then we have to actively prevent the data from being stored because we cannot know whether we would\n    // be putting it into a correct bucket^Hmessage.\n    bool ignoreImmutableData = !list->fetched() && uidRecord == response.data.constEnd();\n\n    int number = response.number - 1;\n    if (number < 0 || number >= list->m_children.size())\n        throw UnknownMessageIndex(QString::fromUtf8(\"Got FETCH that is out of bounds -- got %1 messages\").arg(\n                                      QString::number(list->m_children.size())).toUtf8().constData(), response);\n\n    TreeItemMessage *message = static_cast<TreeItemMessage *>(list->child(number, model));\n\n    // At first, have a look at the response and check the UID of the message\n    if (uidRecord != response.data.constEnd()) {\n        uint receivedUid = static_cast<const Responses::RespData<uint>&>(*(uidRecord.value())).data;\n        if (message->uid() == receivedUid) {\n            // That's what we expect -> do nothing\n        } else if (message->uid() == 0) {\n            // This is the first time we see the UID, so let's take a note\n            message->m_uid = receivedUid;\n            changedMessage = message;\n            if (message->loading()) {\n                // The Model tried to ask for data for this message. That couldn't succeeded because the UID\n                // wasn't known at that point, so let's ask now\n                //\n                // FIXME: tweak this to keep a high watermark of \"highest UID we requested an ENVELOPE for\",\n                // issue bulk fetches in the same manner as we do the UID FETCH (FLAGS) when discovering UIDs,\n                // and at this place in code, only ask for the metadata when the UID is higher than the watermark.\n                // Optionally, simply ask for the ENVELOPE etc along with the FLAGS upon new message arrivals, maybe\n                // with some limit on the number of pending fetches. And make that dapandent on online/expensive modes.\n                message->setFetchStatus(NONE);\n                message->fetch(model);\n            }\n            if (syncState.uidNext() <= receivedUid) {\n                // Try to guess the UIDNEXT. We have to take an educated guess here, and I believe that this approach\n                // at least is not wrong. The server won't tell us the UIDNEXT (well, it could, but it doesn't have to),\n                // the only way of asking for it is via STATUS which is not allowed to reference the current mailbox and\n                // even if it was, it wouldn't be atomic. So, what could the UIDNEXT possibly be? It can't be smaller\n                // than the UID_of_highest_message, and it can't be the same, either, so it really has to be higher.\n                // Let's just increment it by one, this is our lower bound.\n                // Not guessing the UIDNEXT correctly would result at decreased performance at the next sync, and we\n                // can't really do better -> let's just set it now, along with the UID mapping.\n                syncState.setUidNext(receivedUid + 1);\n                list->setFetchStatus(LOADING);\n            }\n        } else {\n            throw MailboxException(QString::fromUtf8(\"FETCH response: UID consistency error for message #%1 -- expected UID %2, got UID %3\").arg(\n                                       QString::number(response.number), QString::number(message->uid()), QString::number(receivedUid)\n                                       ).toUtf8().constData(), response);\n        }\n    } else if (! message->uid()) {\n        qDebug() << \"FETCH: received a FETCH response for message #\" << response.number << \"whose UID is not yet known. This sucks.\";\n        QList<uint> uidsInMailbox;\n        Q_FOREACH(TreeItem *node, list->m_children) {\n            uidsInMailbox << static_cast<TreeItemMessage *>(node)->uid();\n        }\n        qDebug() << \"UIDs in the mailbox now: \" << uidsInMailbox;\n    }\n\n    bool savedBodyStructure = false;\n    bool gotEnvelope = false;\n    bool gotSize = false;\n    bool gotInternalDate = false;\n    bool updatedFlags = false;\n\n    for (Responses::Fetch::dataType::const_iterator it = response.data.begin(); it != response.data.end(); ++ it) {\n        if (it.key() == \"UID\") {\n            // established above\n            Q_ASSERT(static_cast<const Responses::RespData<uint>&>(*(it.value())).data == message->uid());\n        } else if (it.key() == \"FLAGS\") {\n            // Only emit signals when the flags have actually changed\n            QStringList newFlags = model->normalizeFlags(static_cast<const Responses::RespData<QStringList>&>(*(it.value())).data);\n            bool forceChange = (message->m_flags != newFlags);\n            message->setFlags(list, newFlags, forceChange);\n            if (forceChange) {\n                updatedFlags = true;\n                changedMessage = message;\n            }\n        } else if (it.key() == \"MODSEQ\") {\n            quint64 num = static_cast<const Responses::RespData<quint64>&>(*(it.value())).data;\n            if (num > syncState.highestModSeq()) {\n                syncState.setHighestModSeq(num);\n                if (list->accessFetchStatus() == DONE) {\n                    // This means that everything is known already, so we are by definition OK to save stuff to disk.\n                    // We can also skip rebuilding the UID map and save just the HIGHESTMODSEQ, i.e. the SyncState.\n                    model->cache()->setMailboxSyncState(mailbox(), syncState);\n                } else {\n                    // it's already marked as dirty -> nothing to do here\n                }\n            }\n        } else if (ignoreImmutableData) {\n            QByteArray buf;\n            QTextStream ss(&buf);\n            ss << response;\n            ss.flush();\n            qDebug() << \"Ignoring FETCH response to a mailbox that isn't synced yet:\" << buf;\n            continue;\n        } else if (it.key() == \"ENVELOPE\") {\n            message->data()->m_envelope = static_cast<const Responses::RespData<Message::Envelope>&>(*(it.value())).data;\n            message->setFetchStatus(DONE);\n            gotEnvelope = true;\n            changedMessage = message;\n        } else if (it.key() == \"BODYSTRUCTURE\") {\n            if (message->fetched()) {\n                // The message structure is already known, so we are free to ignore it\n            } else {\n                // We had no idea about the structure of the message\n                auto newChildren = static_cast<const Message::AbstractMessage &>(*(it.value())).createTreeItems(message);\n                if (!message->m_children.isEmpty()) {\n                    QModelIndex messageIdx = message->toIndex(model);\n                    model->beginRemoveRows(messageIdx, 0, message->m_children.size() - 1);\n                    auto oldChildren = message->setChildren(newChildren);\n                    model->endRemoveRows();\n                    qDeleteAll(oldChildren);\n                } else {\n                    auto oldChildren = message->setChildren(newChildren);\n                    Q_ASSERT(oldChildren.size() == 0);\n                }\n                savedBodyStructure = true;\n            }\n        } else if (it.key() == \"x-trojita-bodystructure\") {\n            // do nothing\n        } else if (it.key() == \"RFC822.SIZE\") {\n            message->data()->m_size = static_cast<const Responses::RespData<uint>&>(*(it.value())).data;\n            gotSize = true;\n        } else if (it.key().startsWith(\"BODY[HEADER.FIELDS (\")) {\n            // Process any headers found in any such response bit\n            const QByteArray &rawHeaders = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n            message->processAdditionalHeaders(model, rawHeaders);\n            changedMessage = message;\n        } else if (it.key().startsWith(\"BODY[\") || it.key().startsWith(\"BINARY[\")) {\n            if (it.key()[ it.key().size() - 1 ] != ']')\n                throw UnknownMessageIndex(\"Can't parse such BODY[]/BINARY[]\", response);\n            TreeItemPart *part = partIdToPtr(model, message, it.key());\n            if (! part)\n                throw UnknownMessageIndex(\"Got BODY[]/BINARY[] fetch that did not resolve to any known part\", response);\n            const QByteArray &data = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n            if (it.key().startsWith(\"BODY[\")) {\n\n                // Check whether we are supposed to be loading the raw, undecoded part as well.\n                // The check has to be done via a direct pointer access to m_partRaw to make sure that it does not\n                // get instantiated when not actually needed.\n                if (part->m_partRaw && part->m_partRaw->loading()) {\n                    part->m_partRaw->m_data = data;\n                    part->m_partRaw->setFetchStatus(DONE);\n                    changedParts.append(part->m_partRaw);\n                    if (message->uid()) {\n                        model->cache()->forgetMessagePart(mailbox(), message->uid(), part->partId());\n                        model->cache()->setMsgPart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\"), data);\n                    }\n                }\n\n                // Do not overwrite the part data if we were not asked to fetch it.\n                // One possibility is that it's already there because it was fetched before. The second option is that\n                // we were in fact asked to only fetch the raw data and the user is not itnerested in the processed data at all.\n                if (part->loading()) {\n                    // got to decode the part data by hand\n                    Imap::decodeContentTransferEncoding(data, part->encoding(), part->dataPtr());\n                    part->setFetchStatus(DONE);\n                    changedParts.append(part);\n                    if (message->uid()\n                            && model->cache()->messagePart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\")).isNull()) {\n                        // Do not store the data into cache if the raw data are already there\n                        model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                    }\n                }\n\n            } else {\n                // A BINARY FETCH item is already decoded for us, yay\n                part->m_data = data;\n                part->setFetchStatus(DONE);\n                changedParts.append(part);\n                if (message->uid()) {\n                    model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                }\n            }\n        } else if (it.key() == \"INTERNALDATE\") {\n            message->data()->m_internalDate = static_cast<const Responses::RespData<QDateTime>&>(*(it.value())).data;\n            gotInternalDate = true;\n        } else {\n            qDebug() << \"TreeItemMailbox::handleFetchResponse: unknown FETCH identifier\" << it.key();\n        }\n    }\n    if (message->uid()) {\n        if (gotEnvelope && gotSize && savedBodyStructure && gotInternalDate) {\n            Imap::Mailbox::AbstractCache::MessageDataBundle dataForCache;\n            dataForCache.envelope = message->data()->m_envelope;\n            dataForCache.serializedBodyStructure = static_cast<const Responses::RespData<QByteArray>&>(*(response.data[ \"x-trojita-bodystructure\" ])).data;\n            dataForCache.size = message->data()->m_size;\n            dataForCache.uid = message->uid();\n            dataForCache.internalDate = message->data()->m_internalDate;\n            dataForCache.hdrReferences = message->data()->m_hdrReferences;\n            dataForCache.hdrListPost = message->data()->m_hdrListPost;\n            dataForCache.hdrListPostNo = message->data()->m_hdrListPostNo;\n            model->cache()->setMessageMetadata(mailbox(), message->uid(), dataForCache);\n        }\n        if (updatedFlags) {\n            model->cache()->setMsgFlags(mailbox(), message->uid(), message->m_flags);\n        }\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleFetchResponse(Model *const model,\n          const Responses::Fetch &response,\n          QList<TreeItemPart *> &changedParts,\n          TreeItemMessage *&changedMessage, bool usingQresync)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(m_children[0]);\n  \n      Responses::Fetch::dataType::const_iterator uidRecord = response.data.find(\"UID\");\n  \n      // Previously, we would ignore any FETCH responses until we are fully synced. This is rather hard do to \"properly\",\n      // though.\n      // What we want to achieve is to never store data into a \"wrong\" message. Theoretically, we are prone to just this\n      // in case the server sends us unsolicited data before we are fully synced. When this happens for flags, it's a pretty\n      // harmless operation as we're going to re-fetch the flags for the concerned part of mailbox anyway (even with CONDSTORE,\n      // and this is never an issue with QRESYNC).\n      // It's worse when the data refer to some immutable piece of information like the bodystructure or body parts.\n      // If that happens, then we have to actively prevent the data from being stored because we cannot know whether we would\n      // be putting it into a correct bucket^Hmessage.\n      bool ignoreImmutableData = !list->fetched() && uidRecord == response.data.constEnd();\n  \n      int number = response.number - 1;\n      if (number < 0 || number >= list->m_children.size())\n          throw UnknownMessageIndex(QString::fromUtf8(\"Got FETCH that is out of bounds -- got %1 messages\").arg(\n                                        QString::number(list->m_children.size())).toUtf8().constData(), response);\n  \n      TreeItemMessage *message = static_cast<TreeItemMessage *>(list->child(number, model));\n  \n      // At first, have a look at the response and check the UID of the message\n      if (uidRecord != response.data.constEnd()) {\n          uint receivedUid = static_cast<const Responses::RespData<uint>&>(*(uidRecord.value())).data;\n          if (message->uid() == receivedUid) {\n              // That's what we expect -> do nothing\n          } else if (message->uid() == 0) {\n              // This is the first time we see the UID, so let's take a note\n              message->m_uid = receivedUid;\n              changedMessage = message;\n              if (message->loading()) {\n                  // The Model tried to ask for data for this message. That couldn't succeeded because the UID\n                  // wasn't known at that point, so let's ask now\n                  //\n                  // FIXME: tweak this to keep a high watermark of \"highest UID we requested an ENVELOPE for\",\n                  // issue bulk fetches in the same manner as we do the UID FETCH (FLAGS) when discovering UIDs,\n                  // and at this place in code, only ask for the metadata when the UID is higher than the watermark.\n                  // Optionally, simply ask for the ENVELOPE etc along with the FLAGS upon new message arrivals, maybe\n                  // with some limit on the number of pending fetches. And make that dapandent on online/expensive modes.\n                  message->setFetchStatus(NONE);\n                  message->fetch(model);\n              }\n              if (syncState.uidNext() <= receivedUid) {\n                  // Try to guess the UIDNEXT. We have to take an educated guess here, and I believe that this approach\n                  // at least is not wrong. The server won't tell us the UIDNEXT (well, it could, but it doesn't have to),\n                  // the only way of asking for it is via STATUS which is not allowed to reference the current mailbox and\n                  // even if it was, it wouldn't be atomic. So, what could the UIDNEXT possibly be? It can't be smaller\n                  // than the UID_of_highest_message, and it can't be the same, either, so it really has to be higher.\n                  // Let's just increment it by one, this is our lower bound.\n                  // Not guessing the UIDNEXT correctly would result at decreased performance at the next sync, and we\n                  // can't really do better -> let's just set it now, along with the UID mapping.\n                  syncState.setUidNext(receivedUid + 1);\n                  list->setFetchStatus(LOADING);\n              }\n          } else {\n              throw MailboxException(QString::fromUtf8(\"FETCH response: UID consistency error for message #%1 -- expected UID %2, got UID %3\").arg(\n                                         QString::number(response.number), QString::number(message->uid()), QString::number(receivedUid)\n                                         ).toUtf8().constData(), response);\n          }\n      } else if (! message->uid()) {\n          qDebug() << \"FETCH: received a FETCH response for message #\" << response.number << \"whose UID is not yet known. This sucks.\";\n          QList<uint> uidsInMailbox;\n          Q_FOREACH(TreeItem *node, list->m_children) {\n              uidsInMailbox << static_cast<TreeItemMessage *>(node)->uid();\n          }\n          qDebug() << \"UIDs in the mailbox now: \" << uidsInMailbox;\n      }\n  \n      bool savedBodyStructure = false;\n      bool gotEnvelope = false;\n      bool gotSize = false;\n      bool gotInternalDate = false;\n      bool updatedFlags = false;\n  \n      for (Responses::Fetch::dataType::const_iterator it = response.data.begin(); it != response.data.end(); ++ it) {\n          if (it.key() == \"UID\") {\n              // established above\n              Q_ASSERT(static_cast<const Responses::RespData<uint>&>(*(it.value())).data == message->uid());\n          } else if (it.key() == \"FLAGS\") {\n              // Only emit signals when the flags have actually changed\n              QStringList newFlags = model->normalizeFlags(static_cast<const Responses::RespData<QStringList>&>(*(it.value())).data);\n              bool forceChange = (message->m_flags != newFlags);\n              message->setFlags(list, newFlags, forceChange);\n              if (forceChange) {\n                  updatedFlags = true;\n                  changedMessage = message;\n              }\n          } else if (it.key() == \"MODSEQ\") {\n              quint64 num = static_cast<const Responses::RespData<quint64>&>(*(it.value())).data;\n              if (num > syncState.highestModSeq()) {\n                  syncState.setHighestModSeq(num);\n                  if (list->accessFetchStatus() == DONE) {\n                      // This means that everything is known already, so we are by definition OK to save stuff to disk.\n                      // We can also skip rebuilding the UID map and save just the HIGHESTMODSEQ, i.e. the SyncState.\n                      model->cache()->setMailboxSyncState(mailbox(), syncState);\n                  } else {\n                      // it's already marked as dirty -> nothing to do here\n                  }\n              }\n          } else if (ignoreImmutableData) {\n              QByteArray buf;\n              QTextStream ss(&buf);\n              ss << response;\n              ss.flush();\n              qDebug() << \"Ignoring FETCH response to a mailbox that isn't synced yet:\" << buf;\n              continue;\n          } else if (it.key() == \"ENVELOPE\") {\n              message->data()->m_envelope = static_cast<const Responses::RespData<Message::Envelope>&>(*(it.value())).data;\n              message->setFetchStatus(DONE);\n              gotEnvelope = true;\n              changedMessage = message;\n          } else if (it.key() == \"BODYSTRUCTURE\") {\n              if (message->fetched()) {\n                  // The message structure is already known, so we are free to ignore it\n              } else {\n                  // We had no idea about the structure of the message\n                  auto newChildren = static_cast<const Message::AbstractMessage &>(*(it.value())).createTreeItems(message);\n                  if (!message->m_children.isEmpty()) {\n                      QModelIndex messageIdx = message->toIndex(model);\n                      model->beginRemoveRows(messageIdx, 0, message->m_children.size() - 1);\n                      auto oldChildren = message->setChildren(newChildren);\n                      model->endRemoveRows();\n                      qDeleteAll(oldChildren);\n                  } else {\n                      auto oldChildren = message->setChildren(newChildren);\n                      Q_ASSERT(oldChildren.size() == 0);\n                  }\n                  savedBodyStructure = true;\n              }\n          } else if (it.key() == \"x-trojita-bodystructure\") {\n              // do nothing\n          } else if (it.key() == \"RFC822.SIZE\") {\n              message->data()->m_size = static_cast<const Responses::RespData<uint>&>(*(it.value())).data;\n              gotSize = true;\n          } else if (it.key().startsWith(\"BODY[HEADER.FIELDS (\")) {\n              // Process any headers found in any such response bit\n              const QByteArray &rawHeaders = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n              message->processAdditionalHeaders(model, rawHeaders);\n              changedMessage = message;\n          } else if (it.key().startsWith(\"BODY[\") || it.key().startsWith(\"BINARY[\")) {\n              if (it.key()[ it.key().size() - 1 ] != ']')\n                  throw UnknownMessageIndex(\"Can't parse such BODY[]/BINARY[]\", response);\n              TreeItemPart *part = partIdToPtr(model, message, it.key());\n              if (! part)\n                  throw UnknownMessageIndex(\"Got BODY[]/BINARY[] fetch that did not resolve to any known part\", response);\n              const QByteArray &data = static_cast<const Responses::RespData<QByteArray>&>(*(it.value())).data;\n              if (it.key().startsWith(\"BODY[\")) {\n  \n                  // Check whether we are supposed to be loading the raw, undecoded part as well.\n                  // The check has to be done via a direct pointer access to m_partRaw to make sure that it does not\n                  // get instantiated when not actually needed.\n                  if (part->m_partRaw && part->m_partRaw->loading()) {\n                      part->m_partRaw->m_data = data;\n                      part->m_partRaw->setFetchStatus(DONE);\n                      changedParts.append(part->m_partRaw);\n                      if (message->uid()) {\n                          model->cache()->forgetMessagePart(mailbox(), message->uid(), part->partId());\n                          model->cache()->setMsgPart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\"), data);\n                      }\n                  }\n  \n                  // Do not overwrite the part data if we were not asked to fetch it.\n                  // One possibility is that it's already there because it was fetched before. The second option is that\n                  // we were in fact asked to only fetch the raw data and the user is not itnerested in the processed data at all.\n                  if (part->loading()) {\n                      // got to decode the part data by hand\n                      Imap::decodeContentTransferEncoding(data, part->encoding(), part->dataPtr());\n                      part->setFetchStatus(DONE);\n                      changedParts.append(part);\n                      if (message->uid()\n                              && model->cache()->messagePart(mailbox(), message->uid(), part->partId() + QLatin1String(\".X-RAW\")).isNull()) {\n                          // Do not store the data into cache if the raw data are already there\n                          model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                      }\n                  }\n  \n              } else {\n                  // A BINARY FETCH item is already decoded for us, yay\n                  part->m_data = data;\n                  part->setFetchStatus(DONE);\n                  changedParts.append(part);\n                  if (message->uid()) {\n                      model->cache()->setMsgPart(mailbox(), message->uid(), part->partId(), part->m_data);\n                  }\n              }\n          } else if (it.key() == \"INTERNALDATE\") {\n              message->data()->m_internalDate = static_cast<const Responses::RespData<QDateTime>&>(*(it.value())).data;\n              gotInternalDate = true;\n          } else {\n              qDebug() << \"TreeItemMailbox::handleFetchResponse: unknown FETCH identifier\" << it.key();\n          }\n      }\n      if (message->uid()) {\n          if (gotEnvelope && gotSize && savedBodyStructure && gotInternalDate) {\n              Imap::Mailbox::AbstractCache::MessageDataBundle dataForCache;\n              dataForCache.envelope = message->data()->m_envelope;\n              dataForCache.serializedBodyStructure = static_cast<const Responses::RespData<QByteArray>&>(*(response.data[ \"x-trojita-bodystructure\" ])).data;\n              dataForCache.size = message->data()->m_size;\n              dataForCache.uid = message->uid();\n              dataForCache.internalDate = message->data()->m_internalDate;\n              dataForCache.hdrReferences = message->data()->m_hdrReferences;\n              dataForCache.hdrListPost = message->data()->m_hdrListPost;\n              dataForCache.hdrListPostNo = message->data()->m_hdrListPostNo;\n              model->cache()->setMessageMetadata(mailbox(), message->uid(), dataForCache);\n          }\n          if (updatedFlags) {\n              model->cache()->setMsgFlags(mailbox(), message->uid(), message->m_flags);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleFetch(const Imap::Responses::Fetch *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      QList<TreeItemPart *> changedParts;\n      TreeItemMessage *changedMessage = 0;\n      mailbox->handleFetchResponse(model, *resp, changedParts, changedMessage, m_usingQresync);\n      if (changedMessage) {\n          QModelIndex index = changedMessage->toIndex(model);\n          emit model->dataChanged(index, index);\n          if (mailbox->syncState.uidNext() <= changedMessage->uid()) {\n              mailbox->syncState.setUidNext(changedMessage->uid() + 1);\n          }\n          // On the other hand, this one will be emitted at the very end\n          // model->emitMessageCountChanged(mailbox);\n      }\n      if (!changedParts.isEmpty() && !m_usingQresync) {\n          // On the other hand, with QRESYNC our code is ready to receive extra data that changes body parts...\n          qDebug() << \"Weird, FETCH when syncing has changed some body parts. We aren't ready for that.\";\n          log(QLatin1String(\"This response has changed some message parts. That should not have happened, as we're still syncing.\"));\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "finalizeSearch(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "918-964",
    "snippet": "oid ObtainSynchronizedMailboxTask::finalizeSearch()\n{\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n\n    switch (uidSyncingMode) {\n    case UID_SYNC_ALL:\n        if (static_cast<uint>(uidMap.size()) != mailbox->syncState.exists()) {\n            // The (possibly updated) EXISTS does not match what we received for UID (E)SEARCH ALL. Please note that\n            // it's the server's responsibility to feed us with valid data; scenarios like sending out-of-order responses\n            // would clearly break this contract.\n            std::ostringstream ss;\n            ss << \"Error when synchronizing all messages: server said that there are \" << mailbox->syncState.exists() <<\n                  \" messages, but UID (E)SEARCH ALL response contains \" << uidMap.size() << \" entries\" << std::endl;\n            ss.flush();\n            throw MailboxException(ss.str().c_str());\n        }\n        break;\n    case UID_SYNC_ONLY_NEW:\n    {\n        // Be sure there really are some new messages\n        const int newArrivals = mailbox->syncState.exists() - firstUnknownUidOffset;\n        Q_ASSERT(newArrivals >= 0);\n\n        if (newArrivals != uidMap.size()) {\n            std::ostringstream ss;\n            ss << \"Error when synchronizing new messages: server said that there are \" << mailbox->syncState.exists() <<\n                  \" messages in total (\" << newArrivals << \" new), but UID (E)SEARCH response contains \" << uidMap.size() <<\n                  \" entries\" << std::endl;\n            ss.flush();\n            throw MailboxException(ss.str().c_str());\n        }\n        break;\n    }\n    }\n\n    qSort(uidMap);\n    if (!uidMap.isEmpty() && uidMap.front() == 0) {\n        throw MailboxException(\"UID (E)SEARCH response contains invalid UID zero\");\n    }\n    applyUids(mailbox);\n    uidMap.clear();\n    updateHighestKnownUid(mailbox, list);\n    status = STATE_SYNCING_FLAGS;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdateHighestKnownUid(",
          "args": [
            "ailbox,",
            "ist)"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "updateHighestKnownUid(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "670-680",
          "snippet": "oid ObtainSynchronizedMailboxTask::updateHighestKnownUid(TreeItemMailbox *mailbox, const TreeItemMsgList *list) const\n{\n    uint highestKnownUid = 0;\n    for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n        highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n    }\n    if (highestKnownUid) {\n        // If the UID walk return a usable number, remember that and use it for updating our idea of the UIDNEXT\n        mailbox->syncState.setUidNext(qMax(mailbox->syncState.uidNext(), highestKnownUid + 1));\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::updateHighestKnownUid(TreeItemMailbox *mailbox, const TreeItemMsgList *list) const\n  {\n      uint highestKnownUid = 0;\n      for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n          highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n      }\n      if (highestKnownUid) {\n          // If the UID walk return a usable number, remember that and use it for updating our idea of the UIDNEXT\n          mailbox->syncState.setUidNext(qMax(mailbox->syncState.uidNext(), highestKnownUid + 1));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "idMap.clear",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pplyUids(",
          "args": [
            "ailbox)"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "applyUids(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "997-1100",
          "snippet": "oid ObtainSynchronizedMailboxTask::applyUids(TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    QModelIndex parent = list->toIndex(model);\n    list->m_children.reserve(mailbox->syncState.exists());\n\n    int i = firstUnknownUidOffset;\n    while (i < uidMap.size() + static_cast<int>(firstUnknownUidOffset)) {\n        // Index inside the uidMap in which the UID of a message at offset i in the list->m_children can be found\n        int uidOffset = i - firstUnknownUidOffset;\n        Q_ASSERT(uidOffset >= 0);\n        Q_ASSERT(uidOffset < uidMap.size());\n\n        // For each UID which is really supposed to be there...\n\n        Q_ASSERT(i <= list->m_children.size());\n        if (i == list->m_children.size()) {\n            // now we're just adding new messages to the end of the list\n            const int futureTotalMessages = mailbox->syncState.exists();\n            model->beginInsertRows(parent, i, futureTotalMessages - 1);\n            for (/*nothing*/; i < futureTotalMessages; ++i) {\n                // Add all messages in one go\n                TreeItemMessage *msg = new TreeItemMessage(list);\n                msg->m_offset = i;\n                // We're iterating with i, so we got to update the uidOffset\n                uidOffset = i - firstUnknownUidOffset;\n                Q_ASSERT(uidOffset >= 0);\n                Q_ASSERT(uidOffset < uidMap.size());\n                msg->m_uid = uidMap[uidOffset];\n                list->m_children << msg;\n            }\n            model->endInsertRows();\n            Q_ASSERT(i == list->m_children.size());\n            Q_ASSERT(i == futureTotalMessages);\n        } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == uidMap[uidOffset]) {\n            // If the UID of the \"current message\" matches, we're okay\n            static_cast<TreeItemMessage *>(list->m_children[i])->m_offset = i;\n            ++i;\n        } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == 0) {\n            // If the UID of the \"current message\" is zero, replace that with this message\n            TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n            msg->m_uid = uidMap[uidOffset];\n            msg->m_offset = i;\n            QModelIndex idx = model->createIndex(i, 0, msg);\n            emit model->dataChanged(idx, idx);\n            if (msg->accessFetchStatus() == TreeItem::LOADING) {\n                // We've got to ask for the message metadata once again; the first attempt happened when the UID was still zero,\n                // so this is our chance\n                model->askForMsgMetadata(msg, Model::PRELOAD_PER_POLICY);\n            }\n            ++i;\n        } else {\n            // We've got an UID mismatch\n            int pos = i;\n            while (pos < list->m_children.size()) {\n                // Remove any messages which have non-zero UID which is at the same time different than the UID we want to add\n                // The key idea here is that IMAP guarantees that each and every new message will have greater UID than any\n                // other message already in the mailbox. Just for the sake of completeness, should an evil server send us a\n                // malformed response, we wouldn't care (or notice at this point), we'd just \"needlessly\" delete many \"innocent\"\n                // messages due to that one out-of-place arrival -- but we'd still remain correct and not crash.\n                TreeItemMessage *otherMessage = static_cast<TreeItemMessage*>(list->m_children[pos]);\n                if (otherMessage->m_uid != 0 && otherMessage->m_uid != uidMap[uidOffset]) {\n                    model->cache()->clearMessage(mailbox->mailbox(), otherMessage->uid());\n                    ++pos;\n                } else {\n                    break;\n                }\n            }\n            Q_ASSERT(pos > i);\n            model->beginRemoveRows(parent, i, pos - 1);\n            TreeItemChildrenList removedItems = list->m_children.mid(i, pos - i);\n            list->m_children.erase(list->m_children.begin() + i, list->m_children.begin() + pos);\n            model->endRemoveRows();\n            // the m_offset of all subsequent messages will be updated later, at the time *they* are processed\n            qDeleteAll(removedItems);\n            if (i == list->m_children.size()) {\n                // We're asked to add messages to the end of the list. That's something that's already implemented above,\n                // so let's reuse that code. That's why we do *not* want to increment the counter here.\n            } else {\n                Q_ASSERT(i < list->m_children.size());\n                // But this case is also already implemented above, so we won't touch the counter from here, either,\n                // and let the existing code do its job\n            }\n        }\n    }\n\n    if (i != list->m_children.size()) {\n        // remove items at the end\n        model->beginRemoveRows(parent, i, list->m_children.size() - 1);\n        TreeItemChildrenList removedItems = list->m_children.mid(i);\n        list->m_children.erase(list->m_children.begin() + i, list->m_children.end());\n        model->endRemoveRows();\n        qDeleteAll(removedItems);\n    }\n\n    uidMap.clear();\n\n    list->m_totalMessageCount = list->m_children.size();\n    list->setFetchStatus(TreeItem::DONE);\n\n    model->emitMessageCountChanged(mailbox);\n    model->changeConnectionState(parser, CONN_STATE_SELECTED);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::applyUids(TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      QModelIndex parent = list->toIndex(model);\n      list->m_children.reserve(mailbox->syncState.exists());\n  \n      int i = firstUnknownUidOffset;\n      while (i < uidMap.size() + static_cast<int>(firstUnknownUidOffset)) {\n          // Index inside the uidMap in which the UID of a message at offset i in the list->m_children can be found\n          int uidOffset = i - firstUnknownUidOffset;\n          Q_ASSERT(uidOffset >= 0);\n          Q_ASSERT(uidOffset < uidMap.size());\n  \n          // For each UID which is really supposed to be there...\n  \n          Q_ASSERT(i <= list->m_children.size());\n          if (i == list->m_children.size()) {\n              // now we're just adding new messages to the end of the list\n              const int futureTotalMessages = mailbox->syncState.exists();\n              model->beginInsertRows(parent, i, futureTotalMessages - 1);\n              for (/*nothing*/; i < futureTotalMessages; ++i) {\n                  // Add all messages in one go\n                  TreeItemMessage *msg = new TreeItemMessage(list);\n                  msg->m_offset = i;\n                  // We're iterating with i, so we got to update the uidOffset\n                  uidOffset = i - firstUnknownUidOffset;\n                  Q_ASSERT(uidOffset >= 0);\n                  Q_ASSERT(uidOffset < uidMap.size());\n                  msg->m_uid = uidMap[uidOffset];\n                  list->m_children << msg;\n              }\n              model->endInsertRows();\n              Q_ASSERT(i == list->m_children.size());\n              Q_ASSERT(i == futureTotalMessages);\n          } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == uidMap[uidOffset]) {\n              // If the UID of the \"current message\" matches, we're okay\n              static_cast<TreeItemMessage *>(list->m_children[i])->m_offset = i;\n              ++i;\n          } else if (static_cast<TreeItemMessage *>(list->m_children[i])->m_uid == 0) {\n              // If the UID of the \"current message\" is zero, replace that with this message\n              TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n              msg->m_uid = uidMap[uidOffset];\n              msg->m_offset = i;\n              QModelIndex idx = model->createIndex(i, 0, msg);\n              emit model->dataChanged(idx, idx);\n              if (msg->accessFetchStatus() == TreeItem::LOADING) {\n                  // We've got to ask for the message metadata once again; the first attempt happened when the UID was still zero,\n                  // so this is our chance\n                  model->askForMsgMetadata(msg, Model::PRELOAD_PER_POLICY);\n              }\n              ++i;\n          } else {\n              // We've got an UID mismatch\n              int pos = i;\n              while (pos < list->m_children.size()) {\n                  // Remove any messages which have non-zero UID which is at the same time different than the UID we want to add\n                  // The key idea here is that IMAP guarantees that each and every new message will have greater UID than any\n                  // other message already in the mailbox. Just for the sake of completeness, should an evil server send us a\n                  // malformed response, we wouldn't care (or notice at this point), we'd just \"needlessly\" delete many \"innocent\"\n                  // messages due to that one out-of-place arrival -- but we'd still remain correct and not crash.\n                  TreeItemMessage *otherMessage = static_cast<TreeItemMessage*>(list->m_children[pos]);\n                  if (otherMessage->m_uid != 0 && otherMessage->m_uid != uidMap[uidOffset]) {\n                      model->cache()->clearMessage(mailbox->mailbox(), otherMessage->uid());\n                      ++pos;\n                  } else {\n                      break;\n                  }\n              }\n              Q_ASSERT(pos > i);\n              model->beginRemoveRows(parent, i, pos - 1);\n              TreeItemChildrenList removedItems = list->m_children.mid(i, pos - i);\n              list->m_children.erase(list->m_children.begin() + i, list->m_children.begin() + pos);\n              model->endRemoveRows();\n              // the m_offset of all subsequent messages will be updated later, at the time *they* are processed\n              qDeleteAll(removedItems);\n              if (i == list->m_children.size()) {\n                  // We're asked to add messages to the end of the list. That's something that's already implemented above,\n                  // so let's reuse that code. That's why we do *not* want to increment the counter here.\n              } else {\n                  Q_ASSERT(i < list->m_children.size());\n                  // But this case is also already implemented above, so we won't touch the counter from here, either,\n                  // and let the existing code do its job\n              }\n          }\n      }\n  \n      if (i != list->m_children.size()) {\n          // remove items at the end\n          model->beginRemoveRows(parent, i, list->m_children.size() - 1);\n          TreeItemChildrenList removedItems = list->m_children.mid(i);\n          list->m_children.erase(list->m_children.begin() + i, list->m_children.end());\n          model->endRemoveRows();\n          qDeleteAll(removedItems);\n      }\n  \n      uidMap.clear();\n  \n      list->m_totalMessageCount = list->m_children.size();\n      list->setFetchStatus(TreeItem::DONE);\n  \n      model->emitMessageCountChanged(mailbox);\n      model->changeConnectionState(parser, CONN_STATE_SELECTED);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxException(",
          "args": [
            "UID (E)SEARCH response contains invalid UID zero\")"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "MailboxException(",
          "container": "ailboxException",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Exceptions.cpp",
          "lines": "56-60",
          "snippet": "ailboxException::MailboxException(const char *const msg)\n{\n    m_msg = msg;\n    m_exceptionClass = \"MailboxException\";\n}",
          "includes": [
            "include \"Parser/Response.h\"",
            "include <QTextStream>\n#",
            "include \"Exceptions.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/Response.h\"\ninclude <QTextStream>\n#\ninclude \"Exceptions.h\"\n\nailboxException {\n  ailboxException::MailboxException(const char *const msg)\n  {\n      m_msg = msg;\n      m_exceptionClass = \"MailboxException\";\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "idMap.front",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.isEmpty",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sort(",
          "args": [
            "idMap)"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "handleSort(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "170-174",
          "snippet": "ool ImapTask::handleSort(const Imap::Responses::Sort *const resp)\n{\n    Q_UNUSED(resp);\n    return false;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  ool ImapTask::handleSort(const Imap::Responses::Sort *const resp)\n  {\n      Q_UNUSED(resp);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.str",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.str",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.flush",
          "args": [],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ewArrivals >= 0)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.str",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.str",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.flush",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "idMap.size())"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList*>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::finalizeSearch()\n  {\n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n  \n      switch (uidSyncingMode) {\n      case UID_SYNC_ALL:\n          if (static_cast<uint>(uidMap.size()) != mailbox->syncState.exists()) {\n              // The (possibly updated) EXISTS does not match what we received for UID (E)SEARCH ALL. Please note that\n              // it's the server's responsibility to feed us with valid data; scenarios like sending out-of-order responses\n              // would clearly break this contract.\n              std::ostringstream ss;\n              ss << \"Error when synchronizing all messages: server said that there are \" << mailbox->syncState.exists() <<\n                    \" messages, but UID (E)SEARCH ALL response contains \" << uidMap.size() << \" entries\" << std::endl;\n              ss.flush();\n              throw MailboxException(ss.str().c_str());\n          }\n          break;\n      case UID_SYNC_ONLY_NEW:\n      {\n          // Be sure there really are some new messages\n          const int newArrivals = mailbox->syncState.exists() - firstUnknownUidOffset;\n          Q_ASSERT(newArrivals >= 0);\n  \n          if (newArrivals != uidMap.size()) {\n              std::ostringstream ss;\n              ss << \"Error when synchronizing new messages: server said that there are \" << mailbox->syncState.exists() <<\n                    \" messages in total (\" << newArrivals << \" new), but UID (E)SEARCH response contains \" << uidMap.size() <<\n                    \" entries\" << std::endl;\n              ss.flush();\n              throw MailboxException(ss.str().c_str());\n          }\n          break;\n      }\n      }\n  \n      qSort(uidMap);\n      if (!uidMap.isEmpty() && uidMap.front() == 0) {\n          throw MailboxException(\"UID (E)SEARCH response contains invalid UID zero\");\n      }\n      applyUids(mailbox);\n      uidMap.clear();\n      updateHighestKnownUid(mailbox, list);\n      status = STATE_SYNCING_FLAGS;\n  }\n}"
  },
  {
    "function_name": "handleEnabled(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "903-915",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleEnabled(const Responses::Enabled * const resp)\n{\n    if (dieIfInvalidMailbox())\n        return false;\n\n    // This function is needed to work around a bug in Kolab's version of Cyrus which sometimes sends out untagged ENABLED\n    // during the SELECT processing. RFC 5161 is pretty clear in saying that ENABLED shall be sent only in response to\n    // the ENABLE command; the log submitted at https://bugs.kde.org/show_bug.cgi?id=329204#c5 shows that Trojita receives\n    // an extra * ENABLED CONDSTORE QRESYNC even after we have issued the x ENABLE QRESYNC previously and the server already\n    // replied with * ENABLED QRESYNC to that.\n\n    return resp->extensions.contains(\"CONDSTORE\") || resp->extensions.contains(\"QRESYNC\");\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esp->extensions.contains",
          "args": [
            "QRESYNC\")"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->extensions.contains",
          "args": [
            "CONDSTORE\")"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleEnabled(const Responses::Enabled * const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return false;\n  \n      // This function is needed to work around a bug in Kolab's version of Cyrus which sometimes sends out untagged ENABLED\n      // during the SELECT processing. RFC 5161 is pretty clear in saying that ENABLED shall be sent only in response to\n      // the ENABLE command; the log submitted at https://bugs.kde.org/show_bug.cgi?id=329204#c5 shows that Trojita receives\n      // an extra * ENABLED CONDSTORE QRESYNC even after we have issued the x ENABLE QRESYNC previously and the server already\n      // replied with * ENABLED QRESYNC to that.\n  \n      return resp->extensions.contains(\"CONDSTORE\") || resp->extensions.contains(\"QRESYNC\");\n  }\n}"
  },
  {
    "function_name": "handleESearch(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "873-901",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleESearch(const Imap::Responses::ESearch *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    if (resp->tag.isEmpty() || resp->tag != uidSyncingCmd)\n        return false;\n\n    if (resp->seqOrUids != Imap::Responses::ESearch::UIDS)\n        throw UnexpectedResponseReceived(\"ESEARCH response with matching tag uses sequence numbers instead of UIDs\", *resp);\n\n    // Yes, I just love templates.\n    Responses::ESearch::CompareListDataIdentifier<Responses::ESearch::ListData_t> allComparator(\"ALL\");\n    Responses::ESearch::ListData_t::const_iterator listIterator =\n            std::find_if(resp->listData.constBegin(), resp->listData.constEnd(), allComparator);\n\n    if (listIterator != resp->listData.constEnd()) {\n        uidMap = listIterator->second;\n        ++listIterator;\n        if (std::find_if(listIterator, resp->listData.constEnd(), allComparator) != resp->listData.constEnd())\n            throw UnexpectedResponseReceived(\"ESEARCH contains the ALL key too many times\", *resp);\n    } else {\n        // If the ALL key is not present, the server is telling us that there are no messages matching the query\n        uidMap.clear();\n    }\n\n    finalizeSearch();\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inalizeSearch(",
          "args": [],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "finalizeSearch(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "918-964",
          "snippet": "oid ObtainSynchronizedMailboxTask::finalizeSearch()\n{\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n\n    switch (uidSyncingMode) {\n    case UID_SYNC_ALL:\n        if (static_cast<uint>(uidMap.size()) != mailbox->syncState.exists()) {\n            // The (possibly updated) EXISTS does not match what we received for UID (E)SEARCH ALL. Please note that\n            // it's the server's responsibility to feed us with valid data; scenarios like sending out-of-order responses\n            // would clearly break this contract.\n            std::ostringstream ss;\n            ss << \"Error when synchronizing all messages: server said that there are \" << mailbox->syncState.exists() <<\n                  \" messages, but UID (E)SEARCH ALL response contains \" << uidMap.size() << \" entries\" << std::endl;\n            ss.flush();\n            throw MailboxException(ss.str().c_str());\n        }\n        break;\n    case UID_SYNC_ONLY_NEW:\n    {\n        // Be sure there really are some new messages\n        const int newArrivals = mailbox->syncState.exists() - firstUnknownUidOffset;\n        Q_ASSERT(newArrivals >= 0);\n\n        if (newArrivals != uidMap.size()) {\n            std::ostringstream ss;\n            ss << \"Error when synchronizing new messages: server said that there are \" << mailbox->syncState.exists() <<\n                  \" messages in total (\" << newArrivals << \" new), but UID (E)SEARCH response contains \" << uidMap.size() <<\n                  \" entries\" << std::endl;\n            ss.flush();\n            throw MailboxException(ss.str().c_str());\n        }\n        break;\n    }\n    }\n\n    qSort(uidMap);\n    if (!uidMap.isEmpty() && uidMap.front() == 0) {\n        throw MailboxException(\"UID (E)SEARCH response contains invalid UID zero\");\n    }\n    applyUids(mailbox);\n    uidMap.clear();\n    updateHighestKnownUid(mailbox, list);\n    status = STATE_SYNCING_FLAGS;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::finalizeSearch()\n  {\n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n  \n      switch (uidSyncingMode) {\n      case UID_SYNC_ALL:\n          if (static_cast<uint>(uidMap.size()) != mailbox->syncState.exists()) {\n              // The (possibly updated) EXISTS does not match what we received for UID (E)SEARCH ALL. Please note that\n              // it's the server's responsibility to feed us with valid data; scenarios like sending out-of-order responses\n              // would clearly break this contract.\n              std::ostringstream ss;\n              ss << \"Error when synchronizing all messages: server said that there are \" << mailbox->syncState.exists() <<\n                    \" messages, but UID (E)SEARCH ALL response contains \" << uidMap.size() << \" entries\" << std::endl;\n              ss.flush();\n              throw MailboxException(ss.str().c_str());\n          }\n          break;\n      case UID_SYNC_ONLY_NEW:\n      {\n          // Be sure there really are some new messages\n          const int newArrivals = mailbox->syncState.exists() - firstUnknownUidOffset;\n          Q_ASSERT(newArrivals >= 0);\n  \n          if (newArrivals != uidMap.size()) {\n              std::ostringstream ss;\n              ss << \"Error when synchronizing new messages: server said that there are \" << mailbox->syncState.exists() <<\n                    \" messages in total (\" << newArrivals << \" new), but UID (E)SEARCH response contains \" << uidMap.size() <<\n                    \" entries\" << std::endl;\n              ss.flush();\n              throw MailboxException(ss.str().c_str());\n          }\n          break;\n      }\n      }\n  \n      qSort(uidMap);\n      if (!uidMap.isEmpty() && uidMap.front() == 0) {\n          throw MailboxException(\"UID (E)SEARCH response contains invalid UID zero\");\n      }\n      applyUids(mailbox);\n      uidMap.clear();\n      updateHighestKnownUid(mailbox, list);\n      status = STATE_SYNCING_FLAGS;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "idMap.clear",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "ESEARCH contains the ALL key too many times\",",
            "resp)"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "istIterator,",
            "esp->listData.constEnd(),",
            "llComparator)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "esp->listData.constBegin(),",
            "esp->listData.constEnd(),",
            "llComparator)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constBegin",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "ESEARCH response with matching tag uses sequence numbers instead of UIDs\",",
            "resp)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleESearch(const Imap::Responses::ESearch *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      if (resp->tag.isEmpty() || resp->tag != uidSyncingCmd)\n          return false;\n  \n      if (resp->seqOrUids != Imap::Responses::ESearch::UIDS)\n          throw UnexpectedResponseReceived(\"ESEARCH response with matching tag uses sequence numbers instead of UIDs\", *resp);\n  \n      // Yes, I just love templates.\n      Responses::ESearch::CompareListDataIdentifier<Responses::ESearch::ListData_t> allComparator(\"ALL\");\n      Responses::ESearch::ListData_t::const_iterator listIterator =\n              std::find_if(resp->listData.constBegin(), resp->listData.constEnd(), allComparator);\n  \n      if (listIterator != resp->listData.constEnd()) {\n          uidMap = listIterator->second;\n          ++listIterator;\n          if (std::find_if(listIterator, resp->listData.constEnd(), allComparator) != resp->listData.constEnd())\n              throw UnexpectedResponseReceived(\"ESEARCH contains the ALL key too many times\", *resp);\n      } else {\n          // If the ALL key is not present, the server is telling us that there are no messages matching the query\n          uidMap.clear();\n      }\n  \n      finalizeSearch();\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleSearch(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "857-871",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleSearch(const Imap::Responses::Search *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    if (uidSyncingCmd.isEmpty())\n        return false;\n\n    Q_ASSERT(Model::mailboxForSomeItem(mailboxIndex));\n\n    uidMap += resp->items;\n\n    finalizeSearch();\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inalizeSearch(",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "finalizeSearch(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "918-964",
          "snippet": "oid ObtainSynchronizedMailboxTask::finalizeSearch()\n{\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n\n    switch (uidSyncingMode) {\n    case UID_SYNC_ALL:\n        if (static_cast<uint>(uidMap.size()) != mailbox->syncState.exists()) {\n            // The (possibly updated) EXISTS does not match what we received for UID (E)SEARCH ALL. Please note that\n            // it's the server's responsibility to feed us with valid data; scenarios like sending out-of-order responses\n            // would clearly break this contract.\n            std::ostringstream ss;\n            ss << \"Error when synchronizing all messages: server said that there are \" << mailbox->syncState.exists() <<\n                  \" messages, but UID (E)SEARCH ALL response contains \" << uidMap.size() << \" entries\" << std::endl;\n            ss.flush();\n            throw MailboxException(ss.str().c_str());\n        }\n        break;\n    case UID_SYNC_ONLY_NEW:\n    {\n        // Be sure there really are some new messages\n        const int newArrivals = mailbox->syncState.exists() - firstUnknownUidOffset;\n        Q_ASSERT(newArrivals >= 0);\n\n        if (newArrivals != uidMap.size()) {\n            std::ostringstream ss;\n            ss << \"Error when synchronizing new messages: server said that there are \" << mailbox->syncState.exists() <<\n                  \" messages in total (\" << newArrivals << \" new), but UID (E)SEARCH response contains \" << uidMap.size() <<\n                  \" entries\" << std::endl;\n            ss.flush();\n            throw MailboxException(ss.str().c_str());\n        }\n        break;\n    }\n    }\n\n    qSort(uidMap);\n    if (!uidMap.isEmpty() && uidMap.front() == 0) {\n        throw MailboxException(\"UID (E)SEARCH response contains invalid UID zero\");\n    }\n    applyUids(mailbox);\n    uidMap.clear();\n    updateHighestKnownUid(mailbox, list);\n    status = STATE_SYNCING_FLAGS;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::finalizeSearch()\n  {\n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n  \n      switch (uidSyncingMode) {\n      case UID_SYNC_ALL:\n          if (static_cast<uint>(uidMap.size()) != mailbox->syncState.exists()) {\n              // The (possibly updated) EXISTS does not match what we received for UID (E)SEARCH ALL. Please note that\n              // it's the server's responsibility to feed us with valid data; scenarios like sending out-of-order responses\n              // would clearly break this contract.\n              std::ostringstream ss;\n              ss << \"Error when synchronizing all messages: server said that there are \" << mailbox->syncState.exists() <<\n                    \" messages, but UID (E)SEARCH ALL response contains \" << uidMap.size() << \" entries\" << std::endl;\n              ss.flush();\n              throw MailboxException(ss.str().c_str());\n          }\n          break;\n      case UID_SYNC_ONLY_NEW:\n      {\n          // Be sure there really are some new messages\n          const int newArrivals = mailbox->syncState.exists() - firstUnknownUidOffset;\n          Q_ASSERT(newArrivals >= 0);\n  \n          if (newArrivals != uidMap.size()) {\n              std::ostringstream ss;\n              ss << \"Error when synchronizing new messages: server said that there are \" << mailbox->syncState.exists() <<\n                    \" messages in total (\" << newArrivals << \" new), but UID (E)SEARCH response contains \" << uidMap.size() <<\n                    \" entries\" << std::endl;\n              ss.flush();\n              throw MailboxException(ss.str().c_str());\n          }\n          break;\n      }\n      }\n  \n      qSort(uidMap);\n      if (!uidMap.isEmpty() && uidMap.front() == 0) {\n          throw MailboxException(\"UID (E)SEARCH response contains invalid UID zero\");\n      }\n      applyUids(mailbox);\n      uidMap.clear();\n      updateHighestKnownUid(mailbox, list);\n      status = STATE_SYNCING_FLAGS;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel::mailboxForSomeItem(mailboxIndex))"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idSyncingCmd.isEmpty",
          "args": [],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleSearch(const Imap::Responses::Search *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      if (uidSyncingCmd.isEmpty())\n          return false;\n  \n      Q_ASSERT(Model::mailboxForSomeItem(mailboxIndex));\n  \n      uidMap += resp->items;\n  \n      finalizeSearch();\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleFlags(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "846-855",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleFlags(const Imap::Responses::Flags *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    mailbox->syncState.setFlags(resp->flags);\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailbox->syncState.setFlags",
          "args": [
            "esp->flags)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleFlags(const Imap::Responses::Flags *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      mailbox->syncState.setFlags(resp->flags);\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleVanished(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "821-844",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleVanished(const Imap::Responses::Vanished *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n\n    switch (status) {\n    case STATE_WAIT_FOR_CONN:\n        Q_ASSERT(false);\n        return false;\n\n    case STATE_SELECTING:\n    case STATE_SYNCING_UIDS:\n    case STATE_SYNCING_FLAGS:\n    case STATE_DONE:\n        mailbox->handleVanished(model, *resp);\n        return true;\n    }\n\n    Q_ASSERT(false);\n    return false;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->handleVanished",
          "args": [
            "odel,",
            "resp)"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "handleVanished(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "609-736",
          "snippet": "oid TreeItemMailbox::handleVanished(Model *const model, const Responses::Vanished &resp)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n    Q_ASSERT(list);\n    QModelIndex listIndex = list->toIndex(model);\n\n    QList<uint> uids = resp.uids;\n    qSort(uids);\n    // Remove duplicates -- even that garbage can be present in a perfectly valid VANISHED :(\n    uids.erase(std::unique(uids.begin(), uids.end()), uids.end());\n\n    auto it = list->m_children.end();\n    while (!uids.isEmpty()) {\n        // We have to process each UID separately because the UIDs in the mailbox are not necessarily present\n        // in a continuous range; zeros might be present\n        uint uid = uids.takeLast();\n\n        if (uid == 0) {\n            qDebug() << \"VANISHED informs about removal of UID zero...\";\n            model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                            \"VANISHED contains UID zero for increased fun\");\n            break;\n        }\n\n        if (list->m_children.isEmpty()) {\n            // Well, it'd be cool to throw an exception here but VANISHED is free to contain references to UIDs which are not here\n            // at all...\n            qDebug() << \"VANISHED attempted to remove too many messages\";\n            model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                            \"VANISHED attempted to remove too many messages\");\n            break;\n        }\n\n        // Find a highest message with UID zero such as no message with non-zero UID higher than the current UID exists\n        // at a position after the target message\n        it = model->findMessageOrNextOneByUid(list, uid);\n\n        if (it == list->m_children.end()) {\n            // this is a legitimate situation, the UID of the last message in the mailbox which is getting expunged right now\n            // could very well be not know at this point\n            --it;\n        }\n        // there's a special case above guarding against an empty list\n        Q_ASSERT(it >= list->m_children.begin());\n\n        TreeItemMessage *msgCandidate = static_cast<TreeItemMessage*>(*it);\n        if (msgCandidate->uid() == uid) {\n            // will be deleted\n        } else if (resp.earlier == Responses::Vanished::EARLIER) {\n            // We don't have any such UID in our UID mapping, so we can safely ignore this one\n            continue;\n        } else if (msgCandidate->uid() == 0) {\n            // will be deleted\n        } else {\n            if (it != list->m_children.begin()) {\n                --it;\n                msgCandidate = static_cast<TreeItemMessage*>(*it);\n                if (msgCandidate->uid() == 0) {\n                    // will be deleted\n                } else {\n                    // VANISHED is free to refer to a non-existing UID...\n                    QString str;\n                    QTextStream ss(&str);\n                    ss << \"VANISHED refers to UID \" << uid << \" which wasn't found in the mailbox (found adjacent UIDs \" <<\n                          msgCandidate->uid() << \" and \" << static_cast<TreeItemMessage*>(*(it + 1))->uid() << \" with \" <<\n                          static_cast<TreeItemMessage*>(*(list->m_children.end() - 1))->uid() << \" at the end)\";\n                    ss.flush();\n                    qDebug() << str.toUtf8().constData();\n                    model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                    continue;\n                }\n            } else {\n                // Again, VANISHED can refer to non-existing UIDs\n                QString str;\n                QTextStream ss(&str);\n                ss << \"VANISHED refers to UID \" << uid << \" which is too low (lowest UID is \" <<\n                      static_cast<TreeItemMessage*>(list->m_children.front())->uid() << \")\";\n                ss.flush();\n                qDebug() << str.toUtf8().constData();\n                model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                continue;\n            }\n        }\n\n        int row = msgCandidate->row();\n        Q_ASSERT(row == it - list->m_children.begin());\n        model->beginRemoveRows(listIndex, row, row);\n        it = list->m_children.erase(it);\n        for (auto furtherMessage = it; furtherMessage != list->m_children.end(); ++furtherMessage) {\n            --static_cast<TreeItemMessage *>(*furtherMessage)->m_offset;\n        }\n        model->endRemoveRows();\n\n        if (syncState.uidNext() <= uid) {\n            // We're informed about a message being deleted; this means that that UID must have been in the mailbox for some\n            // (possibly tiny) time and we can therefore use it to get an idea about the UIDNEXT\n            syncState.setUidNext(uid + 1);\n        }\n        model->cache()->clearMessage(mailbox(), uid);\n        delete msgCandidate;\n    }\n\n    if (resp.earlier == Responses::Vanished::EARLIER && static_cast<uint>(list->m_children.size()) < syncState.exists()) {\n        // Okay, there were some new arrivals which we failed to take into account because we had processed EXISTS\n        // before VANISHED (EARLIER). That means that we have to add some of that messages back right now.\n        int newArrivals = syncState.exists() - list->m_children.size();\n        Q_ASSERT(newArrivals > 0);\n        QModelIndex parent = list->toIndex(model);\n        int offset = list->m_children.size();\n        model->beginInsertRows(parent, offset, syncState.exists() - 1);\n        for (int i = 0; i < newArrivals; ++i) {\n            TreeItemMessage *msg = new TreeItemMessage(list);\n            msg->m_offset = i + offset;\n            list->m_children << msg;\n            // yes, we really have to add this message with UID 0 :(\n        }\n        model->endInsertRows();\n    }\n\n    list->m_totalMessageCount = list->m_children.size();\n    syncState.setExists(list->m_totalMessageCount);\n    list->recalcVariousMessageCounts(const_cast<Model *>(model));\n\n    if (list->accessFetchStatus() == DONE) {\n        // Previously, we were synced, so we got to save this update\n        saveSyncStateAndUids(model);\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleVanished(Model *const model, const Responses::Vanished &resp)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n      Q_ASSERT(list);\n      QModelIndex listIndex = list->toIndex(model);\n  \n      QList<uint> uids = resp.uids;\n      qSort(uids);\n      // Remove duplicates -- even that garbage can be present in a perfectly valid VANISHED :(\n      uids.erase(std::unique(uids.begin(), uids.end()), uids.end());\n  \n      auto it = list->m_children.end();\n      while (!uids.isEmpty()) {\n          // We have to process each UID separately because the UIDs in the mailbox are not necessarily present\n          // in a continuous range; zeros might be present\n          uint uid = uids.takeLast();\n  \n          if (uid == 0) {\n              qDebug() << \"VANISHED informs about removal of UID zero...\";\n              model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                              \"VANISHED contains UID zero for increased fun\");\n              break;\n          }\n  \n          if (list->m_children.isEmpty()) {\n              // Well, it'd be cool to throw an exception here but VANISHED is free to contain references to UIDs which are not here\n              // at all...\n              qDebug() << \"VANISHED attempted to remove too many messages\";\n              model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                              \"VANISHED attempted to remove too many messages\");\n              break;\n          }\n  \n          // Find a highest message with UID zero such as no message with non-zero UID higher than the current UID exists\n          // at a position after the target message\n          it = model->findMessageOrNextOneByUid(list, uid);\n  \n          if (it == list->m_children.end()) {\n              // this is a legitimate situation, the UID of the last message in the mailbox which is getting expunged right now\n              // could very well be not know at this point\n              --it;\n          }\n          // there's a special case above guarding against an empty list\n          Q_ASSERT(it >= list->m_children.begin());\n  \n          TreeItemMessage *msgCandidate = static_cast<TreeItemMessage*>(*it);\n          if (msgCandidate->uid() == uid) {\n              // will be deleted\n          } else if (resp.earlier == Responses::Vanished::EARLIER) {\n              // We don't have any such UID in our UID mapping, so we can safely ignore this one\n              continue;\n          } else if (msgCandidate->uid() == 0) {\n              // will be deleted\n          } else {\n              if (it != list->m_children.begin()) {\n                  --it;\n                  msgCandidate = static_cast<TreeItemMessage*>(*it);\n                  if (msgCandidate->uid() == 0) {\n                      // will be deleted\n                  } else {\n                      // VANISHED is free to refer to a non-existing UID...\n                      QString str;\n                      QTextStream ss(&str);\n                      ss << \"VANISHED refers to UID \" << uid << \" which wasn't found in the mailbox (found adjacent UIDs \" <<\n                            msgCandidate->uid() << \" and \" << static_cast<TreeItemMessage*>(*(it + 1))->uid() << \" with \" <<\n                            static_cast<TreeItemMessage*>(*(list->m_children.end() - 1))->uid() << \" at the end)\";\n                      ss.flush();\n                      qDebug() << str.toUtf8().constData();\n                      model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                      continue;\n                  }\n              } else {\n                  // Again, VANISHED can refer to non-existing UIDs\n                  QString str;\n                  QTextStream ss(&str);\n                  ss << \"VANISHED refers to UID \" << uid << \" which is too low (lowest UID is \" <<\n                        static_cast<TreeItemMessage*>(list->m_children.front())->uid() << \")\";\n                  ss.flush();\n                  qDebug() << str.toUtf8().constData();\n                  model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                  continue;\n              }\n          }\n  \n          int row = msgCandidate->row();\n          Q_ASSERT(row == it - list->m_children.begin());\n          model->beginRemoveRows(listIndex, row, row);\n          it = list->m_children.erase(it);\n          for (auto furtherMessage = it; furtherMessage != list->m_children.end(); ++furtherMessage) {\n              --static_cast<TreeItemMessage *>(*furtherMessage)->m_offset;\n          }\n          model->endRemoveRows();\n  \n          if (syncState.uidNext() <= uid) {\n              // We're informed about a message being deleted; this means that that UID must have been in the mailbox for some\n              // (possibly tiny) time and we can therefore use it to get an idea about the UIDNEXT\n              syncState.setUidNext(uid + 1);\n          }\n          model->cache()->clearMessage(mailbox(), uid);\n          delete msgCandidate;\n      }\n  \n      if (resp.earlier == Responses::Vanished::EARLIER && static_cast<uint>(list->m_children.size()) < syncState.exists()) {\n          // Okay, there were some new arrivals which we failed to take into account because we had processed EXISTS\n          // before VANISHED (EARLIER). That means that we have to add some of that messages back right now.\n          int newArrivals = syncState.exists() - list->m_children.size();\n          Q_ASSERT(newArrivals > 0);\n          QModelIndex parent = list->toIndex(model);\n          int offset = list->m_children.size();\n          model->beginInsertRows(parent, offset, syncState.exists() - 1);\n          for (int i = 0; i < newArrivals; ++i) {\n              TreeItemMessage *msg = new TreeItemMessage(list);\n              msg->m_offset = i + offset;\n              list->m_children << msg;\n              // yes, we really have to add this message with UID 0 :(\n          }\n          model->endInsertRows();\n      }\n  \n      list->m_totalMessageCount = list->m_children.size();\n      syncState.setExists(list->m_totalMessageCount);\n      list->recalcVariousMessageCounts(const_cast<Model *>(model));\n  \n      if (list->accessFetchStatus() == DONE) {\n          // Previously, we were synced, so we got to save this update\n          saveSyncStateAndUids(model);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleVanished(const Imap::Responses::Vanished *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n  \n      switch (status) {\n      case STATE_WAIT_FOR_CONN:\n          Q_ASSERT(false);\n          return false;\n  \n      case STATE_SELECTING:\n      case STATE_SYNCING_UIDS:\n      case STATE_SYNCING_FLAGS:\n      case STATE_DONE:\n          mailbox->handleVanished(model, *resp);\n          return true;\n      }\n  \n      Q_ASSERT(false);\n      return false;\n  }\n}"
  },
  {
    "function_name": "handleNumberResponse(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "682-819",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleNumberResponse(const Imap::Responses::NumberResponse *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    switch (resp->kind) {\n    case Imap::Responses::EXISTS:\n        switch (status) {\n        case STATE_WAIT_FOR_CONN:\n            Q_ASSERT(false);\n            return false;\n\n        case STATE_SELECTING:\n            if (m_usingQresync) {\n                // Because QRESYNC won't tell us anything about the new UIDs, we have to resort to this kludgy way of working.\n                // I really, really wonder why there's no such thing like the ARRIVED to accompany VANISHED. Oh well.\n                mailbox->syncState.setExists(resp->number);\n                int newArrivals = resp->number - list->m_children.size();\n                if (newArrivals > 0) {\n                    // We have to add empty messages here\n                    QModelIndex parent = list->toIndex(model);\n                    int offset = list->m_children.size();\n                    list->m_children.reserve(resp->number);\n                    model->beginInsertRows(parent, offset, resp->number - 1);\n                    for (int i = 0; i < newArrivals; ++i) {\n                        TreeItemMessage *msg = new TreeItemMessage(list);\n                        msg->m_offset = i + offset;\n                        list->m_children << msg;\n                        // yes, we really have to add this message with UID 0 :(\n                    }\n                    model->endInsertRows();\n                    list->m_totalMessageCount = resp->number;\n                }\n            } else {\n                // It's perfectly acceptable for the server to start its responses with EXISTS instead of UIDVALIDITY & UIDNEXT, so\n                // we really cannot do anything besides remembering this value for later.\n                mailbox->syncState.setExists(resp->number);\n            }\n            return true;\n\n        case STATE_SYNCING_UIDS:\n            mailbox->handleExists(model, *resp);\n            updateHighestKnownUid(mailbox, list);\n            return true;\n\n        case STATE_SYNCING_FLAGS:\n        case STATE_DONE:\n            if (resp->number == static_cast<uint>(list->m_children.size())) {\n                // no changes\n                return true;\n            }\n            mailbox->handleExists(model, *resp);\n            Q_ASSERT(list->m_children.size());\n            updateHighestKnownUid(mailbox, list);\n            CommandHandle fetchCmd = parser->uidFetch(Sequence::startingAt(\n                                                    // prevent a possible invalid 0:*\n                                                    qMax(mailbox->syncState.uidNext(), 1u)\n                                                ), QStringList() << QLatin1String(\"FLAGS\"));\n            newArrivalsFetch.append(fetchCmd);\n            return true;\n        }\n        Q_ASSERT(false);\n        return false;\n\n    case Imap::Responses::EXPUNGE:\n\n        if (mailbox->syncState.exists() > 0) {\n            // Always update the number of expected messages\n            mailbox->syncState.setExists(mailbox->syncState.exists() - 1);\n        }\n\n        switch (status) {\n        case STATE_SYNCING_FLAGS:\n            // The UID mapping has been already established, but we don't have enough information for\n            // an atomic state transition yet\n            mailbox->handleExpunge(model, *resp);\n            // The SyncState and the UID map will be saved later, along with the flags, when this task finishes\n            return true;\n\n        case STATE_DONE:\n            // The UID mapping has been already established, so we just want to handle the EXPUNGE as usual\n            mailbox->handleExpunge(model, *resp);\n            mailbox->saveSyncStateAndUids(model);\n            return true;\n\n        default:\n            // This is handled by the code below\n            break;\n        }\n\n        // We shall track updates to the place where the unknown UIDs resign\n        if (resp->number < firstUnknownUidOffset + 1) {\n            // The message which we're deleting has UID which is already known, ie. it isn't among those whose UIDs got requested\n            // by an incremental UID SEARCH\n            Q_ASSERT(firstUnknownUidOffset > 0);\n            --firstUnknownUidOffset;\n\n            // The deleted message has previously been present; that means that we shall immediately signal about its expunge\n            mailbox->handleExpunge(model, *resp);\n        }\n\n        switch(status) {\n        case STATE_WAIT_FOR_CONN:\n            Q_ASSERT(false);\n            return false;\n\n        case STATE_SELECTING:\n            // The actual change will be handled by the UID syncing code\n            return true;\n\n        case STATE_SYNCING_UIDS:\n            // We shouldn't delete stuff at this point, it will be handled by the UID syncing.\n            // The response shall be consumed, though.\n            return true;\n\n        case STATE_SYNCING_FLAGS:\n        case STATE_DONE:\n            // Already handled above\n            Q_ASSERT(false);\n            return false;\n\n        }\n\n        break;\n    case Imap::Responses::RECENT:\n        mailbox->syncState.setRecent(resp->number);\n        list->m_recentMessageCount = resp->number;\n        return true;\n        break;\n    default:\n        throw CantHappen(\"Got a NumberResponse of invalid kind. This is supposed to be handled in its constructor!\", *resp);\n    }\n    return false;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "Got a NumberResponse of invalid kind. This is supposed to be handled in its constructor!\",",
            "resp)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setRecent",
          "args": [
            "esp->number)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->handleExpunge",
          "args": [
            "odel,",
            "resp)"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "handleExpunge(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "579-607",
          "snippet": "oid TreeItemMailbox::handleExpunge(Model *const model, const Responses::NumberResponse &resp)\n{\n    Q_ASSERT(resp.kind == Responses::EXPUNGE);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n    Q_ASSERT(list);\n    if (resp.number > static_cast<uint>(list->m_children.size()) || resp.number == 0) {\n        throw UnknownMessageIndex(\"EXPUNGE references message number which is out-of-bounds\");\n    }\n    uint offset = resp.number - 1;\n\n    model->beginRemoveRows(list->toIndex(model), offset, offset);\n    auto it = list->m_children.begin() + offset;\n    TreeItemMessage *message = static_cast<TreeItemMessage *>(*it);\n    list->m_children.erase(it);\n    model->cache()->clearMessage(static_cast<TreeItemMailbox *>(list->parent())->mailbox(), message->uid());\n    for (int i = offset; i < list->m_children.size(); ++i) {\n        --static_cast<TreeItemMessage *>(list->m_children[i])->m_offset;\n    }\n    model->endRemoveRows();\n    delete message;\n\n    --list->m_totalMessageCount;\n    list->recalcVariousMessageCounts(const_cast<Model *>(model));\n\n    if (list->accessFetchStatus() == DONE) {\n        // Previously, we were synced, so we got to save this update\n        saveSyncStateAndUids(model);\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleExpunge(Model *const model, const Responses::NumberResponse &resp)\n  {\n      Q_ASSERT(resp.kind == Responses::EXPUNGE);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n      Q_ASSERT(list);\n      if (resp.number > static_cast<uint>(list->m_children.size()) || resp.number == 0) {\n          throw UnknownMessageIndex(\"EXPUNGE references message number which is out-of-bounds\");\n      }\n      uint offset = resp.number - 1;\n  \n      model->beginRemoveRows(list->toIndex(model), offset, offset);\n      auto it = list->m_children.begin() + offset;\n      TreeItemMessage *message = static_cast<TreeItemMessage *>(*it);\n      list->m_children.erase(it);\n      model->cache()->clearMessage(static_cast<TreeItemMailbox *>(list->parent())->mailbox(), message->uid());\n      for (int i = offset; i < list->m_children.size(); ++i) {\n          --static_cast<TreeItemMessage *>(list->m_children[i])->m_offset;\n      }\n      model->endRemoveRows();\n      delete message;\n  \n      --list->m_totalMessageCount;\n      list->recalcVariousMessageCounts(const_cast<Model *>(model));\n  \n      if (list->accessFetchStatus() == DONE) {\n          // Previously, we were synced, so we got to save this update\n          saveSyncStateAndUids(model);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irstUnknownUidOffset > 0)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setExists",
          "args": [
            "ailbox->syncState.exists() - 1)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.append",
          "args": [
            "etchCmd)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->uidFetch",
          "args": [
            "equence::startingAt(\n                                                    // prevent a possible invalid 0:*\n                                                    qMax(mailbox->syncState.uidNext(), 1u)\n                                                ),",
            "StringList() << QLatin1String(\"FLAGS\"))"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "uidFetch(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "460-465",
          "snippet": "ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n{\n    return queueCommand(Commands::Command(\"UID FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n  {\n      return queueCommand(Commands::Command(\"UID FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FLAGS\")"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::startingAt(",
          "args": [
            "/ prevent a possible invalid 0:*\nMax(mailbox->syncState.uidNext(), 1u)"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "startingAt(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "35-41",
          "snippet": "equence Sequence::startingAt(const uint lo)\n{\n    Sequence res(lo);\n    res.lo = lo;\n    res.kind = UNLIMITED;\n    return res;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  equence Sequence::startingAt(const uint lo)\n  {\n      Sequence res(lo);\n      res.lo = lo;\n      res.kind = UNLIMITED;\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            "ailbox->syncState.uidNext(),",
            "u)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidNext",
          "args": [],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdateHighestKnownUid(",
          "args": [
            "ailbox,",
            "ist)"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "updateHighestKnownUid(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "670-680",
          "snippet": "oid ObtainSynchronizedMailboxTask::updateHighestKnownUid(TreeItemMailbox *mailbox, const TreeItemMsgList *list) const\n{\n    uint highestKnownUid = 0;\n    for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n        highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n    }\n    if (highestKnownUid) {\n        // If the UID walk return a usable number, remember that and use it for updating our idea of the UIDNEXT\n        mailbox->syncState.setUidNext(qMax(mailbox->syncState.uidNext(), highestKnownUid + 1));\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::updateHighestKnownUid(TreeItemMailbox *mailbox, const TreeItemMsgList *list) const\n  {\n      uint highestKnownUid = 0;\n      for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n          highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n      }\n      if (highestKnownUid) {\n          // If the UID walk return a usable number, remember that and use it for updating our idea of the UIDNEXT\n          mailbox->syncState.setUidNext(qMax(mailbox->syncState.uidNext(), highestKnownUid + 1));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->handleExists",
          "args": [
            "odel,",
            "resp)"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "handleExists(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "742-773",
          "snippet": "oid TreeItemMailbox::handleExists(Model *const model, const Responses::NumberResponse &resp)\n{\n    Q_ASSERT(resp.kind == Responses::EXISTS);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[0]);\n    Q_ASSERT(list);\n    // This is a bit tricky -- unfortunately, we can't assume anything about the UID of new arrivals. On the other hand,\n    // these messages can be referenced by (even unrequested) FETCH responses and deleted by EXPUNGE, so we really want\n    // to add them to the tree.\n    int newArrivals = resp.number - list->m_children.size();\n    if (newArrivals < 0) {\n        throw UnexpectedResponseReceived(\"EXISTS response attempted to decrease number of messages\", resp);\n    }\n    syncState.setExists(resp.number);\n    if (newArrivals == 0) {\n        // remains unchanged...\n        return;\n    }\n\n    QModelIndex parent = list->toIndex(model);\n    int offset = list->m_children.size();\n    model->beginInsertRows(parent, offset, resp.number - 1);\n    for (int i = 0; i < newArrivals; ++i) {\n        TreeItemMessage *msg = new TreeItemMessage(list);\n        msg->m_offset = i + offset;\n        list->m_children << msg;\n        // yes, we really have to add this message with UID 0 :(\n    }\n    model->endInsertRows();\n    list->m_totalMessageCount = resp.number;\n    list->setFetchStatus(LOADING);\n    model->emitMessageCountChanged(this);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleExists(Model *const model, const Responses::NumberResponse &resp)\n  {\n      Q_ASSERT(resp.kind == Responses::EXISTS);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[0]);\n      Q_ASSERT(list);\n      // This is a bit tricky -- unfortunately, we can't assume anything about the UID of new arrivals. On the other hand,\n      // these messages can be referenced by (even unrequested) FETCH responses and deleted by EXPUNGE, so we really want\n      // to add them to the tree.\n      int newArrivals = resp.number - list->m_children.size();\n      if (newArrivals < 0) {\n          throw UnexpectedResponseReceived(\"EXISTS response attempted to decrease number of messages\", resp);\n      }\n      syncState.setExists(resp.number);\n      if (newArrivals == 0) {\n          // remains unchanged...\n          return;\n      }\n  \n      QModelIndex parent = list->toIndex(model);\n      int offset = list->m_children.size();\n      model->beginInsertRows(parent, offset, resp.number - 1);\n      for (int i = 0; i < newArrivals; ++i) {\n          TreeItemMessage *msg = new TreeItemMessage(list);\n          msg->m_offset = i + offset;\n          list->m_children << msg;\n          // yes, we really have to add this message with UID 0 :(\n      }\n      model->endInsertRows();\n      list->m_totalMessageCount = resp.number;\n      list->setFetchStatus(LOADING);\n      model->emitMessageCountChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setExists",
          "args": [
            "esp->number)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->endInsertRows",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->beginInsertRows",
          "args": [
            "arent,",
            "ffset,",
            "esp->number - 1)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.reserve",
          "args": [
            "esp->number)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->toIndex",
          "args": [
            "odel)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setExists",
          "args": [
            "esp->number)"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleNumberResponse(const Imap::Responses::NumberResponse *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      switch (resp->kind) {\n      case Imap::Responses::EXISTS:\n          switch (status) {\n          case STATE_WAIT_FOR_CONN:\n              Q_ASSERT(false);\n              return false;\n  \n          case STATE_SELECTING:\n              if (m_usingQresync) {\n                  // Because QRESYNC won't tell us anything about the new UIDs, we have to resort to this kludgy way of working.\n                  // I really, really wonder why there's no such thing like the ARRIVED to accompany VANISHED. Oh well.\n                  mailbox->syncState.setExists(resp->number);\n                  int newArrivals = resp->number - list->m_children.size();\n                  if (newArrivals > 0) {\n                      // We have to add empty messages here\n                      QModelIndex parent = list->toIndex(model);\n                      int offset = list->m_children.size();\n                      list->m_children.reserve(resp->number);\n                      model->beginInsertRows(parent, offset, resp->number - 1);\n                      for (int i = 0; i < newArrivals; ++i) {\n                          TreeItemMessage *msg = new TreeItemMessage(list);\n                          msg->m_offset = i + offset;\n                          list->m_children << msg;\n                          // yes, we really have to add this message with UID 0 :(\n                      }\n                      model->endInsertRows();\n                      list->m_totalMessageCount = resp->number;\n                  }\n              } else {\n                  // It's perfectly acceptable for the server to start its responses with EXISTS instead of UIDVALIDITY & UIDNEXT, so\n                  // we really cannot do anything besides remembering this value for later.\n                  mailbox->syncState.setExists(resp->number);\n              }\n              return true;\n  \n          case STATE_SYNCING_UIDS:\n              mailbox->handleExists(model, *resp);\n              updateHighestKnownUid(mailbox, list);\n              return true;\n  \n          case STATE_SYNCING_FLAGS:\n          case STATE_DONE:\n              if (resp->number == static_cast<uint>(list->m_children.size())) {\n                  // no changes\n                  return true;\n              }\n              mailbox->handleExists(model, *resp);\n              Q_ASSERT(list->m_children.size());\n              updateHighestKnownUid(mailbox, list);\n              CommandHandle fetchCmd = parser->uidFetch(Sequence::startingAt(\n                                                      // prevent a possible invalid 0:*\n                                                      qMax(mailbox->syncState.uidNext(), 1u)\n                                                  ), QStringList() << QLatin1String(\"FLAGS\"));\n              newArrivalsFetch.append(fetchCmd);\n              return true;\n          }\n          Q_ASSERT(false);\n          return false;\n  \n      case Imap::Responses::EXPUNGE:\n  \n          if (mailbox->syncState.exists() > 0) {\n              // Always update the number of expected messages\n              mailbox->syncState.setExists(mailbox->syncState.exists() - 1);\n          }\n  \n          switch (status) {\n          case STATE_SYNCING_FLAGS:\n              // The UID mapping has been already established, but we don't have enough information for\n              // an atomic state transition yet\n              mailbox->handleExpunge(model, *resp);\n              // The SyncState and the UID map will be saved later, along with the flags, when this task finishes\n              return true;\n  \n          case STATE_DONE:\n              // The UID mapping has been already established, so we just want to handle the EXPUNGE as usual\n              mailbox->handleExpunge(model, *resp);\n              mailbox->saveSyncStateAndUids(model);\n              return true;\n  \n          default:\n              // This is handled by the code below\n              break;\n          }\n  \n          // We shall track updates to the place where the unknown UIDs resign\n          if (resp->number < firstUnknownUidOffset + 1) {\n              // The message which we're deleting has UID which is already known, ie. it isn't among those whose UIDs got requested\n              // by an incremental UID SEARCH\n              Q_ASSERT(firstUnknownUidOffset > 0);\n              --firstUnknownUidOffset;\n  \n              // The deleted message has previously been present; that means that we shall immediately signal about its expunge\n              mailbox->handleExpunge(model, *resp);\n          }\n  \n          switch(status) {\n          case STATE_WAIT_FOR_CONN:\n              Q_ASSERT(false);\n              return false;\n  \n          case STATE_SELECTING:\n              // The actual change will be handled by the UID syncing code\n              return true;\n  \n          case STATE_SYNCING_UIDS:\n              // We shouldn't delete stuff at this point, it will be handled by the UID syncing.\n              // The response shall be consumed, though.\n              return true;\n  \n          case STATE_SYNCING_FLAGS:\n          case STATE_DONE:\n              // Already handled above\n              Q_ASSERT(false);\n              return false;\n  \n          }\n  \n          break;\n      case Imap::Responses::RECENT:\n          mailbox->syncState.setRecent(resp->number);\n          list->m_recentMessageCount = resp->number;\n          return true;\n          break;\n      default:\n          throw CantHappen(\"Got a NumberResponse of invalid kind. This is supposed to be handled in its constructor!\", *resp);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "updateHighestKnownUid(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "670-680",
    "snippet": "oid ObtainSynchronizedMailboxTask::updateHighestKnownUid(TreeItemMailbox *mailbox, const TreeItemMsgList *list) const\n{\n    uint highestKnownUid = 0;\n    for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n        highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n    }\n    if (highestKnownUid) {\n        // If the UID walk return a usable number, remember that and use it for updating our idea of the UIDNEXT\n        mailbox->syncState.setUidNext(qMax(mailbox->syncState.uidNext(), highestKnownUid + 1));\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailbox->syncState.setUidNext",
          "args": [
            "Max(mailbox->syncState.uidNext(), highestKnownUid + 1))"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            "ailbox->syncState.uidNext(),",
            "ighestKnownUid + 1)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidNext",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<const TreeItemMessage *>",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<const TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::updateHighestKnownUid(TreeItemMailbox *mailbox, const TreeItemMsgList *list) const\n  {\n      uint highestKnownUid = 0;\n      for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n          highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n      }\n      if (highestKnownUid) {\n          // If the UID walk return a usable number, remember that and use it for updating our idea of the UIDNEXT\n          mailbox->syncState.setUidNext(qMax(mailbox->syncState.uidNext(), highestKnownUid + 1));\n      }\n  }\n}"
  },
  {
    "function_name": "handleResponseCodeInsideState(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "592-668",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return resp->tag.isEmpty();\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    switch (resp->respCode) {\n    case Responses::UNSEEN:\n    {\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUnSeenOffset(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UNSEEN respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::PERMANENTFLAGS:\n    {\n        const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setPermanentFlags(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::UIDNEXT:\n    {\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUidNext(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::UIDVALIDITY:\n    {\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUidValidity(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UIDVALIDITY respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::NOMODSEQ:\n        // NOMODSEQ means that this mailbox doesn't support CONDSTORE or QRESYNC. We have to avoid sending any fancy commands like\n        // the FETCH CHANGEDSINCE etc.\n        mailbox->syncState.setHighestModSeq(0);\n        m_usingQresync = false;\n        return resp->tag.isEmpty();\n        break;\n\n    case Responses::HIGHESTMODSEQ:\n    {\n        const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n        Q_ASSERT(num);\n        mailbox->syncState.setHighestModSeq(num->data);\n        return resp->tag.isEmpty();\n        break;\n    }\n    case Responses::CLOSED:\n        // FIXME: handle when supporting the qresync\n        return resp->tag.isEmpty();\n        break;\n    default:\n        break;\n    }\n    return false;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            "um->data)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "um)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<quint64>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->respCodeData.data",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "State response has invalid UIDVALIDITY respCodeData\",",
            "resp)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setUidValidity",
          "args": [
            "um->data)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<uint>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "State response has invalid UIDNEXT respCodeData\",",
            "resp)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setUidNext",
          "args": [
            "um->data)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<uint>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "State response has invalid PERMANENTFLAGS respCodeData\",",
            "resp)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setPermanentFlags",
          "args": [
            "um->data)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<QStringList>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "State response has invalid UNSEEN respCodeData\",",
            "resp)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setUnSeenOffset",
          "args": [
            "um->data)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<uint>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return resp->tag.isEmpty();\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      switch (resp->respCode) {\n      case Responses::UNSEEN:\n      {\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUnSeenOffset(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UNSEEN respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::PERMANENTFLAGS:\n      {\n          const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setPermanentFlags(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::UIDNEXT:\n      {\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUidNext(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::UIDVALIDITY:\n      {\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUidValidity(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UIDVALIDITY respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::NOMODSEQ:\n          // NOMODSEQ means that this mailbox doesn't support CONDSTORE or QRESYNC. We have to avoid sending any fancy commands like\n          // the FETCH CHANGEDSINCE etc.\n          mailbox->syncState.setHighestModSeq(0);\n          m_usingQresync = false;\n          return resp->tag.isEmpty();\n          break;\n  \n      case Responses::HIGHESTMODSEQ:\n      {\n          const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n          Q_ASSERT(num);\n          mailbox->syncState.setHighestModSeq(num->data);\n          return resp->tag.isEmpty();\n          break;\n      }\n      case Responses::CLOSED:\n          // FIXME: handle when supporting the qresync\n          return resp->tag.isEmpty();\n          break;\n      default:\n          break;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "syncFlags(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "532-590",
    "snippet": "oid ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n{\n    status = STATE_SYNCING_FLAGS;\n    log(\"Syncing flags\", Common::LOG_MAILBOX_SYNC);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n    Q_ASSERT(list);\n\n    // 0 => don't use it; >0 => use that as the old value\n    quint64 useModSeq = 0;\n    if ((model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\")) ||\n         model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\"))) &&\n            oldSyncState.highestModSeq() > 0 && mailbox->syncState.isUsableForCondstore() &&\n            oldSyncState.uidValidity() == mailbox->syncState.uidValidity()) {\n        // The CONDSTORE is available, UIDVALIDITY has not changed and the HIGHESTMODSEQ suggests that\n        // it will be useful\n        if (oldSyncState.highestModSeq() == mailbox->syncState.highestModSeq()) {\n            // Looks like there were no changes in flags -- that's cool, we're done here,\n            // but only after some sanity checks\n            if (oldSyncState.exists() > mailbox->syncState.exists()) {\n                log(\"Some messages have arrived to the mailbox, but HIGHESTMODSEQ hasn't changed. \"\n                    \"That's a bug in the server implementation.\", Common::LOG_MAILBOX_SYNC);\n                // will issue the ordinary FETCH command for FLAGS\n            } else if (oldSyncState.uidNext() != mailbox->syncState.uidNext()) {\n                log(\"UIDNEXT has changed, yet HIGHESTMODSEQ remained constant; that's server's bug\", Common::LOG_MAILBOX_SYNC);\n                // and again, don't trust that HIGHESTMODSEQ\n            } else {\n                // According to HIGHESTMODSEQ, there hasn't been any change. UIDNEXT and EXISTS do not contradict\n                // this interpretation, so we can go and call stuff finished.\n                if (newArrivalsFetch.isEmpty()) {\n                    // No pending activity -> let's call it a day\n                    status = STATE_DONE;\n                    mailbox->saveSyncStateAndUids(model);\n                    model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                    _completed();\n                    return;\n                } else {\n                    // ...but there's still some pending activity; let's wait for its termination\n                    status = STATE_DONE;\n                }\n            }\n        } else if (oldSyncState.highestModSeq() > mailbox->syncState.highestModSeq()) {\n            // Clearly a bug\n            log(\"HIGHESTMODSEQ decreased, that's a bug in the IMAP server\", Common::LOG_MAILBOX_SYNC);\n            // won't use HIGHESTMODSEQ\n        } else {\n            // Will use FETCH CHANGEDSINCE\n            useModSeq = oldSyncState.highestModSeq();\n        }\n    }\n    if (useModSeq > 0) {\n        QMap<QByteArray, quint64> fetchModifier;\n        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n    } else {\n        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n    }\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    emit model->mailboxSyncingProgress(mailboxIndex, status);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->fetch",
          "args": [
            "equence(1, mailbox->syncState.exists()),",
            "StringList() << QLatin1String(\"FLAGS\"))"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FLAGS\")"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence(",
          "args": [
            ",",
            "ailbox->syncState.exists())"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "etSequence(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/LowLevelParser.cpp",
          "lines": "344-389",
          "snippet": "List<uint> getSequence(const QByteArray &line, int &start)\n{\n    uint num = LowLevelParser::getUInt(line, start);\n    if (start >= line.size() - 2) {\n        // It's definitely just a number because there's no more data in here\n        return QList<uint>() << num;\n    } else {\n        QList<uint> numbers;\n        numbers << num;\n\n        enum {COMMA, RANGE} currentType = COMMA;\n\n        // Try to find further items in the sequence set\n        while (line[start] == ':' || line[start] == ',') {\n            // it's a sequence set\n\n            if (line[start] == ':') {\n                if (currentType == RANGE) {\n                    // Now \"x:y:z\" is a funny syntax\n                    throw UnexpectedHere(\"Sequence set: range cannot me defined by three numbers\", line, start);\n                }\n                currentType = RANGE;\n            } else {\n                currentType = COMMA;\n            }\n\n            ++start;\n            if (start >= line.size() - 2) throw NoData(\"Truncated sequence set\", line, start);\n\n            uint num = LowLevelParser::getUInt(line, start);\n            if (currentType == COMMA) {\n                // just adding one more to the set\n                numbers << num;\n            } else {\n                // working with a range\n                if (numbers.last() >= num)\n                    throw UnexpectedHere(\"Sequence set contains an invalid range. \"\n                                         \"First item of a range must always be smaller than the second item.\", line, start);\n\n                for (uint i = numbers.last() + 1; i <= num; ++i)\n                    numbers << i;\n            }\n        }\n        return numbers;\n    }\n}",
          "includes": [
            "include \"Imap/Encoders.h\"",
            "include \"../Exceptions.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include <QDateTime>\n#",
            "include <QVariant>\n#",
            "include <QStringList>\n#",
            "include <QPair>\n#",
            "include <limits>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Encoders.h\"\ninclude \"../Exceptions.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude <QDateTime>\n#\ninclude <QVariant>\n#\ninclude <QStringList>\n#\ninclude <QPair>\n#\ninclude <limits>\n#\n\nList<uint> getSequence(const QByteArray &line, int &start)\n{\n    uint num = LowLevelParser::getUInt(line, start);\n    if (start >= line.size() - 2) {\n        // It's definitely just a number because there's no more data in here\n        return QList<uint>() << num;\n    } else {\n        QList<uint> numbers;\n        numbers << num;\n\n        enum {COMMA, RANGE} currentType = COMMA;\n\n        // Try to find further items in the sequence set\n        while (line[start] == ':' || line[start] == ',') {\n            // it's a sequence set\n\n            if (line[start] == ':') {\n                if (currentType == RANGE) {\n                    // Now \"x:y:z\" is a funny syntax\n                    throw UnexpectedHere(\"Sequence set: range cannot me defined by three numbers\", line, start);\n                }\n                currentType = RANGE;\n            } else {\n                currentType = COMMA;\n            }\n\n            ++start;\n            if (start >= line.size() - 2) throw NoData(\"Truncated sequence set\", line, start);\n\n            uint num = LowLevelParser::getUInt(line, start);\n            if (currentType == COMMA) {\n                // just adding one more to the set\n                numbers << num;\n            } else {\n                // working with a range\n                if (numbers.last() >= num)\n                    throw UnexpectedHere(\"Sequence set contains an invalid range. \"\n                                         \"First item of a range must always be smaller than the second item.\", line, start);\n\n                for (uint i = numbers.last() + 1; i <= num; ++i)\n                    numbers << i;\n            }\n        }\n        return numbers;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->fetch",
          "args": [
            "equence(1, mailbox->syncState.exists()),",
            "StringList() << QLatin1String(\"FLAGS\"),",
            "etchModifier)"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "fetch(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "428-442",
          "snippet": "ommandHandle Parser::fetch(const Sequence &seq, const QStringList &items, const QMap<QByteArray, quint64> &uint64Modifiers)\n{\n    Commands::Command cmd = Commands::Command(\"FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')');\n    if (!uint64Modifiers.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n        for (QMap<QByteArray, quint64>::const_iterator it = uint64Modifiers.constBegin(); it != uint64Modifiers.constEnd(); ++it) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, it.key()) <<\n                   Commands::PartOfCommand(Commands::ATOM, QByteArray::number(it.value()));\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::fetch(const Sequence &seq, const QStringList &items, const QMap<QByteArray, quint64> &uint64Modifiers)\n  {\n      Commands::Command cmd = Commands::Command(\"FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')');\n      if (!uint64Modifiers.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n          for (QMap<QByteArray, quint64>::const_iterator it = uint64Modifiers.constBegin(); it != uint64Modifiers.constEnd(); ++it) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, it.key()) <<\n                     Commands::PartOfCommand(Commands::ATOM, QByteArray::number(it.value()));\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FLAGS\")"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "HIGHESTMODSEQ decreased, that's a bug in the IMAP server\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.highestModSeq",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidNext",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.highestModSeq",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidValidity",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidValidity",
          "args": [],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.isUsableForCondstore",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"QRESYNC\"))"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "QRESYNC\")"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"CONDSTORE\"))"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CONDSTORE\")"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[ 0 ])"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n  {\n      status = STATE_SYNCING_FLAGS;\n      log(\"Syncing flags\", Common::LOG_MAILBOX_SYNC);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n      Q_ASSERT(list);\n  \n      // 0 => don't use it; >0 => use that as the old value\n      quint64 useModSeq = 0;\n      if ((model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\")) ||\n           model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\"))) &&\n              oldSyncState.highestModSeq() > 0 && mailbox->syncState.isUsableForCondstore() &&\n              oldSyncState.uidValidity() == mailbox->syncState.uidValidity()) {\n          // The CONDSTORE is available, UIDVALIDITY has not changed and the HIGHESTMODSEQ suggests that\n          // it will be useful\n          if (oldSyncState.highestModSeq() == mailbox->syncState.highestModSeq()) {\n              // Looks like there were no changes in flags -- that's cool, we're done here,\n              // but only after some sanity checks\n              if (oldSyncState.exists() > mailbox->syncState.exists()) {\n                  log(\"Some messages have arrived to the mailbox, but HIGHESTMODSEQ hasn't changed. \"\n                      \"That's a bug in the server implementation.\", Common::LOG_MAILBOX_SYNC);\n                  // will issue the ordinary FETCH command for FLAGS\n              } else if (oldSyncState.uidNext() != mailbox->syncState.uidNext()) {\n                  log(\"UIDNEXT has changed, yet HIGHESTMODSEQ remained constant; that's server's bug\", Common::LOG_MAILBOX_SYNC);\n                  // and again, don't trust that HIGHESTMODSEQ\n              } else {\n                  // According to HIGHESTMODSEQ, there hasn't been any change. UIDNEXT and EXISTS do not contradict\n                  // this interpretation, so we can go and call stuff finished.\n                  if (newArrivalsFetch.isEmpty()) {\n                      // No pending activity -> let's call it a day\n                      status = STATE_DONE;\n                      mailbox->saveSyncStateAndUids(model);\n                      model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                      _completed();\n                      return;\n                  } else {\n                      // ...but there's still some pending activity; let's wait for its termination\n                      status = STATE_DONE;\n                  }\n              }\n          } else if (oldSyncState.highestModSeq() > mailbox->syncState.highestModSeq()) {\n              // Clearly a bug\n              log(\"HIGHESTMODSEQ decreased, that's a bug in the IMAP server\", Common::LOG_MAILBOX_SYNC);\n              // won't use HIGHESTMODSEQ\n          } else {\n              // Will use FETCH CHANGEDSINCE\n              useModSeq = oldSyncState.highestModSeq();\n          }\n      }\n      if (useModSeq > 0) {\n          QMap<QByteArray, quint64> fetchModifier;\n          fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n          flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n      } else {\n          flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n      }\n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      emit model->mailboxSyncingProgress(mailboxIndex, status);\n  }\n}"
  },
  {
    "function_name": "syncUids(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "513-530",
    "snippet": "oid ObtainSynchronizedMailboxTask::syncUids(TreeItemMailbox *mailbox, const uint lowestUidToQuery)\n{\n    status = STATE_SYNCING_UIDS;\n    log(\"Syncing UIDs\", Common::LOG_MAILBOX_SYNC);\n    QByteArray uidSpecification;\n    if (lowestUidToQuery == 0) {\n        uidSpecification = \"ALL\";\n    } else {\n        uidSpecification = QString::fromUtf8(\"UID %1:*\").arg(QString::number(lowestUidToQuery)).toUtf8();\n    }\n    uidMap.clear();\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ESEARCH\"))) {\n        uidSyncingCmd = parser->uidESearchUid(uidSpecification);\n    } else {\n        uidSyncingCmd = parser->uidSearchUid(uidSpecification);\n    }\n    emit model->mailboxSyncingProgress(mailboxIndex, status);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->uidSearchUid",
          "args": [
            "idSpecification)"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "uidSearchUid(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "332-337",
          "snippet": "ommandHandle Parser::uidSearchUid(const QByteArray &sequence)\n{\n    Commands::Command command(\"UID SEARCH\");\n    command << Commands::PartOfCommand(Commands::ATOM, sequence);\n    return queueCommand(command);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSearchUid(const QByteArray &sequence)\n  {\n      Commands::Command command(\"UID SEARCH\");\n      command << Commands::PartOfCommand(Commands::ATOM, sequence);\n      return queueCommand(command);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arser->uidESearchUid",
          "args": [
            "idSpecification)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "uidESearchUid(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "339-344",
          "snippet": "ommandHandle Parser::uidESearchUid(const QByteArray &sequence)\n{\n    Commands::Command command(\"UID SEARCH RETURN (ALL)\");\n    command << Commands::PartOfCommand(Commands::ATOM, sequence);\n    return queueCommand(command);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidESearchUid(const QByteArray &sequence)\n  {\n      Commands::Command command(\"UID SEARCH RETURN (ALL)\");\n      command << Commands::PartOfCommand(Commands::ATOM, sequence);\n      return queueCommand(command);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"ESEARCH\"))"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ESEARCH\")"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.clear",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(lowestUidToQuery))"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "owestUidToQuery)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "UID %1:*\")"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Syncing UIDs\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncUids(TreeItemMailbox *mailbox, const uint lowestUidToQuery)\n  {\n      status = STATE_SYNCING_UIDS;\n      log(\"Syncing UIDs\", Common::LOG_MAILBOX_SYNC);\n      QByteArray uidSpecification;\n      if (lowestUidToQuery == 0) {\n          uidSpecification = \"ALL\";\n      } else {\n          uidSpecification = QString::fromUtf8(\"UID %1:*\").arg(QString::number(lowestUidToQuery)).toUtf8();\n      }\n      uidMap.clear();\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ESEARCH\"))) {\n          uidSyncingCmd = parser->uidESearchUid(uidSpecification);\n      } else {\n          uidSyncingCmd = parser->uidSearchUid(uidSpecification);\n      }\n      emit model->mailboxSyncingProgress(mailboxIndex, status);\n  }\n}"
  },
  {
    "function_name": "syncGeneric(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "503-511",
    "snippet": "oid ObtainSynchronizedMailboxTask::syncGeneric(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    log(\"generic synchronization from previous state\", Common::LOG_MAILBOX_SYNC);\n\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    list->m_unreadMessageCount = 0;\n    uidSyncingMode = UID_SYNC_ALL;\n    syncUids(mailbox);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "yncUids(",
          "args": [
            "ailbox)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "generic synchronization from previous state\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncGeneric(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      log(\"generic synchronization from previous state\", Common::LOG_MAILBOX_SYNC);\n  \n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      list->m_unreadMessageCount = 0;\n      uidSyncingMode = UID_SYNC_ALL;\n      syncUids(mailbox);\n  }\n}"
  },
  {
    "function_name": "syncOnlyAdditions(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "489-501",
    "snippet": "oid ObtainSynchronizedMailboxTask::syncOnlyAdditions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    log(\"Syncing new arrivals\", Common::LOG_MAILBOX_SYNC);\n\n    // So, we know that messages only got added to the mailbox and that none were removed,\n    // neither those that we already know or those that got added while we weren't around.\n    // Therefore we ask only for UIDs of new messages\n\n    firstUnknownUidOffset = oldSyncState.exists();\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    uidSyncingMode = UID_SYNC_ONLY_NEW;\n    syncUids(mailbox, oldSyncState.uidNext());\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "yncUids(",
          "args": [
            "ailbox,",
            "ldSyncState.uidNext())"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "syncUids(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "513-530",
          "snippet": "oid ObtainSynchronizedMailboxTask::syncUids(TreeItemMailbox *mailbox, const uint lowestUidToQuery)\n{\n    status = STATE_SYNCING_UIDS;\n    log(\"Syncing UIDs\", Common::LOG_MAILBOX_SYNC);\n    QByteArray uidSpecification;\n    if (lowestUidToQuery == 0) {\n        uidSpecification = \"ALL\";\n    } else {\n        uidSpecification = QString::fromUtf8(\"UID %1:*\").arg(QString::number(lowestUidToQuery)).toUtf8();\n    }\n    uidMap.clear();\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ESEARCH\"))) {\n        uidSyncingCmd = parser->uidESearchUid(uidSpecification);\n    } else {\n        uidSyncingCmd = parser->uidSearchUid(uidSpecification);\n    }\n    emit model->mailboxSyncingProgress(mailboxIndex, status);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncUids(TreeItemMailbox *mailbox, const uint lowestUidToQuery)\n  {\n      status = STATE_SYNCING_UIDS;\n      log(\"Syncing UIDs\", Common::LOG_MAILBOX_SYNC);\n      QByteArray uidSpecification;\n      if (lowestUidToQuery == 0) {\n          uidSpecification = \"ALL\";\n      } else {\n          uidSpecification = QString::fromUtf8(\"UID %1:*\").arg(QString::number(lowestUidToQuery)).toUtf8();\n      }\n      uidMap.clear();\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"ESEARCH\"))) {\n          uidSyncingCmd = parser->uidESearchUid(uidSpecification);\n      } else {\n          uidSyncingCmd = parser->uidSearchUid(uidSpecification);\n      }\n      emit model->mailboxSyncingProgress(mailboxIndex, status);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Syncing new arrivals\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncOnlyAdditions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      log(\"Syncing new arrivals\", Common::LOG_MAILBOX_SYNC);\n  \n      // So, we know that messages only got added to the mailbox and that none were removed,\n      // neither those that we already know or those that got added while we weren't around.\n      // Therefore we ask only for UIDs of new messages\n  \n      firstUnknownUidOffset = oldSyncState.exists();\n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      uidSyncingMode = UID_SYNC_ONLY_NEW;\n      syncUids(mailbox, oldSyncState.uidNext());\n  }\n}"
  },
  {
    "function_name": "syncNoNewNoDeletions(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "435-487",
    "snippet": "oid ObtainSynchronizedMailboxTask::syncNoNewNoDeletions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    Q_ASSERT(mailbox->syncState.exists() == static_cast<uint>(uidMap.size()));\n    log(\"No arrivals or deletions since the last time\", Common::LOG_MAILBOX_SYNC);\n    if (mailbox->syncState.exists()) {\n        // Verify that we indeed have all UIDs and not need them anymore\n#ifndef QT_NO_DEBUG\n        for (int i = 0; i < list->m_children.size(); ++i) {\n            // FIXME: This assert can fail if the mailbox contained messages with missing UIDs even before we opened it now.\n            Q_ASSERT(static_cast<TreeItemMessage *>(list->m_children[i])->uid());\n        }\n#endif\n    } else {\n        list->m_unreadMessageCount = 0;\n        list->m_totalMessageCount = 0;\n        list->m_numberFetchingStatus = TreeItem::DONE;\n    }\n\n    if (list->m_children.isEmpty()) {\n        TreeItemChildrenList messages;\n        list->m_children.reserve(mailbox->syncState.exists());\n        for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n            TreeItemMessage *msg = new TreeItemMessage(list);\n            msg->m_offset = i;\n            msg->m_uid = uidMap[ i ];\n            messages << msg;\n        }\n        list->setChildren(messages);\n\n    } else {\n        if (mailbox->syncState.exists() != static_cast<uint>(list->m_children.size())) {\n            throw CantHappen(\"TreeItemMsgList has wrong number of \"\n                             \"children, even though no change of \"\n                             \"message count occurred\");\n        }\n    }\n\n    list->setFetchStatus(TreeItem::DONE);\n\n    if (mailbox->syncState.exists()) {\n        syncFlags(mailbox);\n    } else {\n        status = STATE_DONE;\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        notifyInterestingMessages(mailbox);\n\n        if (newArrivalsFetch.isEmpty()) {\n            mailbox->saveSyncStateAndUids(model);\n            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n            _completed();\n        }\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "otifyInterestingMessages(",
          "args": [
            "ailbox)"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "notifyInterestingMessages(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1131-1157",
          "snippet": "oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n{\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    list->recalcVariousMessageCounts(model);\n    QModelIndex listIndex = list->toIndex(model);\n    Q_ASSERT(listIndex.isValid());\n    QModelIndex firstInterestingMessage = model->index(\n                // remember, the offset has one-based indexing\n                mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n    if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n            firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n        // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n        int offset = model->rowCount(listIndex) - 1;\n        log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n            .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                 QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n        firstInterestingMessage = model->index(offset, 0, listIndex);\n    } else {\n        log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n            .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                 firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                 ), Common::LOG_MAILBOX_SYNC);\n    }\n    emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n  {\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      list->recalcVariousMessageCounts(model);\n      QModelIndex listIndex = list->toIndex(model);\n      Q_ASSERT(listIndex.isValid());\n      QModelIndex firstInterestingMessage = model->index(\n                  // remember, the offset has one-based indexing\n                  mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n      if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n              firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n          // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n          int offset = model->rowCount(listIndex) - 1;\n          log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n              .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                   QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n          firstInterestingMessage = model->index(offset, 0, listIndex);\n      } else {\n          log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n              .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                   firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                   ), Common::LOG_MAILBOX_SYNC);\n      }\n      emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncFlags(",
          "args": [
            "ailbox)"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "syncFlags(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "532-590",
          "snippet": "oid ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n{\n    status = STATE_SYNCING_FLAGS;\n    log(\"Syncing flags\", Common::LOG_MAILBOX_SYNC);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n    Q_ASSERT(list);\n\n    // 0 => don't use it; >0 => use that as the old value\n    quint64 useModSeq = 0;\n    if ((model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\")) ||\n         model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\"))) &&\n            oldSyncState.highestModSeq() > 0 && mailbox->syncState.isUsableForCondstore() &&\n            oldSyncState.uidValidity() == mailbox->syncState.uidValidity()) {\n        // The CONDSTORE is available, UIDVALIDITY has not changed and the HIGHESTMODSEQ suggests that\n        // it will be useful\n        if (oldSyncState.highestModSeq() == mailbox->syncState.highestModSeq()) {\n            // Looks like there were no changes in flags -- that's cool, we're done here,\n            // but only after some sanity checks\n            if (oldSyncState.exists() > mailbox->syncState.exists()) {\n                log(\"Some messages have arrived to the mailbox, but HIGHESTMODSEQ hasn't changed. \"\n                    \"That's a bug in the server implementation.\", Common::LOG_MAILBOX_SYNC);\n                // will issue the ordinary FETCH command for FLAGS\n            } else if (oldSyncState.uidNext() != mailbox->syncState.uidNext()) {\n                log(\"UIDNEXT has changed, yet HIGHESTMODSEQ remained constant; that's server's bug\", Common::LOG_MAILBOX_SYNC);\n                // and again, don't trust that HIGHESTMODSEQ\n            } else {\n                // According to HIGHESTMODSEQ, there hasn't been any change. UIDNEXT and EXISTS do not contradict\n                // this interpretation, so we can go and call stuff finished.\n                if (newArrivalsFetch.isEmpty()) {\n                    // No pending activity -> let's call it a day\n                    status = STATE_DONE;\n                    mailbox->saveSyncStateAndUids(model);\n                    model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                    _completed();\n                    return;\n                } else {\n                    // ...but there's still some pending activity; let's wait for its termination\n                    status = STATE_DONE;\n                }\n            }\n        } else if (oldSyncState.highestModSeq() > mailbox->syncState.highestModSeq()) {\n            // Clearly a bug\n            log(\"HIGHESTMODSEQ decreased, that's a bug in the IMAP server\", Common::LOG_MAILBOX_SYNC);\n            // won't use HIGHESTMODSEQ\n        } else {\n            // Will use FETCH CHANGEDSINCE\n            useModSeq = oldSyncState.highestModSeq();\n        }\n    }\n    if (useModSeq > 0) {\n        QMap<QByteArray, quint64> fetchModifier;\n        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n    } else {\n        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n    }\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    emit model->mailboxSyncingProgress(mailboxIndex, status);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n  {\n      status = STATE_SYNCING_FLAGS;\n      log(\"Syncing flags\", Common::LOG_MAILBOX_SYNC);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n      Q_ASSERT(list);\n  \n      // 0 => don't use it; >0 => use that as the old value\n      quint64 useModSeq = 0;\n      if ((model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\")) ||\n           model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\"))) &&\n              oldSyncState.highestModSeq() > 0 && mailbox->syncState.isUsableForCondstore() &&\n              oldSyncState.uidValidity() == mailbox->syncState.uidValidity()) {\n          // The CONDSTORE is available, UIDVALIDITY has not changed and the HIGHESTMODSEQ suggests that\n          // it will be useful\n          if (oldSyncState.highestModSeq() == mailbox->syncState.highestModSeq()) {\n              // Looks like there were no changes in flags -- that's cool, we're done here,\n              // but only after some sanity checks\n              if (oldSyncState.exists() > mailbox->syncState.exists()) {\n                  log(\"Some messages have arrived to the mailbox, but HIGHESTMODSEQ hasn't changed. \"\n                      \"That's a bug in the server implementation.\", Common::LOG_MAILBOX_SYNC);\n                  // will issue the ordinary FETCH command for FLAGS\n              } else if (oldSyncState.uidNext() != mailbox->syncState.uidNext()) {\n                  log(\"UIDNEXT has changed, yet HIGHESTMODSEQ remained constant; that's server's bug\", Common::LOG_MAILBOX_SYNC);\n                  // and again, don't trust that HIGHESTMODSEQ\n              } else {\n                  // According to HIGHESTMODSEQ, there hasn't been any change. UIDNEXT and EXISTS do not contradict\n                  // this interpretation, so we can go and call stuff finished.\n                  if (newArrivalsFetch.isEmpty()) {\n                      // No pending activity -> let's call it a day\n                      status = STATE_DONE;\n                      mailbox->saveSyncStateAndUids(model);\n                      model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                      _completed();\n                      return;\n                  } else {\n                      // ...but there's still some pending activity; let's wait for its termination\n                      status = STATE_DONE;\n                  }\n              }\n          } else if (oldSyncState.highestModSeq() > mailbox->syncState.highestModSeq()) {\n              // Clearly a bug\n              log(\"HIGHESTMODSEQ decreased, that's a bug in the IMAP server\", Common::LOG_MAILBOX_SYNC);\n              // won't use HIGHESTMODSEQ\n          } else {\n              // Will use FETCH CHANGEDSINCE\n              useModSeq = oldSyncState.highestModSeq();\n          }\n      }\n      if (useModSeq > 0) {\n          QMap<QByteArray, quint64> fetchModifier;\n          fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n          flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n      } else {\n          flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n      }\n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      emit model->mailboxSyncingProgress(mailboxIndex, status);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "TreeItemMsgList has wrong number of \"\n                             \"children, even though no change of \"\n                             \"message count occurred\")"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->setChildren",
          "args": [
            "essages)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.reserve",
          "args": [
            "ailbox->syncState.exists())"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.isEmpty",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tatic_cast<TreeItemMessage *>(list->m_children[i])->uid())"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "No arrivals or deletions since the last time\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox->syncState.exists() == static_cast<uint>(uidMap.size()))"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "idMap.size())"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncNoNewNoDeletions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      Q_ASSERT(mailbox->syncState.exists() == static_cast<uint>(uidMap.size()));\n      log(\"No arrivals or deletions since the last time\", Common::LOG_MAILBOX_SYNC);\n      if (mailbox->syncState.exists()) {\n          // Verify that we indeed have all UIDs and not need them anymore\n  #ifndef QT_NO_DEBUG\n          for (int i = 0; i < list->m_children.size(); ++i) {\n              // FIXME: This assert can fail if the mailbox contained messages with missing UIDs even before we opened it now.\n              Q_ASSERT(static_cast<TreeItemMessage *>(list->m_children[i])->uid());\n          }\n  #endif\n      } else {\n          list->m_unreadMessageCount = 0;\n          list->m_totalMessageCount = 0;\n          list->m_numberFetchingStatus = TreeItem::DONE;\n      }\n  \n      if (list->m_children.isEmpty()) {\n          TreeItemChildrenList messages;\n          list->m_children.reserve(mailbox->syncState.exists());\n          for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n              TreeItemMessage *msg = new TreeItemMessage(list);\n              msg->m_offset = i;\n              msg->m_uid = uidMap[ i ];\n              messages << msg;\n          }\n          list->setChildren(messages);\n  \n      } else {\n          if (mailbox->syncState.exists() != static_cast<uint>(list->m_children.size())) {\n              throw CantHappen(\"TreeItemMsgList has wrong number of \"\n                               \"children, even though no change of \"\n                               \"message count occurred\");\n          }\n      }\n  \n      list->setFetchStatus(TreeItem::DONE);\n  \n      if (mailbox->syncState.exists()) {\n          syncFlags(mailbox);\n      } else {\n          status = STATE_DONE;\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          notifyInterestingMessages(mailbox);\n  \n          if (newArrivalsFetch.isEmpty()) {\n              mailbox->saveSyncStateAndUids(model);\n              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n              _completed();\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "fullMboxSync(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "386-433",
    "snippet": "oid ObtainSynchronizedMailboxTask::fullMboxSync(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    log(\"Full synchronization\", Common::LOG_MAILBOX_SYNC);\n\n    QModelIndex parent = list->toIndex(model);\n    if (! list->m_children.isEmpty()) {\n        model->beginRemoveRows(parent, 0, list->m_children.size() - 1);\n        auto oldItems = list->m_children;\n        list->m_children.clear();\n        model->endRemoveRows();\n        qDeleteAll(oldItems);\n    }\n    if (mailbox->syncState.exists()) {\n        list->m_children.reserve(mailbox->syncState.exists());\n        model->beginInsertRows(parent, 0, mailbox->syncState.exists() - 1);\n        for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n            TreeItemMessage *msg = new TreeItemMessage(list);\n            msg->m_offset = i;\n            list->m_children << msg;\n        }\n        model->endInsertRows();\n\n        syncUids(mailbox);\n        list->m_numberFetchingStatus = TreeItem::LOADING;\n        list->m_unreadMessageCount = 0;\n    } else {\n        // No messages, we're done here\n        list->m_totalMessageCount = 0;\n        list->m_unreadMessageCount = 0;\n        list->m_numberFetchingStatus = TreeItem::DONE;\n        list->setFetchStatus(TreeItem::DONE);\n\n        // The remote mailbox is empty -> we're done now\n        model->changeConnectionState(parser, CONN_STATE_SELECTED);\n        status = STATE_DONE;\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        notifyInterestingMessages(mailbox);\n        mailbox->saveSyncStateAndUids(model);\n        model->changeConnectionState(parser, CONN_STATE_SELECTED);\n        // Take care here: this call could invalidate our index (see test coverage)\n        _completed();\n    }\n    // Our mailbox might have actually been invalidated by various callbacks activated above\n    if (mailboxIndex.isValid()) {\n        Q_ASSERT(mailboxIndex.internalPointer() == mailbox);\n        model->emitMessageCountChanged(mailbox);\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->emitMessageCountChanged",
          "args": [
            "ailbox)"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "emitMessageCountChanged(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "495-501",
          "snippet": "oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    QModelIndex msgListIndex = list->toIndex(this);\n    emit dataChanged(msgListIndex, msgListIndex);\n    emit messageCountPossiblyChanged(mailbox->toIndex(this));\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      QModelIndex msgListIndex = list->toIndex(this);\n      emit dataChanged(msgListIndex, msgListIndex);\n      emit messageCountPossiblyChanged(mailbox->toIndex(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.internalPointer() == mailbox)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "otifyInterestingMessages(",
          "args": [
            "ailbox)"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "notifyInterestingMessages(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1131-1157",
          "snippet": "oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n{\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    list->recalcVariousMessageCounts(model);\n    QModelIndex listIndex = list->toIndex(model);\n    Q_ASSERT(listIndex.isValid());\n    QModelIndex firstInterestingMessage = model->index(\n                // remember, the offset has one-based indexing\n                mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n    if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n            firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n        // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n        int offset = model->rowCount(listIndex) - 1;\n        log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n            .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                 QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n        firstInterestingMessage = model->index(offset, 0, listIndex);\n    } else {\n        log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n            .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                 firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                 ), Common::LOG_MAILBOX_SYNC);\n    }\n    emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n  {\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      list->recalcVariousMessageCounts(model);\n      QModelIndex listIndex = list->toIndex(model);\n      Q_ASSERT(listIndex.isValid());\n      QModelIndex firstInterestingMessage = model->index(\n                  // remember, the offset has one-based indexing\n                  mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n      if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n              firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n          // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n          int offset = model->rowCount(listIndex) - 1;\n          log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n              .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                   QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n          firstInterestingMessage = model->index(offset, 0, listIndex);\n      } else {\n          log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n              .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                   firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                   ), Common::LOG_MAILBOX_SYNC);\n      }\n      emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncUids(",
          "args": [
            "ailbox)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->endInsertRows",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->beginInsertRows",
          "args": [
            "arent,",
            ",",
            "ailbox->syncState.exists() - 1)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.reserve",
          "args": [
            "ailbox->syncState.exists())"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteAll(",
          "args": [
            "ldItems)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->endRemoveRows",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.clear",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->beginRemoveRows",
          "args": [
            "arent,",
            ",",
            "ist->m_children.size() - 1)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.isEmpty",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->toIndex",
          "args": [
            "odel)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Full synchronization\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::fullMboxSync(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      log(\"Full synchronization\", Common::LOG_MAILBOX_SYNC);\n  \n      QModelIndex parent = list->toIndex(model);\n      if (! list->m_children.isEmpty()) {\n          model->beginRemoveRows(parent, 0, list->m_children.size() - 1);\n          auto oldItems = list->m_children;\n          list->m_children.clear();\n          model->endRemoveRows();\n          qDeleteAll(oldItems);\n      }\n      if (mailbox->syncState.exists()) {\n          list->m_children.reserve(mailbox->syncState.exists());\n          model->beginInsertRows(parent, 0, mailbox->syncState.exists() - 1);\n          for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n              TreeItemMessage *msg = new TreeItemMessage(list);\n              msg->m_offset = i;\n              list->m_children << msg;\n          }\n          model->endInsertRows();\n  \n          syncUids(mailbox);\n          list->m_numberFetchingStatus = TreeItem::LOADING;\n          list->m_unreadMessageCount = 0;\n      } else {\n          // No messages, we're done here\n          list->m_totalMessageCount = 0;\n          list->m_unreadMessageCount = 0;\n          list->m_numberFetchingStatus = TreeItem::DONE;\n          list->setFetchStatus(TreeItem::DONE);\n  \n          // The remote mailbox is empty -> we're done now\n          model->changeConnectionState(parser, CONN_STATE_SELECTED);\n          status = STATE_DONE;\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          notifyInterestingMessages(mailbox);\n          mailbox->saveSyncStateAndUids(model);\n          model->changeConnectionState(parser, CONN_STATE_SELECTED);\n          // Take care here: this call could invalidate our index (see test coverage)\n          _completed();\n      }\n      // Our mailbox might have actually been invalidated by various callbacks activated above\n      if (mailboxIndex.isValid()) {\n          Q_ASSERT(mailboxIndex.internalPointer() == mailbox);\n          model->emitMessageCountChanged(mailbox);\n      }\n  }\n}"
  },
  {
    "function_name": "finalizeSelect(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "220-384",
    "snippet": "oid ObtainSynchronizedMailboxTask::finalizeSelect()\n{\n    Q_ASSERT(mailboxIndex.isValid());\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n    Q_ASSERT(list);\n\n    model->changeConnectionState(parser, CONN_STATE_SYNCING);\n    const SyncState &syncState = mailbox->syncState;\n    oldSyncState = model->cache()->mailboxSyncState(mailbox->mailbox());\n    list->m_totalMessageCount = syncState.exists();\n    // Note: syncState.unSeen() is the NUMBER of the first unseen message, not their count!\n\n    uidMap = model->cache()->uidMapping(mailbox->mailbox());\n\n    if (static_cast<uint>(uidMap.size()) != oldSyncState.exists()) {\n\n        QString buf;\n        QDebug dbg(&buf);\n        dbg << \"Inconsistent cache data, falling back to full sync (\" << uidMap.size() << \"in UID map,\" << oldSyncState.exists() <<\n            \"EXIST before)\";\n        log(buf, Common::LOG_MAILBOX_SYNC);\n        oldSyncState.setHighestModSeq(0);\n        fullMboxSync(mailbox, list);\n    } else {\n        if (syncState.isUsableForSyncing() && oldSyncState.isUsableForSyncing() && syncState.uidValidity() == oldSyncState.uidValidity()) {\n            // Perform a nice re-sync\n\n            // Check the QRESYNC support and availability\n            if (m_usingQresync && oldSyncState.isUsableForCondstore() && syncState.isUsableForCondstore()) {\n                // Looks like we can use QRESYNC for fast syncing\n                if (oldSyncState.highestModSeq() > syncState.highestModSeq()) {\n                    // Looks like a corrupted cache or a server's bug\n                    log(\"Yuck, recycled HIGHESTMODSEQ when trying to use QRESYNC\", Common::LOG_MAILBOX_SYNC);\n                    mailbox->syncState.setHighestModSeq(0);\n                    model->cache()->clearAllMessages(mailbox->mailbox());\n                    m_usingQresync = false;\n                    fullMboxSync(mailbox, list);\n                } else {\n                    if (oldSyncState.highestModSeq() == syncState.highestModSeq()) {\n                        if (oldSyncState.exists() != syncState.exists()) {\n                            log(\"Sync error: QRESYNC says no changes but EXISTS has changed\", Common::LOG_MAILBOX_SYNC);\n                            mailbox->syncState.setHighestModSeq(0);\n                            model->cache()->clearAllMessages(mailbox->mailbox());\n                            m_usingQresync = false;\n                            fullMboxSync(mailbox, list);\n                        } else if (oldSyncState.uidNext() != syncState.uidNext()) {\n                            log(\"Sync error: QRESYNC says no changes but UIDNEXT has changed\", Common::LOG_MAILBOX_SYNC);\n                            mailbox->syncState.setHighestModSeq(0);\n                            model->cache()->clearAllMessages(mailbox->mailbox());\n                            m_usingQresync = false;\n                            fullMboxSync(mailbox, list);\n                        } else if (syncState.exists() != static_cast<uint>(list->m_children.size())) {\n                            log(QString::fromUtf8(\"Sync error: constant HIGHESTMODSEQ, EXISTS says %1 messages but in fact \"\n                                                   \"there are %2 when finalizing SELECT\")\n                                .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())),\n                                Common::LOG_MAILBOX_SYNC);\n                            mailbox->syncState.setHighestModSeq(0);\n                            model->cache()->clearAllMessages(mailbox->mailbox());\n                            m_usingQresync = false;\n                            fullMboxSync(mailbox, list);\n                        } else {\n                            // This should be enough\n                            list->setFetchStatus(TreeItem::DONE);\n                            notifyInterestingMessages(mailbox);\n                            mailbox->saveSyncStateAndUids(model);\n                            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                            _completed();\n                        }\n                        return;\n                    }\n\n                    if (static_cast<uint>(list->m_children.size()) != mailbox->syncState.exists()) {\n                        log(QString::fromUtf8(\"Sync error: EXISTS says %1 messages, msgList has %2\")\n                            .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())));\n                        mailbox->syncState.setHighestModSeq(0);\n                        model->cache()->clearAllMessages(mailbox->mailbox());\n                        m_usingQresync = false;\n                        fullMboxSync(mailbox, list);\n                        return;\n                    }\n\n\n                    if (oldSyncState.uidNext() < syncState.uidNext()) {\n                        list->setFetchStatus(TreeItem::DONE);\n                        int seqWithLowestUnknownUid = -1;\n                        for (int i = 0; i < list->m_children.size(); ++i) {\n                            TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n                            if (!msg->uid()) {\n                                seqWithLowestUnknownUid = i;\n                                break;\n                            }\n                        }\n                        if (seqWithLowestUnknownUid >= 0) {\n                            // We've got some new arrivals, but unfortunately QRESYNC won't report them just yet :(\n                            CommandHandle fetchCmd = parser->uidFetch(Sequence::startingAt(qMax(oldSyncState.uidNext(), 1u)),\n                                                                      QStringList() << QLatin1String(\"FLAGS\"));\n                            newArrivalsFetch.append(fetchCmd);\n                            status = STATE_DONE;\n                        } else {\n                            // All UIDs are known at this point, including the new arrivals, yay\n                            notifyInterestingMessages(mailbox);\n                            mailbox->saveSyncStateAndUids(model);\n                            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                            _completed();\n                        }\n                    } else {\n                        // This should be enough, the server should've sent the data already\n                        list->setFetchStatus(TreeItem::DONE);\n                        notifyInterestingMessages(mailbox);\n                        mailbox->saveSyncStateAndUids(model);\n                        model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                        _completed();\n                    }\n                }\n                return;\n            }\n\n            if (syncState.exists() == 0) {\n                // This is a special case, the mailbox doesn't contain any messages now.\n                // Let's just save ourselves some work and reuse the \"smart\" code in the fullMboxSync() here, it will\n                // do the right thing.\n                fullMboxSync(mailbox, list);\n                return;\n            }\n\n            if (syncState.uidNext() == oldSyncState.uidNext()) {\n                // No new messages\n\n                if (syncState.exists() == oldSyncState.exists()) {\n                    // No deletions, either, so we resync only flag changes\n                    syncNoNewNoDeletions(mailbox, list);\n                } else {\n                    // Some messages got deleted, but there have been no additions\n                    syncGeneric(mailbox, list);\n                }\n\n            } else if (syncState.uidNext() > oldSyncState.uidNext()) {\n                // Some new messages were delivered since we checked the last time.\n                // There's no guarantee they are still present, though.\n\n                if (syncState.uidNext() - oldSyncState.uidNext() == syncState.exists() - oldSyncState.exists()) {\n                    // Only some new arrivals, no deletions\n                    syncOnlyAdditions(mailbox, list);\n                } else {\n                    // Generic case; we don't know anything about which messages were deleted and which added\n                    syncGeneric(mailbox, list);\n                }\n            } else {\n                // The UIDNEXT has decreased while UIDVALIDITY remains the same. This is forbidden,\n                // so either a server's bug, or a completely invalid cache.\n                Q_ASSERT(syncState.uidNext() < oldSyncState.uidNext());\n                Q_ASSERT(syncState.uidValidity() == oldSyncState.uidValidity());\n                log(\"Yuck, UIDVALIDITY remains same but UIDNEXT decreased\", Common::LOG_MAILBOX_SYNC);\n                model->cache()->clearAllMessages(mailbox->mailbox());\n                fullMboxSync(mailbox, list);\n            }\n        } else {\n            // Forget everything, do a dumb sync\n            model->cache()->clearAllMessages(mailbox->mailbox());\n            fullMboxSync(mailbox, list);\n        }\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ullMboxSync(",
          "args": [
            "ailbox,",
            "ist)"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "fullMboxSync(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "386-433",
          "snippet": "oid ObtainSynchronizedMailboxTask::fullMboxSync(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    log(\"Full synchronization\", Common::LOG_MAILBOX_SYNC);\n\n    QModelIndex parent = list->toIndex(model);\n    if (! list->m_children.isEmpty()) {\n        model->beginRemoveRows(parent, 0, list->m_children.size() - 1);\n        auto oldItems = list->m_children;\n        list->m_children.clear();\n        model->endRemoveRows();\n        qDeleteAll(oldItems);\n    }\n    if (mailbox->syncState.exists()) {\n        list->m_children.reserve(mailbox->syncState.exists());\n        model->beginInsertRows(parent, 0, mailbox->syncState.exists() - 1);\n        for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n            TreeItemMessage *msg = new TreeItemMessage(list);\n            msg->m_offset = i;\n            list->m_children << msg;\n        }\n        model->endInsertRows();\n\n        syncUids(mailbox);\n        list->m_numberFetchingStatus = TreeItem::LOADING;\n        list->m_unreadMessageCount = 0;\n    } else {\n        // No messages, we're done here\n        list->m_totalMessageCount = 0;\n        list->m_unreadMessageCount = 0;\n        list->m_numberFetchingStatus = TreeItem::DONE;\n        list->setFetchStatus(TreeItem::DONE);\n\n        // The remote mailbox is empty -> we're done now\n        model->changeConnectionState(parser, CONN_STATE_SELECTED);\n        status = STATE_DONE;\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        notifyInterestingMessages(mailbox);\n        mailbox->saveSyncStateAndUids(model);\n        model->changeConnectionState(parser, CONN_STATE_SELECTED);\n        // Take care here: this call could invalidate our index (see test coverage)\n        _completed();\n    }\n    // Our mailbox might have actually been invalidated by various callbacks activated above\n    if (mailboxIndex.isValid()) {\n        Q_ASSERT(mailboxIndex.internalPointer() == mailbox);\n        model->emitMessageCountChanged(mailbox);\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::fullMboxSync(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      log(\"Full synchronization\", Common::LOG_MAILBOX_SYNC);\n  \n      QModelIndex parent = list->toIndex(model);\n      if (! list->m_children.isEmpty()) {\n          model->beginRemoveRows(parent, 0, list->m_children.size() - 1);\n          auto oldItems = list->m_children;\n          list->m_children.clear();\n          model->endRemoveRows();\n          qDeleteAll(oldItems);\n      }\n      if (mailbox->syncState.exists()) {\n          list->m_children.reserve(mailbox->syncState.exists());\n          model->beginInsertRows(parent, 0, mailbox->syncState.exists() - 1);\n          for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n              TreeItemMessage *msg = new TreeItemMessage(list);\n              msg->m_offset = i;\n              list->m_children << msg;\n          }\n          model->endInsertRows();\n  \n          syncUids(mailbox);\n          list->m_numberFetchingStatus = TreeItem::LOADING;\n          list->m_unreadMessageCount = 0;\n      } else {\n          // No messages, we're done here\n          list->m_totalMessageCount = 0;\n          list->m_unreadMessageCount = 0;\n          list->m_numberFetchingStatus = TreeItem::DONE;\n          list->setFetchStatus(TreeItem::DONE);\n  \n          // The remote mailbox is empty -> we're done now\n          model->changeConnectionState(parser, CONN_STATE_SELECTED);\n          status = STATE_DONE;\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          notifyInterestingMessages(mailbox);\n          mailbox->saveSyncStateAndUids(model);\n          model->changeConnectionState(parser, CONN_STATE_SELECTED);\n          // Take care here: this call could invalidate our index (see test coverage)\n          _completed();\n      }\n      // Our mailbox might have actually been invalidated by various callbacks activated above\n      if (mailboxIndex.isValid()) {\n          Q_ASSERT(mailboxIndex.internalPointer() == mailbox);\n          model->emitMessageCountChanged(mailbox);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Yuck, UIDVALIDITY remains same but UIDNEXT decreased\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "yncState.uidValidity() == oldSyncState.uidValidity())"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidValidity",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.uidValidity",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "uidValidity(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "108-111",
          "snippet": "int SyncState::uidValidity() const\n{\n    return m_uidValidity;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::uidValidity() const\n  {\n      return m_uidValidity;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "yncState.uidNext() < oldSyncState.uidNext())"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.uidNext",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "uidNext(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "97-100",
          "snippet": "int SyncState::uidNext() const\n{\n    return m_uidNext;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::uidNext() const\n  {\n      return m_uidNext;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncGeneric(",
          "args": [
            "ailbox,",
            "ist)"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "syncGeneric(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "503-511",
          "snippet": "oid ObtainSynchronizedMailboxTask::syncGeneric(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    log(\"generic synchronization from previous state\", Common::LOG_MAILBOX_SYNC);\n\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    list->m_unreadMessageCount = 0;\n    uidSyncingMode = UID_SYNC_ALL;\n    syncUids(mailbox);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncGeneric(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      log(\"generic synchronization from previous state\", Common::LOG_MAILBOX_SYNC);\n  \n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      list->m_unreadMessageCount = 0;\n      uidSyncingMode = UID_SYNC_ALL;\n      syncUids(mailbox);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncOnlyAdditions(",
          "args": [
            "ailbox,",
            "ist)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "syncOnlyAdditions(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "489-501",
          "snippet": "oid ObtainSynchronizedMailboxTask::syncOnlyAdditions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    log(\"Syncing new arrivals\", Common::LOG_MAILBOX_SYNC);\n\n    // So, we know that messages only got added to the mailbox and that none were removed,\n    // neither those that we already know or those that got added while we weren't around.\n    // Therefore we ask only for UIDs of new messages\n\n    firstUnknownUidOffset = oldSyncState.exists();\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    uidSyncingMode = UID_SYNC_ONLY_NEW;\n    syncUids(mailbox, oldSyncState.uidNext());\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncOnlyAdditions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      log(\"Syncing new arrivals\", Common::LOG_MAILBOX_SYNC);\n  \n      // So, we know that messages only got added to the mailbox and that none were removed,\n      // neither those that we already know or those that got added while we weren't around.\n      // Therefore we ask only for UIDs of new messages\n  \n      firstUnknownUidOffset = oldSyncState.exists();\n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      uidSyncingMode = UID_SYNC_ONLY_NEW;\n      syncUids(mailbox, oldSyncState.uidNext());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.exists",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "exists(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "53-56",
          "snippet": "int SyncState::exists() const\n{\n    return m_exists;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::exists() const\n  {\n      return m_exists;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncNoNewNoDeletions(",
          "args": [
            "ailbox,",
            "ist)"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "syncNoNewNoDeletions(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "435-487",
          "snippet": "oid ObtainSynchronizedMailboxTask::syncNoNewNoDeletions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n{\n    Q_ASSERT(mailbox->syncState.exists() == static_cast<uint>(uidMap.size()));\n    log(\"No arrivals or deletions since the last time\", Common::LOG_MAILBOX_SYNC);\n    if (mailbox->syncState.exists()) {\n        // Verify that we indeed have all UIDs and not need them anymore\n#ifndef QT_NO_DEBUG\n        for (int i = 0; i < list->m_children.size(); ++i) {\n            // FIXME: This assert can fail if the mailbox contained messages with missing UIDs even before we opened it now.\n            Q_ASSERT(static_cast<TreeItemMessage *>(list->m_children[i])->uid());\n        }\n#endif\n    } else {\n        list->m_unreadMessageCount = 0;\n        list->m_totalMessageCount = 0;\n        list->m_numberFetchingStatus = TreeItem::DONE;\n    }\n\n    if (list->m_children.isEmpty()) {\n        TreeItemChildrenList messages;\n        list->m_children.reserve(mailbox->syncState.exists());\n        for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n            TreeItemMessage *msg = new TreeItemMessage(list);\n            msg->m_offset = i;\n            msg->m_uid = uidMap[ i ];\n            messages << msg;\n        }\n        list->setChildren(messages);\n\n    } else {\n        if (mailbox->syncState.exists() != static_cast<uint>(list->m_children.size())) {\n            throw CantHappen(\"TreeItemMsgList has wrong number of \"\n                             \"children, even though no change of \"\n                             \"message count occurred\");\n        }\n    }\n\n    list->setFetchStatus(TreeItem::DONE);\n\n    if (mailbox->syncState.exists()) {\n        syncFlags(mailbox);\n    } else {\n        status = STATE_DONE;\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        notifyInterestingMessages(mailbox);\n\n        if (newArrivalsFetch.isEmpty()) {\n            mailbox->saveSyncStateAndUids(model);\n            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n            _completed();\n        }\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncNoNewNoDeletions(TreeItemMailbox *mailbox, TreeItemMsgList *list)\n  {\n      Q_ASSERT(mailbox->syncState.exists() == static_cast<uint>(uidMap.size()));\n      log(\"No arrivals or deletions since the last time\", Common::LOG_MAILBOX_SYNC);\n      if (mailbox->syncState.exists()) {\n          // Verify that we indeed have all UIDs and not need them anymore\n  #ifndef QT_NO_DEBUG\n          for (int i = 0; i < list->m_children.size(); ++i) {\n              // FIXME: This assert can fail if the mailbox contained messages with missing UIDs even before we opened it now.\n              Q_ASSERT(static_cast<TreeItemMessage *>(list->m_children[i])->uid());\n          }\n  #endif\n      } else {\n          list->m_unreadMessageCount = 0;\n          list->m_totalMessageCount = 0;\n          list->m_numberFetchingStatus = TreeItem::DONE;\n      }\n  \n      if (list->m_children.isEmpty()) {\n          TreeItemChildrenList messages;\n          list->m_children.reserve(mailbox->syncState.exists());\n          for (uint i = 0; i < mailbox->syncState.exists(); ++i) {\n              TreeItemMessage *msg = new TreeItemMessage(list);\n              msg->m_offset = i;\n              msg->m_uid = uidMap[ i ];\n              messages << msg;\n          }\n          list->setChildren(messages);\n  \n      } else {\n          if (mailbox->syncState.exists() != static_cast<uint>(list->m_children.size())) {\n              throw CantHappen(\"TreeItemMsgList has wrong number of \"\n                               \"children, even though no change of \"\n                               \"message count occurred\");\n          }\n      }\n  \n      list->setFetchStatus(TreeItem::DONE);\n  \n      if (mailbox->syncState.exists()) {\n          syncFlags(mailbox);\n      } else {\n          status = STATE_DONE;\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          notifyInterestingMessages(mailbox);\n  \n          if (newArrivalsFetch.isEmpty()) {\n              mailbox->saveSyncStateAndUids(model);\n              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n              _completed();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "otifyInterestingMessages(",
          "args": [
            "ailbox)"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "notifyInterestingMessages(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1131-1157",
          "snippet": "oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n{\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    list->recalcVariousMessageCounts(model);\n    QModelIndex listIndex = list->toIndex(model);\n    Q_ASSERT(listIndex.isValid());\n    QModelIndex firstInterestingMessage = model->index(\n                // remember, the offset has one-based indexing\n                mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n    if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n            firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n        // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n        int offset = model->rowCount(listIndex) - 1;\n        log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n            .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                 QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n        firstInterestingMessage = model->index(offset, 0, listIndex);\n    } else {\n        log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n            .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                 firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                 ), Common::LOG_MAILBOX_SYNC);\n    }\n    emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n  {\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      list->recalcVariousMessageCounts(model);\n      QModelIndex listIndex = list->toIndex(model);\n      Q_ASSERT(listIndex.isValid());\n      QModelIndex firstInterestingMessage = model->index(\n                  // remember, the offset has one-based indexing\n                  mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n      if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n              firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n          // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n          int offset = model->rowCount(listIndex) - 1;\n          log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n              .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                   QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n          firstInterestingMessage = model->index(offset, 0, listIndex);\n      } else {\n          log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n              .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                   firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                   ), Common::LOG_MAILBOX_SYNC);\n      }\n      emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.append",
          "args": [
            "etchCmd)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->uidFetch",
          "args": [
            "equence::startingAt(qMax(oldSyncState.uidNext(), 1u)),",
            "StringList() << QLatin1String(\"FLAGS\"))"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "uidFetch(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "460-465",
          "snippet": "ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n{\n    return queueCommand(Commands::Command(\"UID FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n  {\n      return queueCommand(Commands::Command(\"UID FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FLAGS\")"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::startingAt(",
          "args": [
            "Max(oldSyncState.uidNext(), 1u))"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "startingAt(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "35-41",
          "snippet": "equence Sequence::startingAt(const uint lo)\n{\n    Sequence res(lo);\n    res.lo = lo;\n    res.kind = UNLIMITED;\n    return res;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  equence Sequence::startingAt(const uint lo)\n  {\n      Sequence res(lo);\n      res.lo = lo;\n      res.kind = UNLIMITED;\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            "ldSyncState.uidNext(),",
            "u)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg->uid",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMessage*>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "String::fromUtf8(\"Sync error: EXISTS says %1 messages, msgList has %2\")\n                            .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())))"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(mailbox->syncState.exists()),",
            "String::number(list->m_children.size()))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ailbox->syncState.exists())"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Sync error: EXISTS says %1 messages, msgList has %2\")"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "reeItem::DONE)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "String::number(mailbox->syncState.exists()),",
            "String::number(list->m_children.size()))"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ailbox->syncState.exists())"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "Sync error: constant HIGHESTMODSEQ, EXISTS says %1 messages but in fact \"\n                                                   \"there are %2 when finalizing SELECT\")"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidNext",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.highestModSeq",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "highestModSeq(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "141-144",
          "snippet": "uint64 SyncState::highestModSeq() const\n{\n    return m_highestModSeq;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  uint64 SyncState::highestModSeq() const\n  {\n      return m_highestModSeq;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.isUsableForCondstore",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "isUsableForCondstore(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "48-51",
          "snippet": "ool SyncState::isUsableForCondstore() const\n{\n    return m_hasHighestModSeq && highestModSeq() > 0 && isUsableForSyncing();\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  ool SyncState::isUsableForCondstore() const\n  {\n      return m_hasHighestModSeq && highestModSeq() > 0 && isUsableForSyncing();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.isUsableForCondstore",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidValidity",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.isUsableForSyncing",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncState.isUsableForSyncing",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "isUsableForSyncing(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "43-46",
          "snippet": "ool SyncState::isUsableForSyncing() const\n{\n    return m_hasExists && m_hasUidNext && m_hasUidValidity;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  ool SyncState::isUsableForSyncing() const\n  {\n      return m_hasExists && m_hasUidNext && m_hasUidValidity;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.setHighestModSeq",
          "args": [
            ")"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.exists",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "idMap.size())"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idMap.size",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SYNCING)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[ 0 ])"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.isValid())"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::finalizeSelect()\n  {\n      Q_ASSERT(mailboxIndex.isValid());\n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n      Q_ASSERT(list);\n  \n      model->changeConnectionState(parser, CONN_STATE_SYNCING);\n      const SyncState &syncState = mailbox->syncState;\n      oldSyncState = model->cache()->mailboxSyncState(mailbox->mailbox());\n      list->m_totalMessageCount = syncState.exists();\n      // Note: syncState.unSeen() is the NUMBER of the first unseen message, not their count!\n  \n      uidMap = model->cache()->uidMapping(mailbox->mailbox());\n  \n      if (static_cast<uint>(uidMap.size()) != oldSyncState.exists()) {\n  \n          QString buf;\n          QDebug dbg(&buf);\n          dbg << \"Inconsistent cache data, falling back to full sync (\" << uidMap.size() << \"in UID map,\" << oldSyncState.exists() <<\n              \"EXIST before)\";\n          log(buf, Common::LOG_MAILBOX_SYNC);\n          oldSyncState.setHighestModSeq(0);\n          fullMboxSync(mailbox, list);\n      } else {\n          if (syncState.isUsableForSyncing() && oldSyncState.isUsableForSyncing() && syncState.uidValidity() == oldSyncState.uidValidity()) {\n              // Perform a nice re-sync\n  \n              // Check the QRESYNC support and availability\n              if (m_usingQresync && oldSyncState.isUsableForCondstore() && syncState.isUsableForCondstore()) {\n                  // Looks like we can use QRESYNC for fast syncing\n                  if (oldSyncState.highestModSeq() > syncState.highestModSeq()) {\n                      // Looks like a corrupted cache or a server's bug\n                      log(\"Yuck, recycled HIGHESTMODSEQ when trying to use QRESYNC\", Common::LOG_MAILBOX_SYNC);\n                      mailbox->syncState.setHighestModSeq(0);\n                      model->cache()->clearAllMessages(mailbox->mailbox());\n                      m_usingQresync = false;\n                      fullMboxSync(mailbox, list);\n                  } else {\n                      if (oldSyncState.highestModSeq() == syncState.highestModSeq()) {\n                          if (oldSyncState.exists() != syncState.exists()) {\n                              log(\"Sync error: QRESYNC says no changes but EXISTS has changed\", Common::LOG_MAILBOX_SYNC);\n                              mailbox->syncState.setHighestModSeq(0);\n                              model->cache()->clearAllMessages(mailbox->mailbox());\n                              m_usingQresync = false;\n                              fullMboxSync(mailbox, list);\n                          } else if (oldSyncState.uidNext() != syncState.uidNext()) {\n                              log(\"Sync error: QRESYNC says no changes but UIDNEXT has changed\", Common::LOG_MAILBOX_SYNC);\n                              mailbox->syncState.setHighestModSeq(0);\n                              model->cache()->clearAllMessages(mailbox->mailbox());\n                              m_usingQresync = false;\n                              fullMboxSync(mailbox, list);\n                          } else if (syncState.exists() != static_cast<uint>(list->m_children.size())) {\n                              log(QString::fromUtf8(\"Sync error: constant HIGHESTMODSEQ, EXISTS says %1 messages but in fact \"\n                                                     \"there are %2 when finalizing SELECT\")\n                                  .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())),\n                                  Common::LOG_MAILBOX_SYNC);\n                              mailbox->syncState.setHighestModSeq(0);\n                              model->cache()->clearAllMessages(mailbox->mailbox());\n                              m_usingQresync = false;\n                              fullMboxSync(mailbox, list);\n                          } else {\n                              // This should be enough\n                              list->setFetchStatus(TreeItem::DONE);\n                              notifyInterestingMessages(mailbox);\n                              mailbox->saveSyncStateAndUids(model);\n                              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                              _completed();\n                          }\n                          return;\n                      }\n  \n                      if (static_cast<uint>(list->m_children.size()) != mailbox->syncState.exists()) {\n                          log(QString::fromUtf8(\"Sync error: EXISTS says %1 messages, msgList has %2\")\n                              .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())));\n                          mailbox->syncState.setHighestModSeq(0);\n                          model->cache()->clearAllMessages(mailbox->mailbox());\n                          m_usingQresync = false;\n                          fullMboxSync(mailbox, list);\n                          return;\n                      }\n  \n  \n                      if (oldSyncState.uidNext() < syncState.uidNext()) {\n                          list->setFetchStatus(TreeItem::DONE);\n                          int seqWithLowestUnknownUid = -1;\n                          for (int i = 0; i < list->m_children.size(); ++i) {\n                              TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n                              if (!msg->uid()) {\n                                  seqWithLowestUnknownUid = i;\n                                  break;\n                              }\n                          }\n                          if (seqWithLowestUnknownUid >= 0) {\n                              // We've got some new arrivals, but unfortunately QRESYNC won't report them just yet :(\n                              CommandHandle fetchCmd = parser->uidFetch(Sequence::startingAt(qMax(oldSyncState.uidNext(), 1u)),\n                                                                        QStringList() << QLatin1String(\"FLAGS\"));\n                              newArrivalsFetch.append(fetchCmd);\n                              status = STATE_DONE;\n                          } else {\n                              // All UIDs are known at this point, including the new arrivals, yay\n                              notifyInterestingMessages(mailbox);\n                              mailbox->saveSyncStateAndUids(model);\n                              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                              _completed();\n                          }\n                      } else {\n                          // This should be enough, the server should've sent the data already\n                          list->setFetchStatus(TreeItem::DONE);\n                          notifyInterestingMessages(mailbox);\n                          mailbox->saveSyncStateAndUids(model);\n                          model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                          _completed();\n                      }\n                  }\n                  return;\n              }\n  \n              if (syncState.exists() == 0) {\n                  // This is a special case, the mailbox doesn't contain any messages now.\n                  // Let's just save ourselves some work and reuse the \"smart\" code in the fullMboxSync() here, it will\n                  // do the right thing.\n                  fullMboxSync(mailbox, list);\n                  return;\n              }\n  \n              if (syncState.uidNext() == oldSyncState.uidNext()) {\n                  // No new messages\n  \n                  if (syncState.exists() == oldSyncState.exists()) {\n                      // No deletions, either, so we resync only flag changes\n                      syncNoNewNoDeletions(mailbox, list);\n                  } else {\n                      // Some messages got deleted, but there have been no additions\n                      syncGeneric(mailbox, list);\n                  }\n  \n              } else if (syncState.uidNext() > oldSyncState.uidNext()) {\n                  // Some new messages were delivered since we checked the last time.\n                  // There's no guarantee they are still present, though.\n  \n                  if (syncState.uidNext() - oldSyncState.uidNext() == syncState.exists() - oldSyncState.exists()) {\n                      // Only some new arrivals, no deletions\n                      syncOnlyAdditions(mailbox, list);\n                  } else {\n                      // Generic case; we don't know anything about which messages were deleted and which added\n                      syncGeneric(mailbox, list);\n                  }\n              } else {\n                  // The UIDNEXT has decreased while UIDVALIDITY remains the same. This is forbidden,\n                  // so either a server's bug, or a completely invalid cache.\n                  Q_ASSERT(syncState.uidNext() < oldSyncState.uidNext());\n                  Q_ASSERT(syncState.uidValidity() == oldSyncState.uidValidity());\n                  log(\"Yuck, UIDVALIDITY remains same but UIDNEXT decreased\", Common::LOG_MAILBOX_SYNC);\n                  model->cache()->clearAllMessages(mailbox->mailbox());\n                  fullMboxSync(mailbox, list);\n              }\n          } else {\n              // Forget everything, do a dumb sync\n              model->cache()->clearAllMessages(mailbox->mailbox());\n              fullMboxSync(mailbox, list);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "handleStateHelper(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "125-218",
    "snippet": "ool ObtainSynchronizedMailboxTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    if (handleResponseCodeInsideState(resp))\n        return true;\n\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    // We absolutely have to ignore the abort() request\n\n    if (resp->tag == selectCmd) {\n\n        if (resp->kind == Responses::OK) {\n            //qDebug() << \"received OK for selectCmd\";\n            Q_ASSERT(status == STATE_SELECTING);\n            finalizeSelect();\n        } else {\n            _failed(QLatin1String(\"SELECT failed: \") + resp->message);\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n        }\n        return true;\n    } else if (resp->tag == uidSyncingCmd) {\n\n        if (resp->kind == Responses::OK) {\n            // FIXME: move the finalizeSearch() here to support working with split SEARCH reposnes -- but beware of\n            // arrivals/expunges which happen while the UID SEARCH is in progres...\n            log(\"UIDs synchronized\", Common::LOG_MAILBOX_SYNC);\n            Q_ASSERT(status == STATE_SYNCING_FLAGS);\n            Q_ASSERT(mailboxIndex.isValid());   // FIXME\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            syncFlags(mailbox);\n        } else {\n            _failed(QLatin1String(\"UID syncing failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        return true;\n    } else if (resp->tag == flagsCmd) {\n\n        if (resp->kind == Responses::OK) {\n            //qDebug() << \"received OK for flagsCmd\";\n            Q_ASSERT(status == STATE_SYNCING_FLAGS);\n            Q_ASSERT(mailboxIndex.isValid());\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            status = STATE_DONE;\n            log(\"Flags synchronized\", Common::LOG_MAILBOX_SYNC);\n            notifyInterestingMessages(mailbox);\n            flagsCmd.clear();\n\n            if (newArrivalsFetch.isEmpty()) {\n                mailbox->saveSyncStateAndUids(model);\n                model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                _completed();\n            } else {\n                log(\"Pending new arrival fetching, not terminating yet\", Common::LOG_MAILBOX_SYNC);\n            }\n        } else {\n            status = STATE_DONE;\n            _failed(QLatin1String(\"Flags synchronization failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        return true;\n    } else if (newArrivalsFetch.contains(resp->tag)) {\n\n        if (resp->kind == Responses::OK) {\n            newArrivalsFetch.removeOne(resp->tag);\n\n            if (newArrivalsFetch.isEmpty() && status == STATE_DONE && flagsCmd.isEmpty()) {\n                Q_ASSERT(mailboxIndex.isValid());\n                TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n                Q_ASSERT(mailbox);\n                mailbox->saveSyncStateAndUids(model);\n                model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                _completed();\n            }\n        } else {\n            _failed(QLatin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        return true;\n\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Latin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message)"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UID discovery of new arrivals after initial UID sync has failed: \")"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.isValid())"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lagsCmd.isEmpty",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.removeOne",
          "args": [
            "esp->tag)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.contains",
          "args": [
            "esp->tag)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Flags synchronization failed: \")"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Pending new arrival fetching, not terminating yet\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lagsCmd.clear",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "otifyInterestingMessages(",
          "args": [
            "ailbox)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "notifyInterestingMessages(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1131-1157",
          "snippet": "oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n{\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    list->recalcVariousMessageCounts(model);\n    QModelIndex listIndex = list->toIndex(model);\n    Q_ASSERT(listIndex.isValid());\n    QModelIndex firstInterestingMessage = model->index(\n                // remember, the offset has one-based indexing\n                mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n    if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n            firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n        // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n        int offset = model->rowCount(listIndex) - 1;\n        log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n            .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                 QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n        firstInterestingMessage = model->index(offset, 0, listIndex);\n    } else {\n        log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n            .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                 firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                 ), Common::LOG_MAILBOX_SYNC);\n    }\n    emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::notifyInterestingMessages(TreeItemMailbox *mailbox)\n  {\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<Imap::Mailbox::TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      list->recalcVariousMessageCounts(model);\n      QModelIndex listIndex = list->toIndex(model);\n      Q_ASSERT(listIndex.isValid());\n      QModelIndex firstInterestingMessage = model->index(\n                  // remember, the offset has one-based indexing\n                  mailbox->syncState.unSeenOffset() ? mailbox->syncState.unSeenOffset() - 1 : 0, 0, listIndex);\n      if (!firstInterestingMessage.data(RoleMessageIsMarkedRecent).toBool() &&\n              firstInterestingMessage.data(RoleMessageIsMarkedRead).toBool()) {\n          // Clearly the reported value is utter nonsense. Let's just scroll to the end instead\n          int offset = model->rowCount(listIndex) - 1;\n          log(QString::fromUtf8(\"\\\"First interesting message\\\" doesn't look terribly interesting (%1), scrolling to the end at %2 instead\")\n              .arg(firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \")),\n                   QString::number(offset)), Common::LOG_MAILBOX_SYNC);\n          firstInterestingMessage = model->index(offset, 0, listIndex);\n      } else {\n          log(QString::fromUtf8(\"First interesting message at %1 (%2)\")\n              .arg(QString::number(mailbox->syncState.unSeenOffset()),\n                   firstInterestingMessage.data(RoleMessageFlags).toStringList().join(QLatin1String(\", \"))\n                   ), Common::LOG_MAILBOX_SYNC);\n      }\n      emit model->mailboxFirstUnseenMessage(mailbox->toIndex(model), firstInterestingMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.isValid())"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tatus == STATE_SYNCING_FLAGS)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UID syncing failed: \")"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yncFlags(",
          "args": [
            "ailbox)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "syncFlags(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "532-590",
          "snippet": "oid ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n{\n    status = STATE_SYNCING_FLAGS;\n    log(\"Syncing flags\", Common::LOG_MAILBOX_SYNC);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n    Q_ASSERT(list);\n\n    // 0 => don't use it; >0 => use that as the old value\n    quint64 useModSeq = 0;\n    if ((model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\")) ||\n         model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\"))) &&\n            oldSyncState.highestModSeq() > 0 && mailbox->syncState.isUsableForCondstore() &&\n            oldSyncState.uidValidity() == mailbox->syncState.uidValidity()) {\n        // The CONDSTORE is available, UIDVALIDITY has not changed and the HIGHESTMODSEQ suggests that\n        // it will be useful\n        if (oldSyncState.highestModSeq() == mailbox->syncState.highestModSeq()) {\n            // Looks like there were no changes in flags -- that's cool, we're done here,\n            // but only after some sanity checks\n            if (oldSyncState.exists() > mailbox->syncState.exists()) {\n                log(\"Some messages have arrived to the mailbox, but HIGHESTMODSEQ hasn't changed. \"\n                    \"That's a bug in the server implementation.\", Common::LOG_MAILBOX_SYNC);\n                // will issue the ordinary FETCH command for FLAGS\n            } else if (oldSyncState.uidNext() != mailbox->syncState.uidNext()) {\n                log(\"UIDNEXT has changed, yet HIGHESTMODSEQ remained constant; that's server's bug\", Common::LOG_MAILBOX_SYNC);\n                // and again, don't trust that HIGHESTMODSEQ\n            } else {\n                // According to HIGHESTMODSEQ, there hasn't been any change. UIDNEXT and EXISTS do not contradict\n                // this interpretation, so we can go and call stuff finished.\n                if (newArrivalsFetch.isEmpty()) {\n                    // No pending activity -> let's call it a day\n                    status = STATE_DONE;\n                    mailbox->saveSyncStateAndUids(model);\n                    model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                    _completed();\n                    return;\n                } else {\n                    // ...but there's still some pending activity; let's wait for its termination\n                    status = STATE_DONE;\n                }\n            }\n        } else if (oldSyncState.highestModSeq() > mailbox->syncState.highestModSeq()) {\n            // Clearly a bug\n            log(\"HIGHESTMODSEQ decreased, that's a bug in the IMAP server\", Common::LOG_MAILBOX_SYNC);\n            // won't use HIGHESTMODSEQ\n        } else {\n            // Will use FETCH CHANGEDSINCE\n            useModSeq = oldSyncState.highestModSeq();\n        }\n    }\n    if (useModSeq > 0) {\n        QMap<QByteArray, quint64> fetchModifier;\n        fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n    } else {\n        flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n    }\n    list->m_numberFetchingStatus = TreeItem::LOADING;\n    emit model->mailboxSyncingProgress(mailboxIndex, status);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::syncFlags(TreeItemMailbox *mailbox)\n  {\n      status = STATE_SYNCING_FLAGS;\n      log(\"Syncing flags\", Common::LOG_MAILBOX_SYNC);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n      Q_ASSERT(list);\n  \n      // 0 => don't use it; >0 => use that as the old value\n      quint64 useModSeq = 0;\n      if ((model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\")) ||\n           model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\"))) &&\n              oldSyncState.highestModSeq() > 0 && mailbox->syncState.isUsableForCondstore() &&\n              oldSyncState.uidValidity() == mailbox->syncState.uidValidity()) {\n          // The CONDSTORE is available, UIDVALIDITY has not changed and the HIGHESTMODSEQ suggests that\n          // it will be useful\n          if (oldSyncState.highestModSeq() == mailbox->syncState.highestModSeq()) {\n              // Looks like there were no changes in flags -- that's cool, we're done here,\n              // but only after some sanity checks\n              if (oldSyncState.exists() > mailbox->syncState.exists()) {\n                  log(\"Some messages have arrived to the mailbox, but HIGHESTMODSEQ hasn't changed. \"\n                      \"That's a bug in the server implementation.\", Common::LOG_MAILBOX_SYNC);\n                  // will issue the ordinary FETCH command for FLAGS\n              } else if (oldSyncState.uidNext() != mailbox->syncState.uidNext()) {\n                  log(\"UIDNEXT has changed, yet HIGHESTMODSEQ remained constant; that's server's bug\", Common::LOG_MAILBOX_SYNC);\n                  // and again, don't trust that HIGHESTMODSEQ\n              } else {\n                  // According to HIGHESTMODSEQ, there hasn't been any change. UIDNEXT and EXISTS do not contradict\n                  // this interpretation, so we can go and call stuff finished.\n                  if (newArrivalsFetch.isEmpty()) {\n                      // No pending activity -> let's call it a day\n                      status = STATE_DONE;\n                      mailbox->saveSyncStateAndUids(model);\n                      model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                      _completed();\n                      return;\n                  } else {\n                      // ...but there's still some pending activity; let's wait for its termination\n                      status = STATE_DONE;\n                  }\n              }\n          } else if (oldSyncState.highestModSeq() > mailbox->syncState.highestModSeq()) {\n              // Clearly a bug\n              log(\"HIGHESTMODSEQ decreased, that's a bug in the IMAP server\", Common::LOG_MAILBOX_SYNC);\n              // won't use HIGHESTMODSEQ\n          } else {\n              // Will use FETCH CHANGEDSINCE\n              useModSeq = oldSyncState.highestModSeq();\n          }\n      }\n      if (useModSeq > 0) {\n          QMap<QByteArray, quint64> fetchModifier;\n          fetchModifier[\"CHANGEDSINCE\"] = oldSyncState.highestModSeq();\n          flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"), fetchModifier);\n      } else {\n          flagsCmd = parser->fetch(Sequence(1, mailbox->syncState.exists()), QStringList() << QLatin1String(\"FLAGS\"));\n      }\n      list->m_numberFetchingStatus = TreeItem::LOADING;\n      emit model->mailboxSyncingProgress(mailboxIndex, status);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.isValid())"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tatus == STATE_SYNCING_FLAGS)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_AUTHENTICATED)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "SELECT failed: \")"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inalizeSelect(",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "finalizeSelect(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "220-384",
          "snippet": "oid ObtainSynchronizedMailboxTask::finalizeSelect()\n{\n    Q_ASSERT(mailboxIndex.isValid());\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n    Q_ASSERT(list);\n\n    model->changeConnectionState(parser, CONN_STATE_SYNCING);\n    const SyncState &syncState = mailbox->syncState;\n    oldSyncState = model->cache()->mailboxSyncState(mailbox->mailbox());\n    list->m_totalMessageCount = syncState.exists();\n    // Note: syncState.unSeen() is the NUMBER of the first unseen message, not their count!\n\n    uidMap = model->cache()->uidMapping(mailbox->mailbox());\n\n    if (static_cast<uint>(uidMap.size()) != oldSyncState.exists()) {\n\n        QString buf;\n        QDebug dbg(&buf);\n        dbg << \"Inconsistent cache data, falling back to full sync (\" << uidMap.size() << \"in UID map,\" << oldSyncState.exists() <<\n            \"EXIST before)\";\n        log(buf, Common::LOG_MAILBOX_SYNC);\n        oldSyncState.setHighestModSeq(0);\n        fullMboxSync(mailbox, list);\n    } else {\n        if (syncState.isUsableForSyncing() && oldSyncState.isUsableForSyncing() && syncState.uidValidity() == oldSyncState.uidValidity()) {\n            // Perform a nice re-sync\n\n            // Check the QRESYNC support and availability\n            if (m_usingQresync && oldSyncState.isUsableForCondstore() && syncState.isUsableForCondstore()) {\n                // Looks like we can use QRESYNC for fast syncing\n                if (oldSyncState.highestModSeq() > syncState.highestModSeq()) {\n                    // Looks like a corrupted cache or a server's bug\n                    log(\"Yuck, recycled HIGHESTMODSEQ when trying to use QRESYNC\", Common::LOG_MAILBOX_SYNC);\n                    mailbox->syncState.setHighestModSeq(0);\n                    model->cache()->clearAllMessages(mailbox->mailbox());\n                    m_usingQresync = false;\n                    fullMboxSync(mailbox, list);\n                } else {\n                    if (oldSyncState.highestModSeq() == syncState.highestModSeq()) {\n                        if (oldSyncState.exists() != syncState.exists()) {\n                            log(\"Sync error: QRESYNC says no changes but EXISTS has changed\", Common::LOG_MAILBOX_SYNC);\n                            mailbox->syncState.setHighestModSeq(0);\n                            model->cache()->clearAllMessages(mailbox->mailbox());\n                            m_usingQresync = false;\n                            fullMboxSync(mailbox, list);\n                        } else if (oldSyncState.uidNext() != syncState.uidNext()) {\n                            log(\"Sync error: QRESYNC says no changes but UIDNEXT has changed\", Common::LOG_MAILBOX_SYNC);\n                            mailbox->syncState.setHighestModSeq(0);\n                            model->cache()->clearAllMessages(mailbox->mailbox());\n                            m_usingQresync = false;\n                            fullMboxSync(mailbox, list);\n                        } else if (syncState.exists() != static_cast<uint>(list->m_children.size())) {\n                            log(QString::fromUtf8(\"Sync error: constant HIGHESTMODSEQ, EXISTS says %1 messages but in fact \"\n                                                   \"there are %2 when finalizing SELECT\")\n                                .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())),\n                                Common::LOG_MAILBOX_SYNC);\n                            mailbox->syncState.setHighestModSeq(0);\n                            model->cache()->clearAllMessages(mailbox->mailbox());\n                            m_usingQresync = false;\n                            fullMboxSync(mailbox, list);\n                        } else {\n                            // This should be enough\n                            list->setFetchStatus(TreeItem::DONE);\n                            notifyInterestingMessages(mailbox);\n                            mailbox->saveSyncStateAndUids(model);\n                            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                            _completed();\n                        }\n                        return;\n                    }\n\n                    if (static_cast<uint>(list->m_children.size()) != mailbox->syncState.exists()) {\n                        log(QString::fromUtf8(\"Sync error: EXISTS says %1 messages, msgList has %2\")\n                            .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())));\n                        mailbox->syncState.setHighestModSeq(0);\n                        model->cache()->clearAllMessages(mailbox->mailbox());\n                        m_usingQresync = false;\n                        fullMboxSync(mailbox, list);\n                        return;\n                    }\n\n\n                    if (oldSyncState.uidNext() < syncState.uidNext()) {\n                        list->setFetchStatus(TreeItem::DONE);\n                        int seqWithLowestUnknownUid = -1;\n                        for (int i = 0; i < list->m_children.size(); ++i) {\n                            TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n                            if (!msg->uid()) {\n                                seqWithLowestUnknownUid = i;\n                                break;\n                            }\n                        }\n                        if (seqWithLowestUnknownUid >= 0) {\n                            // We've got some new arrivals, but unfortunately QRESYNC won't report them just yet :(\n                            CommandHandle fetchCmd = parser->uidFetch(Sequence::startingAt(qMax(oldSyncState.uidNext(), 1u)),\n                                                                      QStringList() << QLatin1String(\"FLAGS\"));\n                            newArrivalsFetch.append(fetchCmd);\n                            status = STATE_DONE;\n                        } else {\n                            // All UIDs are known at this point, including the new arrivals, yay\n                            notifyInterestingMessages(mailbox);\n                            mailbox->saveSyncStateAndUids(model);\n                            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                            _completed();\n                        }\n                    } else {\n                        // This should be enough, the server should've sent the data already\n                        list->setFetchStatus(TreeItem::DONE);\n                        notifyInterestingMessages(mailbox);\n                        mailbox->saveSyncStateAndUids(model);\n                        model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                        _completed();\n                    }\n                }\n                return;\n            }\n\n            if (syncState.exists() == 0) {\n                // This is a special case, the mailbox doesn't contain any messages now.\n                // Let's just save ourselves some work and reuse the \"smart\" code in the fullMboxSync() here, it will\n                // do the right thing.\n                fullMboxSync(mailbox, list);\n                return;\n            }\n\n            if (syncState.uidNext() == oldSyncState.uidNext()) {\n                // No new messages\n\n                if (syncState.exists() == oldSyncState.exists()) {\n                    // No deletions, either, so we resync only flag changes\n                    syncNoNewNoDeletions(mailbox, list);\n                } else {\n                    // Some messages got deleted, but there have been no additions\n                    syncGeneric(mailbox, list);\n                }\n\n            } else if (syncState.uidNext() > oldSyncState.uidNext()) {\n                // Some new messages were delivered since we checked the last time.\n                // There's no guarantee they are still present, though.\n\n                if (syncState.uidNext() - oldSyncState.uidNext() == syncState.exists() - oldSyncState.exists()) {\n                    // Only some new arrivals, no deletions\n                    syncOnlyAdditions(mailbox, list);\n                } else {\n                    // Generic case; we don't know anything about which messages were deleted and which added\n                    syncGeneric(mailbox, list);\n                }\n            } else {\n                // The UIDNEXT has decreased while UIDVALIDITY remains the same. This is forbidden,\n                // so either a server's bug, or a completely invalid cache.\n                Q_ASSERT(syncState.uidNext() < oldSyncState.uidNext());\n                Q_ASSERT(syncState.uidValidity() == oldSyncState.uidValidity());\n                log(\"Yuck, UIDVALIDITY remains same but UIDNEXT decreased\", Common::LOG_MAILBOX_SYNC);\n                model->cache()->clearAllMessages(mailbox->mailbox());\n                fullMboxSync(mailbox, list);\n            }\n        } else {\n            // Forget everything, do a dumb sync\n            model->cache()->clearAllMessages(mailbox->mailbox());\n            fullMboxSync(mailbox, list);\n        }\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::finalizeSelect()\n  {\n      Q_ASSERT(mailboxIndex.isValid());\n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[ 0 ]);\n      Q_ASSERT(list);\n  \n      model->changeConnectionState(parser, CONN_STATE_SYNCING);\n      const SyncState &syncState = mailbox->syncState;\n      oldSyncState = model->cache()->mailboxSyncState(mailbox->mailbox());\n      list->m_totalMessageCount = syncState.exists();\n      // Note: syncState.unSeen() is the NUMBER of the first unseen message, not their count!\n  \n      uidMap = model->cache()->uidMapping(mailbox->mailbox());\n  \n      if (static_cast<uint>(uidMap.size()) != oldSyncState.exists()) {\n  \n          QString buf;\n          QDebug dbg(&buf);\n          dbg << \"Inconsistent cache data, falling back to full sync (\" << uidMap.size() << \"in UID map,\" << oldSyncState.exists() <<\n              \"EXIST before)\";\n          log(buf, Common::LOG_MAILBOX_SYNC);\n          oldSyncState.setHighestModSeq(0);\n          fullMboxSync(mailbox, list);\n      } else {\n          if (syncState.isUsableForSyncing() && oldSyncState.isUsableForSyncing() && syncState.uidValidity() == oldSyncState.uidValidity()) {\n              // Perform a nice re-sync\n  \n              // Check the QRESYNC support and availability\n              if (m_usingQresync && oldSyncState.isUsableForCondstore() && syncState.isUsableForCondstore()) {\n                  // Looks like we can use QRESYNC for fast syncing\n                  if (oldSyncState.highestModSeq() > syncState.highestModSeq()) {\n                      // Looks like a corrupted cache or a server's bug\n                      log(\"Yuck, recycled HIGHESTMODSEQ when trying to use QRESYNC\", Common::LOG_MAILBOX_SYNC);\n                      mailbox->syncState.setHighestModSeq(0);\n                      model->cache()->clearAllMessages(mailbox->mailbox());\n                      m_usingQresync = false;\n                      fullMboxSync(mailbox, list);\n                  } else {\n                      if (oldSyncState.highestModSeq() == syncState.highestModSeq()) {\n                          if (oldSyncState.exists() != syncState.exists()) {\n                              log(\"Sync error: QRESYNC says no changes but EXISTS has changed\", Common::LOG_MAILBOX_SYNC);\n                              mailbox->syncState.setHighestModSeq(0);\n                              model->cache()->clearAllMessages(mailbox->mailbox());\n                              m_usingQresync = false;\n                              fullMboxSync(mailbox, list);\n                          } else if (oldSyncState.uidNext() != syncState.uidNext()) {\n                              log(\"Sync error: QRESYNC says no changes but UIDNEXT has changed\", Common::LOG_MAILBOX_SYNC);\n                              mailbox->syncState.setHighestModSeq(0);\n                              model->cache()->clearAllMessages(mailbox->mailbox());\n                              m_usingQresync = false;\n                              fullMboxSync(mailbox, list);\n                          } else if (syncState.exists() != static_cast<uint>(list->m_children.size())) {\n                              log(QString::fromUtf8(\"Sync error: constant HIGHESTMODSEQ, EXISTS says %1 messages but in fact \"\n                                                     \"there are %2 when finalizing SELECT\")\n                                  .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())),\n                                  Common::LOG_MAILBOX_SYNC);\n                              mailbox->syncState.setHighestModSeq(0);\n                              model->cache()->clearAllMessages(mailbox->mailbox());\n                              m_usingQresync = false;\n                              fullMboxSync(mailbox, list);\n                          } else {\n                              // This should be enough\n                              list->setFetchStatus(TreeItem::DONE);\n                              notifyInterestingMessages(mailbox);\n                              mailbox->saveSyncStateAndUids(model);\n                              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                              _completed();\n                          }\n                          return;\n                      }\n  \n                      if (static_cast<uint>(list->m_children.size()) != mailbox->syncState.exists()) {\n                          log(QString::fromUtf8(\"Sync error: EXISTS says %1 messages, msgList has %2\")\n                              .arg(QString::number(mailbox->syncState.exists()), QString::number(list->m_children.size())));\n                          mailbox->syncState.setHighestModSeq(0);\n                          model->cache()->clearAllMessages(mailbox->mailbox());\n                          m_usingQresync = false;\n                          fullMboxSync(mailbox, list);\n                          return;\n                      }\n  \n  \n                      if (oldSyncState.uidNext() < syncState.uidNext()) {\n                          list->setFetchStatus(TreeItem::DONE);\n                          int seqWithLowestUnknownUid = -1;\n                          for (int i = 0; i < list->m_children.size(); ++i) {\n                              TreeItemMessage *msg = static_cast<TreeItemMessage*>(list->m_children[i]);\n                              if (!msg->uid()) {\n                                  seqWithLowestUnknownUid = i;\n                                  break;\n                              }\n                          }\n                          if (seqWithLowestUnknownUid >= 0) {\n                              // We've got some new arrivals, but unfortunately QRESYNC won't report them just yet :(\n                              CommandHandle fetchCmd = parser->uidFetch(Sequence::startingAt(qMax(oldSyncState.uidNext(), 1u)),\n                                                                        QStringList() << QLatin1String(\"FLAGS\"));\n                              newArrivalsFetch.append(fetchCmd);\n                              status = STATE_DONE;\n                          } else {\n                              // All UIDs are known at this point, including the new arrivals, yay\n                              notifyInterestingMessages(mailbox);\n                              mailbox->saveSyncStateAndUids(model);\n                              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                              _completed();\n                          }\n                      } else {\n                          // This should be enough, the server should've sent the data already\n                          list->setFetchStatus(TreeItem::DONE);\n                          notifyInterestingMessages(mailbox);\n                          mailbox->saveSyncStateAndUids(model);\n                          model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                          _completed();\n                      }\n                  }\n                  return;\n              }\n  \n              if (syncState.exists() == 0) {\n                  // This is a special case, the mailbox doesn't contain any messages now.\n                  // Let's just save ourselves some work and reuse the \"smart\" code in the fullMboxSync() here, it will\n                  // do the right thing.\n                  fullMboxSync(mailbox, list);\n                  return;\n              }\n  \n              if (syncState.uidNext() == oldSyncState.uidNext()) {\n                  // No new messages\n  \n                  if (syncState.exists() == oldSyncState.exists()) {\n                      // No deletions, either, so we resync only flag changes\n                      syncNoNewNoDeletions(mailbox, list);\n                  } else {\n                      // Some messages got deleted, but there have been no additions\n                      syncGeneric(mailbox, list);\n                  }\n  \n              } else if (syncState.uidNext() > oldSyncState.uidNext()) {\n                  // Some new messages were delivered since we checked the last time.\n                  // There's no guarantee they are still present, though.\n  \n                  if (syncState.uidNext() - oldSyncState.uidNext() == syncState.exists() - oldSyncState.exists()) {\n                      // Only some new arrivals, no deletions\n                      syncOnlyAdditions(mailbox, list);\n                  } else {\n                      // Generic case; we don't know anything about which messages were deleted and which added\n                      syncGeneric(mailbox, list);\n                  }\n              } else {\n                  // The UIDNEXT has decreased while UIDVALIDITY remains the same. This is forbidden,\n                  // so either a server's bug, or a completely invalid cache.\n                  Q_ASSERT(syncState.uidNext() < oldSyncState.uidNext());\n                  Q_ASSERT(syncState.uidValidity() == oldSyncState.uidValidity());\n                  log(\"Yuck, UIDVALIDITY remains same but UIDNEXT decreased\", Common::LOG_MAILBOX_SYNC);\n                  model->cache()->clearAllMessages(mailbox->mailbox());\n                  fullMboxSync(mailbox, list);\n              }\n          } else {\n              // Forget everything, do a dumb sync\n              model->cache()->clearAllMessages(mailbox->mailbox());\n              fullMboxSync(mailbox, list);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "tatus == STATE_SELECTING)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleResponseCodeInsideState(",
          "args": [
            "esp)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "handleResponseCodeInsideState(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "592-668",
          "snippet": "ool ObtainSynchronizedMailboxTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return resp->tag.isEmpty();\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    switch (resp->respCode) {\n    case Responses::UNSEEN:\n    {\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUnSeenOffset(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UNSEEN respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::PERMANENTFLAGS:\n    {\n        const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setPermanentFlags(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::UIDNEXT:\n    {\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUidNext(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::UIDVALIDITY:\n    {\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUidValidity(num->data);\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UIDVALIDITY respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::NOMODSEQ:\n        // NOMODSEQ means that this mailbox doesn't support CONDSTORE or QRESYNC. We have to avoid sending any fancy commands like\n        // the FETCH CHANGEDSINCE etc.\n        mailbox->syncState.setHighestModSeq(0);\n        m_usingQresync = false;\n        return resp->tag.isEmpty();\n        break;\n\n    case Responses::HIGHESTMODSEQ:\n    {\n        const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n        Q_ASSERT(num);\n        mailbox->syncState.setHighestModSeq(num->data);\n        return resp->tag.isEmpty();\n        break;\n    }\n    case Responses::CLOSED:\n        // FIXME: handle when supporting the qresync\n        return resp->tag.isEmpty();\n        break;\n    default:\n        break;\n    }\n    return false;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return resp->tag.isEmpty();\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      switch (resp->respCode) {\n      case Responses::UNSEEN:\n      {\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUnSeenOffset(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UNSEEN respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::PERMANENTFLAGS:\n      {\n          const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setPermanentFlags(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::UIDNEXT:\n      {\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUidNext(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::UIDVALIDITY:\n      {\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUidValidity(num->data);\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UIDVALIDITY respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::NOMODSEQ:\n          // NOMODSEQ means that this mailbox doesn't support CONDSTORE or QRESYNC. We have to avoid sending any fancy commands like\n          // the FETCH CHANGEDSINCE etc.\n          mailbox->syncState.setHighestModSeq(0);\n          m_usingQresync = false;\n          return resp->tag.isEmpty();\n          break;\n  \n      case Responses::HIGHESTMODSEQ:\n      {\n          const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n          Q_ASSERT(num);\n          mailbox->syncState.setHighestModSeq(num->data);\n          return resp->tag.isEmpty();\n          break;\n      }\n      case Responses::CLOSED:\n          // FIXME: handle when supporting the qresync\n          return resp->tag.isEmpty();\n          break;\n      default:\n          break;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1159-1176",
          "snippet": "ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n    // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n\n    log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n\n    if (!unSelectTask) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      // OK, so we are in trouble -- our mailbox has disappeared, but the IMAP server will likely keep us busy with its\n      // status updates. This is bad, so we have to get out as fast as possible. All hands, evasive maneuvers!\n  \n      log(\"Mailbox disappeared\", Common::LOG_MAILBOX_SYNC);\n  \n      if (!unSelectTask) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask*)), this, SLOT(slotUnSelectCompleted()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      if (handleResponseCodeInsideState(resp))\n          return true;\n  \n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      // We absolutely have to ignore the abort() request\n  \n      if (resp->tag == selectCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              //qDebug() << \"received OK for selectCmd\";\n              Q_ASSERT(status == STATE_SELECTING);\n              finalizeSelect();\n          } else {\n              _failed(QLatin1String(\"SELECT failed: \") + resp->message);\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n          }\n          return true;\n      } else if (resp->tag == uidSyncingCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              // FIXME: move the finalizeSearch() here to support working with split SEARCH reposnes -- but beware of\n              // arrivals/expunges which happen while the UID SEARCH is in progres...\n              log(\"UIDs synchronized\", Common::LOG_MAILBOX_SYNC);\n              Q_ASSERT(status == STATE_SYNCING_FLAGS);\n              Q_ASSERT(mailboxIndex.isValid());   // FIXME\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              syncFlags(mailbox);\n          } else {\n              _failed(QLatin1String(\"UID syncing failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          return true;\n      } else if (resp->tag == flagsCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              //qDebug() << \"received OK for flagsCmd\";\n              Q_ASSERT(status == STATE_SYNCING_FLAGS);\n              Q_ASSERT(mailboxIndex.isValid());\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              status = STATE_DONE;\n              log(\"Flags synchronized\", Common::LOG_MAILBOX_SYNC);\n              notifyInterestingMessages(mailbox);\n              flagsCmd.clear();\n  \n              if (newArrivalsFetch.isEmpty()) {\n                  mailbox->saveSyncStateAndUids(model);\n                  model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                  _completed();\n              } else {\n                  log(\"Pending new arrival fetching, not terminating yet\", Common::LOG_MAILBOX_SYNC);\n              }\n          } else {\n              status = STATE_DONE;\n              _failed(QLatin1String(\"Flags synchronization failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          return true;\n      } else if (newArrivalsFetch.contains(resp->tag)) {\n  \n          if (resp->kind == Responses::OK) {\n              newArrivalsFetch.removeOne(resp->tag);\n  \n              if (newArrivalsFetch.isEmpty() && status == STATE_DONE && flagsCmd.isEmpty()) {\n                  Q_ASSERT(mailboxIndex.isValid());\n                  TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n                  Q_ASSERT(mailbox);\n                  mailbox->saveSyncStateAndUids(model);\n                  model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                  _completed();\n              }\n          } else {\n              _failed(QLatin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          return true;\n  \n      } else {\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "65-123",
    "snippet": "oid ObtainSynchronizedMailboxTask::perform()\n{\n    CHECK_TASK_TREE\n    markAsActiveTask();\n\n    if (_dead || _aborted) {\n        // We're at the very start, so let's try to abort in a sane way\n        _failed(\"Asked to abort or die\");\n        die(tr(\"Mailbox syncing dead or aborted\"));\n        return;\n    }\n\n    if (! mailboxIndex.isValid()) {\n        // FIXME: proper error handling\n        log(\"The mailbox went missing, sorry\", Common::LOG_MAILBOX_SYNC);\n        _completed();\n        return;\n    }\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *msgList = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(msgList);\n\n    msgList->setFetchStatus(TreeItem::LOADING);\n\n    Q_ASSERT(model->m_parsers.contains(parser));\n\n    oldSyncState = model->cache()->mailboxSyncState(mailbox->mailbox());\n    if (model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\")) && oldSyncState.isUsableForCondstore()) {\n        m_usingQresync = true;\n        QList<uint> oldUidMap = model->cache()->uidMapping(mailbox->mailbox());\n        if (oldUidMap.isEmpty()) {\n            selectCmd = parser->selectQresync(mailbox->mailbox(), oldSyncState.uidValidity(),\n                                              oldSyncState.highestModSeq());\n        } else {\n            Sequence knownSeq, knownUid;\n            int i = oldUidMap.size() / 2;\n            while (i < oldUidMap.size()) {\n                // Message sequence number is one-based, our indexes are zero-based\n                knownSeq.add(i + 1);\n                knownUid.add(oldUidMap[i]);\n                i += (oldUidMap.size() - i) / 2 + 1;\n            }\n            // We absolutely want to maintain a complete UID->seq mapping at all times, which is why the known-uids shall remain\n            // empty to indicate \"anything\".\n            selectCmd = parser->selectQresync(mailbox->mailbox(), oldSyncState.uidValidity(),\n                                              oldSyncState.highestModSeq(), Sequence(), knownSeq, knownUid);\n        }\n    } else if (model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\"))) {\n        selectCmd = parser->select(mailbox->mailbox(), QList<QByteArray>() << \"CONDSTORE\");\n    } else {\n        selectCmd = parser->select(mailbox->mailbox());\n    }\n    mailbox->syncState = SyncState();\n    status = STATE_SELECTING;\n    log(\"Synchronizing mailbox\", Common::LOG_MAILBOX_SYNC);\n    emit model->mailboxSyncingProgress(mailboxIndex, status);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Synchronizing mailbox\",",
            "ommon::LOG_MAILBOX_SYNC)"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "yncState(",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "SyncState(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "30-36",
          "snippet": "yncState::SyncState():\n    m_exists(0), m_recent(0), m_unSeenCount(0), m_unSeenOffset(0), m_uidNext(0), m_uidValidity(0), m_highestModSeq(0),\n    m_hasExists(false), m_hasRecent(false), m_hasUnSeenCount(false), m_hasUnSeenOffset(false),\n    m_hasUidNext(false), m_hasUidValidity(false), m_hasHighestModSeq(false), m_hasFlags(false),\n    m_hasPermanentFlags(false)\n{\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  yncState::SyncState():\n      m_exists(0), m_recent(0), m_unSeenCount(0), m_unSeenOffset(0), m_uidNext(0), m_uidValidity(0), m_highestModSeq(0),\n      m_hasExists(false), m_hasRecent(false), m_hasUnSeenCount(false), m_hasUnSeenOffset(false),\n      m_hasUidNext(false), m_hasUidValidity(false), m_hasHighestModSeq(false), m_hasFlags(false),\n      m_hasPermanentFlags(false)\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arser->select",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->select",
          "args": [
            "ailbox->mailbox(),",
            "List<QByteArray>() << \"CONDSTORE\")"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "select(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "154-165",
          "snippet": "ommandHandle Parser::select(const QString &mailbox, const QList<QByteArray> &params)\n{\n    Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox);\n    if (!params.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n        Q_FOREACH(const QByteArray &param, params) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, param);\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::select(const QString &mailbox, const QList<QByteArray> &params)\n  {\n      Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox);\n      if (!params.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n          Q_FOREACH(const QByteArray &param, params) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, param);\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "List<QByteArray>",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "ake_ListChildMailboxesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/Fake_ListChildMailboxesTask.cpp",
          "lines": "42-67",
          "snippet": "oid Fake_ListChildMailboxesTask::perform()\n{\n    parser = conn->parser;\n    markAsActiveTask();\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    parser = conn->parser;\n    QList<Responses::List> &listResponses = model->accessParser(parser).listResponses;\n    Q_ASSERT(listResponses.isEmpty());\n    TestingTaskFactory *factory = dynamic_cast<TestingTaskFactory *>(model->m_taskFactory.get());\n    Q_ASSERT(factory);\n    for (QMap<QString, QStringList>::const_iterator it = factory->fakeListChildMailboxesMap.constBegin();\n         it != factory->fakeListChildMailboxesMap.constEnd(); ++it) {\n        if (it.key() != mailbox->mailbox())\n            continue;\n        for (QStringList::const_iterator childIt = it->begin(); childIt != it->end(); ++childIt) {\n            QString childMailbox = mailbox->mailbox().isEmpty() ? *childIt : QString::fromUtf8(\"%1^%2\").arg(mailbox->mailbox(), *childIt);\n            listResponses.append(Responses::List(Responses::LIST, QStringList(), QLatin1String(\"^\"), childMailbox, QMap<QByteArray, QVariant>()));\n        }\n    }\n    model->finalizeList(parser, mailbox);\n    _completed();\n}",
          "includes": [
            "include \"GetAnyConnectionTask.h\"",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Fake_ListChildMailboxesTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"GetAnyConnectionTask.h\"\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Fake_ListChildMailboxesTask.h\"\n#\n\nake_ListChildMailboxesTask {\n  oid Fake_ListChildMailboxesTask::perform()\n  {\n      parser = conn->parser;\n      markAsActiveTask();\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      parser = conn->parser;\n      QList<Responses::List> &listResponses = model->accessParser(parser).listResponses;\n      Q_ASSERT(listResponses.isEmpty());\n      TestingTaskFactory *factory = dynamic_cast<TestingTaskFactory *>(model->m_taskFactory.get());\n      Q_ASSERT(factory);\n      for (QMap<QString, QStringList>::const_iterator it = factory->fakeListChildMailboxesMap.constBegin();\n           it != factory->fakeListChildMailboxesMap.constEnd(); ++it) {\n          if (it.key() != mailbox->mailbox())\n              continue;\n          for (QStringList::const_iterator childIt = it->begin(); childIt != it->end(); ++childIt) {\n              QString childMailbox = mailbox->mailbox().isEmpty() ? *childIt : QString::fromUtf8(\"%1^%2\").arg(mailbox->mailbox(), *childIt);\n              listResponses.append(Responses::List(Responses::LIST, QStringList(), QLatin1String(\"^\"), childMailbox, QMap<QByteArray, QVariant>()));\n          }\n      }\n      model->finalizeList(parser, mailbox);\n      _completed();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"CONDSTORE\"))"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CONDSTORE\")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->selectQresync",
          "args": [
            "ailbox->mailbox(),",
            "ldSyncState.uidValidity(),",
            "ldSyncState.highestModSeq(),",
            "equence(),",
            "nownSeq,",
            "nownUid)"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "selectQresync(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "167-188",
          "snippet": "ommandHandle Parser::selectQresync(const QString &mailbox, const uint uidValidity,\n                                    const quint64 highestModSeq, const Sequence &knownUids, const Sequence &sequenceSnapshot,\n                                    const Sequence &uidSnapshot)\n{\n    Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox) <<\n           Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (QRESYNC (\") <<\n           Commands::PartOfCommand(Commands::ATOM, QByteArray::number(uidValidity)) <<\n           Commands::PartOfCommand(Commands::ATOM, QByteArray::number(highestModSeq));\n    if (knownUids.isValid()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM, knownUids.toByteArray());\n    }\n    Q_ASSERT(uidSnapshot.isValid() == sequenceSnapshot.isValid());\n    if (sequenceSnapshot.isValid()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\") <<\n               Commands::PartOfCommand(Commands::ATOM, sequenceSnapshot.toByteArray()) <<\n               Commands::PartOfCommand(Commands::ATOM, uidSnapshot.toByteArray()) <<\n               Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")))\");\n    } else {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \"))\");\n    }\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::selectQresync(const QString &mailbox, const uint uidValidity,\n                                      const quint64 highestModSeq, const Sequence &knownUids, const Sequence &sequenceSnapshot,\n                                      const Sequence &uidSnapshot)\n  {\n      Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox) <<\n             Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (QRESYNC (\") <<\n             Commands::PartOfCommand(Commands::ATOM, QByteArray::number(uidValidity)) <<\n             Commands::PartOfCommand(Commands::ATOM, QByteArray::number(highestModSeq));\n      if (knownUids.isValid()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM, knownUids.toByteArray());\n      }\n      Q_ASSERT(uidSnapshot.isValid() == sequenceSnapshot.isValid());\n      if (sequenceSnapshot.isValid()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\") <<\n                 Commands::PartOfCommand(Commands::ATOM, sequenceSnapshot.toByteArray()) <<\n                 Commands::PartOfCommand(Commands::ATOM, uidSnapshot.toByteArray()) <<\n                 Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")))\");\n      } else {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \"))\");\n      }\n      return queueCommand(cmd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "equence(",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "equence(",
          "container": "equence\n",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.h",
          "lines": "46-46",
          "snippet": "equence(): kind(DISTINCT) {}",
          "includes": [
            "include <QString>",
            "include <QList>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QString>\ninclude <QList>\n#\n\nequence\n {\n  equence(): kind(DISTINCT) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidValidity",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldUidMap.size",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nownUid.add",
          "args": [
            "ldUidMap[i])"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nownSeq.add",
          "args": [
            "+ 1)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldUidMap.size",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldUidMap.size",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->selectQresync",
          "args": [
            "ailbox->mailbox(),",
            "ldSyncState.uidValidity(),",
            "ldSyncState.highestModSeq())"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.highestModSeq",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.uidValidity",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldUidMap.isEmpty",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ldSyncState.isUsableForCondstore",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"QRESYNC\"))"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "QRESYNC\")"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [
            "ailbox->mailbox())"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->cache",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel->m_parsers.contains(parser))"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_parsers.contains",
          "args": [
            "arser)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sgList->setFetchStatus",
          "args": [
            "reeItem::LOADING)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sgList)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie(",
          "args": [
            "r(\"Mailbox syncing dead or aborted\"))"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "619-630",
          "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::die(const QString &message)\n  {\n      if (shouldExit) {\n          // OK, we're done, and getting killed. This is fine; just don't emit failed()\n          // because we aren't actually failing.\n          // This is a speciality of the KeepMailboxOpenTask because it's the only task\n          // this has a very long life.\n          _finished = true;\n      }\n      ImapTask::die(message);\n      detachFromMailbox();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Mailbox syncing dead or aborted\")"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "125-218",
          "snippet": "ool ObtainSynchronizedMailboxTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    if (handleResponseCodeInsideState(resp))\n        return true;\n\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n    // We absolutely have to ignore the abort() request\n\n    if (resp->tag == selectCmd) {\n\n        if (resp->kind == Responses::OK) {\n            //qDebug() << \"received OK for selectCmd\";\n            Q_ASSERT(status == STATE_SELECTING);\n            finalizeSelect();\n        } else {\n            _failed(QLatin1String(\"SELECT failed: \") + resp->message);\n            model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n        }\n        return true;\n    } else if (resp->tag == uidSyncingCmd) {\n\n        if (resp->kind == Responses::OK) {\n            // FIXME: move the finalizeSearch() here to support working with split SEARCH reposnes -- but beware of\n            // arrivals/expunges which happen while the UID SEARCH is in progres...\n            log(\"UIDs synchronized\", Common::LOG_MAILBOX_SYNC);\n            Q_ASSERT(status == STATE_SYNCING_FLAGS);\n            Q_ASSERT(mailboxIndex.isValid());   // FIXME\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            syncFlags(mailbox);\n        } else {\n            _failed(QLatin1String(\"UID syncing failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        return true;\n    } else if (resp->tag == flagsCmd) {\n\n        if (resp->kind == Responses::OK) {\n            //qDebug() << \"received OK for flagsCmd\";\n            Q_ASSERT(status == STATE_SYNCING_FLAGS);\n            Q_ASSERT(mailboxIndex.isValid());\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            status = STATE_DONE;\n            log(\"Flags synchronized\", Common::LOG_MAILBOX_SYNC);\n            notifyInterestingMessages(mailbox);\n            flagsCmd.clear();\n\n            if (newArrivalsFetch.isEmpty()) {\n                mailbox->saveSyncStateAndUids(model);\n                model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                _completed();\n            } else {\n                log(\"Pending new arrival fetching, not terminating yet\", Common::LOG_MAILBOX_SYNC);\n            }\n        } else {\n            status = STATE_DONE;\n            _failed(QLatin1String(\"Flags synchronization failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        emit model->mailboxSyncingProgress(mailboxIndex, status);\n        return true;\n    } else if (newArrivalsFetch.contains(resp->tag)) {\n\n        if (resp->kind == Responses::OK) {\n            newArrivalsFetch.removeOne(resp->tag);\n\n            if (newArrivalsFetch.isEmpty() && status == STATE_DONE && flagsCmd.isEmpty()) {\n                Q_ASSERT(mailboxIndex.isValid());\n                TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n                Q_ASSERT(mailbox);\n                mailbox->saveSyncStateAndUids(model);\n                model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                _completed();\n            }\n        } else {\n            _failed(QLatin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message);\n            // FIXME: UNSELECT?\n        }\n        return true;\n\n    } else {\n        return false;\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  ool ObtainSynchronizedMailboxTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      if (handleResponseCodeInsideState(resp))\n          return true;\n  \n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n      // We absolutely have to ignore the abort() request\n  \n      if (resp->tag == selectCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              //qDebug() << \"received OK for selectCmd\";\n              Q_ASSERT(status == STATE_SELECTING);\n              finalizeSelect();\n          } else {\n              _failed(QLatin1String(\"SELECT failed: \") + resp->message);\n              model->changeConnectionState(parser, CONN_STATE_AUTHENTICATED);\n          }\n          return true;\n      } else if (resp->tag == uidSyncingCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              // FIXME: move the finalizeSearch() here to support working with split SEARCH reposnes -- but beware of\n              // arrivals/expunges which happen while the UID SEARCH is in progres...\n              log(\"UIDs synchronized\", Common::LOG_MAILBOX_SYNC);\n              Q_ASSERT(status == STATE_SYNCING_FLAGS);\n              Q_ASSERT(mailboxIndex.isValid());   // FIXME\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              syncFlags(mailbox);\n          } else {\n              _failed(QLatin1String(\"UID syncing failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          return true;\n      } else if (resp->tag == flagsCmd) {\n  \n          if (resp->kind == Responses::OK) {\n              //qDebug() << \"received OK for flagsCmd\";\n              Q_ASSERT(status == STATE_SYNCING_FLAGS);\n              Q_ASSERT(mailboxIndex.isValid());\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              status = STATE_DONE;\n              log(\"Flags synchronized\", Common::LOG_MAILBOX_SYNC);\n              notifyInterestingMessages(mailbox);\n              flagsCmd.clear();\n  \n              if (newArrivalsFetch.isEmpty()) {\n                  mailbox->saveSyncStateAndUids(model);\n                  model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                  _completed();\n              } else {\n                  log(\"Pending new arrival fetching, not terminating yet\", Common::LOG_MAILBOX_SYNC);\n              }\n          } else {\n              status = STATE_DONE;\n              _failed(QLatin1String(\"Flags synchronization failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          emit model->mailboxSyncingProgress(mailboxIndex, status);\n          return true;\n      } else if (newArrivalsFetch.contains(resp->tag)) {\n  \n          if (resp->kind == Responses::OK) {\n              newArrivalsFetch.removeOne(resp->tag);\n  \n              if (newArrivalsFetch.isEmpty() && status == STATE_DONE && flagsCmd.isEmpty()) {\n                  Q_ASSERT(mailboxIndex.isValid());\n                  TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n                  Q_ASSERT(mailbox);\n                  mailbox->saveSyncStateAndUids(model);\n                  model->changeConnectionState(parser, CONN_STATE_SELECTED);\n                  _completed();\n              }\n          } else {\n              _failed(QLatin1String(\"UID discovery of new arrivals after initial UID sync has failed: \") + resp->message);\n              // FIXME: UNSELECT?\n          }\n          return true;\n  \n      } else {\n          return false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Asked to abort or die\")"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::perform()\n  {\n      CHECK_TASK_TREE\n      markAsActiveTask();\n  \n      if (_dead || _aborted) {\n          // We're at the very start, so let's try to abort in a sane way\n          _failed(\"Asked to abort or die\");\n          die(tr(\"Mailbox syncing dead or aborted\"));\n          return;\n      }\n  \n      if (! mailboxIndex.isValid()) {\n          // FIXME: proper error handling\n          log(\"The mailbox went missing, sorry\", Common::LOG_MAILBOX_SYNC);\n          _completed();\n          return;\n      }\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *msgList = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(msgList);\n  \n      msgList->setFetchStatus(TreeItem::LOADING);\n  \n      Q_ASSERT(model->m_parsers.contains(parser));\n  \n      oldSyncState = model->cache()->mailboxSyncState(mailbox->mailbox());\n      if (model->accessParser(parser).capabilities.contains(QLatin1String(\"QRESYNC\")) && oldSyncState.isUsableForCondstore()) {\n          m_usingQresync = true;\n          QList<uint> oldUidMap = model->cache()->uidMapping(mailbox->mailbox());\n          if (oldUidMap.isEmpty()) {\n              selectCmd = parser->selectQresync(mailbox->mailbox(), oldSyncState.uidValidity(),\n                                                oldSyncState.highestModSeq());\n          } else {\n              Sequence knownSeq, knownUid;\n              int i = oldUidMap.size() / 2;\n              while (i < oldUidMap.size()) {\n                  // Message sequence number is one-based, our indexes are zero-based\n                  knownSeq.add(i + 1);\n                  knownUid.add(oldUidMap[i]);\n                  i += (oldUidMap.size() - i) / 2 + 1;\n              }\n              // We absolutely want to maintain a complete UID->seq mapping at all times, which is why the known-uids shall remain\n              // empty to indicate \"anything\".\n              selectCmd = parser->selectQresync(mailbox->mailbox(), oldSyncState.uidValidity(),\n                                                oldSyncState.highestModSeq(), Sequence(), knownSeq, knownUid);\n          }\n      } else if (model->accessParser(parser).capabilities.contains(QLatin1String(\"CONDSTORE\"))) {\n          selectCmd = parser->select(mailbox->mailbox(), QList<QByteArray>() << \"CONDSTORE\");\n      } else {\n          selectCmd = parser->select(mailbox->mailbox());\n      }\n      mailbox->syncState = SyncState();\n      status = STATE_SELECTING;\n      log(\"Synchronizing mailbox\", Common::LOG_MAILBOX_SYNC);\n      emit model->mailboxSyncingProgress(mailboxIndex, status);\n  }\n}"
  },
  {
    "function_name": "addDependentTask(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "57-63",
    "snippet": "oid ObtainSynchronizedMailboxTask::addDependentTask(ImapTask *task)\n{\n    if (!dependentTasks.isEmpty()) {\n        throw CantHappen(\"Attempted to add another dependent task to an ObtainSynchronizedMailboxTask\");\n    }\n    ImapTask::addDependentTask(task);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapTask::addDependentTask(",
          "args": [
            "ask)"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "addDependentTask(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "57-63",
          "snippet": "oid ObtainSynchronizedMailboxTask::addDependentTask(ImapTask *task)\n{\n    if (!dependentTasks.isEmpty()) {\n        throw CantHappen(\"Attempted to add another dependent task to an ObtainSynchronizedMailboxTask\");\n    }\n    ImapTask::addDependentTask(task);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "Attempted to add another dependent task to an ObtainSynchronizedMailboxTask\")"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependentTasks.isEmpty",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::addDependentTask(ImapTask *task)\n  {\n      if (!dependentTasks.isEmpty()) {\n          throw CantHappen(\"Attempted to add another dependent task to an ObtainSynchronizedMailboxTask\");\n      }\n      ImapTask::addDependentTask(task);\n  }\n}"
  },
  {
    "function_name": "ObtainSynchronizedMailboxTask(",
    "container": "btainSynchronizedMailboxTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
    "lines": "39-55",
    "snippet": "btainSynchronizedMailboxTask::ObtainSynchronizedMailboxTask(Model *model, const QModelIndex &mailboxIndex, ImapTask *parentTask,\n        KeepMailboxOpenTask *keepTask):\n    ImapTask(model), conn(parentTask), mailboxIndex(mailboxIndex), status(STATE_WAIT_FOR_CONN), uidSyncingMode(UID_SYNC_ALL),\n    firstUnknownUidOffset(0), m_usingQresync(false), unSelectTask(0), keepTaskChild(keepTask)\n{\n    // The Parser* is not provided by our parent task, but instead through the keepTaskChild.  The reason is simple, the parent\n    // task might not even exist, but there's always an KeepMailboxOpenTask in the game.\n    parser = keepTaskChild->parser;\n    Q_ASSERT(parser);\n    if (conn) {\n        conn->addDependentTask(this);\n    }\n    CHECK_TASK_TREE\n    addDependentTask(keepTaskChild);\n    CHECK_TASK_TREE\n    connect(this, SIGNAL(failed(QString)), this, SLOT(signalSyncFailure(QString)));\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include <QTimer>\n#",
      "include <sstream>\n#",
      "include <algorithm>\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "ignalSyncFailure(QString))"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignalSyncFailure(",
          "args": [
            "String)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "signalSyncFailure(",
          "container": "btainSynchronizedMailboxTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ObtainSynchronizedMailboxTask.cpp",
          "lines": "1190-1199",
          "snippet": "oid ObtainSynchronizedMailboxTask::signalSyncFailure(const QString &message)\n{\n    if (!mailboxIndex.isValid()) {\n        // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n        // Seems that there's nothing to report here.\n        return;\n    }\n\n    EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include <QTimer>\n#",
            "include <sstream>\n#",
            "include <algorithm>\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  oid ObtainSynchronizedMailboxTask::signalSyncFailure(const QString &message)\n  {\n      if (!mailboxIndex.isValid()) {\n          // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n          // Seems that there's nothing to report here.\n          return;\n      }\n  \n      EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ailed(QString))"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailed(",
          "args": [
            "String)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arser)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude <QTimer>\n#\ninclude <sstream>\n#\ninclude <algorithm>\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\n\nbtainSynchronizedMailboxTask {\n  btainSynchronizedMailboxTask::ObtainSynchronizedMailboxTask(Model *model, const QModelIndex &mailboxIndex, ImapTask *parentTask,\n          KeepMailboxOpenTask *keepTask):\n      ImapTask(model), conn(parentTask), mailboxIndex(mailboxIndex), status(STATE_WAIT_FOR_CONN), uidSyncingMode(UID_SYNC_ALL),\n      firstUnknownUidOffset(0), m_usingQresync(false), unSelectTask(0), keepTaskChild(keepTask)\n  {\n      // The Parser* is not provided by our parent task, but instead through the keepTaskChild.  The reason is simple, the parent\n      // task might not even exist, but there's always an KeepMailboxOpenTask in the game.\n      parser = keepTaskChild->parser;\n      Q_ASSERT(parser);\n      if (conn) {\n          conn->addDependentTask(this);\n      }\n      CHECK_TASK_TREE\n      addDependentTask(keepTaskChild);\n      CHECK_TASK_TREE\n      connect(this, SIGNAL(failed(QString)), this, SLOT(signalSyncFailure(QString)));\n  }\n}"
  }
]