[
  {
    "function_name": "isConnectingEncryptedSinceStart(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "406-409",
    "snippet": "ool SslTlsSocket::isConnectingEncryptedSinceStart() const\n{\n    return startEncrypted;\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  ool SslTlsSocket::isConnectingEncryptedSinceStart() const\n  {\n      return startEncrypted;\n  }\n}"
  },
  {
    "function_name": "sslErrors(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "399-404",
    "snippet": "List<QSslError> SslTlsSocket::sslErrors() const\n{\n    QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n    Q_ASSERT(sock);\n    return sock->sslErrors();\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ock->sslErrors",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QSslSocket *>",
          "args": [
            ")"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  List<QSslError> SslTlsSocket::sslErrors() const\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n      Q_ASSERT(sock);\n      return sock->sslErrors();\n  }\n}"
  },
  {
    "function_name": "sslChain(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "392-397",
    "snippet": "List<QSslCertificate> SslTlsSocket::sslChain() const\n{\n    QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n    Q_ASSERT(sock);\n    return sock->peerCertificateChain();\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ock->peerCertificateChain",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QSslSocket *>",
          "args": [
            ")"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  List<QSslCertificate> SslTlsSocket::sslChain() const\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n      Q_ASSERT(sock);\n      return sock->peerCertificateChain();\n  }\n}"
  },
  {
    "function_name": "delayedStart(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "335-390",
    "snippet": "oid SslTlsSocket::delayedStart()\n{\n    QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n    Q_ASSERT(sock);\n\n    switch (m_proxySettings) {\n    case Streams::ProxySettings::RespectSystemProxy:\n    {\n        QNetworkProxy setting;\n        QNetworkProxyQuery query = QNetworkProxyQuery(host, port, m_protocolTag, QNetworkProxyQuery::TcpSocket);\n\n        // set to true if a capable setting is found\n        bool capableSettingFound = false;\n\n        // set to true if at least one valid setting is found\n        bool settingFound = false;\n\n        // FIXME: this static function works particularly slow in Windows\n        QList<QNetworkProxy> proxySettingsList = QNetworkProxyFactory::systemProxyForQuery(query);\n\n        /* Proxy Settings are read from the user's environment variables by the above static method.\n         * A peculiar case is with *nix systems, where an undefined environment variable is returned as\n         * an empty string. Such entries *might* exist in our proxySettingsList, and shouldn't be processed.\n         * One good check is to use hostName() of the QNetworkProxy object, and treat the Proxy Setting as invalid if\n         * the host name is empty. */\n        Q_FOREACH (setting, proxySettingsList) {\n            if (!setting.hostName().isEmpty()) {\n                settingFound = true;\n\n                // now check whether setting has capabilities\n                if (setting.capabilities().testFlag(QNetworkProxy::TunnelingCapability)) {\n                    sock->setProxy(setting);\n                    capableSettingFound = true;\n                    break;\n                }\n            }\n        }\n\n        if (!settingFound || proxySettingsList.isEmpty()) {\n            sock->setProxy(QNetworkProxy::NoProxy);\n        } else if (!capableSettingFound) {\n            emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\")\n                              .arg(host, QString::number(port), QLatin1String(\"Cannot find proxy setting capable of tunneling\")));\n        }\n        break;\n    }\n    case Streams::ProxySettings::DirectConnect:\n        sock->setProxy(QNetworkProxy::NoProxy);\n        break;\n    }\n\n    if (startEncrypted)\n        sock->connectToHostEncrypted(host, port);\n    else\n        sock->connectToHost(host, port);\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ock->connectToHost",
          "args": [
            "ost,",
            "ort)"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "connectToHost",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "567-576",
          "snippet": "int QwwSmtpClient::connectToHost(const QString & hostName, quint16 port) {\n    SMTPCommand cmd;\n    cmd.type = SMTPCommand::Connect;\n    cmd.data = QVariantList() << hostName << port << false;\n    cmd.id = ++d->lastId;\n    d->commandqueue.enqueue(cmd);\n    if (!d->inProgress)\n        d->processNextCommand();\n    return cmd.id;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  int QwwSmtpClient::connectToHost(const QString & hostName, quint16 port) {\n      SMTPCommand cmd;\n      cmd.type = SMTPCommand::Connect;\n      cmd.data = QVariantList() << hostName << port << false;\n      cmd.id = ++d->lastId;\n      d->commandqueue.enqueue(cmd);\n      if (!d->inProgress)\n          d->processNextCommand();\n      return cmd.id;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->connectToHostEncrypted",
          "args": [
            "ost,",
            "ort)"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "connectToHostEncrypted",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "584-594",
          "snippet": "int QwwSmtpClient::connectToHostEncrypted(const QString & hostName, quint16 port)\n{\n    SMTPCommand cmd;\n    cmd.type = SMTPCommand::Connect;\n    cmd.data = QVariantList() << hostName << port << true;\n    cmd.id = ++d->lastId;\n    d->commandqueue.enqueue(cmd);\n    if(!d->inProgress)\n        d->processNextCommand();\n    return cmd.id;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  int QwwSmtpClient::connectToHostEncrypted(const QString & hostName, quint16 port)\n  {\n      SMTPCommand cmd;\n      cmd.type = SMTPCommand::Connect;\n      cmd.data = QVariantList() << hostName << port << true;\n      cmd.id = ++d->lastId;\n      d->commandqueue.enqueue(cmd);\n      if(!d->inProgress)\n          d->processNextCommand();\n      return cmd.id;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->setProxy",
          "args": [
            "NetworkProxy::NoProxy)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ost,",
            "String::number(port),",
            "Latin1String(\"Cannot find proxy setting capable of tunneling\"))"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessSocket(",
          "container": "rocessSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "139-144",
          "snippet": "rocessSocket::ProcessSocket(QProcess *proc, const QString &executable, const QStringList &args):\n    IODeviceSocket(proc), executable(executable), args(args)\n{\n    connect(proc, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(handleStateChanged()));\n    connect(proc, SIGNAL(error(QProcess::ProcessError)), this, SLOT(handleProcessError(QProcess::ProcessError)));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  rocessSocket::ProcessSocket(QProcess *proc, const QString &executable, const QStringList &args):\n      IODeviceSocket(proc), executable(executable), args(args)\n  {\n      connect(proc, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(handleStateChanged()));\n      connect(proc, SIGNAL(error(QProcess::ProcessError)), this, SLOT(handleProcessError(QProcess::ProcessError)));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "Cannot find proxy setting capable of tunneling\")"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ort)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "The underlying socket is having troubles when processing connection to %1:%2: %3\")"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->setProxy",
          "args": [
            "NetworkProxy::NoProxy)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roxySettingsList.isEmpty",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->setProxy",
          "args": [
            "etting)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etting.capabilities",
          "args": [
            "NetworkProxy::TunnelingCapability)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etting.capabilities",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etting.hostName",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etting.hostName",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NetworkProxyFactory::systemProxyForQuery(",
          "args": [
            "uery)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NetworkProxyQuery(",
          "args": [
            "ost,",
            "ort,",
            "_protocolTag,",
            "NetworkProxyQuery::TcpSocket)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QSslSocket *>",
          "args": [
            ")"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::delayedStart()\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n      Q_ASSERT(sock);\n  \n      switch (m_proxySettings) {\n      case Streams::ProxySettings::RespectSystemProxy:\n      {\n          QNetworkProxy setting;\n          QNetworkProxyQuery query = QNetworkProxyQuery(host, port, m_protocolTag, QNetworkProxyQuery::TcpSocket);\n  \n          // set to true if a capable setting is found\n          bool capableSettingFound = false;\n  \n          // set to true if at least one valid setting is found\n          bool settingFound = false;\n  \n          // FIXME: this static function works particularly slow in Windows\n          QList<QNetworkProxy> proxySettingsList = QNetworkProxyFactory::systemProxyForQuery(query);\n  \n          /* Proxy Settings are read from the user's environment variables by the above static method.\n           * A peculiar case is with *nix systems, where an undefined environment variable is returned as\n           * an empty string. Such entries *might* exist in our proxySettingsList, and shouldn't be processed.\n           * One good check is to use hostName() of the QNetworkProxy object, and treat the Proxy Setting as invalid if\n           * the host name is empty. */\n          Q_FOREACH (setting, proxySettingsList) {\n              if (!setting.hostName().isEmpty()) {\n                  settingFound = true;\n  \n                  // now check whether setting has capabilities\n                  if (setting.capabilities().testFlag(QNetworkProxy::TunnelingCapability)) {\n                      sock->setProxy(setting);\n                      capableSettingFound = true;\n                      break;\n                  }\n              }\n          }\n  \n          if (!settingFound || proxySettingsList.isEmpty()) {\n              sock->setProxy(QNetworkProxy::NoProxy);\n          } else if (!capableSettingFound) {\n              emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\")\n                                .arg(host, QString::number(port), QLatin1String(\"Cannot find proxy setting capable of tunneling\")));\n          }\n          break;\n      }\n      case Streams::ProxySettings::DirectConnect:\n          sock->setProxy(QNetworkProxy::NoProxy);\n          break;\n      }\n  \n      if (startEncrypted)\n          sock->connectToHostEncrypted(host, port);\n      else\n          sock->connectToHost(host, port);\n  }\n}"
  },
  {
    "function_name": "isDead(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "328-333",
    "snippet": "ool SslTlsSocket::isDead()\n{\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    return sock->state() != QAbstractSocket::ConnectedState;\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ock->state",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QAbstractSocket *>",
          "args": [
            ")"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  ool SslTlsSocket::isDead()\n  {\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      return sock->state() != QAbstractSocket::ConnectedState;\n  }\n}"
  },
  {
    "function_name": "handleSocketError(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "318-326",
    "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ost,",
            "String::number(port),",
            "ock->errorString())"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessSocket(",
          "container": "rocessSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "139-144",
          "snippet": "rocessSocket::ProcessSocket(QProcess *proc, const QString &executable, const QStringList &args):\n    IODeviceSocket(proc), executable(executable), args(args)\n{\n    connect(proc, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(handleStateChanged()));\n    connect(proc, SIGNAL(error(QProcess::ProcessError)), this, SLOT(handleProcessError(QProcess::ProcessError)));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  rocessSocket::ProcessSocket(QProcess *proc, const QString &executable, const QStringList &args):\n      IODeviceSocket(proc), executable(executable), args(args)\n  {\n      connect(proc, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(handleStateChanged()));\n      connect(proc, SIGNAL(error(QProcess::ProcessError)), this, SLOT(handleProcessError(QProcess::ProcessError)));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->errorString",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "errorString",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "712-714",
          "snippet": "QString QwwSmtpClient::errorString() const{\n    return d->errorString;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  QString QwwSmtpClient::errorString() const{\n      return d->errorString;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ort)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "The underlying socket is having troubles when processing connection to %1:%2: %3\")"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "elayedDisconnect->stop",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QAbstractSocket *>",
          "args": [
            ")"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "rr)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
  },
  {
    "function_name": "handleStateChanged(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "262-316",
    "snippet": "oid SslTlsSocket::handleStateChanged()\n{\n    /* Qt delivers the stateChanged() signal before the error() one.\n    That's a problem because we really want to provide a nice error message\n    to the user and QAbstractSocket::error() is not set yet by the time this\n    function executes. That's why we have to delay the first disconnected() signal. */\n\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    QString proxyMsg;\n    switch (sock->proxy().type()) {\n    case QNetworkProxy::NoProxy:\n        break;\n    case QNetworkProxy::DefaultProxy:\n    case QNetworkProxy::HttpCachingProxy:\n    case QNetworkProxy::FtpCachingProxy:\n        // these proxy types are not supposed to be supported\n        Q_ASSERT(false);\n        break;\n    case QNetworkProxy::Socks5Proxy:\n        proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    case QNetworkProxy::HttpProxy:\n        proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    }\n    switch (sock->state()) {\n    case QAbstractSocket::HostLookupState:\n        emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::ConnectingState:\n        emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                              host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::BoundState:\n    case QAbstractSocket::ListeningState:\n        break;\n    case QAbstractSocket::ConnectedState:\n        if (! startEncrypted) {\n            emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n        } else {\n            emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n        }\n        break;\n    case QAbstractSocket::UnconnectedState:\n    case QAbstractSocket::ClosingState:\n        disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n        delayedDisconnect->start();\n        break;\n    }\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elayedDisconnect->start",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ock->errorString())"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->errorString",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "errorString",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "712-714",
          "snippet": "QString QwwSmtpClient::errorString() const{\n    return d->errorString;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  QString QwwSmtpClient::errorString() const{\n      return d->errorString;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ost,",
            "String::number(port),",
            "tartEncrypted ? tr(\" (SSL)\") : QString(),",
            "ock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                              proxyMsg : QString())"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "SimplePartWidget(",
          "container": "implePartWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/SimplePartWidget.cpp",
          "lines": "41-97",
          "snippet": "implePartWidget::SimplePartWidget(QWidget *parent, Imap::Network::MsgPartNetAccessManager *manager,\n                                   const QModelIndex &partIndex, MessageView *messageView):\n    EmbeddedWebView(parent, manager), m_partIndex(partIndex), m_messageView(messageView), m_netAccessManager(manager),\n    flowedFormat(Composer::Util::FORMAT_PLAIN)\n{\n    Q_ASSERT(partIndex.isValid());\n\n    if (m_messageView) {\n        connect(this, SIGNAL(loadStarted()), m_messageView, SLOT(onWebViewLoadStarted()));\n        connect(this, SIGNAL(loadFinished(bool)), m_messageView, SLOT(onWebViewLoadFinished()));\n    }\n\n    QUrl url;\n    url.setScheme(QLatin1String(\"trojita-imap\"));\n    url.setHost(QLatin1String(\"msg\"));\n    url.setPath(partIndex.data(Imap::Mailbox::RolePartPathToPart).toString());\n    if (partIndex.data(Imap::Mailbox::RolePartMimeType).toString() == QLatin1String(\"text/plain\")\n            && partIndex.data(Imap::Mailbox::RolePartOctets).toUInt() < 100 * 1024) {\n        connect(this, SIGNAL(loadFinished(bool)), this, SLOT(slotMarkupPlainText()));\n    }\n    if (partIndex.data(Imap::Mailbox::RolePartContentFormat).toString().toLower() == QLatin1String(\"flowed\")) {\n        flowedFormat = Composer::Util::FORMAT_FLOWED;\n\n        if (partIndex.data(Imap::Mailbox::RolePartContentDelSp).toString().toLower() == QLatin1String(\"yes\"))\n            flowedFormat = Composer::Util::FORMAT_FLOWED_DELSP;\n    }\n    load(url);\n\n    m_savePart = new QAction(tr(\"Save this message part...\"), this);\n    connect(m_savePart, SIGNAL(triggered()), this, SLOT(slotDownloadPart()));\n    this->addAction(m_savePart);\n\n    m_saveMessage = new QAction(tr(\"Save whole message...\"), this);\n    connect(m_saveMessage, SIGNAL(triggered()), this, SLOT(slotDownloadMessage()));\n    this->addAction(m_saveMessage);\n\n    m_findAction = new QAction(tr(\"Search...\"), this);\n    m_findAction->setShortcut(tr(\"Ctrl+F\"));\n    connect(m_findAction, SIGNAL(triggered()), this, SIGNAL(searchDialogRequested()));\n    addAction(m_findAction);\n\n    setContextMenuPolicy(Qt::CustomContextMenu);\n\n    // It is actually OK to construct this widget without any connection to a messageView -- this is often used when\n    // displaying message source or message headers. Let's silence the QObject::connect warning.\n    if (m_messageView) {\n        connect(this, SIGNAL(customContextMenuRequested(QPoint)), m_messageView, SLOT(partContextMenuRequested(QPoint)));\n        connect(this, SIGNAL(searchDialogRequested()), m_messageView, SLOT(triggerSearchDialog()));\n        // The targets expect the sender() of the signal to be a SimplePartWidget, not a QWebPage,\n        // which means we have to do this indirection\n        connect(page(), SIGNAL(linkHovered(QString,QString,QString)), this, SIGNAL(linkHovered(QString,QString,QString)));\n        connect(this, SIGNAL(linkHovered(QString,QString,QString)),\n                m_messageView, SLOT(partLinkHovered(QString,QString,QString)));\n\n        installEventFilter(m_messageView);\n    }\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Imap/Network/FileDownloadManager.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Gui/Util.h\"\n#",
            "include \"Gui/MessageView.h\" // so that the compiler knows that it's a QObject\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"SimplePartWidget.h\"\n#",
            "include <QWebFrame>",
            "include <QNetworkReply>\n#",
            "include <QFileDialog>\n#",
            "include <QApplication>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Imap/Network/FileDownloadManager.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Gui/Util.h\"\n#\ninclude \"Gui/MessageView.h\" // so that the compiler knows that it's a QObject\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"SimplePartWidget.h\"\n#\ninclude <QWebFrame>\ninclude <QNetworkReply>\n#\ninclude <QFileDialog>\n#\ninclude <QApplication>\n#\n\nimplePartWidget {\n  implePartWidget::SimplePartWidget(QWidget *parent, Imap::Network::MsgPartNetAccessManager *manager,\n                                     const QModelIndex &partIndex, MessageView *messageView):\n      EmbeddedWebView(parent, manager), m_partIndex(partIndex), m_messageView(messageView), m_netAccessManager(manager),\n      flowedFormat(Composer::Util::FORMAT_PLAIN)\n  {\n      Q_ASSERT(partIndex.isValid());\n  \n      if (m_messageView) {\n          connect(this, SIGNAL(loadStarted()), m_messageView, SLOT(onWebViewLoadStarted()));\n          connect(this, SIGNAL(loadFinished(bool)), m_messageView, SLOT(onWebViewLoadFinished()));\n      }\n  \n      QUrl url;\n      url.setScheme(QLatin1String(\"trojita-imap\"));\n      url.setHost(QLatin1String(\"msg\"));\n      url.setPath(partIndex.data(Imap::Mailbox::RolePartPathToPart).toString());\n      if (partIndex.data(Imap::Mailbox::RolePartMimeType).toString() == QLatin1String(\"text/plain\")\n              && partIndex.data(Imap::Mailbox::RolePartOctets).toUInt() < 100 * 1024) {\n          connect(this, SIGNAL(loadFinished(bool)), this, SLOT(slotMarkupPlainText()));\n      }\n      if (partIndex.data(Imap::Mailbox::RolePartContentFormat).toString().toLower() == QLatin1String(\"flowed\")) {\n          flowedFormat = Composer::Util::FORMAT_FLOWED;\n  \n          if (partIndex.data(Imap::Mailbox::RolePartContentDelSp).toString().toLower() == QLatin1String(\"yes\"))\n              flowedFormat = Composer::Util::FORMAT_FLOWED_DELSP;\n      }\n      load(url);\n  \n      m_savePart = new QAction(tr(\"Save this message part...\"), this);\n      connect(m_savePart, SIGNAL(triggered()), this, SLOT(slotDownloadPart()));\n      this->addAction(m_savePart);\n  \n      m_saveMessage = new QAction(tr(\"Save whole message...\"), this);\n      connect(m_saveMessage, SIGNAL(triggered()), this, SLOT(slotDownloadMessage()));\n      this->addAction(m_saveMessage);\n  \n      m_findAction = new QAction(tr(\"Search...\"), this);\n      m_findAction->setShortcut(tr(\"Ctrl+F\"));\n      connect(m_findAction, SIGNAL(triggered()), this, SIGNAL(searchDialogRequested()));\n      addAction(m_findAction);\n  \n      setContextMenuPolicy(Qt::CustomContextMenu);\n  \n      // It is actually OK to construct this widget without any connection to a messageView -- this is often used when\n      // displaying message source or message headers. Let's silence the QObject::connect warning.\n      if (m_messageView) {\n          connect(this, SIGNAL(customContextMenuRequested(QPoint)), m_messageView, SLOT(partContextMenuRequested(QPoint)));\n          connect(this, SIGNAL(searchDialogRequested()), m_messageView, SLOT(triggerSearchDialog()));\n          // The targets expect the sender() of the signal to be a SimplePartWidget, not a QWebPage,\n          // which means we have to do this indirection\n          connect(page(), SIGNAL(linkHovered(QString,QString,QString)), this, SIGNAL(linkHovered(QString,QString,QString)));\n          connect(this, SIGNAL(linkHovered(QString,QString,QString)),\n                  m_messageView, SLOT(partLinkHovered(QString,QString,QString)));\n  \n          installEventFilter(m_messageView);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [
            "NetworkProxy::TunnelingCapability)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "ort)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "ost,",
            "ock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                              proxyMsg : QString())"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "setProxySettings(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "248-252",
          "snippet": "oid SslTlsSocket::setProxySettings(const ProxySettings proxySettings, const QString &protocolTag)\n{\n    m_proxySettings = proxySettings;\n    m_protocolTag = protocolTag;\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::setProxySettings(const ProxySettings proxySettings, const QString &protocolTag)\n  {\n      m_proxySettings = proxySettings;\n      m_protocolTag = protocolTag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [
            "NetworkProxy::HostNameLookupCapability)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->state",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->proxy",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QAbstractSocket *>",
          "args": [
            ")"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleStateChanged()\n  {\n      /* Qt delivers the stateChanged() signal before the error() one.\n      That's a problem because we really want to provide a nice error message\n      to the user and QAbstractSocket::error() is not set yet by the time this\n      function executes. That's why we have to delay the first disconnected() signal. */\n  \n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      QString proxyMsg;\n      switch (sock->proxy().type()) {\n      case QNetworkProxy::NoProxy:\n          break;\n      case QNetworkProxy::DefaultProxy:\n      case QNetworkProxy::HttpCachingProxy:\n      case QNetworkProxy::FtpCachingProxy:\n          // these proxy types are not supposed to be supported\n          Q_ASSERT(false);\n          break;\n      case QNetworkProxy::Socks5Proxy:\n          proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      case QNetworkProxy::HttpProxy:\n          proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      }\n      switch (sock->state()) {\n      case QAbstractSocket::HostLookupState:\n          emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::ConnectingState:\n          emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                                host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::BoundState:\n      case QAbstractSocket::ListeningState:\n          break;\n      case QAbstractSocket::ConnectedState:\n          if (! startEncrypted) {\n              emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n          } else {\n              emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n          }\n          break;\n      case QAbstractSocket::UnconnectedState:\n      case QAbstractSocket::ClosingState:\n          disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n          delayedDisconnect->start();\n          break;\n      }\n  }\n}"
  },
  {
    "function_name": "close(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "254-260",
    "snippet": "oid SslTlsSocket::close()\n{\n    QSslSocket *sock = qobject_cast<QSslSocket*>(d);\n    Q_ASSERT(sock);\n    sock->abort();\n    emit disconnected(tr(\"Connection closed\"));\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Connection closed\")"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ock->abort",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ock)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QSslSocket*>",
          "args": [
            ")"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::close()\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket*>(d);\n      Q_ASSERT(sock);\n      sock->abort();\n      emit disconnected(tr(\"Connection closed\"));\n  }\n}"
  },
  {
    "function_name": "setProxySettings(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "248-252",
    "snippet": "oid SslTlsSocket::setProxySettings(const ProxySettings proxySettings, const QString &protocolTag)\n{\n    m_proxySettings = proxySettings;\n    m_protocolTag = protocolTag;\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::setProxySettings(const ProxySettings proxySettings, const QString &protocolTag)\n  {\n      m_proxySettings = proxySettings;\n      m_protocolTag = protocolTag;\n  }\n}"
  },
  {
    "function_name": "SslTlsSocket(",
    "container": "slTlsSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "219-246",
    "snippet": "slTlsSocket::SslTlsSocket(QSslSocket *sock, const QString &host, const quint16 port, const bool startEncrypted):\n    IODeviceSocket(sock), startEncrypted(startEncrypted), host(host), port(port), m_proxySettings(ProxySettings::RespectSystemProxy)\n{\n    // The Qt API for deciding about whereabouts of a SSL connection is unfortunately blocking, ie. one is expected to\n    // call a function from a slot attached to the sslErrors signal to tell the code whether to proceed or not.\n    // In QML, one cannot display a dialog box with a nested event loop, so this means that we have to deal with SSL/TLS\n    // establishing at higher level.\n    sock->ignoreSslErrors();\n    sock->setProtocol(QSsl::AnyProtocol);\n    sock->setPeerVerifyMode(QSslSocket::QueryPeer);\n\n    // In response to the attacks related to the SSL compression, Digia has decided to disable SSL compression starting in\n    // Qt 4.8.4 -- see http://qt.digia.com/en/Release-Notes/security-issue-september-2012/.\n    // I have brought this up on the imap-protocol mailing list; the consensus seemed to be that the likelihood of an\n    // successful exploit on an IMAP conversation is very unlikely.  The compression itself is, on the other hand, a\n    // very worthwhile goal, so we explicitly enable it again.\n    // Unfortunately, this was backported to older Qt versions as well (see qt4.git's 3488f1db96dbf70bb0486d3013d86252ebf433e0),\n    // but there is no way of enabling compression back again.\n#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n    QSslConfiguration sslConf = sock->sslConfiguration();\n    sslConf.setSslOption(QSsl::SslOptionDisableCompression, false);\n    sock->setSslConfiguration(sslConf);\n#endif\n\n    connect(sock, SIGNAL(encrypted()), this, SIGNAL(encrypted()));\n    connect(sock, SIGNAL(stateChanged(QAbstractSocket::SocketState)), this, SLOT(handleStateChanged()));\n    connect(sock, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(handleSocketError(QAbstractSocket::SocketError)));\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ock,",
            "IGNAL(error(QAbstractSocket::SocketError)),",
            "his,",
            "LOT(handleSocketError(QAbstractSocket::SocketError)))"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleSocketError(QAbstractSocket::SocketError))"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleSocketError(",
          "args": [
            "AbstractSocket::SocketError)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "rror(QAbstractSocket::SocketError))"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ock,",
            "IGNAL(stateChanged(QAbstractSocket::SocketState)),",
            "his,",
            "LOT(handleStateChanged()))"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleStateChanged())"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleStateChanged(",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateChanged(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "262-316",
          "snippet": "oid SslTlsSocket::handleStateChanged()\n{\n    /* Qt delivers the stateChanged() signal before the error() one.\n    That's a problem because we really want to provide a nice error message\n    to the user and QAbstractSocket::error() is not set yet by the time this\n    function executes. That's why we have to delay the first disconnected() signal. */\n\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    QString proxyMsg;\n    switch (sock->proxy().type()) {\n    case QNetworkProxy::NoProxy:\n        break;\n    case QNetworkProxy::DefaultProxy:\n    case QNetworkProxy::HttpCachingProxy:\n    case QNetworkProxy::FtpCachingProxy:\n        // these proxy types are not supposed to be supported\n        Q_ASSERT(false);\n        break;\n    case QNetworkProxy::Socks5Proxy:\n        proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    case QNetworkProxy::HttpProxy:\n        proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    }\n    switch (sock->state()) {\n    case QAbstractSocket::HostLookupState:\n        emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::ConnectingState:\n        emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                              host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::BoundState:\n    case QAbstractSocket::ListeningState:\n        break;\n    case QAbstractSocket::ConnectedState:\n        if (! startEncrypted) {\n            emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n        } else {\n            emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n        }\n        break;\n    case QAbstractSocket::UnconnectedState:\n    case QAbstractSocket::ClosingState:\n        disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n        delayedDisconnect->start();\n        break;\n    }\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleStateChanged()\n  {\n      /* Qt delivers the stateChanged() signal before the error() one.\n      That's a problem because we really want to provide a nice error message\n      to the user and QAbstractSocket::error() is not set yet by the time this\n      function executes. That's why we have to delay the first disconnected() signal. */\n  \n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      QString proxyMsg;\n      switch (sock->proxy().type()) {\n      case QNetworkProxy::NoProxy:\n          break;\n      case QNetworkProxy::DefaultProxy:\n      case QNetworkProxy::HttpCachingProxy:\n      case QNetworkProxy::FtpCachingProxy:\n          // these proxy types are not supposed to be supported\n          Q_ASSERT(false);\n          break;\n      case QNetworkProxy::Socks5Proxy:\n          proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      case QNetworkProxy::HttpProxy:\n          proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      }\n      switch (sock->state()) {\n      case QAbstractSocket::HostLookupState:\n          emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::ConnectingState:\n          emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                                host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::BoundState:\n      case QAbstractSocket::ListeningState:\n          break;\n      case QAbstractSocket::ConnectedState:\n          if (! startEncrypted) {\n              emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n          } else {\n              emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n          }\n          break;\n      case QAbstractSocket::UnconnectedState:\n      case QAbstractSocket::ClosingState:\n          disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n          delayedDisconnect->start();\n          break;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "tateChanged(QAbstractSocket::SocketState))"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tateChanged(",
          "args": [
            "AbstractSocket::SocketState)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "onGlobalOnlineStateChanged(",
          "container": "ystemNetworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SystemNetworkWatcher.cpp",
          "lines": "59-69",
          "snippet": "oid SystemNetworkWatcher::onGlobalOnlineStateChanged(const bool online)\n{\n    if (online) {\n        m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"Network Session\"), QLatin1String(\"System is back online\"));\n        setDesiredNetworkPolicy(m_desiredPolicy);\n    } else {\n        m_model->setNetworkPolicy(NETWORK_OFFLINE);\n        // The session remains open, so that we indicate our intention to reconnect after the connectivity is restored\n        // (or when a configured AP comes back to range, etc).\n    }\n}",
          "includes": [
            "include \"Model.h\"",
            "include <QNetworkSession>\n#",
            "include <QNetworkConfigurationManager>\n#",
            "include \"SystemNetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude <QNetworkSession>\n#\ninclude <QNetworkConfigurationManager>\n#\ninclude \"SystemNetworkWatcher.h\"\n#\n\nystemNetworkWatcher {\n  oid SystemNetworkWatcher::onGlobalOnlineStateChanged(const bool online)\n  {\n      if (online) {\n          m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"Network Session\"), QLatin1String(\"System is back online\"));\n          setDesiredNetworkPolicy(m_desiredPolicy);\n      } else {\n          m_model->setNetworkPolicy(NETWORK_OFFLINE);\n          // The session remains open, so that we indicate our intention to reconnect after the connectivity is restored\n          // (or when a configured AP comes back to range, etc).\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ock,",
            "IGNAL(encrypted()),",
            "his,",
            "IGNAL(encrypted()))"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncrypted())"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncrypted(",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "slotEmitEncrypted(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "57-60",
          "snippet": "oid FakeSocket::slotEmitEncrypted()\n{\n    emit encrypted();\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::slotEmitEncrypted()\n  {\n      emit encrypted();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncrypted())"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->setSslConfiguration",
          "args": [
            "slConf)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slConf.setSslOption",
          "args": [
            "Ssl::SslOptionDisableCompression,",
            "alse)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->sslConfiguration",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->setPeerVerifyMode",
          "args": [
            "SslSocket::QueryPeer)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->setProtocol",
          "args": [
            "Ssl::AnyProtocol)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ock->ignoreSslErrors",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ignoreSslErrors",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "700-702",
          "snippet": "void QwwSmtpClient::ignoreSslErrors()\n{d->socket->ignoreSslErrors();\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  void QwwSmtpClient::ignoreSslErrors()\n  {d->socket->ignoreSslErrors();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  slTlsSocket::SslTlsSocket(QSslSocket *sock, const QString &host, const quint16 port, const bool startEncrypted):\n      IODeviceSocket(sock), startEncrypted(startEncrypted), host(host), port(port), m_proxySettings(ProxySettings::RespectSystemProxy)\n  {\n      // The Qt API for deciding about whereabouts of a SSL connection is unfortunately blocking, ie. one is expected to\n      // call a function from a slot attached to the sslErrors signal to tell the code whether to proceed or not.\n      // In QML, one cannot display a dialog box with a nested event loop, so this means that we have to deal with SSL/TLS\n      // establishing at higher level.\n      sock->ignoreSslErrors();\n      sock->setProtocol(QSsl::AnyProtocol);\n      sock->setPeerVerifyMode(QSslSocket::QueryPeer);\n  \n      // In response to the attacks related to the SSL compression, Digia has decided to disable SSL compression starting in\n      // Qt 4.8.4 -- see http://qt.digia.com/en/Release-Notes/security-issue-september-2012/.\n      // I have brought this up on the imap-protocol mailing list; the consensus seemed to be that the likelihood of an\n      // successful exploit on an IMAP conversation is very unlikely.  The compression itself is, on the other hand, a\n      // very worthwhile goal, so we explicitly enable it again.\n      // Unfortunately, this was backported to older Qt versions as well (see qt4.git's 3488f1db96dbf70bb0486d3013d86252ebf433e0),\n      // but there is no way of enabling compression back again.\n  #if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)\n      QSslConfiguration sslConf = sock->sslConfiguration();\n      sslConf.setSslOption(QSsl::SslOptionDisableCompression, false);\n      sock->setSslConfiguration(sslConf);\n  #endif\n  \n      connect(sock, SIGNAL(encrypted()), this, SIGNAL(encrypted()));\n      connect(sock, SIGNAL(stateChanged(QAbstractSocket::SocketState)), this, SLOT(handleStateChanged()));\n      connect(sock, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(handleSocketError(QAbstractSocket::SocketError)));\n  }\n}"
  },
  {
    "function_name": "delayedStart(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "212-217",
    "snippet": "oid ProcessSocket::delayedStart()\n{\n    QProcess *proc = qobject_cast<QProcess *>(d);\n    Q_ASSERT(proc);\n    proc->start(executable, args);\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roc->start",
          "args": [
            "xecutable,",
            "rgs)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "roc)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QProcess *>",
          "args": [
            ")"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  oid ProcessSocket::delayedStart()\n  {\n      QProcess *proc = qobject_cast<QProcess *>(d);\n      Q_ASSERT(proc);\n      proc->start(executable, args);\n  }\n}"
  },
  {
    "function_name": "handleStateChanged(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "180-210",
    "snippet": "oid ProcessSocket::handleStateChanged()\n{\n    /* Qt delivers the stateChanged() signal before the error() one.\n    That's a problem because we really want to provide a nice error message\n    to the user and QAbstractSocket::error() is not set yet by the time this\n    function executes. That's why we have to delay the first disconnected() signal. */\n\n    QProcess *proc = qobject_cast<QProcess *>(d);\n    Q_ASSERT(proc);\n    switch (proc->state()) {\n    case QProcess::Running:\n        emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"The process has started\"));\n        break;\n    case QProcess::Starting:\n        emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Starting process `%1 %2`\").arg(executable, args.join(QLatin1String(\" \"))));\n        break;\n    case QProcess::NotRunning: {\n        if (delayedDisconnect->isActive())\n            break;\n        QString stdErr = QString::fromLocal8Bit(proc->readAllStandardError());\n        if (stdErr.isEmpty())\n            disconnectedMessage = tr(\"The QProcess has exited with return code %1.\").arg(\n                                      proc->exitCode());\n        else\n            disconnectedMessage = tr(\"The QProcess has exited with return code %1:\\n\\n%2\").arg(\n                                      proc->exitCode()).arg(stdErr);\n        delayedDisconnect->start();\n    }\n    break;\n    }\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elayedDisconnect->start",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "tdErr)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roc->exitCode",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->exitCode",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tdErr.isEmpty",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromLocal8Bit(",
          "args": [
            "roc->readAllStandardError())"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->readAllStandardError",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedDisconnect->isActive",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r",
          "args": [
            "xecutable,",
            "rgs.join(QLatin1String(\" \")))"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "setProxySettings(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "248-252",
          "snippet": "oid SslTlsSocket::setProxySettings(const ProxySettings proxySettings, const QString &protocolTag)\n{\n    m_proxySettings = proxySettings;\n    m_protocolTag = protocolTag;\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::setProxySettings(const ProxySettings proxySettings, const QString &protocolTag)\n  {\n      m_proxySettings = proxySettings;\n      m_protocolTag = protocolTag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgs.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->state",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "roc)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QProcess *>",
          "args": [
            ")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  oid ProcessSocket::handleStateChanged()\n  {\n      /* Qt delivers the stateChanged() signal before the error() one.\n      That's a problem because we really want to provide a nice error message\n      to the user and QAbstractSocket::error() is not set yet by the time this\n      function executes. That's why we have to delay the first disconnected() signal. */\n  \n      QProcess *proc = qobject_cast<QProcess *>(d);\n      Q_ASSERT(proc);\n      switch (proc->state()) {\n      case QProcess::Running:\n          emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"The process has started\"));\n          break;\n      case QProcess::Starting:\n          emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Starting process `%1 %2`\").arg(executable, args.join(QLatin1String(\" \"))));\n          break;\n      case QProcess::NotRunning: {\n          if (delayedDisconnect->isActive())\n              break;\n          QString stdErr = QString::fromLocal8Bit(proc->readAllStandardError());\n          if (stdErr.isEmpty())\n              disconnectedMessage = tr(\"The QProcess has exited with return code %1.\").arg(\n                                        proc->exitCode());\n          else\n              disconnectedMessage = tr(\"The QProcess has exited with return code %1:\\n\\n%2\").arg(\n                                        proc->exitCode()).arg(stdErr);\n          delayedDisconnect->start();\n      }\n      break;\n      }\n  }\n}"
  },
  {
    "function_name": "handleProcessError(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "171-178",
    "snippet": "oid ProcessSocket::handleProcessError(QProcess::ProcessError err)\n{\n    Q_UNUSED(err);\n    QProcess *proc = qobject_cast<QProcess *>(d);\n    Q_ASSERT(proc);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The QProcess is having troubles: %1\").arg(proc->errorString()));\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r",
          "args": [
            "roc->errorString())"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "roc->errorString",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "errorString",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "712-714",
          "snippet": "QString QwwSmtpClient::errorString() const{\n    return d->errorString;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  QString QwwSmtpClient::errorString() const{\n      return d->errorString;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "elayedDisconnect->stop",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "roc)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QProcess *>",
          "args": [
            ")"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "rr)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  oid ProcessSocket::handleProcessError(QProcess::ProcessError err)\n  {\n      Q_UNUSED(err);\n      QProcess *proc = qobject_cast<QProcess *>(d);\n      Q_ASSERT(proc);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The QProcess is having troubles: %1\").arg(proc->errorString()));\n  }\n}"
  },
  {
    "function_name": "isDead(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "164-169",
    "snippet": "ool ProcessSocket::isDead()\n{\n    QProcess *proc = qobject_cast<QProcess *>(d);\n    Q_ASSERT(proc);\n    return proc->state() != QProcess::Running;\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roc->state",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "roc)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QProcess *>",
          "args": [
            ")"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  ool ProcessSocket::isDead()\n  {\n      QProcess *proc = qobject_cast<QProcess *>(d);\n      Q_ASSERT(proc);\n      return proc->state() != QProcess::Running;\n  }\n}"
  },
  {
    "function_name": "close(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "151-162",
    "snippet": "oid ProcessSocket::close()\n{\n    QProcess *proc = qobject_cast<QProcess *>(d);\n    Q_ASSERT(proc);\n    // Be nice to it, let it die peacefully before using an axe\n    // QTBUG-5990, don't call waitForFinished() on a process which hadn't started\n    if (proc->state() == QProcess::Running) {\n        proc->terminate();\n        proc->waitForFinished(200);\n        proc->kill();\n    }\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roc->kill",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->waitForFinished",
          "args": [
            "00)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->terminate",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roc->state",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "roc)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QProcess *>",
          "args": [
            ")"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  oid ProcessSocket::close()\n  {\n      QProcess *proc = qobject_cast<QProcess *>(d);\n      Q_ASSERT(proc);\n      // Be nice to it, let it die peacefully before using an axe\n      // QTBUG-5990, don't call waitForFinished() on a process which hadn't started\n      if (proc->state() == QProcess::Running) {\n          proc->terminate();\n          proc->waitForFinished(200);\n          proc->kill();\n      }\n  }\n}"
  },
  {
    "function_name": "~ProcessSocket(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "146-149",
    "snippet": "rocessSocket::~ProcessSocket()\n{\n    close();\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lose(",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "close(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "254-260",
          "snippet": "oid SslTlsSocket::close()\n{\n    QSslSocket *sock = qobject_cast<QSslSocket*>(d);\n    Q_ASSERT(sock);\n    sock->abort();\n    emit disconnected(tr(\"Connection closed\"));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::close()\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket*>(d);\n      Q_ASSERT(sock);\n      sock->abort();\n      emit disconnected(tr(\"Connection closed\"));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  rocessSocket::~ProcessSocket()\n  {\n      close();\n  }\n}"
  },
  {
    "function_name": "ProcessSocket(",
    "container": "rocessSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "139-144",
    "snippet": "rocessSocket::ProcessSocket(QProcess *proc, const QString &executable, const QStringList &args):\n    IODeviceSocket(proc), executable(executable), args(args)\n{\n    connect(proc, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(handleStateChanged()));\n    connect(proc, SIGNAL(error(QProcess::ProcessError)), this, SLOT(handleProcessError(QProcess::ProcessError)));\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "roc,",
            "IGNAL(error(QProcess::ProcessError)),",
            "his,",
            "LOT(handleProcessError(QProcess::ProcessError)))"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleProcessError(QProcess::ProcessError))"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleProcessError(",
          "args": [
            "Process::ProcessError)"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "handleProcessError(",
          "container": "rocessSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "171-178",
          "snippet": "oid ProcessSocket::handleProcessError(QProcess::ProcessError err)\n{\n    Q_UNUSED(err);\n    QProcess *proc = qobject_cast<QProcess *>(d);\n    Q_ASSERT(proc);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The QProcess is having troubles: %1\").arg(proc->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  oid ProcessSocket::handleProcessError(QProcess::ProcessError err)\n  {\n      Q_UNUSED(err);\n      QProcess *proc = qobject_cast<QProcess *>(d);\n      Q_ASSERT(proc);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The QProcess is having troubles: %1\").arg(proc->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "rror(QProcess::ProcessError))"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rror(",
          "args": [
            "Process::ProcessError)"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketError(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "318-326",
          "snippet": "oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n{\n    Q_UNUSED(err);\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    delayedDisconnect->stop();\n    emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                          host, QString::number(port), sock->errorString()));\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleSocketError(QAbstractSocket::SocketError err)\n  {\n      Q_UNUSED(err);\n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      delayedDisconnect->stop();\n      emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\").arg(\n                            host, QString::number(port), sock->errorString()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "roc,",
            "IGNAL(stateChanged(QProcess::ProcessState)),",
            "his,",
            "LOT(handleStateChanged()))"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleStateChanged())"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleStateChanged(",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateChanged(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "262-316",
          "snippet": "oid SslTlsSocket::handleStateChanged()\n{\n    /* Qt delivers the stateChanged() signal before the error() one.\n    That's a problem because we really want to provide a nice error message\n    to the user and QAbstractSocket::error() is not set yet by the time this\n    function executes. That's why we have to delay the first disconnected() signal. */\n\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    QString proxyMsg;\n    switch (sock->proxy().type()) {\n    case QNetworkProxy::NoProxy:\n        break;\n    case QNetworkProxy::DefaultProxy:\n    case QNetworkProxy::HttpCachingProxy:\n    case QNetworkProxy::FtpCachingProxy:\n        // these proxy types are not supposed to be supported\n        Q_ASSERT(false);\n        break;\n    case QNetworkProxy::Socks5Proxy:\n        proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    case QNetworkProxy::HttpProxy:\n        proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    }\n    switch (sock->state()) {\n    case QAbstractSocket::HostLookupState:\n        emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::ConnectingState:\n        emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                              host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::BoundState:\n    case QAbstractSocket::ListeningState:\n        break;\n    case QAbstractSocket::ConnectedState:\n        if (! startEncrypted) {\n            emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n        } else {\n            emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n        }\n        break;\n    case QAbstractSocket::UnconnectedState:\n    case QAbstractSocket::ClosingState:\n        disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n        delayedDisconnect->start();\n        break;\n    }\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleStateChanged()\n  {\n      /* Qt delivers the stateChanged() signal before the error() one.\n      That's a problem because we really want to provide a nice error message\n      to the user and QAbstractSocket::error() is not set yet by the time this\n      function executes. That's why we have to delay the first disconnected() signal. */\n  \n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      QString proxyMsg;\n      switch (sock->proxy().type()) {\n      case QNetworkProxy::NoProxy:\n          break;\n      case QNetworkProxy::DefaultProxy:\n      case QNetworkProxy::HttpCachingProxy:\n      case QNetworkProxy::FtpCachingProxy:\n          // these proxy types are not supposed to be supported\n          Q_ASSERT(false);\n          break;\n      case QNetworkProxy::Socks5Proxy:\n          proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      case QNetworkProxy::HttpProxy:\n          proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      }\n      switch (sock->state()) {\n      case QAbstractSocket::HostLookupState:\n          emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::ConnectingState:\n          emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                                host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::BoundState:\n      case QAbstractSocket::ListeningState:\n          break;\n      case QAbstractSocket::ConnectedState:\n          if (! startEncrypted) {\n              emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n          } else {\n              emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n          }\n          break;\n      case QAbstractSocket::UnconnectedState:\n      case QAbstractSocket::ClosingState:\n          disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n          delayedDisconnect->start();\n          break;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "tateChanged(QProcess::ProcessState))"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tateChanged(",
          "args": [
            "Process::ProcessState)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "onGlobalOnlineStateChanged(",
          "container": "ystemNetworkWatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/SystemNetworkWatcher.cpp",
          "lines": "59-69",
          "snippet": "oid SystemNetworkWatcher::onGlobalOnlineStateChanged(const bool online)\n{\n    if (online) {\n        m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"Network Session\"), QLatin1String(\"System is back online\"));\n        setDesiredNetworkPolicy(m_desiredPolicy);\n    } else {\n        m_model->setNetworkPolicy(NETWORK_OFFLINE);\n        // The session remains open, so that we indicate our intention to reconnect after the connectivity is restored\n        // (or when a configured AP comes back to range, etc).\n    }\n}",
          "includes": [
            "include \"Model.h\"",
            "include <QNetworkSession>\n#",
            "include <QNetworkConfigurationManager>\n#",
            "include \"SystemNetworkWatcher.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Model.h\"\ninclude <QNetworkSession>\n#\ninclude <QNetworkConfigurationManager>\n#\ninclude \"SystemNetworkWatcher.h\"\n#\n\nystemNetworkWatcher {\n  oid SystemNetworkWatcher::onGlobalOnlineStateChanged(const bool online)\n  {\n      if (online) {\n          m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"Network Session\"), QLatin1String(\"System is back online\"));\n          setDesiredNetworkPolicy(m_desiredPolicy);\n      } else {\n          m_model->setNetworkPolicy(NETWORK_OFFLINE);\n          // The session remains open, so that we indicate our intention to reconnect after the connectivity is restored\n          // (or when a configured AP comes back to range, etc).\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nrocessSocket {\n  rocessSocket::ProcessSocket(QProcess *proc, const QString &executable, const QStringList &args):\n      IODeviceSocket(proc), executable(executable), args(args)\n  {\n      connect(proc, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(handleStateChanged()));\n      connect(proc, SIGNAL(error(QProcess::ProcessError)), this, SLOT(handleProcessError(QProcess::ProcessError)));\n  }\n}"
  },
  {
    "function_name": "emitError(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "134-137",
    "snippet": "oid IODeviceSocket::emitError()\n{\n    emit disconnected(disconnectedMessage);\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::emitError()\n  {\n      emit disconnected(disconnectedMessage);\n  }\n}"
  },
  {
    "function_name": "handleReadyRead(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "124-132",
    "snippet": "oid IODeviceSocket::handleReadyRead()\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        m_decompressor->consume(d);\n    }\n#endif\n    emit readyRead();\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_decompressor->consume",
          "args": [
            ")"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::handleReadyRead()\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          m_decompressor->consume(d);\n      }\n  #endif\n      emit readyRead();\n  }\n}"
  },
  {
    "function_name": "startDeflate(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "111-122",
    "snippet": "oid IODeviceSocket::startDeflate()\n{\n    if (m_compressor || m_decompressor)\n        throw std::invalid_argument(\"DEFLATE compression is already active\");\n\n#if TROJITA_COMPRESS_DEFLATE\n    m_compressor = new Rfc1951Compressor();\n    m_decompressor = new Rfc1951Decompressor();\n#else\n    throw std::invalid_argument(\"Trojita got built without zlib support\");\n#endif\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "td::invalid_argument(",
          "args": [
            "Trojita got built without zlib support\")"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::invalid_argument(",
          "args": [
            "DEFLATE compression is already active\")"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::startDeflate()\n  {\n      if (m_compressor || m_decompressor)\n          throw std::invalid_argument(\"DEFLATE compression is already active\");\n  \n  #if TROJITA_COMPRESS_DEFLATE\n      m_compressor = new Rfc1951Compressor();\n      m_decompressor = new Rfc1951Decompressor();\n  #else\n      throw std::invalid_argument(\"Trojita got built without zlib support\");\n  #endif\n  }\n}"
  },
  {
    "function_name": "startTls(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "99-109",
    "snippet": "oid IODeviceSocket::startTls()\n{\n    QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n    if (! sock)\n        throw std::invalid_argument(\"This IODeviceSocket is not a QSslSocket, and therefore doesn't support STARTTLS.\");\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_compressor || m_decompressor)\n        throw std::invalid_argument(\"DEFLATE is already active, cannot STARTTLS\");\n#endif\n    sock->startClientEncryption();\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ock->startClientEncryption",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::invalid_argument(",
          "args": [
            "DEFLATE is already active, cannot STARTTLS\")"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::invalid_argument(",
          "args": [
            "This IODeviceSocket is not a QSslSocket, and therefore doesn't support STARTTLS.\")"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QSslSocket *>",
          "args": [
            ")"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::startTls()\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n      if (! sock)\n          throw std::invalid_argument(\"This IODeviceSocket is not a QSslSocket, and therefore doesn't support STARTTLS.\");\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_compressor || m_decompressor)\n          throw std::invalid_argument(\"DEFLATE is already active, cannot STARTTLS\");\n  #endif\n      sock->startClientEncryption();\n  }\n}"
  },
  {
    "function_name": "write(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "88-97",
    "snippet": "int64 IODeviceSocket::write(const QByteArray &byteArray)\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_compressor) {\n        m_compressor->write(d, &const_cast<QByteArray&>(byteArray));\n        return byteArray.size();\n    }\n#endif\n    return d->write(byteArray);\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->write",
          "args": [
            "yteArray)"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "write(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "88-97",
          "snippet": "int64 IODeviceSocket::write(const QByteArray &byteArray)\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_compressor) {\n        m_compressor->write(d, &const_cast<QByteArray&>(byteArray));\n        return byteArray.size();\n    }\n#endif\n    return d->write(byteArray);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "yteArray.size",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_compressor->write",
          "args": [
            ",",
            "const_cast<QByteArray&>(byteArray))"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<QByteArray&>",
          "args": [
            "yteArray)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  int64 IODeviceSocket::write(const QByteArray &byteArray)\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_compressor) {\n          m_compressor->write(d, &const_cast<QByteArray&>(byteArray));\n          return byteArray.size();\n      }\n  #endif\n      return d->write(byteArray);\n  }\n}"
  },
  {
    "function_name": "readLine(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "77-86",
    "snippet": "ByteArray IODeviceSocket::readLine(qint64 maxSize)\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        // FIXME: well, we apparently don't respect the maxSize argument...\n        return m_decompressor->readLine();\n    }\n#endif\n    return d->readLine(maxSize);\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->readLine",
          "args": [
            "axSize)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "readLine(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "77-86",
          "snippet": "ByteArray IODeviceSocket::readLine(qint64 maxSize)\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        // FIXME: well, we apparently don't respect the maxSize argument...\n        return m_decompressor->readLine();\n    }\n#endif\n    return d->readLine(maxSize);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_decompressor->readLine",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  ByteArray IODeviceSocket::readLine(qint64 maxSize)\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          // FIXME: well, we apparently don't respect the maxSize argument...\n          return m_decompressor->readLine();\n      }\n  #endif\n      return d->readLine(maxSize);\n  }\n}"
  },
  {
    "function_name": "read(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "67-75",
    "snippet": "ByteArray IODeviceSocket::read(qint64 maxSize)\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        return m_decompressor->read(maxSize);\n    }\n#endif\n    return d->read(maxSize);\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->read",
          "args": [
            "axSize)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "readLine(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "77-86",
          "snippet": "ByteArray IODeviceSocket::readLine(qint64 maxSize)\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        // FIXME: well, we apparently don't respect the maxSize argument...\n        return m_decompressor->readLine();\n    }\n#endif\n    return d->readLine(maxSize);\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  ByteArray IODeviceSocket::readLine(qint64 maxSize)\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          // FIXME: well, we apparently don't respect the maxSize argument...\n          return m_decompressor->readLine();\n      }\n  #endif\n      return d->readLine(maxSize);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_decompressor->read",
          "args": [
            "axSize)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  ByteArray IODeviceSocket::read(qint64 maxSize)\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          return m_decompressor->read(maxSize);\n      }\n  #endif\n      return d->read(maxSize);\n  }\n}"
  },
  {
    "function_name": "canReadLine(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "57-65",
    "snippet": "ool IODeviceSocket::canReadLine()\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        return m_decompressor->canReadLine();\n    }\n#endif\n    return d->canReadLine();\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->canReadLine",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "canReadLine(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "57-65",
          "snippet": "ool IODeviceSocket::canReadLine()\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        return m_decompressor->canReadLine();\n    }\n#endif\n    return d->canReadLine();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_decompressor->canReadLine",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  ool IODeviceSocket::canReadLine()\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          return m_decompressor->canReadLine();\n      }\n  #endif\n      return d->canReadLine();\n  }\n}"
  },
  {
    "function_name": "~IODeviceSocket(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "48-55",
    "snippet": "ODeviceSocket::~IODeviceSocket()\n{\n    d->deleteLater();\n#if TROJITA_COMPRESS_DEFLATE\n    delete m_compressor;\n    delete m_decompressor;\n#endif\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "->deleteLater",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  ODeviceSocket::~IODeviceSocket()\n  {\n      d->deleteLater();\n  #if TROJITA_COMPRESS_DEFLATE\n      delete m_compressor;\n      delete m_decompressor;\n  #endif\n  }\n}"
  },
  {
    "function_name": "IODeviceSocket(",
    "container": "ODeviceSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
    "lines": "38-46",
    "snippet": "ODeviceSocket::IODeviceSocket(QIODevice *device): d(device), m_compressor(0), m_decompressor(0)\n{\n    connect(d, SIGNAL(readyRead()), this, SLOT(handleReadyRead()));\n    connect(d, SIGNAL(readChannelFinished()), this, SLOT(handleStateChanged()));\n    delayedDisconnect = new QTimer();\n    delayedDisconnect->setSingleShot(true);\n    connect(delayedDisconnect, SIGNAL(timeout()), this, SLOT(emitError()));\n    QTimer::singleShot(0, this, SLOT(delayedStart()));\n}",
    "includes": [
      "include \"3rdparty/rfc1951.h\"\n#",
      "include \"TrojitaZlibStatus.h\"\n#",
      "include <QTimer>\n#",
      "include <QSslSocket>\n#",
      "include <QSslConfiguration>\n#",
      "include <QNetworkProxyQuery>\n#",
      "include <QNetworkProxyFactory>\n#",
      "include <QNetworkProxy>\n#",
      "include <stdexcept>\n#",
      "include \"IODeviceSocket.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(delayedStart()))"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "elayedStart())"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedStart(",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "delayedStart(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "335-390",
          "snippet": "oid SslTlsSocket::delayedStart()\n{\n    QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n    Q_ASSERT(sock);\n\n    switch (m_proxySettings) {\n    case Streams::ProxySettings::RespectSystemProxy:\n    {\n        QNetworkProxy setting;\n        QNetworkProxyQuery query = QNetworkProxyQuery(host, port, m_protocolTag, QNetworkProxyQuery::TcpSocket);\n\n        // set to true if a capable setting is found\n        bool capableSettingFound = false;\n\n        // set to true if at least one valid setting is found\n        bool settingFound = false;\n\n        // FIXME: this static function works particularly slow in Windows\n        QList<QNetworkProxy> proxySettingsList = QNetworkProxyFactory::systemProxyForQuery(query);\n\n        /* Proxy Settings are read from the user's environment variables by the above static method.\n         * A peculiar case is with *nix systems, where an undefined environment variable is returned as\n         * an empty string. Such entries *might* exist in our proxySettingsList, and shouldn't be processed.\n         * One good check is to use hostName() of the QNetworkProxy object, and treat the Proxy Setting as invalid if\n         * the host name is empty. */\n        Q_FOREACH (setting, proxySettingsList) {\n            if (!setting.hostName().isEmpty()) {\n                settingFound = true;\n\n                // now check whether setting has capabilities\n                if (setting.capabilities().testFlag(QNetworkProxy::TunnelingCapability)) {\n                    sock->setProxy(setting);\n                    capableSettingFound = true;\n                    break;\n                }\n            }\n        }\n\n        if (!settingFound || proxySettingsList.isEmpty()) {\n            sock->setProxy(QNetworkProxy::NoProxy);\n        } else if (!capableSettingFound) {\n            emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\")\n                              .arg(host, QString::number(port), QLatin1String(\"Cannot find proxy setting capable of tunneling\")));\n        }\n        break;\n    }\n    case Streams::ProxySettings::DirectConnect:\n        sock->setProxy(QNetworkProxy::NoProxy);\n        break;\n    }\n\n    if (startEncrypted)\n        sock->connectToHostEncrypted(host, port);\n    else\n        sock->connectToHost(host, port);\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::delayedStart()\n  {\n      QSslSocket *sock = qobject_cast<QSslSocket *>(d);\n      Q_ASSERT(sock);\n  \n      switch (m_proxySettings) {\n      case Streams::ProxySettings::RespectSystemProxy:\n      {\n          QNetworkProxy setting;\n          QNetworkProxyQuery query = QNetworkProxyQuery(host, port, m_protocolTag, QNetworkProxyQuery::TcpSocket);\n  \n          // set to true if a capable setting is found\n          bool capableSettingFound = false;\n  \n          // set to true if at least one valid setting is found\n          bool settingFound = false;\n  \n          // FIXME: this static function works particularly slow in Windows\n          QList<QNetworkProxy> proxySettingsList = QNetworkProxyFactory::systemProxyForQuery(query);\n  \n          /* Proxy Settings are read from the user's environment variables by the above static method.\n           * A peculiar case is with *nix systems, where an undefined environment variable is returned as\n           * an empty string. Such entries *might* exist in our proxySettingsList, and shouldn't be processed.\n           * One good check is to use hostName() of the QNetworkProxy object, and treat the Proxy Setting as invalid if\n           * the host name is empty. */\n          Q_FOREACH (setting, proxySettingsList) {\n              if (!setting.hostName().isEmpty()) {\n                  settingFound = true;\n  \n                  // now check whether setting has capabilities\n                  if (setting.capabilities().testFlag(QNetworkProxy::TunnelingCapability)) {\n                      sock->setProxy(setting);\n                      capableSettingFound = true;\n                      break;\n                  }\n              }\n          }\n  \n          if (!settingFound || proxySettingsList.isEmpty()) {\n              sock->setProxy(QNetworkProxy::NoProxy);\n          } else if (!capableSettingFound) {\n              emit disconnected(tr(\"The underlying socket is having troubles when processing connection to %1:%2: %3\")\n                                .arg(host, QString::number(port), QLatin1String(\"Cannot find proxy setting capable of tunneling\")));\n          }\n          break;\n      }\n      case Streams::ProxySettings::DirectConnect:\n          sock->setProxy(QNetworkProxy::NoProxy);\n          break;\n      }\n  \n      if (startEncrypted)\n          sock->connectToHostEncrypted(host, port);\n      else\n          sock->connectToHost(host, port);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "elayedDisconnect,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(emitError()))"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "mitError())"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mitError(",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "emitError(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "134-137",
          "snippet": "oid IODeviceSocket::emitError()\n{\n    emit disconnected(disconnectedMessage);\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::emitError()\n  {\n      emit disconnected(disconnectedMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedDisconnect->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            ",",
            "IGNAL(readChannelFinished()),",
            "his,",
            "LOT(handleStateChanged()))"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleStateChanged())"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleStateChanged(",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateChanged(",
          "container": "slTlsSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "262-316",
          "snippet": "oid SslTlsSocket::handleStateChanged()\n{\n    /* Qt delivers the stateChanged() signal before the error() one.\n    That's a problem because we really want to provide a nice error message\n    to the user and QAbstractSocket::error() is not set yet by the time this\n    function executes. That's why we have to delay the first disconnected() signal. */\n\n    QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n    Q_ASSERT(sock);\n    QString proxyMsg;\n    switch (sock->proxy().type()) {\n    case QNetworkProxy::NoProxy:\n        break;\n    case QNetworkProxy::DefaultProxy:\n    case QNetworkProxy::HttpCachingProxy:\n    case QNetworkProxy::FtpCachingProxy:\n        // these proxy types are not supposed to be supported\n        Q_ASSERT(false);\n        break;\n    case QNetworkProxy::Socks5Proxy:\n        proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    case QNetworkProxy::HttpProxy:\n        proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n        break;\n    }\n    switch (sock->state()) {\n    case QAbstractSocket::HostLookupState:\n        emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::ConnectingState:\n        emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                              host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                              sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                              proxyMsg : QString()));\n        break;\n    case QAbstractSocket::BoundState:\n    case QAbstractSocket::ListeningState:\n        break;\n    case QAbstractSocket::ConnectedState:\n        if (! startEncrypted) {\n            emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n        } else {\n            emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n        }\n        break;\n    case QAbstractSocket::UnconnectedState:\n    case QAbstractSocket::ClosingState:\n        disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n        delayedDisconnect->start();\n        break;\n    }\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nslTlsSocket {\n  oid SslTlsSocket::handleStateChanged()\n  {\n      /* Qt delivers the stateChanged() signal before the error() one.\n      That's a problem because we really want to provide a nice error message\n      to the user and QAbstractSocket::error() is not set yet by the time this\n      function executes. That's why we have to delay the first disconnected() signal. */\n  \n      QAbstractSocket *sock = qobject_cast<QAbstractSocket *>(d);\n      Q_ASSERT(sock);\n      QString proxyMsg;\n      switch (sock->proxy().type()) {\n      case QNetworkProxy::NoProxy:\n          break;\n      case QNetworkProxy::DefaultProxy:\n      case QNetworkProxy::HttpCachingProxy:\n      case QNetworkProxy::FtpCachingProxy:\n          // these proxy types are not supposed to be supported\n          Q_ASSERT(false);\n          break;\n      case QNetworkProxy::Socks5Proxy:\n          proxyMsg = tr(\" (via SOCKS5 proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      case QNetworkProxy::HttpProxy:\n          proxyMsg = tr(\" (via HTTP proxy %1)\").arg(sock->proxy().hostName());\n          break;\n      }\n      switch (sock->state()) {\n      case QAbstractSocket::HostLookupState:\n          emit stateChanged(Imap::CONN_STATE_HOST_LOOKUP, tr(\"Looking up %1%2...\").arg(host,\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::HostNameLookupCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::ConnectingState:\n          emit stateChanged(Imap::CONN_STATE_CONNECTING, tr(\"Connecting to %1:%2%3%4...\").arg(\n                                host, QString::number(port), startEncrypted ? tr(\" (SSL)\") : QString(),\n                                sock->proxy().capabilities().testFlag(QNetworkProxy::TunnelingCapability) ?\n                                proxyMsg : QString()));\n          break;\n      case QAbstractSocket::BoundState:\n      case QAbstractSocket::ListeningState:\n          break;\n      case QAbstractSocket::ConnectedState:\n          if (! startEncrypted) {\n              emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, tr(\"Connected\"));\n          } else {\n              emit stateChanged(Imap::CONN_STATE_SSL_HANDSHAKE, tr(\"Negotiating encryption...\"));\n          }\n          break;\n      case QAbstractSocket::UnconnectedState:\n      case QAbstractSocket::ClosingState:\n          disconnectedMessage = tr(\"Socket is disconnected: %1\").arg(sock->errorString());\n          delayedDisconnect->start();\n          break;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "eadChannelFinished())"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannelFinished(",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            ",",
            "IGNAL(readyRead()),",
            "his,",
            "LOT(handleReadyRead()))"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleReadyRead())"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleReadyRead(",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "handleReadyRead(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "124-132",
          "snippet": "oid IODeviceSocket::handleReadyRead()\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        m_decompressor->consume(d);\n    }\n#endif\n    emit readyRead();\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::handleReadyRead()\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          m_decompressor->consume(d);\n      }\n  #endif\n      emit readyRead();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "eadyRead())"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  ODeviceSocket::IODeviceSocket(QIODevice *device): d(device), m_compressor(0), m_decompressor(0)\n  {\n      connect(d, SIGNAL(readyRead()), this, SLOT(handleReadyRead()));\n      connect(d, SIGNAL(readChannelFinished()), this, SLOT(handleStateChanged()));\n      delayedDisconnect = new QTimer();\n      delayedDisconnect->setSingleShot(true);\n      connect(delayedDisconnect, SIGNAL(timeout()), this, SLOT(emitError()));\n      QTimer::singleShot(0, this, SLOT(delayedStart()));\n  }\n}"
  }
]