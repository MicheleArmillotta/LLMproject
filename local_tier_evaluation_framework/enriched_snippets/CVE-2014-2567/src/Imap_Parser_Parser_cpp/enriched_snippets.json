[
  {
    "function_name": "slotSocketStateChanged(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1157-1172",
    "snippet": "oid Parser::slotSocketStateChanged(const Imap::ConnectionState connState, const QString &message)\n{\n    if (connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n#ifdef PRINT_TRAFFIC_TX\n        qDebug() << m_parserId << \"*** Connection established\";\n#endif\n        emit lineReceived(this, \"*** Connection established\");\n        waitingForConnection = false;\n        QTimer::singleShot(0, this, SLOT(executeCommands()));\n    } else if (connState == CONN_STATE_AUTHENTICATED) {\n        // unit tests: don't wait for the initial untagged response greetings\n        m_expectsInitialGreeting = false;\n    }\n    emit lineReceived(this, \"*** \" + message.toUtf8());\n    emit connectionStateChanged(this, connState);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essage.toUtf8",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::slotSocketStateChanged(const Imap::ConnectionState connState, const QString &message)\n  {\n      if (connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n  #ifdef PRINT_TRAFFIC_TX\n          qDebug() << m_parserId << \"*** Connection established\";\n  #endif\n          emit lineReceived(this, \"*** Connection established\");\n          waitingForConnection = false;\n          QTimer::singleShot(0, this, SLOT(executeCommands()));\n      } else if (connState == CONN_STATE_AUTHENTICATED) {\n          // unit tests: don't wait for the initial untagged response greetings\n          m_expectsInitialGreeting = false;\n      }\n      emit lineReceived(this, \"*** \" + message.toUtf8());\n      emit connectionStateChanged(this, connState);\n  }\n}"
  },
  {
    "function_name": "parserId(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1152-1155",
    "snippet": "int Parser::parserId() const\n{\n    return m_parserId;\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  int Parser::parserId() const\n  {\n      return m_parserId;\n  }\n}"
  },
  {
    "function_name": "~Parser(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1142-1150",
    "snippet": "arser::~Parser()\n{\n    // We want to prevent nasty signals from the underlying socket from\n    // interfering with this object -- some of our local data might have\n    // been already destroyed!\n    socket->disconnect(this);\n    socket->close();\n    socket->deleteLater();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocket->deleteLater",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket->close",
          "args": [],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "close(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "124-128",
          "snippet": "oid FakeSocket::close()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** close ***]\"));\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::close()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** close ***]\"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocket->disconnect",
          "args": [
            "his)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  arser::~Parser()\n  {\n      // We want to prevent nasty signals from the underlying socket from\n      // interfering with this object -- some of our local data might have\n      // been already destroyed!\n      socket->disconnect(this);\n      socket->close();\n      socket->deleteLater();\n  }\n}"
  },
  {
    "function_name": "handleDisconnected(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1133-1140",
    "snippet": "oid Parser::handleDisconnected(const QString &reason)\n{\n    emit lineReceived(this, \"*** Socket disconnected: \" + reason.toUtf8());\n#ifdef PRINT_TRAFFIC_TX\n    qDebug() << m_parserId << \"*** Socket disconnected\";\n#endif\n    queueResponse(QSharedPointer<Responses::AbstractResponse>(new Responses::SocketDisconnectedResponse(reason)));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueResponse(",
          "args": [
            "SharedPointer<Responses::AbstractResponse>(new Responses::SocketDisconnectedResponse(reason)))"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "queueResponse(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "613-636",
          "snippet": "oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n{\n    respQueue.push_back(resp);\n    // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n    if (respQueue.size() == 1) {\n        emit responseReceived(this);\n    }\n\n    if (waitingForContinuation) {\n        // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n        QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n        Q_ASSERT(!literalCommandTag.isEmpty());\n        if (stateResponse && stateResponse->tag == literalCommandTag) {\n            literalCommandTag.clear();\n            waitingForContinuation = false;\n            cmdQueue.pop_front();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n            if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                // FIXME: use parserWarning when it's adapted throughout the code\n                qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n            }\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n  {\n      respQueue.push_back(resp);\n      // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n      if (respQueue.size() == 1) {\n          emit responseReceived(this);\n      }\n  \n      if (waitingForContinuation) {\n          // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n          QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n          Q_ASSERT(!literalCommandTag.isEmpty());\n          if (stateResponse && stateResponse->tag == literalCommandTag) {\n              literalCommandTag.clear();\n              waitingForContinuation = false;\n              cmdQueue.pop_front();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n              if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                  // FIXME: use parserWarning when it's adapted throughout the code\n                  qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::SocketDisconnectedResponse(reason))"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eason.toUtf8",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleDisconnected(const QString &reason)\n  {\n      emit lineReceived(this, \"*** Socket disconnected: \" + reason.toUtf8());\n  #ifdef PRINT_TRAFFIC_TX\n      qDebug() << m_parserId << \"*** Socket disconnected\";\n  #endif\n      queueResponse(QSharedPointer<Responses::AbstractResponse>(new Responses::SocketDisconnectedResponse(reason)));\n  }\n}"
  },
  {
    "function_name": "enableLiteralPlus(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1128-1131",
    "snippet": "oid Parser::enableLiteralPlus(const bool enabled)\n{\n    literalPlus = enabled;\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::enableLiteralPlus(const bool enabled)\n  {\n      literalPlus = enabled;\n  }\n}"
  },
  {
    "function_name": "parseTagged(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1100-1126",
    "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseTagged(const QByteArray &line)\n{\n    int pos = 0;\n    const QByteArray tag = LowLevelParser::getAtom(line, pos);\n    ++pos;\n    const Responses::Kind kind = Responses::kindFromString(LowLevelParser::getAtom(line, pos));\n    ++pos;\n\n    if (compressDeflateInProgress && compressDeflateCommand == tag + ' ') {\n        switch (kind) {\n        case Responses::OK:\n            socket->startDeflate();\n            compressDeflateInProgress = false;\n            compressDeflateCommand.clear();\n            break;\n        default:\n            // do nothing\n            break;\n        }\n        compressDeflateInProgress = false;\n        compressDeflateCommand.clear();\n        QTimer::singleShot(0, this, SLOT(handleCompressionPossibleActivated()));\n    }\n\n    return QSharedPointer<Responses::AbstractResponse>(\n               new Responses::State(tag, kind, line, pos));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::State(tag, kind, line, pos))"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(handleCompressionPossibleActivated()))"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleCompressionPossibleActivated())"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleCompressionPossibleActivated(",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "handleCompressionPossibleActivated(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "767-771",
          "snippet": "oid Parser::handleCompressionPossibleActivated()\n{\n    handleReadyRead();\n    executeCommands();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleCompressionPossibleActivated()\n  {\n      handleReadyRead();\n      executeCommands();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ompressDeflateCommand.clear",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocket->startDeflate",
          "args": [],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "startDeflate(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "112-116",
          "snippet": "oid FakeSocket::startDeflate()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** DEFLATE ***]\"));\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::startDeflate()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** DEFLATE ***]\"));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esponses::kindFromString(",
          "args": [
            "owLevelParser::getAtom(line, pos))"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owLevelParser::getAtom(",
          "args": [
            "ine,",
            "os)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owLevelParser::getAtom(",
          "args": [
            "ine,",
            "os)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseTagged(const QByteArray &line)\n  {\n      int pos = 0;\n      const QByteArray tag = LowLevelParser::getAtom(line, pos);\n      ++pos;\n      const Responses::Kind kind = Responses::kindFromString(LowLevelParser::getAtom(line, pos));\n      ++pos;\n  \n      if (compressDeflateInProgress && compressDeflateCommand == tag + ' ') {\n          switch (kind) {\n          case Responses::OK:\n              socket->startDeflate();\n              compressDeflateInProgress = false;\n              compressDeflateCommand.clear();\n              break;\n          default:\n              // do nothing\n              break;\n          }\n          compressDeflateInProgress = false;\n          compressDeflateCommand.clear();\n          QTimer::singleShot(0, this, SLOT(handleCompressionPossibleActivated()));\n      }\n  \n      return QSharedPointer<Responses::AbstractResponse>(\n                 new Responses::State(tag, kind, line, pos));\n  }\n}"
  },
  {
    "function_name": "parseUntaggedText(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "1012-1098",
    "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedText(\n    const QByteArray &line, int &start)\n{\n    Responses::Kind kind;\n    try {\n        kind = Responses::kindFromString(LowLevelParser::getAtom(line, start));\n    } catch (UnrecognizedResponseKind &e) {\n        throw UnrecognizedResponseKind(e.what(), line, start);\n    }\n    ++start;\n    if (start == line.size() && kind != Responses::SEARCH && kind != Responses::SORT)\n        throw NoData(line, start);\n    switch (kind) {\n    case Responses::CAPABILITY:\n    {\n        QStringList capabilities;\n        QList<QByteArray> list = line.mid(start).split(' ');\n        for (QList<QByteArray>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n            QByteArray str = *it;\n            if (str.endsWith(\"\\r\\n\"))\n                str.chop(2);\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n            capabilities << QString::fromUtf8(str);\n#else\n            capabilities << QString::fromUtf8(str.constData());\n#endif\n        }\n        if (!capabilities.count())\n            throw NoData(line, start);\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Capability(capabilities));\n    }\n    case Responses::OK:\n    case Responses::NO:\n    case Responses::BAD:\n    case Responses::PREAUTH:\n    case Responses::BYE:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::State(QByteArray(), kind, line, start));\n    case Responses::LIST:\n    case Responses::LSUB:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::List(kind, line, start));\n    case Responses::FLAGS:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Flags(line, start));\n    case Responses::SEARCH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Search(line, start));\n    case Responses::ESEARCH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::ESearch(line, start));\n    case Responses::STATUS:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Status(line, start));\n    case Responses::NAMESPACE:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Namespace(line, start));\n    case Responses::SORT:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Sort(line, start));\n    case Responses::THREAD:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Thread(line, start));\n    case Responses::ID:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Id(line, start));\n    case Responses::ENABLED:\n        return QSharedPointer<Responses::AbstractResponse>(\n                    new Responses::Enabled(line, start));\n    case Responses::VANISHED:\n        return QSharedPointer<Responses::AbstractResponse>(\n                    new Responses::Vanished(line, start));\n    case Responses::GENURLAUTH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                    new Responses::GenUrlAuth(line, start));\n\n\n        // Those already handled above follow here\n    case Responses::EXPUNGE:\n    case Responses::FETCH:\n    case Responses::EXISTS:\n    case Responses::RECENT:\n        throw UnexpectedHere(\"Malformed response: the number should go first\", line, start);\n    }\n    throw UnexpectedHere(line, start);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "Malformed response: the number should go first\",",
            "ine,",
            "tart)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::GenUrlAuth(line, start))"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Vanished(line, start))"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Enabled(line, start))"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Id(line, start))"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Thread(line, start))"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Sort(line, start))"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Namespace(line, start))"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Status(line, start))"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::ESearch(line, start))"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Search(line, start))"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Flags(line, start))"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::List(kind, line, start))"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::State(QByteArray(), kind, line, start))"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Capability(capabilities))"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apabilities.count",
          "args": [],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "tr.constData())"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr.constData",
          "args": [],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "tr)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr.chop",
          "args": [
            ")"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr.endsWith",
          "args": [
            "\\r\\n\")"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.constEnd",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist.constBegin",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "')"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "tart)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nrecognizedResponseKind(",
          "args": [
            ".what(),",
            "ine,",
            "tart)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".what",
          "args": [],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esponses::kindFromString(",
          "args": [
            "owLevelParser::getAtom(line, start))"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owLevelParser::getAtom(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedText(\n      const QByteArray &line, int &start)\n  {\n      Responses::Kind kind;\n      try {\n          kind = Responses::kindFromString(LowLevelParser::getAtom(line, start));\n      } catch (UnrecognizedResponseKind &e) {\n          throw UnrecognizedResponseKind(e.what(), line, start);\n      }\n      ++start;\n      if (start == line.size() && kind != Responses::SEARCH && kind != Responses::SORT)\n          throw NoData(line, start);\n      switch (kind) {\n      case Responses::CAPABILITY:\n      {\n          QStringList capabilities;\n          QList<QByteArray> list = line.mid(start).split(' ');\n          for (QList<QByteArray>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n              QByteArray str = *it;\n              if (str.endsWith(\"\\r\\n\"))\n                  str.chop(2);\n  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n              capabilities << QString::fromUtf8(str);\n  #else\n              capabilities << QString::fromUtf8(str.constData());\n  #endif\n          }\n          if (!capabilities.count())\n              throw NoData(line, start);\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Capability(capabilities));\n      }\n      case Responses::OK:\n      case Responses::NO:\n      case Responses::BAD:\n      case Responses::PREAUTH:\n      case Responses::BYE:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::State(QByteArray(), kind, line, start));\n      case Responses::LIST:\n      case Responses::LSUB:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::List(kind, line, start));\n      case Responses::FLAGS:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Flags(line, start));\n      case Responses::SEARCH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Search(line, start));\n      case Responses::ESEARCH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::ESearch(line, start));\n      case Responses::STATUS:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Status(line, start));\n      case Responses::NAMESPACE:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Namespace(line, start));\n      case Responses::SORT:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Sort(line, start));\n      case Responses::THREAD:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Thread(line, start));\n      case Responses::ID:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Id(line, start));\n      case Responses::ENABLED:\n          return QSharedPointer<Responses::AbstractResponse>(\n                      new Responses::Enabled(line, start));\n      case Responses::VANISHED:\n          return QSharedPointer<Responses::AbstractResponse>(\n                      new Responses::Vanished(line, start));\n      case Responses::GENURLAUTH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                      new Responses::GenUrlAuth(line, start));\n  \n  \n          // Those already handled above follow here\n      case Responses::EXPUNGE:\n      case Responses::FETCH:\n      case Responses::EXISTS:\n      case Responses::RECENT:\n          throw UnexpectedHere(\"Malformed response: the number should go first\", line, start);\n      }\n      throw UnexpectedHere(line, start);\n  }\n}"
  },
  {
    "function_name": "parseUntaggedNumber(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "968-1010",
    "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedNumber(\n    const QByteArray &line, int &start, const uint number)\n{\n    if (start == line.size())\n        // number and nothing else\n        throw NoData(line, start);\n\n    QByteArray kindStr = LowLevelParser::getAtom(line, start);\n    Responses::Kind kind;\n    try {\n        kind = Responses::kindFromString(kindStr);\n    } catch (UnrecognizedResponseKind &e) {\n        throw UnrecognizedResponseKind(e.what(), line, start);\n    }\n\n    switch (kind) {\n    case Responses::EXISTS:\n    case Responses::RECENT:\n    case Responses::EXPUNGE:\n        // no more data should follow\n        if (start >= line.size())\n            throw TooMuchData(line, start);\n        else if (line.mid(start) != QByteArray(\"\\r\\n\"))\n            throw UnexpectedHere(line, start);   // expected CRLF\n        else\n            try {\n                return QSharedPointer<Responses::AbstractResponse>(\n                           new Responses::NumberResponse(kind, number));\n            } catch (UnexpectedHere &e) {\n                throw UnexpectedHere(e.what(), line, start);\n            }\n        break;\n\n    case Responses::FETCH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Fetch(number, line, start));\n        break;\n\n    default:\n        break;\n    }\n    throw UnexpectedHere(line, start);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::Fetch(number, line, start))"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            ".what(),",
            "ine,",
            "tart)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".what",
          "args": [],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::NumberResponse(kind, number))"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedHere(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "\\r\\n\")"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ine.mid",
          "args": [
            "tart)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ooMuchData(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nrecognizedResponseKind(",
          "args": [
            ".what(),",
            "ine,",
            "tart)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".what",
          "args": [],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esponses::kindFromString(",
          "args": [
            "indStr)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "owLevelParser::getAtom(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oData(",
          "args": [
            "ine,",
            "tart)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.size",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedNumber(\n      const QByteArray &line, int &start, const uint number)\n  {\n      if (start == line.size())\n          // number and nothing else\n          throw NoData(line, start);\n  \n      QByteArray kindStr = LowLevelParser::getAtom(line, start);\n      Responses::Kind kind;\n      try {\n          kind = Responses::kindFromString(kindStr);\n      } catch (UnrecognizedResponseKind &e) {\n          throw UnrecognizedResponseKind(e.what(), line, start);\n      }\n  \n      switch (kind) {\n      case Responses::EXISTS:\n      case Responses::RECENT:\n      case Responses::EXPUNGE:\n          // no more data should follow\n          if (start >= line.size())\n              throw TooMuchData(line, start);\n          else if (line.mid(start) != QByteArray(\"\\r\\n\"))\n              throw UnexpectedHere(line, start);   // expected CRLF\n          else\n              try {\n                  return QSharedPointer<Responses::AbstractResponse>(\n                             new Responses::NumberResponse(kind, number));\n              } catch (UnexpectedHere &e) {\n                  throw UnexpectedHere(e.what(), line, start);\n              }\n          break;\n  \n      case Responses::FETCH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Fetch(number, line, start));\n          break;\n  \n      default:\n          break;\n      }\n      throw UnexpectedHere(line, start);\n  }\n}"
  },
  {
    "function_name": "parseUntagged(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "955-966",
    "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseUntagged(const QByteArray &line)\n{\n    int pos = 2;\n    uint number;\n    try {\n        number = LowLevelParser::getUInt(line, pos);\n        ++pos;\n    } catch (ParseError &) {\n        return parseUntaggedText(line, pos);\n    }\n    return parseUntaggedNumber(line, pos, number);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arseUntaggedNumber(",
          "args": [
            "ine,",
            "os,",
            "umber)"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "parseUntaggedNumber(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "968-1010",
          "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedNumber(\n    const QByteArray &line, int &start, const uint number)\n{\n    if (start == line.size())\n        // number and nothing else\n        throw NoData(line, start);\n\n    QByteArray kindStr = LowLevelParser::getAtom(line, start);\n    Responses::Kind kind;\n    try {\n        kind = Responses::kindFromString(kindStr);\n    } catch (UnrecognizedResponseKind &e) {\n        throw UnrecognizedResponseKind(e.what(), line, start);\n    }\n\n    switch (kind) {\n    case Responses::EXISTS:\n    case Responses::RECENT:\n    case Responses::EXPUNGE:\n        // no more data should follow\n        if (start >= line.size())\n            throw TooMuchData(line, start);\n        else if (line.mid(start) != QByteArray(\"\\r\\n\"))\n            throw UnexpectedHere(line, start);   // expected CRLF\n        else\n            try {\n                return QSharedPointer<Responses::AbstractResponse>(\n                           new Responses::NumberResponse(kind, number));\n            } catch (UnexpectedHere &e) {\n                throw UnexpectedHere(e.what(), line, start);\n            }\n        break;\n\n    case Responses::FETCH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Fetch(number, line, start));\n        break;\n\n    default:\n        break;\n    }\n    throw UnexpectedHere(line, start);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedNumber(\n      const QByteArray &line, int &start, const uint number)\n  {\n      if (start == line.size())\n          // number and nothing else\n          throw NoData(line, start);\n  \n      QByteArray kindStr = LowLevelParser::getAtom(line, start);\n      Responses::Kind kind;\n      try {\n          kind = Responses::kindFromString(kindStr);\n      } catch (UnrecognizedResponseKind &e) {\n          throw UnrecognizedResponseKind(e.what(), line, start);\n      }\n  \n      switch (kind) {\n      case Responses::EXISTS:\n      case Responses::RECENT:\n      case Responses::EXPUNGE:\n          // no more data should follow\n          if (start >= line.size())\n              throw TooMuchData(line, start);\n          else if (line.mid(start) != QByteArray(\"\\r\\n\"))\n              throw UnexpectedHere(line, start);   // expected CRLF\n          else\n              try {\n                  return QSharedPointer<Responses::AbstractResponse>(\n                             new Responses::NumberResponse(kind, number));\n              } catch (UnexpectedHere &e) {\n                  throw UnexpectedHere(e.what(), line, start);\n              }\n          break;\n  \n      case Responses::FETCH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Fetch(number, line, start));\n          break;\n  \n      default:\n          break;\n      }\n      throw UnexpectedHere(line, start);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arseUntaggedText(",
          "args": [
            "ine,",
            "os)"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "parseUntaggedText(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1012-1098",
          "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedText(\n    const QByteArray &line, int &start)\n{\n    Responses::Kind kind;\n    try {\n        kind = Responses::kindFromString(LowLevelParser::getAtom(line, start));\n    } catch (UnrecognizedResponseKind &e) {\n        throw UnrecognizedResponseKind(e.what(), line, start);\n    }\n    ++start;\n    if (start == line.size() && kind != Responses::SEARCH && kind != Responses::SORT)\n        throw NoData(line, start);\n    switch (kind) {\n    case Responses::CAPABILITY:\n    {\n        QStringList capabilities;\n        QList<QByteArray> list = line.mid(start).split(' ');\n        for (QList<QByteArray>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n            QByteArray str = *it;\n            if (str.endsWith(\"\\r\\n\"))\n                str.chop(2);\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n            capabilities << QString::fromUtf8(str);\n#else\n            capabilities << QString::fromUtf8(str.constData());\n#endif\n        }\n        if (!capabilities.count())\n            throw NoData(line, start);\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Capability(capabilities));\n    }\n    case Responses::OK:\n    case Responses::NO:\n    case Responses::BAD:\n    case Responses::PREAUTH:\n    case Responses::BYE:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::State(QByteArray(), kind, line, start));\n    case Responses::LIST:\n    case Responses::LSUB:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::List(kind, line, start));\n    case Responses::FLAGS:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Flags(line, start));\n    case Responses::SEARCH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Search(line, start));\n    case Responses::ESEARCH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::ESearch(line, start));\n    case Responses::STATUS:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Status(line, start));\n    case Responses::NAMESPACE:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Namespace(line, start));\n    case Responses::SORT:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Sort(line, start));\n    case Responses::THREAD:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Thread(line, start));\n    case Responses::ID:\n        return QSharedPointer<Responses::AbstractResponse>(\n                   new Responses::Id(line, start));\n    case Responses::ENABLED:\n        return QSharedPointer<Responses::AbstractResponse>(\n                    new Responses::Enabled(line, start));\n    case Responses::VANISHED:\n        return QSharedPointer<Responses::AbstractResponse>(\n                    new Responses::Vanished(line, start));\n    case Responses::GENURLAUTH:\n        return QSharedPointer<Responses::AbstractResponse>(\n                    new Responses::GenUrlAuth(line, start));\n\n\n        // Those already handled above follow here\n    case Responses::EXPUNGE:\n    case Responses::FETCH:\n    case Responses::EXISTS:\n    case Responses::RECENT:\n        throw UnexpectedHere(\"Malformed response: the number should go first\", line, start);\n    }\n    throw UnexpectedHere(line, start);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseUntaggedText(\n      const QByteArray &line, int &start)\n  {\n      Responses::Kind kind;\n      try {\n          kind = Responses::kindFromString(LowLevelParser::getAtom(line, start));\n      } catch (UnrecognizedResponseKind &e) {\n          throw UnrecognizedResponseKind(e.what(), line, start);\n      }\n      ++start;\n      if (start == line.size() && kind != Responses::SEARCH && kind != Responses::SORT)\n          throw NoData(line, start);\n      switch (kind) {\n      case Responses::CAPABILITY:\n      {\n          QStringList capabilities;\n          QList<QByteArray> list = line.mid(start).split(' ');\n          for (QList<QByteArray>::const_iterator it = list.constBegin(); it != list.constEnd(); ++it) {\n              QByteArray str = *it;\n              if (str.endsWith(\"\\r\\n\"))\n                  str.chop(2);\n  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n              capabilities << QString::fromUtf8(str);\n  #else\n              capabilities << QString::fromUtf8(str.constData());\n  #endif\n          }\n          if (!capabilities.count())\n              throw NoData(line, start);\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Capability(capabilities));\n      }\n      case Responses::OK:\n      case Responses::NO:\n      case Responses::BAD:\n      case Responses::PREAUTH:\n      case Responses::BYE:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::State(QByteArray(), kind, line, start));\n      case Responses::LIST:\n      case Responses::LSUB:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::List(kind, line, start));\n      case Responses::FLAGS:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Flags(line, start));\n      case Responses::SEARCH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Search(line, start));\n      case Responses::ESEARCH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::ESearch(line, start));\n      case Responses::STATUS:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Status(line, start));\n      case Responses::NAMESPACE:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Namespace(line, start));\n      case Responses::SORT:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Sort(line, start));\n      case Responses::THREAD:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Thread(line, start));\n      case Responses::ID:\n          return QSharedPointer<Responses::AbstractResponse>(\n                     new Responses::Id(line, start));\n      case Responses::ENABLED:\n          return QSharedPointer<Responses::AbstractResponse>(\n                      new Responses::Enabled(line, start));\n      case Responses::VANISHED:\n          return QSharedPointer<Responses::AbstractResponse>(\n                      new Responses::Vanished(line, start));\n      case Responses::GENURLAUTH:\n          return QSharedPointer<Responses::AbstractResponse>(\n                      new Responses::GenUrlAuth(line, start));\n  \n  \n          // Those already handled above follow here\n      case Responses::EXPUNGE:\n      case Responses::FETCH:\n      case Responses::EXISTS:\n      case Responses::RECENT:\n          throw UnexpectedHere(\"Malformed response: the number should go first\", line, start);\n      }\n      throw UnexpectedHere(line, start);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "owLevelParser::getUInt(",
          "args": [
            "ine,",
            "os)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseUntagged(const QByteArray &line)\n  {\n      int pos = 2;\n      uint number;\n      try {\n          number = LowLevelParser::getUInt(line, pos);\n          ++pos;\n      } catch (ParseError &) {\n          return parseUntaggedText(line, pos);\n      }\n      return parseUntaggedNumber(line, pos, number);\n  }\n}"
  },
  {
    "function_name": "processLine(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "924-953",
    "snippet": "oid Parser::processLine(QByteArray line)\n{\n#ifdef PRINT_TRAFFIC_RX\n    QByteArray debugLine = line.trimmed();\n    if (debugLine.size() > PRINT_TRAFFIC_RX)\n        qDebug() << m_parserId << \"<<<\" << debugLine.left(PRINT_TRAFFIC_RX) << \"...\";\n    else\n        qDebug() << m_parserId << \"<<<\" << debugLine;\n#endif\n    emit lineReceived(this, line);\n    if (m_expectsInitialGreeting && !line.startsWith(\"* \")) {\n        throw NotAnImapServerError(std::string(), line, -1);\n    } else if (line.startsWith(\"* \")) {\n        m_expectsInitialGreeting = false;\n        queueResponse(parseUntagged(line));\n    } else if (line.startsWith(\"+ \")) {\n        if (waitingForContinuation) {\n            waitingForContinuation = false;\n            literalCommandTag.clear();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n        } else if (waitForInitialIdle) {\n            waitForInitialIdle = false;\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n        } else {\n            throw ContinuationRequest(line.constData());\n        }\n    } else {\n        queueResponse(parseTagged(line));\n    }\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueResponse(",
          "args": [
            "arseTagged(line))"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "queueResponse(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "613-636",
          "snippet": "oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n{\n    respQueue.push_back(resp);\n    // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n    if (respQueue.size() == 1) {\n        emit responseReceived(this);\n    }\n\n    if (waitingForContinuation) {\n        // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n        QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n        Q_ASSERT(!literalCommandTag.isEmpty());\n        if (stateResponse && stateResponse->tag == literalCommandTag) {\n            literalCommandTag.clear();\n            waitingForContinuation = false;\n            cmdQueue.pop_front();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n            if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                // FIXME: use parserWarning when it's adapted throughout the code\n                qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n            }\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n  {\n      respQueue.push_back(resp);\n      // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n      if (respQueue.size() == 1) {\n          emit responseReceived(this);\n      }\n  \n      if (waitingForContinuation) {\n          // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n          QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n          Q_ASSERT(!literalCommandTag.isEmpty());\n          if (stateResponse && stateResponse->tag == literalCommandTag) {\n              literalCommandTag.clear();\n              waitingForContinuation = false;\n              cmdQueue.pop_front();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n              if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                  // FIXME: use parserWarning when it's adapted throughout the code\n                  qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arseTagged(",
          "args": [
            "ine)"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "parseTagged(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1100-1126",
          "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseTagged(const QByteArray &line)\n{\n    int pos = 0;\n    const QByteArray tag = LowLevelParser::getAtom(line, pos);\n    ++pos;\n    const Responses::Kind kind = Responses::kindFromString(LowLevelParser::getAtom(line, pos));\n    ++pos;\n\n    if (compressDeflateInProgress && compressDeflateCommand == tag + ' ') {\n        switch (kind) {\n        case Responses::OK:\n            socket->startDeflate();\n            compressDeflateInProgress = false;\n            compressDeflateCommand.clear();\n            break;\n        default:\n            // do nothing\n            break;\n        }\n        compressDeflateInProgress = false;\n        compressDeflateCommand.clear();\n        QTimer::singleShot(0, this, SLOT(handleCompressionPossibleActivated()));\n    }\n\n    return QSharedPointer<Responses::AbstractResponse>(\n               new Responses::State(tag, kind, line, pos));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseTagged(const QByteArray &line)\n  {\n      int pos = 0;\n      const QByteArray tag = LowLevelParser::getAtom(line, pos);\n      ++pos;\n      const Responses::Kind kind = Responses::kindFromString(LowLevelParser::getAtom(line, pos));\n      ++pos;\n  \n      if (compressDeflateInProgress && compressDeflateCommand == tag + ' ') {\n          switch (kind) {\n          case Responses::OK:\n              socket->startDeflate();\n              compressDeflateInProgress = false;\n              compressDeflateCommand.clear();\n              break;\n          default:\n              // do nothing\n              break;\n          }\n          compressDeflateInProgress = false;\n          compressDeflateCommand.clear();\n          QTimer::singleShot(0, this, SLOT(handleCompressionPossibleActivated()));\n      }\n  \n      return QSharedPointer<Responses::AbstractResponse>(\n                 new Responses::State(tag, kind, line, pos));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ontinuationRequest(",
          "args": [
            "ine.constData())"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.constData",
          "args": [],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iteralCommandTag.clear",
          "args": [],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "+ \")"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseUntagged(",
          "args": [
            "ine)"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "parseUntagged(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "955-966",
          "snippet": "SharedPointer<Responses::AbstractResponse> Parser::parseUntagged(const QByteArray &line)\n{\n    int pos = 2;\n    uint number;\n    try {\n        number = LowLevelParser::getUInt(line, pos);\n        ++pos;\n    } catch (ParseError &) {\n        return parseUntaggedText(line, pos);\n    }\n    return parseUntaggedNumber(line, pos, number);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::parseUntagged(const QByteArray &line)\n  {\n      int pos = 2;\n      uint number;\n      try {\n          number = LowLevelParser::getUInt(line, pos);\n          ++pos;\n      } catch (ParseError &) {\n          return parseUntaggedText(line, pos);\n      }\n      return parseUntaggedNumber(line, pos, number);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "* \")"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "otAnImapServerError(",
          "args": [
            "td::string(),",
            "ine,",
            "1)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::string(",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.startsWith",
          "args": [
            "* \")"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebugLine.left",
          "args": [
            "RINT_TRAFFIC_RX)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebugLine.size",
          "args": [],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ine.trimmed",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::processLine(QByteArray line)\n  {\n  #ifdef PRINT_TRAFFIC_RX\n      QByteArray debugLine = line.trimmed();\n      if (debugLine.size() > PRINT_TRAFFIC_RX)\n          qDebug() << m_parserId << \"<<<\" << debugLine.left(PRINT_TRAFFIC_RX) << \"...\";\n      else\n          qDebug() << m_parserId << \"<<<\" << debugLine;\n  #endif\n      emit lineReceived(this, line);\n      if (m_expectsInitialGreeting && !line.startsWith(\"* \")) {\n          throw NotAnImapServerError(std::string(), line, -1);\n      } else if (line.startsWith(\"* \")) {\n          m_expectsInitialGreeting = false;\n          queueResponse(parseUntagged(line));\n      } else if (line.startsWith(\"+ \")) {\n          if (waitingForContinuation) {\n              waitingForContinuation = false;\n              literalCommandTag.clear();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n          } else if (waitForInitialIdle) {\n              waitForInitialIdle = false;\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n          } else {\n              throw ContinuationRequest(line.constData());\n          }\n      } else {\n          queueResponse(parseTagged(line));\n      }\n  }\n}"
  },
  {
    "function_name": "executeACommand(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "781-921",
    "snippet": "oid Parser::executeACommand()\n{\n    Q_ASSERT(! cmdQueue.isEmpty());\n    Commands::Command &cmd = cmdQueue.first();\n\n    QByteArray buf;\n\n    bool sensitiveCommand = (cmd.cmds.size() > 2 && cmd.cmds[1].text == \"LOGIN\");\n    QByteArray privateMessage = sensitiveCommand ? QByteArray(\"[LOGIN command goes here]\") : QByteArray();\n\n#ifdef PRINT_TRAFFIC_TX\n#ifdef PRINT_TRAFFIC_SENSITIVE\n    bool printThisCommand = true;\n#else\n    bool printThisCommand = ! sensitiveCommand;\n#endif\n#endif\n\n    if (cmd.cmds[ cmd.currentPart ].kind == Commands::IDLE_DONE) {\n        // Handling of the IDLE_DONE is a bit special, as we have to check and update the idling flag...\n        Q_ASSERT(idling);\n        buf.append(\"DONE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n        qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n        socket->write(buf);\n        idling = false;\n        cmdQueue.pop_front();\n        emit lineSent(this, buf);\n        buf.clear();\n        return;\n    }\n\n    Q_ASSERT(! idling);\n\n    while (1) {\n        Commands::PartOfCommand &part = cmd.cmds[ cmd.currentPart ];\n        switch (part.kind) {\n        case Commands::ATOM:\n        case Commands::ATOM_NO_SPACE_AROUND:\n            buf.append(part.text);\n            break;\n        case Commands::QUOTED_STRING:\n        {\n            QByteArray item = part.text;\n            item.replace('\\\\', \"\\\\\\\\\");\n            buf.append('\"');\n            buf.append(item);\n            buf.append('\"');\n        }\n        break;\n        case Commands::LITERAL:\n            if (literalPlus) {\n                buf.append('{');\n                buf.append(QByteArray::number(part.text.size()));\n                buf.append(\"+}\\r\\n\");\n                buf.append(part.text);\n            } else if (part.numberSent) {\n                buf.append(part.text);\n            } else {\n                buf.append('{');\n                buf.append(QByteArray::number(part.text.size()));\n                buf.append(\"}\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n                if (printThisCommand)\n                    qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n                else\n                    qDebug() << m_parserId << \">>> [sensitive command] -- added literal\";\n#endif\n                socket->write(buf);\n                part.numberSent = true;\n                waitingForContinuation = true;\n                Q_ASSERT(literalCommandTag.isEmpty());\n                literalCommandTag = cmd.cmds.first().text;\n                Q_ASSERT(!literalCommandTag.isEmpty());\n                emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n                return; // and wait for continuation request\n            }\n            break;\n        case Commands::IDLE_DONE:\n            Q_ASSERT(false); // is handled above\n            break;\n        case Commands::IDLE:\n            buf.append(\"IDLE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            idling = true;\n            waitForInitialIdle = true;\n            cmdQueue.pop_front();\n            emit lineSent(this, buf);\n            return;\n            break;\n        case Commands::STARTTLS:\n            startTlsCommand = buf;\n            buf.append(\"STARTTLS\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            startTlsInProgress = true;\n            emit lineSent(this, buf);\n            return;\n            break;\n        case Commands::COMPRESS_DEFLATE:\n            compressDeflateCommand = buf;\n            buf.append(\"COMPRESS DEFLATE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            compressDeflateInProgress = true;\n            cmdQueue.pop_front();\n            emit lineSent(this, buf);\n            return;\n            break;\n        }\n        if (cmd.currentPart == cmd.cmds.size() - 1) {\n            // finalize\n            buf.append(\"\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            if (printThisCommand)\n                qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n            else\n                qDebug() << m_parserId << \">>> [sensitive command]\";\n#endif\n            socket->write(buf);\n            cmdQueue.pop_front();\n            emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n            break;\n        } else {\n            if (part.kind == Commands::ATOM_NO_SPACE_AROUND || cmd.cmds[cmd.currentPart + 1].kind == Commands::ATOM_NO_SPACE_AROUND) {\n                // Skip the extra space if asked to do so\n            } else {\n                buf.append(' ');\n            }\n            ++cmd.currentPart;\n        }\n    }\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "')"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdQueue.pop_front",
          "args": [],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket->write",
          "args": [
            "uf)"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "write(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "100-103",
          "snippet": "int64 FakeSocket::write(const QByteArray &byteArray)\n{\n    return writeChannel->write(byteArray);\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  int64 FakeSocket::write(const QByteArray &byteArray)\n  {\n      return writeChannel->write(byteArray);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [
            "RINT_TRAFFIC_TX)"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "\\r\\n\")"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md.cmds.size",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdQueue.pop_front",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [
            "RINT_TRAFFIC_TX)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "COMPRESS DEFLATE\\r\\n\")"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [
            "RINT_TRAFFIC_TX)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "STARTTLS\\r\\n\")"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdQueue.pop_front",
          "args": [],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [
            "RINT_TRAFFIC_TX)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "IDLE\\r\\n\")"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "literalCommandTag.isEmpty())"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iteralCommandTag.isEmpty",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md.cmds.first",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "iteralCommandTag.isEmpty())"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iteralCommandTag.isEmpty",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [
            "RINT_TRAFFIC_TX)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "}\\r\\n\")"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "ByteArray::number(part.text.size()))"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "art.text.size())"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.text.size",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "{')"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "art.text)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "art.text)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "+}\\r\\n\")"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "ByteArray::number(part.text.size()))"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "art.text.size())"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.text.size",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "{')"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "\"')"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "tem)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "\"')"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem.replace",
          "args": [
            "\\\\',",
            "\\\\\\\\\")"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "art.text)"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "idling)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.clear",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdQueue.pop_front",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.left",
          "args": [
            "RINT_TRAFFIC_TX)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.append",
          "args": [
            "DONE\\r\\n\")"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "dling)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "[LOGIN command goes here]\")"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "md.cmds.size",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "cmdQueue.isEmpty())"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdQueue.isEmpty",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeACommand()\n  {\n      Q_ASSERT(! cmdQueue.isEmpty());\n      Commands::Command &cmd = cmdQueue.first();\n  \n      QByteArray buf;\n  \n      bool sensitiveCommand = (cmd.cmds.size() > 2 && cmd.cmds[1].text == \"LOGIN\");\n      QByteArray privateMessage = sensitiveCommand ? QByteArray(\"[LOGIN command goes here]\") : QByteArray();\n  \n  #ifdef PRINT_TRAFFIC_TX\n  #ifdef PRINT_TRAFFIC_SENSITIVE\n      bool printThisCommand = true;\n  #else\n      bool printThisCommand = ! sensitiveCommand;\n  #endif\n  #endif\n  \n      if (cmd.cmds[ cmd.currentPart ].kind == Commands::IDLE_DONE) {\n          // Handling of the IDLE_DONE is a bit special, as we have to check and update the idling flag...\n          Q_ASSERT(idling);\n          buf.append(\"DONE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n          qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n          socket->write(buf);\n          idling = false;\n          cmdQueue.pop_front();\n          emit lineSent(this, buf);\n          buf.clear();\n          return;\n      }\n  \n      Q_ASSERT(! idling);\n  \n      while (1) {\n          Commands::PartOfCommand &part = cmd.cmds[ cmd.currentPart ];\n          switch (part.kind) {\n          case Commands::ATOM:\n          case Commands::ATOM_NO_SPACE_AROUND:\n              buf.append(part.text);\n              break;\n          case Commands::QUOTED_STRING:\n          {\n              QByteArray item = part.text;\n              item.replace('\\\\', \"\\\\\\\\\");\n              buf.append('\"');\n              buf.append(item);\n              buf.append('\"');\n          }\n          break;\n          case Commands::LITERAL:\n              if (literalPlus) {\n                  buf.append('{');\n                  buf.append(QByteArray::number(part.text.size()));\n                  buf.append(\"+}\\r\\n\");\n                  buf.append(part.text);\n              } else if (part.numberSent) {\n                  buf.append(part.text);\n              } else {\n                  buf.append('{');\n                  buf.append(QByteArray::number(part.text.size()));\n                  buf.append(\"}\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n                  if (printThisCommand)\n                      qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n                  else\n                      qDebug() << m_parserId << \">>> [sensitive command] -- added literal\";\n  #endif\n                  socket->write(buf);\n                  part.numberSent = true;\n                  waitingForContinuation = true;\n                  Q_ASSERT(literalCommandTag.isEmpty());\n                  literalCommandTag = cmd.cmds.first().text;\n                  Q_ASSERT(!literalCommandTag.isEmpty());\n                  emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n                  return; // and wait for continuation request\n              }\n              break;\n          case Commands::IDLE_DONE:\n              Q_ASSERT(false); // is handled above\n              break;\n          case Commands::IDLE:\n              buf.append(\"IDLE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              idling = true;\n              waitForInitialIdle = true;\n              cmdQueue.pop_front();\n              emit lineSent(this, buf);\n              return;\n              break;\n          case Commands::STARTTLS:\n              startTlsCommand = buf;\n              buf.append(\"STARTTLS\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              startTlsInProgress = true;\n              emit lineSent(this, buf);\n              return;\n              break;\n          case Commands::COMPRESS_DEFLATE:\n              compressDeflateCommand = buf;\n              buf.append(\"COMPRESS DEFLATE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              compressDeflateInProgress = true;\n              cmdQueue.pop_front();\n              emit lineSent(this, buf);\n              return;\n              break;\n          }\n          if (cmd.currentPart == cmd.cmds.size() - 1) {\n              // finalize\n              buf.append(\"\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              if (printThisCommand)\n                  qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n              else\n                  qDebug() << m_parserId << \">>> [sensitive command]\";\n  #endif\n              socket->write(buf);\n              cmdQueue.pop_front();\n              emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n              break;\n          } else {\n              if (part.kind == Commands::ATOM_NO_SPACE_AROUND || cmd.cmds[cmd.currentPart + 1].kind == Commands::ATOM_NO_SPACE_AROUND) {\n                  // Skip the extra space if asked to do so\n              } else {\n                  buf.append(' ');\n              }\n              ++cmd.currentPart;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "unfreezeAfterEncryption(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "773-779",
    "snippet": "oid Parser::unfreezeAfterEncryption()\n{\n    Q_ASSERT(waitingForSslPolicy);\n    waitingForSslPolicy = false;\n    handleReadyRead();\n    executeCommands();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "andleReadyRead(",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "handleReadyRead(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "658-685",
          "snippet": "oid Parser::handleReadyRead()\n{\n    while (!waitingForEncryption && !waitingForSslPolicy) {\n        switch (readingMode) {\n        case ReadingLine:\n            if (socket->canReadLine()) {\n                reallyReadLine();\n            } else {\n                // Not enough data yet, let's try again later\n                return;\n            }\n            break;\n        case ReadingNumberOfBytes:\n        {\n            QByteArray buf = socket->read(readingBytes);\n            readingBytes -= buf.size();\n            currentLine += buf;\n            if (readingBytes == 0) {\n                // we've read the literal\n                readingMode = ReadingLine;\n            } else {\n                return;\n            }\n        }\n        break;\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleReadyRead()\n  {\n      while (!waitingForEncryption && !waitingForSslPolicy) {\n          switch (readingMode) {\n          case ReadingLine:\n              if (socket->canReadLine()) {\n                  reallyReadLine();\n              } else {\n                  // Not enough data yet, let's try again later\n                  return;\n              }\n              break;\n          case ReadingNumberOfBytes:\n          {\n              QByteArray buf = socket->read(readingBytes);\n              readingBytes -= buf.size();\n              currentLine += buf;\n              if (readingBytes == 0) {\n                  // we've read the literal\n                  readingMode = ReadingLine;\n              } else {\n                  return;\n              }\n          }\n          break;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "aitingForSslPolicy)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::unfreezeAfterEncryption()\n  {\n      Q_ASSERT(waitingForSslPolicy);\n      waitingForSslPolicy = false;\n      handleReadyRead();\n      executeCommands();\n  }\n}"
  },
  {
    "function_name": "handleCompressionPossibleActivated(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "767-771",
    "snippet": "oid Parser::handleCompressionPossibleActivated()\n{\n    handleReadyRead();\n    executeCommands();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "andleReadyRead(",
          "args": [],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "handleReadyRead(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "658-685",
          "snippet": "oid Parser::handleReadyRead()\n{\n    while (!waitingForEncryption && !waitingForSslPolicy) {\n        switch (readingMode) {\n        case ReadingLine:\n            if (socket->canReadLine()) {\n                reallyReadLine();\n            } else {\n                // Not enough data yet, let's try again later\n                return;\n            }\n            break;\n        case ReadingNumberOfBytes:\n        {\n            QByteArray buf = socket->read(readingBytes);\n            readingBytes -= buf.size();\n            currentLine += buf;\n            if (readingBytes == 0) {\n                // we've read the literal\n                readingMode = ReadingLine;\n            } else {\n                return;\n            }\n        }\n        break;\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleReadyRead()\n  {\n      while (!waitingForEncryption && !waitingForSslPolicy) {\n          switch (readingMode) {\n          case ReadingLine:\n              if (socket->canReadLine()) {\n                  reallyReadLine();\n              } else {\n                  // Not enough data yet, let's try again later\n                  return;\n              }\n              break;\n          case ReadingNumberOfBytes:\n          {\n              QByteArray buf = socket->read(readingBytes);\n              readingBytes -= buf.size();\n              currentLine += buf;\n              if (readingBytes == 0) {\n                  // we've read the literal\n                  readingMode = ReadingLine;\n              } else {\n                  return;\n              }\n          }\n          break;\n          }\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleCompressionPossibleActivated()\n  {\n      handleReadyRead();\n      executeCommands();\n  }\n}"
  },
  {
    "function_name": "handleSocketEncrypted(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "746-764",
    "snippet": "oid Parser::handleSocketEncrypted()\n{\n    waitingForEncryption = false;\n    waitingForConnection = false;\n    waitingForSslPolicy = true;\n    QSharedPointer<Responses::AbstractResponse> resp(\n                new Responses::SocketEncryptedResponse(socket->sslChain(), socket->sslErrors()));\n    QByteArray buf;\n    QTextStream ss(&buf);\n    ss << \"*** \" << *resp;\n    ss.flush();\n#ifdef PRINT_TRAFFIC_RX\n    qDebug() << m_parserId << \"***\" << buf;\n#endif\n    emit lineReceived(this, buf);\n    handleReadyRead();\n    queueResponse(resp);\n    executeCommands();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueueResponse(",
          "args": [
            "esp)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "queueResponse(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "613-636",
          "snippet": "oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n{\n    respQueue.push_back(resp);\n    // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n    if (respQueue.size() == 1) {\n        emit responseReceived(this);\n    }\n\n    if (waitingForContinuation) {\n        // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n        QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n        Q_ASSERT(!literalCommandTag.isEmpty());\n        if (stateResponse && stateResponse->tag == literalCommandTag) {\n            literalCommandTag.clear();\n            waitingForContinuation = false;\n            cmdQueue.pop_front();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n            if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                // FIXME: use parserWarning when it's adapted throughout the code\n                qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n            }\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n  {\n      respQueue.push_back(resp);\n      // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n      if (respQueue.size() == 1) {\n          emit responseReceived(this);\n      }\n  \n      if (waitingForContinuation) {\n          // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n          QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n          Q_ASSERT(!literalCommandTag.isEmpty());\n          if (stateResponse && stateResponse->tag == literalCommandTag) {\n              literalCommandTag.clear();\n              waitingForContinuation = false;\n              cmdQueue.pop_front();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n              if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                  // FIXME: use parserWarning when it's adapted throughout the code\n                  qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "andleReadyRead(",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "handleReadyRead(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "658-685",
          "snippet": "oid Parser::handleReadyRead()\n{\n    while (!waitingForEncryption && !waitingForSslPolicy) {\n        switch (readingMode) {\n        case ReadingLine:\n            if (socket->canReadLine()) {\n                reallyReadLine();\n            } else {\n                // Not enough data yet, let's try again later\n                return;\n            }\n            break;\n        case ReadingNumberOfBytes:\n        {\n            QByteArray buf = socket->read(readingBytes);\n            readingBytes -= buf.size();\n            currentLine += buf;\n            if (readingBytes == 0) {\n                // we've read the literal\n                readingMode = ReadingLine;\n            } else {\n                return;\n            }\n        }\n        break;\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleReadyRead()\n  {\n      while (!waitingForEncryption && !waitingForSslPolicy) {\n          switch (readingMode) {\n          case ReadingLine:\n              if (socket->canReadLine()) {\n                  reallyReadLine();\n              } else {\n                  // Not enough data yet, let's try again later\n                  return;\n              }\n              break;\n          case ReadingNumberOfBytes:\n          {\n              QByteArray buf = socket->read(readingBytes);\n              readingBytes -= buf.size();\n              currentLine += buf;\n              if (readingBytes == 0) {\n                  // we've read the literal\n                  readingMode = ReadingLine;\n              } else {\n                  return;\n              }\n          }\n          break;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.flush",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket->sslErrors",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "sslErrors(",
          "container": "ocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/Socket.cpp",
          "lines": "42-45",
          "snippet": "List<QSslError> Socket::sslErrors() const\n{\n    return QList<QSslError>();\n}",
          "includes": [
            "include \"Socket.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Socket.h\"\n\nocket {\n  List<QSslError> Socket::sslErrors() const\n  {\n      return QList<QSslError>();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocket->sslChain",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "sslChain(",
          "container": "ocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/Socket.cpp",
          "lines": "37-40",
          "snippet": "List<QSslCertificate> Socket::sslChain() const\n{\n    return QList<QSslCertificate>();\n}",
          "includes": [
            "include \"Socket.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Socket.h\"\n\nocket {\n  List<QSslCertificate> Socket::sslChain() const\n  {\n      return QList<QSslCertificate>();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleSocketEncrypted()\n  {\n      waitingForEncryption = false;\n      waitingForConnection = false;\n      waitingForSslPolicy = true;\n      QSharedPointer<Responses::AbstractResponse> resp(\n                  new Responses::SocketEncryptedResponse(socket->sslChain(), socket->sslErrors()));\n      QByteArray buf;\n      QTextStream ss(&buf);\n      ss << \"*** \" << *resp;\n      ss.flush();\n  #ifdef PRINT_TRAFFIC_RX\n      qDebug() << m_parserId << \"***\" << buf;\n  #endif\n      emit lineReceived(this, buf);\n      handleReadyRead();\n      queueResponse(resp);\n      executeCommands();\n  }\n}"
  },
  {
    "function_name": "finishStartTls(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "733-744",
    "snippet": "oid Parser::finishStartTls()\n{\n    emit lineSent(this, \"*** STARTTLS\");\n#ifdef PRINT_TRAFFIC_TX\n    qDebug() << m_parserId << \"*** STARTTLS\";\n#endif\n    cmdQueue.pop_front();\n    socket->startTls(); // warn: this might invoke event loop\n    startTlsInProgress = false;\n    waitingForEncryption = true;\n    processLine(startTlsReply);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rocessLine(",
          "args": [
            "tartTlsReply)"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "processLine(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "924-953",
          "snippet": "oid Parser::processLine(QByteArray line)\n{\n#ifdef PRINT_TRAFFIC_RX\n    QByteArray debugLine = line.trimmed();\n    if (debugLine.size() > PRINT_TRAFFIC_RX)\n        qDebug() << m_parserId << \"<<<\" << debugLine.left(PRINT_TRAFFIC_RX) << \"...\";\n    else\n        qDebug() << m_parserId << \"<<<\" << debugLine;\n#endif\n    emit lineReceived(this, line);\n    if (m_expectsInitialGreeting && !line.startsWith(\"* \")) {\n        throw NotAnImapServerError(std::string(), line, -1);\n    } else if (line.startsWith(\"* \")) {\n        m_expectsInitialGreeting = false;\n        queueResponse(parseUntagged(line));\n    } else if (line.startsWith(\"+ \")) {\n        if (waitingForContinuation) {\n            waitingForContinuation = false;\n            literalCommandTag.clear();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n        } else if (waitForInitialIdle) {\n            waitForInitialIdle = false;\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n        } else {\n            throw ContinuationRequest(line.constData());\n        }\n    } else {\n        queueResponse(parseTagged(line));\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::processLine(QByteArray line)\n  {\n  #ifdef PRINT_TRAFFIC_RX\n      QByteArray debugLine = line.trimmed();\n      if (debugLine.size() > PRINT_TRAFFIC_RX)\n          qDebug() << m_parserId << \"<<<\" << debugLine.left(PRINT_TRAFFIC_RX) << \"...\";\n      else\n          qDebug() << m_parserId << \"<<<\" << debugLine;\n  #endif\n      emit lineReceived(this, line);\n      if (m_expectsInitialGreeting && !line.startsWith(\"* \")) {\n          throw NotAnImapServerError(std::string(), line, -1);\n      } else if (line.startsWith(\"* \")) {\n          m_expectsInitialGreeting = false;\n          queueResponse(parseUntagged(line));\n      } else if (line.startsWith(\"+ \")) {\n          if (waitingForContinuation) {\n              waitingForContinuation = false;\n              literalCommandTag.clear();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n          } else if (waitForInitialIdle) {\n              waitForInitialIdle = false;\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n          } else {\n              throw ContinuationRequest(line.constData());\n          }\n      } else {\n          queueResponse(parseTagged(line));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocket->startTls",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "startTls(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "105-110",
          "snippet": "oid FakeSocket::startTls()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** STARTTLS ***]\"));\n    QTimer::singleShot(0, this, SLOT(slotEmitEncrypted()));\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::startTls()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** STARTTLS ***]\"));\n      QTimer::singleShot(0, this, SLOT(slotEmitEncrypted()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdQueue.pop_front",
          "args": [],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::finishStartTls()\n  {\n      emit lineSent(this, \"*** STARTTLS\");\n  #ifdef PRINT_TRAFFIC_TX\n      qDebug() << m_parserId << \"*** STARTTLS\";\n  #endif\n      cmdQueue.pop_front();\n      socket->startTls(); // warn: this might invoke event loop\n      startTlsInProgress = false;\n      waitingForEncryption = true;\n      processLine(startTlsReply);\n  }\n}"
  },
  {
    "function_name": "executeCommands(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "725-731",
    "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xecuteACommand(",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "executeACommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "781-921",
          "snippet": "oid Parser::executeACommand()\n{\n    Q_ASSERT(! cmdQueue.isEmpty());\n    Commands::Command &cmd = cmdQueue.first();\n\n    QByteArray buf;\n\n    bool sensitiveCommand = (cmd.cmds.size() > 2 && cmd.cmds[1].text == \"LOGIN\");\n    QByteArray privateMessage = sensitiveCommand ? QByteArray(\"[LOGIN command goes here]\") : QByteArray();\n\n#ifdef PRINT_TRAFFIC_TX\n#ifdef PRINT_TRAFFIC_SENSITIVE\n    bool printThisCommand = true;\n#else\n    bool printThisCommand = ! sensitiveCommand;\n#endif\n#endif\n\n    if (cmd.cmds[ cmd.currentPart ].kind == Commands::IDLE_DONE) {\n        // Handling of the IDLE_DONE is a bit special, as we have to check and update the idling flag...\n        Q_ASSERT(idling);\n        buf.append(\"DONE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n        qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n        socket->write(buf);\n        idling = false;\n        cmdQueue.pop_front();\n        emit lineSent(this, buf);\n        buf.clear();\n        return;\n    }\n\n    Q_ASSERT(! idling);\n\n    while (1) {\n        Commands::PartOfCommand &part = cmd.cmds[ cmd.currentPart ];\n        switch (part.kind) {\n        case Commands::ATOM:\n        case Commands::ATOM_NO_SPACE_AROUND:\n            buf.append(part.text);\n            break;\n        case Commands::QUOTED_STRING:\n        {\n            QByteArray item = part.text;\n            item.replace('\\\\', \"\\\\\\\\\");\n            buf.append('\"');\n            buf.append(item);\n            buf.append('\"');\n        }\n        break;\n        case Commands::LITERAL:\n            if (literalPlus) {\n                buf.append('{');\n                buf.append(QByteArray::number(part.text.size()));\n                buf.append(\"+}\\r\\n\");\n                buf.append(part.text);\n            } else if (part.numberSent) {\n                buf.append(part.text);\n            } else {\n                buf.append('{');\n                buf.append(QByteArray::number(part.text.size()));\n                buf.append(\"}\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n                if (printThisCommand)\n                    qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n                else\n                    qDebug() << m_parserId << \">>> [sensitive command] -- added literal\";\n#endif\n                socket->write(buf);\n                part.numberSent = true;\n                waitingForContinuation = true;\n                Q_ASSERT(literalCommandTag.isEmpty());\n                literalCommandTag = cmd.cmds.first().text;\n                Q_ASSERT(!literalCommandTag.isEmpty());\n                emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n                return; // and wait for continuation request\n            }\n            break;\n        case Commands::IDLE_DONE:\n            Q_ASSERT(false); // is handled above\n            break;\n        case Commands::IDLE:\n            buf.append(\"IDLE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            idling = true;\n            waitForInitialIdle = true;\n            cmdQueue.pop_front();\n            emit lineSent(this, buf);\n            return;\n            break;\n        case Commands::STARTTLS:\n            startTlsCommand = buf;\n            buf.append(\"STARTTLS\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            startTlsInProgress = true;\n            emit lineSent(this, buf);\n            return;\n            break;\n        case Commands::COMPRESS_DEFLATE:\n            compressDeflateCommand = buf;\n            buf.append(\"COMPRESS DEFLATE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            compressDeflateInProgress = true;\n            cmdQueue.pop_front();\n            emit lineSent(this, buf);\n            return;\n            break;\n        }\n        if (cmd.currentPart == cmd.cmds.size() - 1) {\n            // finalize\n            buf.append(\"\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            if (printThisCommand)\n                qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n            else\n                qDebug() << m_parserId << \">>> [sensitive command]\";\n#endif\n            socket->write(buf);\n            cmdQueue.pop_front();\n            emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n            break;\n        } else {\n            if (part.kind == Commands::ATOM_NO_SPACE_AROUND || cmd.cmds[cmd.currentPart + 1].kind == Commands::ATOM_NO_SPACE_AROUND) {\n                // Skip the extra space if asked to do so\n            } else {\n                buf.append(' ');\n            }\n            ++cmd.currentPart;\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeACommand()\n  {\n      Q_ASSERT(! cmdQueue.isEmpty());\n      Commands::Command &cmd = cmdQueue.first();\n  \n      QByteArray buf;\n  \n      bool sensitiveCommand = (cmd.cmds.size() > 2 && cmd.cmds[1].text == \"LOGIN\");\n      QByteArray privateMessage = sensitiveCommand ? QByteArray(\"[LOGIN command goes here]\") : QByteArray();\n  \n  #ifdef PRINT_TRAFFIC_TX\n  #ifdef PRINT_TRAFFIC_SENSITIVE\n      bool printThisCommand = true;\n  #else\n      bool printThisCommand = ! sensitiveCommand;\n  #endif\n  #endif\n  \n      if (cmd.cmds[ cmd.currentPart ].kind == Commands::IDLE_DONE) {\n          // Handling of the IDLE_DONE is a bit special, as we have to check and update the idling flag...\n          Q_ASSERT(idling);\n          buf.append(\"DONE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n          qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n          socket->write(buf);\n          idling = false;\n          cmdQueue.pop_front();\n          emit lineSent(this, buf);\n          buf.clear();\n          return;\n      }\n  \n      Q_ASSERT(! idling);\n  \n      while (1) {\n          Commands::PartOfCommand &part = cmd.cmds[ cmd.currentPart ];\n          switch (part.kind) {\n          case Commands::ATOM:\n          case Commands::ATOM_NO_SPACE_AROUND:\n              buf.append(part.text);\n              break;\n          case Commands::QUOTED_STRING:\n          {\n              QByteArray item = part.text;\n              item.replace('\\\\', \"\\\\\\\\\");\n              buf.append('\"');\n              buf.append(item);\n              buf.append('\"');\n          }\n          break;\n          case Commands::LITERAL:\n              if (literalPlus) {\n                  buf.append('{');\n                  buf.append(QByteArray::number(part.text.size()));\n                  buf.append(\"+}\\r\\n\");\n                  buf.append(part.text);\n              } else if (part.numberSent) {\n                  buf.append(part.text);\n              } else {\n                  buf.append('{');\n                  buf.append(QByteArray::number(part.text.size()));\n                  buf.append(\"}\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n                  if (printThisCommand)\n                      qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n                  else\n                      qDebug() << m_parserId << \">>> [sensitive command] -- added literal\";\n  #endif\n                  socket->write(buf);\n                  part.numberSent = true;\n                  waitingForContinuation = true;\n                  Q_ASSERT(literalCommandTag.isEmpty());\n                  literalCommandTag = cmd.cmds.first().text;\n                  Q_ASSERT(!literalCommandTag.isEmpty());\n                  emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n                  return; // and wait for continuation request\n              }\n              break;\n          case Commands::IDLE_DONE:\n              Q_ASSERT(false); // is handled above\n              break;\n          case Commands::IDLE:\n              buf.append(\"IDLE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              idling = true;\n              waitForInitialIdle = true;\n              cmdQueue.pop_front();\n              emit lineSent(this, buf);\n              return;\n              break;\n          case Commands::STARTTLS:\n              startTlsCommand = buf;\n              buf.append(\"STARTTLS\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              startTlsInProgress = true;\n              emit lineSent(this, buf);\n              return;\n              break;\n          case Commands::COMPRESS_DEFLATE:\n              compressDeflateCommand = buf;\n              buf.append(\"COMPRESS DEFLATE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              compressDeflateInProgress = true;\n              cmdQueue.pop_front();\n              emit lineSent(this, buf);\n              return;\n              break;\n          }\n          if (cmd.currentPart == cmd.cmds.size() - 1) {\n              // finalize\n              buf.append(\"\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              if (printThisCommand)\n                  qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n              else\n                  qDebug() << m_parserId << \">>> [sensitive command]\";\n  #endif\n              socket->write(buf);\n              cmdQueue.pop_front();\n              emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n              break;\n          } else {\n              if (part.kind == Commands::ATOM_NO_SPACE_AROUND || cmd.cmds[cmd.currentPart + 1].kind == Commands::ATOM_NO_SPACE_AROUND) {\n                  // Skip the extra space if asked to do so\n              } else {\n                  buf.append(' ');\n              }\n              ++cmd.currentPart;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdQueue.isEmpty",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
  },
  {
    "function_name": "reallyReadLine(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "687-723",
    "snippet": "oid Parser::reallyReadLine()\n{\n    try {\n        currentLine += socket->readLine();\n        if (currentLine.endsWith(\"}\\r\\n\")) {\n            int offset = currentLine.lastIndexOf('{');\n            if (offset < oldLiteralPosition)\n                throw ParseError(\"Got unmatched '}'\", currentLine, currentLine.size() - 3);\n            bool ok;\n            int number = currentLine.mid(offset + 1, currentLine.size() - offset - 4).toInt(&ok);\n            if (!ok)\n                throw ParseError(\"Can't parse numeric literal size\", currentLine, offset);\n            if (number < 0)\n                throw ParseError(\"Negative literal size\", currentLine, offset);\n            oldLiteralPosition = offset;\n            readingMode = ReadingNumberOfBytes;\n            readingBytes = number;\n        } else if (currentLine.endsWith(\"\\r\\n\")) {\n            // it's complete\n            if (startTlsInProgress && currentLine.startsWith(startTlsCommand)) {\n                startTlsCommand.clear();\n                startTlsReply = currentLine;\n                currentLine.clear();\n                oldLiteralPosition = 0;\n                QTimer::singleShot(0, this, SLOT(finishStartTls()));\n                return;\n            }\n            processLine(currentLine);\n            currentLine.clear();\n            oldLiteralPosition = 0;\n        } else {\n            throw ParseError(\"Received line doesn't end with any of \\\"}\\\\r\\\\n\\\" and \\\"\\\\r\\\\n\\\"\", currentLine, 0);\n        }\n    } catch (ParserException &e) {\n        queueResponse(QSharedPointer<Responses::AbstractResponse>(new Responses::ParseErrorResponse(e)));\n    }\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueResponse(",
          "args": [
            "SharedPointer<Responses::AbstractResponse>(new Responses::ParseErrorResponse(e)))"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "queueResponse(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "613-636",
          "snippet": "oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n{\n    respQueue.push_back(resp);\n    // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n    if (respQueue.size() == 1) {\n        emit responseReceived(this);\n    }\n\n    if (waitingForContinuation) {\n        // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n        QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n        Q_ASSERT(!literalCommandTag.isEmpty());\n        if (stateResponse && stateResponse->tag == literalCommandTag) {\n            literalCommandTag.clear();\n            waitingForContinuation = false;\n            cmdQueue.pop_front();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n            if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                // FIXME: use parserWarning when it's adapted throughout the code\n                qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n            }\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n  {\n      respQueue.push_back(resp);\n      // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n      if (respQueue.size() == 1) {\n          emit responseReceived(this);\n      }\n  \n      if (waitingForContinuation) {\n          // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n          QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n          Q_ASSERT(!literalCommandTag.isEmpty());\n          if (stateResponse && stateResponse->tag == literalCommandTag) {\n              literalCommandTag.clear();\n              waitingForContinuation = false;\n              cmdQueue.pop_front();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n              if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                  // FIXME: use parserWarning when it's adapted throughout the code\n                  qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SharedPointer<Responses::AbstractResponse>",
          "args": [
            "ew Responses::ParseErrorResponse(e))"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Received line doesn't end with any of \\\"}\\\\r\\\\n\\\" and \\\"\\\\r\\\\n\\\"\",",
            "urrentLine,",
            ")"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.clear",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rocessLine(",
          "args": [
            "urrentLine)"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "processLine(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "924-953",
          "snippet": "oid Parser::processLine(QByteArray line)\n{\n#ifdef PRINT_TRAFFIC_RX\n    QByteArray debugLine = line.trimmed();\n    if (debugLine.size() > PRINT_TRAFFIC_RX)\n        qDebug() << m_parserId << \"<<<\" << debugLine.left(PRINT_TRAFFIC_RX) << \"...\";\n    else\n        qDebug() << m_parserId << \"<<<\" << debugLine;\n#endif\n    emit lineReceived(this, line);\n    if (m_expectsInitialGreeting && !line.startsWith(\"* \")) {\n        throw NotAnImapServerError(std::string(), line, -1);\n    } else if (line.startsWith(\"* \")) {\n        m_expectsInitialGreeting = false;\n        queueResponse(parseUntagged(line));\n    } else if (line.startsWith(\"+ \")) {\n        if (waitingForContinuation) {\n            waitingForContinuation = false;\n            literalCommandTag.clear();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n        } else if (waitForInitialIdle) {\n            waitForInitialIdle = false;\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n        } else {\n            throw ContinuationRequest(line.constData());\n        }\n    } else {\n        queueResponse(parseTagged(line));\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::processLine(QByteArray line)\n  {\n  #ifdef PRINT_TRAFFIC_RX\n      QByteArray debugLine = line.trimmed();\n      if (debugLine.size() > PRINT_TRAFFIC_RX)\n          qDebug() << m_parserId << \"<<<\" << debugLine.left(PRINT_TRAFFIC_RX) << \"...\";\n      else\n          qDebug() << m_parserId << \"<<<\" << debugLine;\n  #endif\n      emit lineReceived(this, line);\n      if (m_expectsInitialGreeting && !line.startsWith(\"* \")) {\n          throw NotAnImapServerError(std::string(), line, -1);\n      } else if (line.startsWith(\"* \")) {\n          m_expectsInitialGreeting = false;\n          queueResponse(parseUntagged(line));\n      } else if (line.startsWith(\"+ \")) {\n          if (waitingForContinuation) {\n              waitingForContinuation = false;\n              literalCommandTag.clear();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n          } else if (waitForInitialIdle) {\n              waitForInitialIdle = false;\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n          } else {\n              throw ContinuationRequest(line.constData());\n          }\n      } else {\n          queueResponse(parseTagged(line));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(finishStartTls()))"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "inishStartTls())"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inishStartTls(",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "finishStartTls(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "733-744",
          "snippet": "oid Parser::finishStartTls()\n{\n    emit lineSent(this, \"*** STARTTLS\");\n#ifdef PRINT_TRAFFIC_TX\n    qDebug() << m_parserId << \"*** STARTTLS\";\n#endif\n    cmdQueue.pop_front();\n    socket->startTls(); // warn: this might invoke event loop\n    startTlsInProgress = false;\n    waitingForEncryption = true;\n    processLine(startTlsReply);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::finishStartTls()\n  {\n      emit lineSent(this, \"*** STARTTLS\");\n  #ifdef PRINT_TRAFFIC_TX\n      qDebug() << m_parserId << \"*** STARTTLS\";\n  #endif\n      cmdQueue.pop_front();\n      socket->startTls(); // warn: this might invoke event loop\n      startTlsInProgress = false;\n      waitingForEncryption = true;\n      processLine(startTlsReply);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "urrentLine.startsWith",
          "args": [
            "tartTlsCommand)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.endsWith",
          "args": [
            "\\r\\n\")"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Negative literal size\",",
            "urrentLine,",
            "ffset)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Can't parse numeric literal size\",",
            "urrentLine,",
            "ffset)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.mid",
          "args": [
            "ok)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.mid",
          "args": [
            "ffset + 1,",
            "urrentLine.size() - offset - 4)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.size",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arseError(",
          "args": [
            "Got unmatched '}'\",",
            "urrentLine,",
            "urrentLine.size() - 3)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.size",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.lastIndexOf",
          "args": [
            "{')"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentLine.endsWith",
          "args": [
            "}\\r\\n\")"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket->readLine",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::reallyReadLine()\n  {\n      try {\n          currentLine += socket->readLine();\n          if (currentLine.endsWith(\"}\\r\\n\")) {\n              int offset = currentLine.lastIndexOf('{');\n              if (offset < oldLiteralPosition)\n                  throw ParseError(\"Got unmatched '}'\", currentLine, currentLine.size() - 3);\n              bool ok;\n              int number = currentLine.mid(offset + 1, currentLine.size() - offset - 4).toInt(&ok);\n              if (!ok)\n                  throw ParseError(\"Can't parse numeric literal size\", currentLine, offset);\n              if (number < 0)\n                  throw ParseError(\"Negative literal size\", currentLine, offset);\n              oldLiteralPosition = offset;\n              readingMode = ReadingNumberOfBytes;\n              readingBytes = number;\n          } else if (currentLine.endsWith(\"\\r\\n\")) {\n              // it's complete\n              if (startTlsInProgress && currentLine.startsWith(startTlsCommand)) {\n                  startTlsCommand.clear();\n                  startTlsReply = currentLine;\n                  currentLine.clear();\n                  oldLiteralPosition = 0;\n                  QTimer::singleShot(0, this, SLOT(finishStartTls()));\n                  return;\n              }\n              processLine(currentLine);\n              currentLine.clear();\n              oldLiteralPosition = 0;\n          } else {\n              throw ParseError(\"Received line doesn't end with any of \\\"}\\\\r\\\\n\\\" and \\\"\\\\r\\\\n\\\"\", currentLine, 0);\n          }\n      } catch (ParserException &e) {\n          queueResponse(QSharedPointer<Responses::AbstractResponse>(new Responses::ParseErrorResponse(e)));\n      }\n  }\n}"
  },
  {
    "function_name": "handleReadyRead(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "658-685",
    "snippet": "oid Parser::handleReadyRead()\n{\n    while (!waitingForEncryption && !waitingForSslPolicy) {\n        switch (readingMode) {\n        case ReadingLine:\n            if (socket->canReadLine()) {\n                reallyReadLine();\n            } else {\n                // Not enough data yet, let's try again later\n                return;\n            }\n            break;\n        case ReadingNumberOfBytes:\n        {\n            QByteArray buf = socket->read(readingBytes);\n            readingBytes -= buf.size();\n            currentLine += buf;\n            if (readingBytes == 0) {\n                // we've read the literal\n                readingMode = ReadingLine;\n            } else {\n                return;\n            }\n        }\n        break;\n        }\n    }\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uf.size",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket->read",
          "args": [
            "eadingBytes)"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "readLine(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "95-98",
          "snippet": "ByteArray FakeSocket::readLine(qint64 maxSize)\n{\n    return readChannel->readLine(maxSize);\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ByteArray FakeSocket::readLine(qint64 maxSize)\n  {\n      return readChannel->readLine(maxSize);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eallyReadLine(",
          "args": [],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "reallyReadLine(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "687-723",
          "snippet": "oid Parser::reallyReadLine()\n{\n    try {\n        currentLine += socket->readLine();\n        if (currentLine.endsWith(\"}\\r\\n\")) {\n            int offset = currentLine.lastIndexOf('{');\n            if (offset < oldLiteralPosition)\n                throw ParseError(\"Got unmatched '}'\", currentLine, currentLine.size() - 3);\n            bool ok;\n            int number = currentLine.mid(offset + 1, currentLine.size() - offset - 4).toInt(&ok);\n            if (!ok)\n                throw ParseError(\"Can't parse numeric literal size\", currentLine, offset);\n            if (number < 0)\n                throw ParseError(\"Negative literal size\", currentLine, offset);\n            oldLiteralPosition = offset;\n            readingMode = ReadingNumberOfBytes;\n            readingBytes = number;\n        } else if (currentLine.endsWith(\"\\r\\n\")) {\n            // it's complete\n            if (startTlsInProgress && currentLine.startsWith(startTlsCommand)) {\n                startTlsCommand.clear();\n                startTlsReply = currentLine;\n                currentLine.clear();\n                oldLiteralPosition = 0;\n                QTimer::singleShot(0, this, SLOT(finishStartTls()));\n                return;\n            }\n            processLine(currentLine);\n            currentLine.clear();\n            oldLiteralPosition = 0;\n        } else {\n            throw ParseError(\"Received line doesn't end with any of \\\"}\\\\r\\\\n\\\" and \\\"\\\\r\\\\n\\\"\", currentLine, 0);\n        }\n    } catch (ParserException &e) {\n        queueResponse(QSharedPointer<Responses::AbstractResponse>(new Responses::ParseErrorResponse(e)));\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::reallyReadLine()\n  {\n      try {\n          currentLine += socket->readLine();\n          if (currentLine.endsWith(\"}\\r\\n\")) {\n              int offset = currentLine.lastIndexOf('{');\n              if (offset < oldLiteralPosition)\n                  throw ParseError(\"Got unmatched '}'\", currentLine, currentLine.size() - 3);\n              bool ok;\n              int number = currentLine.mid(offset + 1, currentLine.size() - offset - 4).toInt(&ok);\n              if (!ok)\n                  throw ParseError(\"Can't parse numeric literal size\", currentLine, offset);\n              if (number < 0)\n                  throw ParseError(\"Negative literal size\", currentLine, offset);\n              oldLiteralPosition = offset;\n              readingMode = ReadingNumberOfBytes;\n              readingBytes = number;\n          } else if (currentLine.endsWith(\"\\r\\n\")) {\n              // it's complete\n              if (startTlsInProgress && currentLine.startsWith(startTlsCommand)) {\n                  startTlsCommand.clear();\n                  startTlsReply = currentLine;\n                  currentLine.clear();\n                  oldLiteralPosition = 0;\n                  QTimer::singleShot(0, this, SLOT(finishStartTls()));\n                  return;\n              }\n              processLine(currentLine);\n              currentLine.clear();\n              oldLiteralPosition = 0;\n          } else {\n              throw ParseError(\"Received line doesn't end with any of \\\"}\\\\r\\\\n\\\" and \\\"\\\\r\\\\n\\\"\", currentLine, 0);\n          }\n      } catch (ParserException &e) {\n          queueResponse(QSharedPointer<Responses::AbstractResponse>(new Responses::ParseErrorResponse(e)));\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocket->canReadLine",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "canReadLine(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "85-88",
          "snippet": "ool FakeSocket::canReadLine()\n{\n    return readChannel->canReadLine();\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ool FakeSocket::canReadLine()\n  {\n      return readChannel->canReadLine();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleReadyRead()\n  {\n      while (!waitingForEncryption && !waitingForSslPolicy) {\n          switch (readingMode) {\n          case ReadingLine:\n              if (socket->canReadLine()) {\n                  reallyReadLine();\n              } else {\n                  // Not enough data yet, let's try again later\n                  return;\n              }\n              break;\n          case ReadingNumberOfBytes:\n          {\n              QByteArray buf = socket->read(readingBytes);\n              readingBytes -= buf.size();\n              currentLine += buf;\n              if (readingBytes == 0) {\n                  // we've read the literal\n                  readingMode = ReadingLine;\n              } else {\n                  return;\n              }\n          }\n          break;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "generateTag(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "653-656",
    "snippet": "ByteArray Parser::generateTag()\n{\n    return QString::fromUtf8(\"y%1\").arg(m_lastTagUsed++).toUtf8();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "_lastTagUsed++)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "y%1\")"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ByteArray Parser::generateTag()\n  {\n      return QString::fromUtf8(\"y%1\").arg(m_lastTagUsed++).toUtf8();\n  }\n}"
  },
  {
    "function_name": "getResponse(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "643-651",
    "snippet": "SharedPointer<Responses::AbstractResponse> Parser::getResponse()\n{\n    QSharedPointer<Responses::AbstractResponse> ptr;\n    if (respQueue.empty())\n        return ptr;\n    ptr = respQueue.front();\n    respQueue.pop_front();\n    return ptr;\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "espQueue.pop_front",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "espQueue.front",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "espQueue.empty",
          "args": [],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "TagListWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/TagListWidget.cpp",
          "lines": "68-72",
          "snippet": "void TagListWidget::empty()\n{\n    qDeleteAll(children.begin(), children.end());\n    children.clear();\n}",
          "includes": [
            "#include \"TagWidget.h\"",
            "#include \"FlowLayout.h\"",
            "#include \"TagListWidget.h\"",
            "#include <QPushButton>",
            "#include <QMessageBox>",
            "#include <QLabel>",
            "#include <QInputDialog>",
            "#include <QHBoxLayout>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"TagWidget.h\"\n#include \"FlowLayout.h\"\n#include \"TagListWidget.h\"\n#include <QPushButton>\n#include <QMessageBox>\n#include <QLabel>\n#include <QInputDialog>\n#include <QHBoxLayout>\n\nTagListWidget {\n  void TagListWidget::empty()\n  {\n      qDeleteAll(children.begin(), children.end());\n      children.clear();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  SharedPointer<Responses::AbstractResponse> Parser::getResponse()\n  {\n      QSharedPointer<Responses::AbstractResponse> ptr;\n      if (respQueue.empty())\n          return ptr;\n      ptr = respQueue.front();\n      respQueue.pop_front();\n      return ptr;\n  }\n}"
  },
  {
    "function_name": "hasResponse(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "638-641",
    "snippet": "ool Parser::hasResponse() const\n{\n    return ! respQueue.empty();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "espQueue.empty",
          "args": [],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "TagListWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/TagListWidget.cpp",
          "lines": "68-72",
          "snippet": "void TagListWidget::empty()\n{\n    qDeleteAll(children.begin(), children.end());\n    children.clear();\n}",
          "includes": [
            "#include \"TagWidget.h\"",
            "#include \"FlowLayout.h\"",
            "#include \"TagListWidget.h\"",
            "#include <QPushButton>",
            "#include <QMessageBox>",
            "#include <QLabel>",
            "#include <QInputDialog>",
            "#include <QHBoxLayout>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"TagWidget.h\"\n#include \"FlowLayout.h\"\n#include \"TagListWidget.h\"\n#include <QPushButton>\n#include <QMessageBox>\n#include <QLabel>\n#include <QInputDialog>\n#include <QHBoxLayout>\n\nTagListWidget {\n  void TagListWidget::empty()\n  {\n      qDeleteAll(children.begin(), children.end());\n      children.clear();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ool Parser::hasResponse() const\n  {\n      return ! respQueue.empty();\n  }\n}"
  },
  {
    "function_name": "queueResponse(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "613-636",
    "snippet": "oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n{\n    respQueue.push_back(resp);\n    // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n    if (respQueue.size() == 1) {\n        emit responseReceived(this);\n    }\n\n    if (waitingForContinuation) {\n        // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n        QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n        Q_ASSERT(!literalCommandTag.isEmpty());\n        if (stateResponse && stateResponse->tag == literalCommandTag) {\n            literalCommandTag.clear();\n            waitingForContinuation = false;\n            cmdQueue.pop_front();\n            QTimer::singleShot(0, this, SLOT(executeCommands()));\n            if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                // FIXME: use parserWarning when it's adapted throughout the code\n                qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n            }\n        }\n    }\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Debug(",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdQueue.pop_front",
          "args": [],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iteralCommandTag.clear",
          "args": [],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "literalCommandTag.isEmpty())"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iteralCommandTag.isEmpty",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp.dynamicCast<Responses::State>",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "espQueue.size",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "espQueue.push_back",
          "args": [
            "esp)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::queueResponse(const QSharedPointer<Responses::AbstractResponse> &resp)\n  {\n      respQueue.push_back(resp);\n      // Try to limit the signal rate -- when there are multiple items in the queue, there's no point in sending more signals\n      if (respQueue.size() == 1) {\n          emit responseReceived(this);\n      }\n  \n      if (waitingForContinuation) {\n          // Check whether this is the server's way of informing us that the continuation request is not going to arrive\n          QSharedPointer<Responses::State> stateResponse = resp.dynamicCast<Responses::State>();\n          Q_ASSERT(!literalCommandTag.isEmpty());\n          if (stateResponse && stateResponse->tag == literalCommandTag) {\n              literalCommandTag.clear();\n              waitingForContinuation = false;\n              cmdQueue.pop_front();\n              QTimer::singleShot(0, this, SLOT(executeCommands()));\n              if (stateResponse->kind != Responses::NO && stateResponse->kind != Responses::BAD) {\n                  // FIXME: use parserWarning when it's adapted throughout the code\n                  qDebug() << \"Synchronized literal rejected but response is neither NO nor BAD\";\n              }\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "queueCommand(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "604-611",
    "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdQueue.append",
          "args": [
            "ommand)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommand.addTag",
          "args": [
            "ag)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enerateTag(",
          "args": [],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "generateTag(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "653-656",
          "snippet": "ByteArray Parser::generateTag()\n{\n    return QString::fromUtf8(\"y%1\").arg(m_lastTagUsed++).toUtf8();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ByteArray Parser::generateTag()\n  {\n      return QString::fromUtf8(\"y%1\").arg(m_lastTagUsed++).toUtf8();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
  },
  {
    "function_name": "uidSendmail(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "573-602",
    "snippet": "ommandHandle Parser::uidSendmail(const uint uid, const Mailbox::UidSubmitOptionsList &submissionOptions)\n{\n    Commands::Command cmd(\"UID SENDMAIL\");\n    cmd << Commands::PartOfCommand(QByteArray::number(uid));\n    if (!submissionOptions.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n        for (Mailbox::UidSubmitOptionsList::const_iterator it = submissionOptions.begin(); it != submissionOptions.end(); ++it) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, it->first);\n            switch (it->second.type()) {\n            case QVariant::ByteArray:\n                cmd << Commands::PartOfCommand(it->second.toByteArray());\n                break;\n            case QVariant::List:\n                cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n                Q_FOREACH(const QVariant &item, it->second.toList()) {\n                    cmd << Commands::PartOfCommand(Commands::ATOM, item.toByteArray());\n                }\n                cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n                break;\n            case QVariant::Invalid:\n                cmd << Commands::PartOfCommand(Commands::ATOM, \"NIL\");\n                break;\n            default:\n                throw InvalidArgument(\"Internal error: Malformed data for the UID SEND command.\");\n            }\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvalidArgument(",
          "args": [
            "Internal error: Malformed data for the UID SEND command.\")"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "NIL\")"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "tem.toByteArray())"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem.toByteArray",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_FOREACH(",
          "args": [
            "onst Variant &item,",
            "t->second.toList())"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "_FOREACH(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/PartWidget.cpp",
          "lines": "209-216",
          "snippet": "_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"PartWidgetFactory.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"LoadablePartWidget.h\"\n#",
            "include \"EnvelopeView.h\"\n#",
            "include <QTabBar>",
            "include <QVBoxLayout>\n#",
            "include <QModelIndex>\n#",
            "include <QLabel>\n#",
            "include \"PartWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"PartWidgetFactory.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"LoadablePartWidget.h\"\n#\ninclude \"EnvelopeView.h\"\n#\ninclude <QTabBar>\ninclude <QVBoxLayout>\n#\ninclude <QModelIndex>\n#\ninclude <QLabel>\n#\ninclude \"PartWidget.h\"\n\n_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\"
        }
      },
      {
        "call_info": {
          "callee": "t->second.toList",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "t->second.toByteArray())"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->second.toByteArray",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->second.type",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "328-331",
          "snippet": "QMimeMagicRule::Type QMimeMagicRule::type() const\n{\n    return d->type;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type() const\n  {\n      return d->type;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "t->first)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubmissionOptions.end",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubmissionOptions.begin",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubmissionOptions.isEmpty",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ByteArray::number(uid))"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "id)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSendmail(const uint uid, const Mailbox::UidSubmitOptionsList &submissionOptions)\n  {\n      Commands::Command cmd(\"UID SENDMAIL\");\n      cmd << Commands::PartOfCommand(QByteArray::number(uid));\n      if (!submissionOptions.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n          for (Mailbox::UidSubmitOptionsList::const_iterator it = submissionOptions.begin(); it != submissionOptions.end(); ++it) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, it->first);\n              switch (it->second.type()) {\n              case QVariant::ByteArray:\n                  cmd << Commands::PartOfCommand(it->second.toByteArray());\n                  break;\n              case QVariant::List:\n                  cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n                  Q_FOREACH(const QVariant &item, it->second.toList()) {\n                      cmd << Commands::PartOfCommand(Commands::ATOM, item.toByteArray());\n                  }\n                  cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n                  break;\n              case QVariant::Invalid:\n                  cmd << Commands::PartOfCommand(Commands::ATOM, \"NIL\");\n                  break;\n              default:\n                  throw InvalidArgument(\"Internal error: Malformed data for the UID SEND command.\");\n              }\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "genUrlAuth(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "565-571",
    "snippet": "ommandHandle Parser::genUrlAuth(const QByteArray &url, const QByteArray mechanism)\n{\n    Commands::Command cmd(\"GENURLAUTH\");\n    cmd << Commands::PartOfCommand(Commands::QUOTED_STRING, url);\n    cmd << Commands::PartOfCommand(Commands::ATOM, mechanism);\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "echanism)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::QUOTED_STRING,",
            "rl)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::genUrlAuth(const QByteArray &url, const QByteArray mechanism)\n  {\n      Commands::Command cmd(\"GENURLAUTH\");\n      cmd << Commands::PartOfCommand(Commands::QUOTED_STRING, url);\n      cmd << Commands::PartOfCommand(Commands::ATOM, mechanism);\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "enable(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "556-563",
    "snippet": "ommandHandle Parser::enable(const QList<QByteArray> &extensions)\n{\n    Commands::Command cmd(\"ENABLE\");\n    Q_FOREACH(const QByteArray &item, extensions) {\n        cmd << Commands::PartOfCommand(Commands::ATOM, item);\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "tem)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::enable(const QList<QByteArray> &extensions)\n  {\n      Commands::Command cmd(\"ENABLE\");\n      Q_FOREACH(const QByteArray &item, extensions) {\n          cmd << Commands::PartOfCommand(Commands::ATOM, item);\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "idCommand(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "545-554",
    "snippet": "ommandHandle Parser::idCommand(const QMap<QByteArray,QByteArray> &args)\n{\n    Commands::Command cmd(\"ID \");\n    cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \"(\");\n    for (QMap<QByteArray,QByteArray>::const_iterator it = args.constBegin(); it != args.constEnd(); ++it) {\n        cmd << Commands::PartOfCommand(Commands::QUOTED_STRING, it.key()) << Commands::PartOfCommand(Commands::QUOTED_STRING, it.value());\n    }\n    cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::QUOTED_STRING,",
            "t.value())"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.value",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::QUOTED_STRING,",
            "t.key())"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.constEnd",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rgs.constBegin",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::idCommand(const QMap<QByteArray,QByteArray> &args)\n  {\n      Commands::Command cmd(\"ID \");\n      cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \"(\");\n      for (QMap<QByteArray,QByteArray>::const_iterator it = args.constBegin(); it != args.constEnd(); ++it) {\n          cmd << Commands::PartOfCommand(Commands::QUOTED_STRING, it.key()) << Commands::PartOfCommand(Commands::QUOTED_STRING, it.value());\n      }\n      cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "idCommand(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "540-543",
    "snippet": "ommandHandle Parser::idCommand()\n{\n    return queueCommand(Commands::Command(\"ID NIL\"));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"ID NIL\"))"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "ID NIL\")"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::idCommand()\n  {\n      return queueCommand(Commands::Command(\"ID NIL\"));\n  }\n}"
  },
  {
    "function_name": "namespaceCommand(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "535-538",
    "snippet": "ommandHandle Parser::namespaceCommand()\n{\n    return queueCommand(Commands::ATOM, \"NAMESPACE\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "NAMESPACE\")"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::namespaceCommand()\n  {\n      return queueCommand(Commands::ATOM, \"NAMESPACE\");\n  }\n}"
  },
  {
    "function_name": "idleMagicallyTerminatedByServer(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "528-533",
    "snippet": "oid Parser::idleMagicallyTerminatedByServer()\n{\n    Q_ASSERT(! waitForInitialIdle);\n    Q_ASSERT(idling);\n    idling = false;\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "dling)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "waitForInitialIdle)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::idleMagicallyTerminatedByServer()\n  {\n      Q_ASSERT(! waitForInitialIdle);\n      Q_ASSERT(idling);\n      idling = false;\n  }\n}"
  },
  {
    "function_name": "idleContinuationWontCome(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "520-526",
    "snippet": "oid Parser::idleContinuationWontCome()\n{\n    Q_ASSERT(waitForInitialIdle);\n    waitForInitialIdle = false;\n    idling = false;\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "aitForInitialIdle)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::idleContinuationWontCome()\n  {\n      Q_ASSERT(waitForInitialIdle);\n      waitForInitialIdle = false;\n      idling = false;\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n  }\n}"
  },
  {
    "function_name": "idleDone(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "510-518",
    "snippet": "oid Parser::idleDone()\n{\n    // This is not a new \"command\", so we don't go via queueCommand()\n    // which would allocate a new tag for us, but submit directly\n    Commands::Command cmd;\n    cmd << Commands::PartOfCommand(Commands::IDLE_DONE, \"DONE\");\n    cmdQueue.append(cmd);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(executeCommands()))"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "xecuteCommands())"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xecuteCommands(",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "executeCommands(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "725-731",
          "snippet": "oid Parser::executeCommands()\n{\n    while (! waitingForContinuation && ! waitForInitialIdle &&\n           ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n           ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n        executeACommand();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeCommands()\n  {\n      while (! waitingForContinuation && ! waitForInitialIdle &&\n             ! waitingForConnection && ! waitingForEncryption && ! waitingForSslPolicy &&\n             ! cmdQueue.isEmpty() && ! startTlsInProgress && !compressDeflateInProgress)\n          executeACommand();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdQueue.append",
          "args": [
            "md)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::IDLE_DONE,",
            "DONE\")"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::idleDone()\n  {\n      // This is not a new \"command\", so we don't go via queueCommand()\n      // which would allocate a new tag for us, but submit directly\n      Commands::Command cmd;\n      cmd << Commands::PartOfCommand(Commands::IDLE_DONE, \"DONE\");\n      cmdQueue.append(cmd);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n  }\n}"
  },
  {
    "function_name": "idle(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "505-508",
    "snippet": "ommandHandle Parser::idle()\n{\n    return queueCommand(Commands::IDLE, \"IDLE\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::IDLE,",
            "IDLE\")"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::idle()\n  {\n      return queueCommand(Commands::IDLE, \"IDLE\");\n  }\n}"
  },
  {
    "function_name": "unSelect(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "500-503",
    "snippet": "ommandHandle Parser::unSelect()\n{\n    return queueCommand(Commands::ATOM, \"UNSELECT\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "UNSELECT\")"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::unSelect()\n  {\n      return queueCommand(Commands::ATOM, \"UNSELECT\");\n  }\n}"
  },
  {
    "function_name": "xAtom(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "495-498",
    "snippet": "ommandHandle Parser::xAtom(const Commands::Command &cmd)\n{\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::xAtom(const Commands::Command &cmd)\n  {\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "uidExpunge(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "489-493",
    "snippet": "ommandHandle Parser::uidExpunge(const Sequence &seq)\n{\n    return queueCommand(Commands::Command(\"UID EXPUNGE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"UID EXPUNGE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()))"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "UID EXPUNGE\")"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidExpunge(const Sequence &seq)\n  {\n      return queueCommand(Commands::Command(\"UID EXPUNGE\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()));\n  }\n}"
  },
  {
    "function_name": "uidMove(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "482-487",
    "snippet": "ommandHandle Parser::uidMove(const Sequence &seq, const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"UID MOVE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"UID MOVE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        encodeImapFolderName(mailbox))"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "UID MOVE\")"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidMove(const Sequence &seq, const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"UID MOVE\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "uidCopy(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "475-480",
    "snippet": "ommandHandle Parser::uidCopy(const Sequence &seq, const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"UID COPY\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"UID COPY\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        encodeImapFolderName(mailbox))"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "UID COPY\")"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidCopy(const Sequence &seq, const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"UID COPY\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "uidStore(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "467-473",
    "snippet": "ommandHandle Parser::uidStore(const Sequence &seq, const QString &item, const QString &value)\n{\n    return queueCommand(Commands::Command(\"UID STORE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, item.toUtf8()) <<\n                        Commands::PartOfCommand(Commands::ATOM, value.toUtf8()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"UID STORE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, item.toUtf8()) <<\n                        Commands::PartOfCommand(Commands::ATOM, value.toUtf8()))"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "alue.toUtf8())"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.toUtf8",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "tem.toUtf8())"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem.toUtf8",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "UID STORE\")"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidStore(const Sequence &seq, const QString &item, const QString &value)\n  {\n      return queueCommand(Commands::Command(\"UID STORE\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, item.toUtf8()) <<\n                          Commands::PartOfCommand(Commands::ATOM, value.toUtf8()));\n  }\n}"
  },
  {
    "function_name": "uidFetch(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "460-465",
    "snippet": "ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n{\n    return queueCommand(Commands::Command(\"UID FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"UID FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'))"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "(' + items.join(QLatin1String(\" \")).toUtf8() + ')')"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.join",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "UID FETCH\")"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n  {\n      return queueCommand(Commands::Command(\"UID FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n  }\n}"
  },
  {
    "function_name": "copy(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "453-458",
    "snippet": "ommandHandle Parser::copy(const Sequence &seq, const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"COPY\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"COPY\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        encodeImapFolderName(mailbox))"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "COPY\")"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::copy(const Sequence &seq, const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"COPY\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "store(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "444-451",
    "snippet": "ommandHandle Parser::store(const Sequence &seq, const QString &item, const QString &value)\n{\n    return queueCommand(Commands::Command(\"STORE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, item.toUtf8()) <<\n                        Commands::PartOfCommand(Commands::ATOM, value.toUtf8())\n                       );\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"STORE\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, item.toUtf8()) <<\n                        Commands::PartOfCommand(Commands::ATOM, value.toUtf8())"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "alue.toUtf8())"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alue.toUtf8",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "tem.toUtf8())"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem.toUtf8",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "STORE\")"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::store(const Sequence &seq, const QString &item, const QString &value)\n  {\n      return queueCommand(Commands::Command(\"STORE\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, item.toUtf8()) <<\n                          Commands::PartOfCommand(Commands::ATOM, value.toUtf8())\n                         );\n  }\n}"
  },
  {
    "function_name": "fetch(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "428-442",
    "snippet": "ommandHandle Parser::fetch(const Sequence &seq, const QStringList &items, const QMap<QByteArray, quint64> &uint64Modifiers)\n{\n    Commands::Command cmd = Commands::Command(\"FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')');\n    if (!uint64Modifiers.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n        for (QMap<QByteArray, quint64>::const_iterator it = uint64Modifiers.constBegin(); it != uint64Modifiers.constEnd(); ++it) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, it.key()) <<\n                   Commands::PartOfCommand(Commands::ATOM, QByteArray::number(it.value()));\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "ByteArray::number(it.value()))"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "t.value())"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.value",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "t.key())"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64Modifiers.constEnd",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64Modifiers.constBegin",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int64Modifiers.isEmpty",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "(' + items.join(QLatin1String(\" \")).toUtf8() + ')')"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.join",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tems.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "eq.toByteArray())"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eq.toByteArray",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "FETCH\")"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::fetch(const Sequence &seq, const QStringList &items, const QMap<QByteArray, quint64> &uint64Modifiers)\n  {\n      Commands::Command cmd = Commands::Command(\"FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')');\n      if (!uint64Modifiers.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n          for (QMap<QByteArray, quint64>::const_iterator it = uint64Modifiers.constBegin(); it != uint64Modifiers.constEnd(); ++it) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, it.key()) <<\n                     Commands::PartOfCommand(Commands::ATOM, QByteArray::number(it.value()));\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "uidEThread(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "421-426",
    "snippet": "ommandHandle Parser::uidEThread(const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria,\n                                 const QStringList &returnOptions)\n{\n    return threadHelper(\"UID THREAD RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                        algo, charset, searchCriteria);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hreadHelper(",
          "args": [
            "UID THREAD RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",",
            "lgo,",
            "harset,",
            "earchCriteria)"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "threadHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "397-409",
          "snippet": "ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n\n    for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n        // FIXME: this is another place which needs proper structure for this searching stuff...\n        cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n  \n      for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n          // FIXME: this is another place which needs proper structure for this searching stuff...\n          cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eturnOptions.join",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturnOptions.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidEThread(const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria,\n                                   const QStringList &returnOptions)\n  {\n      return threadHelper(\"UID THREAD RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                          algo, charset, searchCriteria);\n  }\n}"
  },
  {
    "function_name": "uidThread(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "416-419",
    "snippet": "ommandHandle Parser::uidThread(const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return threadHelper(\"UID THREAD\", algo, charset, searchCriteria);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hreadHelper(",
          "args": [
            "UID THREAD\",",
            "lgo,",
            "harset,",
            "earchCriteria)"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "threadHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "397-409",
          "snippet": "ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n\n    for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n        // FIXME: this is another place which needs proper structure for this searching stuff...\n        cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n  \n      for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n          // FIXME: this is another place which needs proper structure for this searching stuff...\n          cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidThread(const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return threadHelper(\"UID THREAD\", algo, charset, searchCriteria);\n  }\n}"
  },
  {
    "function_name": "thread(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "411-414",
    "snippet": "ommandHandle Parser::thread(const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return threadHelper(\"THREAD\", algo, charset, searchCriteria);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hreadHelper(",
          "args": [
            "THREAD\",",
            "lgo,",
            "harset,",
            "earchCriteria)"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "threadHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "397-409",
          "snippet": "ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n\n    for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n        // FIXME: this is another place which needs proper structure for this searching stuff...\n        cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n  \n      for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n          // FIXME: this is another place which needs proper structure for this searching stuff...\n          cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::thread(const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return threadHelper(\"THREAD\", algo, charset, searchCriteria);\n  }\n}"
  },
  {
    "function_name": "threadHelper(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "397-409",
    "snippet": "ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n\n    for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n        // FIXME: this is another place which needs proper structure for this searching stuff...\n        cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n    }\n\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "t->toUtf8())"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->toUtf8",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.end",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.begin",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "ommand)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::threadHelper(const QByteArray &command, const QByteArray &algo, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) << algo << charset;\n  \n      for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it) {\n          // FIXME: this is another place which needs proper structure for this searching stuff...\n          cmd << Commands::PartOfCommand(Commands::ATOM, it->toUtf8());\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "cancelUpdate(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "390-395",
    "snippet": "ommandHandle Parser::cancelUpdate(const CommandHandle &tag)\n{\n    Commands::Command command(\"CANCELUPDATE\");\n    command << Commands::PartOfCommand(Commands::QUOTED_STRING, tag);\n    return queueCommand(command);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommand)"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::QUOTED_STRING,",
            "ag)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::cancelUpdate(const CommandHandle &tag)\n  {\n      Commands::Command command(\"CANCELUPDATE\");\n      command << Commands::PartOfCommand(Commands::QUOTED_STRING, tag);\n      return queueCommand(command);\n  }\n}"
  },
  {
    "function_name": "uidESearch(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "384-388",
    "snippet": "ommandHandle Parser::uidESearch(const QByteArray &charset, const QStringList &searchCriteria, const QStringList &returnOptions)\n{\n    return searchHelper(\"UID SEARCH RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                        searchCriteria, charset);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "earchHelper(",
          "args": [
            "UID SEARCH RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",",
            "earchCriteria,",
            "harset)"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "searchHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "311-330",
          "snippet": "ommandHandle Parser::searchHelper(const QByteArray &command, const QStringList &criteria, const QByteArray &charset)\n{\n    Commands::Command cmd(command);\n\n    if (!charset.isEmpty())\n        cmd << \"CHARSET\" << charset;\n\n    // FIXME: we don't really support anything else but utf-8 here\n\n    if (criteria.size() == 1) {\n        // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n        // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n        cmd << Commands::PartOfCommand(Commands::ATOM, criteria.front().toUtf8());\n    } else {\n        for (QStringList::const_iterator it = criteria.begin(); it != criteria.end(); ++it)\n            cmd << it->toUtf8();\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::searchHelper(const QByteArray &command, const QStringList &criteria, const QByteArray &charset)\n  {\n      Commands::Command cmd(command);\n  \n      if (!charset.isEmpty())\n          cmd << \"CHARSET\" << charset;\n  \n      // FIXME: we don't really support anything else but utf-8 here\n  \n      if (criteria.size() == 1) {\n          // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n          // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n          cmd << Commands::PartOfCommand(Commands::ATOM, criteria.front().toUtf8());\n      } else {\n          for (QStringList::const_iterator it = criteria.begin(); it != criteria.end(); ++it)\n              cmd << it->toUtf8();\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eturnOptions.join",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturnOptions.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidESearch(const QByteArray &charset, const QStringList &searchCriteria, const QStringList &returnOptions)\n  {\n      return searchHelper(\"UID SEARCH RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                          searchCriteria, charset);\n  }\n}"
  },
  {
    "function_name": "uidESort(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "377-382",
    "snippet": "ommandHandle Parser::uidESort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria,\n                               const QStringList &returnOptions)\n{\n    return sortHelper(\"UID SORT RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                      sortCriteria, charset, searchCriteria);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ortHelper(",
          "args": [
            "UID SORT RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",",
            "ortCriteria,",
            "harset,",
            "earchCriteria)"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "sortHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "346-365",
          "snippet": "ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Q_ASSERT(! sortCriteria.isEmpty());\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n        Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n        charset;\n\n    if (searchCriteria.size() == 1) {\n        // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n        // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n        cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n    } else {\n        for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n            cmd << it->toUtf8();\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Q_ASSERT(! sortCriteria.isEmpty());\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n          Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n          charset;\n  \n      if (searchCriteria.size() == 1) {\n          // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n          // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n          cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n      } else {\n          for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n              cmd << it->toUtf8();\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eturnOptions.join",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturnOptions.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidESort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria,\n                                 const QStringList &returnOptions)\n  {\n      return sortHelper(\"UID SORT RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                        sortCriteria, charset, searchCriteria);\n  }\n}"
  },
  {
    "function_name": "uidSort(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "372-375",
    "snippet": "ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ortHelper(",
          "args": [
            "UID SORT\",",
            "ortCriteria,",
            "harset,",
            "earchCriteria)"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sortHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "346-365",
          "snippet": "ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Q_ASSERT(! sortCriteria.isEmpty());\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n        Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n        charset;\n\n    if (searchCriteria.size() == 1) {\n        // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n        // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n        cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n    } else {\n        for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n            cmd << it->toUtf8();\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Q_ASSERT(! sortCriteria.isEmpty());\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n          Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n          charset;\n  \n      if (searchCriteria.size() == 1) {\n          // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n          // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n          cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n      } else {\n          for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n              cmd << it->toUtf8();\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n  }\n}"
  },
  {
    "function_name": "sort(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "367-370",
    "snippet": "ommandHandle Parser::sort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return sortHelper(\"SORT\", sortCriteria, charset, searchCriteria);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ortHelper(",
          "args": [
            "SORT\",",
            "ortCriteria,",
            "harset,",
            "earchCriteria)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "sortHelper(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "346-365",
          "snippet": "ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Q_ASSERT(! sortCriteria.isEmpty());\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n        Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n        charset;\n\n    if (searchCriteria.size() == 1) {\n        // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n        // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n        cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n    } else {\n        for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n            cmd << it->toUtf8();\n    }\n\n    return queueCommand(cmd);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Q_ASSERT(! sortCriteria.isEmpty());\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n          Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n          charset;\n  \n      if (searchCriteria.size() == 1) {\n          // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n          // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n          cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n      } else {\n          for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n              cmd << it->toUtf8();\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::sort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return sortHelper(\"SORT\", sortCriteria, charset, searchCriteria);\n  }\n}"
  },
  {
    "function_name": "sortHelper(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "346-365",
    "snippet": "ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    Q_ASSERT(! sortCriteria.isEmpty());\n    Commands::Command cmd;\n\n    cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n        Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n        charset;\n\n    if (searchCriteria.size() == 1) {\n        // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n        // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n        cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n    } else {\n        for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n            cmd << it->toUtf8();\n    }\n\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->toUtf8",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.end",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.begin",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "earchCriteria.front().toUtf8())"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.front",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.front",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchCriteria.size",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortCriteria.join",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortCriteria.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "ommand)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sortCriteria.isEmpty())"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortCriteria.isEmpty",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::sortHelper(const QByteArray &command, const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      Q_ASSERT(! sortCriteria.isEmpty());\n      Commands::Command cmd;\n  \n      cmd << Commands::PartOfCommand(Commands::ATOM, command) <<\n          Commands::PartOfCommand(Commands::ATOM, \"(\" + sortCriteria.join(QLatin1String(\" \")).toUtf8() + \")\" ) <<\n          charset;\n  \n      if (searchCriteria.size() == 1) {\n          // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n          // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n          cmd << Commands::PartOfCommand(Commands::ATOM, searchCriteria.front().toUtf8());\n      } else {\n          for (QStringList::const_iterator it = searchCriteria.begin(); it != searchCriteria.end(); ++it)\n              cmd << it->toUtf8();\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "uidESearchUid(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "339-344",
    "snippet": "ommandHandle Parser::uidESearchUid(const QByteArray &sequence)\n{\n    Commands::Command command(\"UID SEARCH RETURN (ALL)\");\n    command << Commands::PartOfCommand(Commands::ATOM, sequence);\n    return queueCommand(command);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommand)"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "equence)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidESearchUid(const QByteArray &sequence)\n  {\n      Commands::Command command(\"UID SEARCH RETURN (ALL)\");\n      command << Commands::PartOfCommand(Commands::ATOM, sequence);\n      return queueCommand(command);\n  }\n}"
  },
  {
    "function_name": "uidSearchUid(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "332-337",
    "snippet": "ommandHandle Parser::uidSearchUid(const QByteArray &sequence)\n{\n    Commands::Command command(\"UID SEARCH\");\n    command << Commands::PartOfCommand(Commands::ATOM, sequence);\n    return queueCommand(command);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommand)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "equence)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSearchUid(const QByteArray &sequence)\n  {\n      Commands::Command command(\"UID SEARCH\");\n      command << Commands::PartOfCommand(Commands::ATOM, sequence);\n      return queueCommand(command);\n  }\n}"
  },
  {
    "function_name": "searchHelper(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "311-330",
    "snippet": "ommandHandle Parser::searchHelper(const QByteArray &command, const QStringList &criteria, const QByteArray &charset)\n{\n    Commands::Command cmd(command);\n\n    if (!charset.isEmpty())\n        cmd << \"CHARSET\" << charset;\n\n    // FIXME: we don't really support anything else but utf-8 here\n\n    if (criteria.size() == 1) {\n        // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n        // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n        cmd << Commands::PartOfCommand(Commands::ATOM, criteria.front().toUtf8());\n    } else {\n        for (QStringList::const_iterator it = criteria.begin(); it != criteria.end(); ++it)\n            cmd << it->toUtf8();\n    }\n\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->toUtf8",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteria.end",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteria.begin",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "riteria.front().toUtf8())"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteria.front",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteria.front",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "riteria.size",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "harset.isEmpty",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::searchHelper(const QByteArray &command, const QStringList &criteria, const QByteArray &charset)\n  {\n      Commands::Command cmd(command);\n  \n      if (!charset.isEmpty())\n          cmd << \"CHARSET\" << charset;\n  \n      // FIXME: we don't really support anything else but utf-8 here\n  \n      if (criteria.size() == 1) {\n          // Hack: if it's just a single item, let's assume it's already well-formatted by the caller.\n          // This is required in the current shape of the API if we want to allow the user to type in their queries directly.\n          cmd << Commands::PartOfCommand(Commands::ATOM, criteria.front().toUtf8());\n      } else {\n          for (QStringList::const_iterator it = criteria.begin(); it != criteria.end(); ++it)\n              cmd << it->toUtf8();\n      }\n  \n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "expunge(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "306-309",
    "snippet": "ommandHandle Parser::expunge()\n{\n    return queueCommand(Commands::ATOM, \"EXPUNGE\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "EXPUNGE\")"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::expunge()\n  {\n      return queueCommand(Commands::ATOM, \"EXPUNGE\");\n  }\n}"
  },
  {
    "function_name": "close(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "301-304",
    "snippet": "ommandHandle Parser::close()\n{\n    return queueCommand(Commands::ATOM, \"CLOSE\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "CLOSE\")"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::close()\n  {\n      return queueCommand(Commands::ATOM, \"CLOSE\");\n  }\n}"
  },
  {
    "function_name": "check(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "296-299",
    "snippet": "ommandHandle Parser::check()\n{\n    return queueCommand(Commands::ATOM, \"CHECK\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "CHECK\")"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::check()\n  {\n      return queueCommand(Commands::ATOM, \"CHECK\");\n  }\n}"
  },
  {
    "function_name": "appendCatenate(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "269-294",
    "snippet": "ommandHandle Parser::appendCatenate(const QString &mailbox, const QList<Imap::Mailbox::CatenatePair> &data,\n                                     const QStringList &flags, const QDateTime &timestamp)\n{\n    Commands::Command command(\"APPEND\");\n    command << encodeImapFolderName(mailbox);\n    if (flags.count())\n        command << Commands::PartOfCommand(Commands::ATOM, \"(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\");\n    if (timestamp.isValid())\n        command << Commands::PartOfCommand(Imap::dateTimeToInternalDate(timestamp).toUtf8());\n    command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" CATENATE (\");\n    Q_FOREACH(const Imap::Mailbox::CatenatePair &item, data) {\n        switch (item.first) {\n        case Imap::Mailbox::CATENATE_TEXT:\n            command << Commands::PartOfCommand(Commands::ATOM, \"TEXT\");\n            command << Commands::PartOfCommand(Commands::LITERAL, item.second);\n            break;\n        case Imap::Mailbox::CATENATE_URL:\n            command << Commands::PartOfCommand(Commands::ATOM, \"URL\");\n            command << Commands::PartOfCommand(item.second);\n            break;\n        }\n    }\n    command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n\n    return queueCommand(command);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommand)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "tem.second)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "URL\")"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::LITERAL,",
            "tem.second)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "TEXT\")"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "CATENATE (\")"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "map::dateTimeToInternalDate(timestamp).toUtf8())"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::dateTimeToInternalDate",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::dateTimeToInternalDate(",
          "args": [
            "imestamp)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imestamp.isValid",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags.join",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags.count",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::appendCatenate(const QString &mailbox, const QList<Imap::Mailbox::CatenatePair> &data,\n                                       const QStringList &flags, const QDateTime &timestamp)\n  {\n      Commands::Command command(\"APPEND\");\n      command << encodeImapFolderName(mailbox);\n      if (flags.count())\n          command << Commands::PartOfCommand(Commands::ATOM, \"(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\");\n      if (timestamp.isValid())\n          command << Commands::PartOfCommand(Imap::dateTimeToInternalDate(timestamp).toUtf8());\n      command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" CATENATE (\");\n      Q_FOREACH(const Imap::Mailbox::CatenatePair &item, data) {\n          switch (item.first) {\n          case Imap::Mailbox::CATENATE_TEXT:\n              command << Commands::PartOfCommand(Commands::ATOM, \"TEXT\");\n              command << Commands::PartOfCommand(Commands::LITERAL, item.second);\n              break;\n          case Imap::Mailbox::CATENATE_URL:\n              command << Commands::PartOfCommand(Commands::ATOM, \"URL\");\n              command << Commands::PartOfCommand(item.second);\n              break;\n          }\n      }\n      command << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n  \n      return queueCommand(command);\n  }\n}"
  },
  {
    "function_name": "append(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "256-267",
    "snippet": "ommandHandle Parser::append(const QString &mailbox, const QByteArray &message, const QStringList &flags, const QDateTime &timestamp)\n{\n    Commands::Command command(\"APPEND\");\n    command << encodeImapFolderName(mailbox);\n    if (flags.count())\n        command << Commands::PartOfCommand(Commands::ATOM, \"(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\");\n    if (timestamp.isValid())\n        command << Commands::PartOfCommand(Imap::dateTimeToInternalDate(timestamp).toUtf8());\n    command << Commands::PartOfCommand(Commands::LITERAL, message);\n\n    return queueCommand(command);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommand)"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::LITERAL,",
            "essage)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "map::dateTimeToInternalDate(timestamp).toUtf8())"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::dateTimeToInternalDate",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::dateTimeToInternalDate(",
          "args": [
            "imestamp)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imestamp.isValid",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags.join",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags.count",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::append(const QString &mailbox, const QByteArray &message, const QStringList &flags, const QDateTime &timestamp)\n  {\n      Commands::Command command(\"APPEND\");\n      command << encodeImapFolderName(mailbox);\n      if (flags.count())\n          command << Commands::PartOfCommand(Commands::ATOM, \"(\" + flags.join(QLatin1String(\" \")).toUtf8() + \")\");\n      if (timestamp.isValid())\n          command << Commands::PartOfCommand(Imap::dateTimeToInternalDate(timestamp).toUtf8());\n      command << Commands::PartOfCommand(Commands::LITERAL, message);\n  \n      return queueCommand(command);\n  }\n}"
  },
  {
    "function_name": "status(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "249-254",
    "snippet": "ommandHandle Parser::status(const QString &mailbox, const QStringList &fields)\n{\n    return queueCommand(Commands::Command(\"STATUS\") << encodeImapFolderName(mailbox) <<\n                        Commands::PartOfCommand(Commands::ATOM, \"(\" + fields.join(QLatin1String(\" \")).toUtf8() + \")\")\n                       );\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"STATUS\") << encodeImapFolderName(mailbox) <<\n                        Commands::PartOfCommand(Commands::ATOM, \"(\" + fields.join(QLatin1String(\" \")).toUtf8() + \")\")"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "(\" + fields.join(QLatin1String(\" \")).toUtf8() + \")\")"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ields.join",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ields.join",
          "args": [
            "Latin1String(\" \"))"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "\")"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "STATUS\")"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::status(const QString &mailbox, const QStringList &fields)\n  {\n      return queueCommand(Commands::Command(\"STATUS\") << encodeImapFolderName(mailbox) <<\n                          Commands::PartOfCommand(Commands::ATOM, \"(\" + fields.join(QLatin1String(\" \")).toUtf8() + \")\")\n                         );\n  }\n}"
  },
  {
    "function_name": "lSub(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "244-247",
    "snippet": "ommandHandle Parser::lSub(const QString &reference, const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"LSUB\") << reference.toUtf8() << encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"LSUB\") << reference.toUtf8() << encodeImapFolderName(mailbox))"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "eference.toUtf8",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "LSUB\")"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::lSub(const QString &reference, const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"LSUB\") << reference.toUtf8() << encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "list(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "230-242",
    "snippet": "ommandHandle Parser::list(const QString &reference, const QString &mailbox, const QStringList &returnOptions)\n{\n    Commands::Command cmd(\"LIST\");\n    cmd << reference.toUtf8() << encodeImapFolderName(mailbox);\n    if (!returnOptions.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" RETURN (\");\n        Q_FOREACH(const QString &option, returnOptions) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, option.toUtf8());\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "ption.toUtf8())"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ption.toUtf8",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "RETURN (\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturnOptions.isEmpty",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "eference.toUtf8",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::list(const QString &reference, const QString &mailbox, const QStringList &returnOptions)\n  {\n      Commands::Command cmd(\"LIST\");\n      cmd << reference.toUtf8() << encodeImapFolderName(mailbox);\n      if (!returnOptions.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" RETURN (\");\n          Q_FOREACH(const QString &option, returnOptions) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, option.toUtf8());\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "unSubscribe(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "225-228",
    "snippet": "ommandHandle Parser::unSubscribe(const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"UNSUBSCRIBE\") << encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"UNSUBSCRIBE\") << encodeImapFolderName(mailbox))"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "UNSUBSCRIBE\")"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::unSubscribe(const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"UNSUBSCRIBE\") << encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "subscribe(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "220-223",
    "snippet": "ommandHandle Parser::subscribe(const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"SUBSCRIBE\") << encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"SUBSCRIBE\") << encodeImapFolderName(mailbox))"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "SUBSCRIBE\")"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::subscribe(const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"SUBSCRIBE\") << encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "rename(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "213-218",
    "snippet": "ommandHandle Parser::rename(const QString &oldName, const QString &newName)\n{\n    return queueCommand(Commands::Command(\"RENAME\") <<\n                        encodeImapFolderName(oldName) <<\n                        encodeImapFolderName(newName));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"RENAME\") <<\n                        encodeImapFolderName(oldName) <<\n                        encodeImapFolderName(newName))"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ewName)"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "RENAME\")"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::rename(const QString &oldName, const QString &newName)\n  {\n      return queueCommand(Commands::Command(\"RENAME\") <<\n                          encodeImapFolderName(oldName) <<\n                          encodeImapFolderName(newName));\n  }\n}"
  },
  {
    "function_name": "create(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "208-211",
    "snippet": "ommandHandle Parser::create(const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"CREATE\") << encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"CREATE\") << encodeImapFolderName(mailbox))"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "CREATE\")"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::create(const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"CREATE\") << encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "deleteMailbox(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "203-206",
    "snippet": "ommandHandle Parser::deleteMailbox(const QString &mailbox)\n{\n    return queueCommand(Commands::Command(\"DELETE\") << encodeImapFolderName(mailbox));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"DELETE\") << encodeImapFolderName(mailbox))"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "DELETE\")"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::deleteMailbox(const QString &mailbox)\n  {\n      return queueCommand(Commands::Command(\"DELETE\") << encodeImapFolderName(mailbox));\n  }\n}"
  },
  {
    "function_name": "examine(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "190-201",
    "snippet": "ommandHandle Parser::examine(const QString &mailbox, const QList<QByteArray> &params)\n{\n    Commands::Command cmd = Commands::Command(\"EXAMINE\") << encodeImapFolderName(mailbox);\n    if (!params.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n        Q_FOREACH(const QByteArray &param, params) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, param);\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "aram)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arams.isEmpty",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "EXAMINE\")"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::examine(const QString &mailbox, const QList<QByteArray> &params)\n  {\n      Commands::Command cmd = Commands::Command(\"EXAMINE\") << encodeImapFolderName(mailbox);\n      if (!params.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n          Q_FOREACH(const QByteArray &param, params) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, param);\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "selectQresync(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "167-188",
    "snippet": "ommandHandle Parser::selectQresync(const QString &mailbox, const uint uidValidity,\n                                    const quint64 highestModSeq, const Sequence &knownUids, const Sequence &sequenceSnapshot,\n                                    const Sequence &uidSnapshot)\n{\n    Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox) <<\n           Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (QRESYNC (\") <<\n           Commands::PartOfCommand(Commands::ATOM, QByteArray::number(uidValidity)) <<\n           Commands::PartOfCommand(Commands::ATOM, QByteArray::number(highestModSeq));\n    if (knownUids.isValid()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM, knownUids.toByteArray());\n    }\n    Q_ASSERT(uidSnapshot.isValid() == sequenceSnapshot.isValid());\n    if (sequenceSnapshot.isValid()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\") <<\n               Commands::PartOfCommand(Commands::ATOM, sequenceSnapshot.toByteArray()) <<\n               Commands::PartOfCommand(Commands::ATOM, uidSnapshot.toByteArray()) <<\n               Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")))\");\n    } else {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \"))\");\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "))\")"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")))\")"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "idSnapshot.toByteArray())"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idSnapshot.toByteArray",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "equenceSnapshot.toByteArray())"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equenceSnapshot.toByteArray",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equenceSnapshot.isValid",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "idSnapshot.isValid() == sequenceSnapshot.isValid())"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "nownUids.toByteArray())"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nownUids.toByteArray",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "ByteArray::number(highestModSeq))"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "ighestModSeq)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "ByteArray::number(uidValidity))"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray::number(",
          "args": [
            "idValidity)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(QRESYNC (\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "SELECT\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::selectQresync(const QString &mailbox, const uint uidValidity,\n                                      const quint64 highestModSeq, const Sequence &knownUids, const Sequence &sequenceSnapshot,\n                                      const Sequence &uidSnapshot)\n  {\n      Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox) <<\n             Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (QRESYNC (\") <<\n             Commands::PartOfCommand(Commands::ATOM, QByteArray::number(uidValidity)) <<\n             Commands::PartOfCommand(Commands::ATOM, QByteArray::number(highestModSeq));\n      if (knownUids.isValid()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM, knownUids.toByteArray());\n      }\n      Q_ASSERT(uidSnapshot.isValid() == sequenceSnapshot.isValid());\n      if (sequenceSnapshot.isValid()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\") <<\n                 Commands::PartOfCommand(Commands::ATOM, sequenceSnapshot.toByteArray()) <<\n                 Commands::PartOfCommand(Commands::ATOM, uidSnapshot.toByteArray()) <<\n                 Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")))\");\n      } else {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \"))\");\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "select(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "154-165",
    "snippet": "ommandHandle Parser::select(const QString &mailbox, const QList<QByteArray> &params)\n{\n    Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox);\n    if (!params.isEmpty()) {\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n        Q_FOREACH(const QByteArray &param, params) {\n            cmd << Commands::PartOfCommand(Commands::ATOM, param);\n        }\n        cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n    }\n    return queueCommand(cmd);\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "md)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            ")\")"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "aram)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM_NO_SPACE_AROUND,",
            "(\")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arams.isEmpty",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncodeImapFolderName(",
          "args": [
            "ailbox)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ncodeImapFolderName(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "377-380",
          "snippet": "ByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\nByteArray encodeImapFolderName( const QString& text )\n{\n    return KIMAP::encodeImapFolderName( text ).toLatin1();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "SELECT\")"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::select(const QString &mailbox, const QList<QByteArray> &params)\n  {\n      Commands::Command cmd = Commands::Command(\"SELECT\") << encodeImapFolderName(mailbox);\n      if (!params.isEmpty()) {\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \" (\");\n          Q_FOREACH(const QByteArray &param, params) {\n              cmd << Commands::PartOfCommand(Commands::ATOM, param);\n          }\n          cmd << Commands::PartOfCommand(Commands::ATOM_NO_SPACE_AROUND, \")\");\n      }\n      return queueCommand(cmd);\n  }\n}"
  },
  {
    "function_name": "login(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "148-152",
    "snippet": "ommandHandle Parser::login(const QString &username, const QString &password)\n{\n    return queueCommand(Commands::Command(\"LOGIN\") <<\n                        Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"LOGIN\") <<\n                        Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()))"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "assword.toUtf8())"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assword.toUtf8",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "sername.toUtf8())"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sername.toUtf8",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "LOGIN\")"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::login(const QString &username, const QString &password)\n  {\n      return queueCommand(Commands::Command(\"LOGIN\") <<\n                          Commands::PartOfCommand(username.toUtf8()) << Commands::PartOfCommand(password.toUtf8()));\n  }\n}"
  },
  {
    "function_name": "authenticate(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "141-145",
    "snippet": "ommandHandle Parser::authenticate(/*Authenticator FIXME*/)\n{\n    // FIXME: needs higher priority\n    return queueCommand(Commands::ATOM, \"AUTHENTICATE\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "AUTHENTICATE\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::authenticate(/*Authenticator FIXME*/)\n  {\n      // FIXME: needs higher priority\n      return queueCommand(Commands::ATOM, \"AUTHENTICATE\");\n  }\n}"
  },
  {
    "function_name": "compressDeflate(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "134-138",
    "snippet": "ommandHandle Parser::compressDeflate()\n{\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::COMPRESS_DEFLATE, \"COMPRESS DEFLATE\"));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command() <<\n                        Commands::PartOfCommand(Commands::COMPRESS_DEFLATE, \"COMPRESS DEFLATE\"))"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::COMPRESS_DEFLATE,",
            "COMPRESS DEFLATE\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::compressDeflate()\n  {\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::COMPRESS_DEFLATE, \"COMPRESS DEFLATE\"));\n  }\n}"
  },
  {
    "function_name": "startTls(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "128-132",
    "snippet": "ommandHandle Parser::startTls()\n{\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::STARTTLS, \"STARTTLS\"));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command() <<\n                        Commands::PartOfCommand(Commands::STARTTLS, \"STARTTLS\"))"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::STARTTLS,",
            "STARTTLS\")"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::startTls()\n  {\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::STARTTLS, \"STARTTLS\"));\n  }\n}"
  },
  {
    "function_name": "capability(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "121-126",
    "snippet": "ommandHandle Parser::capability()\n{\n    // CAPABILITY should take precedence over LOGIN, because we have to check for LOGINDISABLED\n    return queueCommand(Commands::Command() <<\n                        Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command() <<\n                        Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"))"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::PartOfCommand(",
          "args": [
            "ommands::ATOM,",
            "CAPABILITY\")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::capability()\n  {\n      // CAPABILITY should take precedence over LOGIN, because we have to check for LOGINDISABLED\n      return queueCommand(Commands::Command() <<\n                          Commands::PartOfCommand(Commands::ATOM, \"CAPABILITY\"));\n  }\n}"
  },
  {
    "function_name": "closeConnection(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "116-119",
    "snippet": "oid Parser::closeConnection()\n{\n    socket->close();\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocket->close",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "close(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "124-128",
          "snippet": "oid FakeSocket::close()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** close ***]\"));\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::close()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** close ***]\"));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::closeConnection()\n  {\n      socket->close();\n  }\n}"
  },
  {
    "function_name": "logout(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "107-113",
    "snippet": "ommandHandle Parser::logout()\n{\n    return queueCommand(Commands::Command(\"LOGOUT\"));\n\n    // Queue a request for closing the socket. It'll get closed after a short while.\n    QTimer::singleShot(1000, this, SLOT(closeConnection()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            "000,",
            "his,",
            "LOT(closeConnection()))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "loseConnection())"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loseConnection(",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "closeConnection(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "116-119",
          "snippet": "oid Parser::closeConnection()\n{\n    socket->close();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::closeConnection()\n  {\n      socket->close();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::Command(\"LOGOUT\"))"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "queueCommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "604-611",
          "snippet": "ommandHandle Parser::queueCommand(Commands::Command command)\n{\n    CommandHandle tag = generateTag();\n    command.addTag(tag);\n    cmdQueue.append(command);\n    QTimer::singleShot(0, this, SLOT(executeCommands()));\n    return tag;\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::queueCommand(Commands::Command command)\n  {\n      CommandHandle tag = generateTag();\n      command.addTag(tag);\n      cmdQueue.append(command);\n      QTimer::singleShot(0, this, SLOT(executeCommands()));\n      return tag;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ommands::Command(",
          "args": [
            "LOGOUT\")"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::logout()\n  {\n      return queueCommand(Commands::Command(\"LOGOUT\"));\n  \n      // Queue a request for closing the socket. It'll get closed after a short while.\n      QTimer::singleShot(1000, this, SLOT(closeConnection()));\n  }\n}"
  },
  {
    "function_name": "noop(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "102-105",
    "snippet": "ommandHandle Parser::noop()\n{\n    return queueCommand(Commands::ATOM, \"NOOP\");\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ueueCommand(",
          "args": [
            "ommands::ATOM,",
            "NOOP\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::noop()\n  {\n      return queueCommand(Commands::ATOM, \"NOOP\");\n  }\n}"
  },
  {
    "function_name": "Parser(",
    "container": "arser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
    "lines": "89-100",
    "snippet": "arser::Parser(QObject *parent, Streams::Socket *socket, const uint myId):\n    QObject(parent), socket(socket), m_lastTagUsed(0), idling(false), waitForInitialIdle(false),\n    literalPlus(false), waitingForContinuation(false), startTlsInProgress(false), compressDeflateInProgress(false),\n    waitingForConnection(true), waitingForEncryption(socket->isConnectingEncryptedSinceStart()), waitingForSslPolicy(false),\n    m_expectsInitialGreeting(true), readingMode(ReadingLine), oldLiteralPosition(0), m_parserId(myId)\n{\n    connect(socket, SIGNAL(disconnected(const QString &)),\n            this, SLOT(handleDisconnected(const QString &)));\n    connect(socket, SIGNAL(readyRead()), this, SLOT(handleReadyRead()));\n    connect(socket, SIGNAL(stateChanged(Imap::ConnectionState,QString)), this, SLOT(slotSocketStateChanged(Imap::ConnectionState,QString)));\n    connect(socket, SIGNAL(encrypted()), this, SLOT(handleSocketEncrypted()));\n}",
    "includes": [
      "include \"../Model/Utils.h\"",
      "include \"../../Streams/IODeviceSocket.h\"\n#",
      "include \"LowLevelParser.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Parser.h\"\n#",
      "include <QTimer>\n#",
      "include <QTime>\n#",
      "include <QSslError>\n#",
      "include <QProcess>\n#",
      "include <QMutexLocker>\n#",
      "include <QStringList>\n#",
      "include <QDebug>\n#",
      "include <algorithm>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ocket,",
            "IGNAL(encrypted()),",
            "his,",
            "LOT(handleSocketEncrypted()))"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleSocketEncrypted())"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleSocketEncrypted(",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "handleSocketEncrypted(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "746-764",
          "snippet": "oid Parser::handleSocketEncrypted()\n{\n    waitingForEncryption = false;\n    waitingForConnection = false;\n    waitingForSslPolicy = true;\n    QSharedPointer<Responses::AbstractResponse> resp(\n                new Responses::SocketEncryptedResponse(socket->sslChain(), socket->sslErrors()));\n    QByteArray buf;\n    QTextStream ss(&buf);\n    ss << \"*** \" << *resp;\n    ss.flush();\n#ifdef PRINT_TRAFFIC_RX\n    qDebug() << m_parserId << \"***\" << buf;\n#endif\n    emit lineReceived(this, buf);\n    handleReadyRead();\n    queueResponse(resp);\n    executeCommands();\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleSocketEncrypted()\n  {\n      waitingForEncryption = false;\n      waitingForConnection = false;\n      waitingForSslPolicy = true;\n      QSharedPointer<Responses::AbstractResponse> resp(\n                  new Responses::SocketEncryptedResponse(socket->sslChain(), socket->sslErrors()));\n      QByteArray buf;\n      QTextStream ss(&buf);\n      ss << \"*** \" << *resp;\n      ss.flush();\n  #ifdef PRINT_TRAFFIC_RX\n      qDebug() << m_parserId << \"***\" << buf;\n  #endif\n      emit lineReceived(this, buf);\n      handleReadyRead();\n      queueResponse(resp);\n      executeCommands();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ncrypted())"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ocket,",
            "IGNAL(stateChanged(Imap::ConnectionState,QString)),",
            "his,",
            "LOT(slotSocketStateChanged(Imap::ConnectionState,QString)))"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotSocketStateChanged(Imap::ConnectionState,QString))"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotSocketStateChanged(",
          "args": [
            "map::ConnectionState,",
            "String)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "slotSocketStateChanged(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1157-1172",
          "snippet": "oid Parser::slotSocketStateChanged(const Imap::ConnectionState connState, const QString &message)\n{\n    if (connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n#ifdef PRINT_TRAFFIC_TX\n        qDebug() << m_parserId << \"*** Connection established\";\n#endif\n        emit lineReceived(this, \"*** Connection established\");\n        waitingForConnection = false;\n        QTimer::singleShot(0, this, SLOT(executeCommands()));\n    } else if (connState == CONN_STATE_AUTHENTICATED) {\n        // unit tests: don't wait for the initial untagged response greetings\n        m_expectsInitialGreeting = false;\n    }\n    emit lineReceived(this, \"*** \" + message.toUtf8());\n    emit connectionStateChanged(this, connState);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::slotSocketStateChanged(const Imap::ConnectionState connState, const QString &message)\n  {\n      if (connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n  #ifdef PRINT_TRAFFIC_TX\n          qDebug() << m_parserId << \"*** Connection established\";\n  #endif\n          emit lineReceived(this, \"*** Connection established\");\n          waitingForConnection = false;\n          QTimer::singleShot(0, this, SLOT(executeCommands()));\n      } else if (connState == CONN_STATE_AUTHENTICATED) {\n          // unit tests: don't wait for the initial untagged response greetings\n          m_expectsInitialGreeting = false;\n      }\n      emit lineReceived(this, \"*** \" + message.toUtf8());\n      emit connectionStateChanged(this, connState);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "tateChanged(Imap::ConnectionState,QString))"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "ocket,",
            "IGNAL(readyRead()),",
            "his,",
            "LOT(handleReadyRead()))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "andleReadyRead())"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleReadyRead(",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "handleReadyRead(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "658-685",
          "snippet": "oid Parser::handleReadyRead()\n{\n    while (!waitingForEncryption && !waitingForSslPolicy) {\n        switch (readingMode) {\n        case ReadingLine:\n            if (socket->canReadLine()) {\n                reallyReadLine();\n            } else {\n                // Not enough data yet, let's try again later\n                return;\n            }\n            break;\n        case ReadingNumberOfBytes:\n        {\n            QByteArray buf = socket->read(readingBytes);\n            readingBytes -= buf.size();\n            currentLine += buf;\n            if (readingBytes == 0) {\n                // we've read the literal\n                readingMode = ReadingLine;\n            } else {\n                return;\n            }\n        }\n        break;\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::handleReadyRead()\n  {\n      while (!waitingForEncryption && !waitingForSslPolicy) {\n          switch (readingMode) {\n          case ReadingLine:\n              if (socket->canReadLine()) {\n                  reallyReadLine();\n              } else {\n                  // Not enough data yet, let's try again later\n                  return;\n              }\n              break;\n          case ReadingNumberOfBytes:\n          {\n              QByteArray buf = socket->read(readingBytes);\n              readingBytes -= buf.size();\n              currentLine += buf;\n              if (readingBytes == 0) {\n                  // we've read the literal\n                  readingMode = ReadingLine;\n              } else {\n                  return;\n              }\n          }\n          break;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "eadyRead())"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocket->isConnectingEncryptedSinceStart",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "isConnectingEncryptedSinceStart(",
          "container": "ocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/Socket.cpp",
          "lines": "31-34",
          "snippet": "ool Socket::isConnectingEncryptedSinceStart() const\n{\n    return false;\n}",
          "includes": [
            "include \"Socket.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Socket.h\"\n\nocket {\n  ool Socket::isConnectingEncryptedSinceStart() const\n  {\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  arser::Parser(QObject *parent, Streams::Socket *socket, const uint myId):\n      QObject(parent), socket(socket), m_lastTagUsed(0), idling(false), waitForInitialIdle(false),\n      literalPlus(false), waitingForContinuation(false), startTlsInProgress(false), compressDeflateInProgress(false),\n      waitingForConnection(true), waitingForEncryption(socket->isConnectingEncryptedSinceStart()), waitingForSslPolicy(false),\n      m_expectsInitialGreeting(true), readingMode(ReadingLine), oldLiteralPosition(0), m_parserId(myId)\n  {\n      connect(socket, SIGNAL(disconnected(const QString &)),\n              this, SLOT(handleDisconnected(const QString &)));\n      connect(socket, SIGNAL(readyRead()), this, SLOT(handleReadyRead()));\n      connect(socket, SIGNAL(stateChanged(Imap::ConnectionState,QString)), this, SLOT(slotSocketStateChanged(Imap::ConnectionState,QString)));\n      connect(socket, SIGNAL(encrypted()), this, SLOT(handleSocketEncrypted()));\n  }\n}"
  }
]