[
  {
    "function_name": "slotShowLogs(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "233-239",
    "snippet": "oid ProtocolLoggerWidget::slotShowLogs()\n{\n    // Please note that we can't return to the event loop from this context, as the log buffer has to be read atomically\n    for (QMap<uint, Common::RingBuffer<Common::LogMessage> >::iterator it = buffers.begin(); it != buffers.end(); ++it) {\n        flushToWidget(it.key(), *it);\n    }\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lushToWidget(",
          "args": [
            "t.key(),",
            "it)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "flushToWidget(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "167-231",
          "snippet": "oid ProtocolLoggerWidget::flushToWidget(const uint parserId, Common::RingBuffer<Common::LogMessage> &buf)\n{\n    using namespace Common;\n\n    QPlainTextEdit *w = getLogger(parserId);\n\n    if (buf.skippedCount()) {\n        w->appendHtml(tr(\"<p style='color: #bb0000'><i><b>%n message(s)</b> were skipped because this widget was hidden.</i></p>\",\n                         \"\", buf.skippedCount()));\n    }\n\n    for (RingBuffer<LogMessage>::const_iterator it = buf.begin(); it != buf.end(); ++it) {\n        QString message = QString::fromUtf8(\"<pre><span style='color: #808080'>%1</span> %2<span style='color: %3;%4'>%5</span>%6</pre>\");\n        QString direction;\n        QString textColor;\n        QString bgColor;\n        QString trimmedInfo;\n\n        switch (it->kind) {\n        case LOG_IO_WRITTEN:\n            if (it->message.startsWith(QLatin1String(\"***\"))) {\n                textColor = \"#800080\";\n                bgColor = \"#d0d0d0\";\n            } else {\n                textColor = \"#800000\";\n                direction = \"<span style='color: #c0c0c0;'>&gt;&gt;&gt;&nbsp;</span>\";\n            }\n            break;\n        case LOG_IO_READ:\n            if (it->message.startsWith(QLatin1String(\"***\"))) {\n                textColor = \"#808000\";\n                bgColor = \"#d0d0d0\";\n            } else {\n                textColor = \"#008000\";\n                direction = \"<span style='color: #c0c0c0;'>&lt;&lt;&lt;&nbsp;</span>\";\n            }\n            break;\n        case LOG_MAILBOX_SYNC:\n        case LOG_MESSAGES:\n        case LOG_OTHER:\n        case LOG_PARSE_ERROR:\n        case LOG_TASKS:\n            direction = QLatin1String(\"<span style='color: #c0c0c0;'>\") + it->source + QLatin1String(\"</span> \");\n            break;\n        }\n\n        if (it->truncatedBytes) {\n            trimmedInfo = tr(\"<br/><span style='color: #808080; font-style: italic;'>(+ %n more bytes)</span>\", \"\", it->truncatedBytes);\n        }\n\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n        QString niceLine = it->message.toHtmlEscaped();\n#else\n        QString niceLine = Qt::escape(it->message);\n#endif\n        niceLine.replace(QChar('\\r'), 0x240d /* SYMBOL FOR CARRIAGE RETURN */)\n        .replace(QChar('\\n'), 0x240a /* SYMBOL FOR LINE FEED */);\n\n        w->appendHtml(message.arg(it->timestamp.toString(QLatin1String(\"hh:mm:ss.zzz\")),\n                                  direction, textColor,\n                                  bgColor.isEmpty() ? QString() : QString::fromUtf8(\"background-color: %1\").arg(bgColor),\n                                  niceLine, trimmedInfo));\n    }\n    buf.clear();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::flushToWidget(const uint parserId, Common::RingBuffer<Common::LogMessage> &buf)\n  {\n      using namespace Common;\n  \n      QPlainTextEdit *w = getLogger(parserId);\n  \n      if (buf.skippedCount()) {\n          w->appendHtml(tr(\"<p style='color: #bb0000'><i><b>%n message(s)</b> were skipped because this widget was hidden.</i></p>\",\n                           \"\", buf.skippedCount()));\n      }\n  \n      for (RingBuffer<LogMessage>::const_iterator it = buf.begin(); it != buf.end(); ++it) {\n          QString message = QString::fromUtf8(\"<pre><span style='color: #808080'>%1</span> %2<span style='color: %3;%4'>%5</span>%6</pre>\");\n          QString direction;\n          QString textColor;\n          QString bgColor;\n          QString trimmedInfo;\n  \n          switch (it->kind) {\n          case LOG_IO_WRITTEN:\n              if (it->message.startsWith(QLatin1String(\"***\"))) {\n                  textColor = \"#800080\";\n                  bgColor = \"#d0d0d0\";\n              } else {\n                  textColor = \"#800000\";\n                  direction = \"<span style='color: #c0c0c0;'>&gt;&gt;&gt;&nbsp;</span>\";\n              }\n              break;\n          case LOG_IO_READ:\n              if (it->message.startsWith(QLatin1String(\"***\"))) {\n                  textColor = \"#808000\";\n                  bgColor = \"#d0d0d0\";\n              } else {\n                  textColor = \"#008000\";\n                  direction = \"<span style='color: #c0c0c0;'>&lt;&lt;&lt;&nbsp;</span>\";\n              }\n              break;\n          case LOG_MAILBOX_SYNC:\n          case LOG_MESSAGES:\n          case LOG_OTHER:\n          case LOG_PARSE_ERROR:\n          case LOG_TASKS:\n              direction = QLatin1String(\"<span style='color: #c0c0c0;'>\") + it->source + QLatin1String(\"</span> \");\n              break;\n          }\n  \n          if (it->truncatedBytes) {\n              trimmedInfo = tr(\"<br/><span style='color: #808080; font-style: italic;'>(+ %n more bytes)</span>\", \"\", it->truncatedBytes);\n          }\n  \n  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n          QString niceLine = it->message.toHtmlEscaped();\n  #else\n          QString niceLine = Qt::escape(it->message);\n  #endif\n          niceLine.replace(QChar('\\r'), 0x240d /* SYMBOL FOR CARRIAGE RETURN */)\n          .replace(QChar('\\n'), 0x240a /* SYMBOL FOR LINE FEED */);\n  \n          w->appendHtml(message.arg(it->timestamp.toString(QLatin1String(\"hh:mm:ss.zzz\")),\n                                    direction, textColor,\n                                    bgColor.isEmpty() ? QString() : QString::fromUtf8(\"background-color: %1\").arg(bgColor),\n                                    niceLine, trimmedInfo));\n      }\n      buf.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uffers.end",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uffers.begin",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::slotShowLogs()\n  {\n      // Please note that we can't return to the event loop from this context, as the log buffer has to be read atomically\n      for (QMap<uint, Common::RingBuffer<Common::LogMessage> >::iterator it = buffers.begin(); it != buffers.end(); ++it) {\n          flushToWidget(it.key(), *it);\n      }\n  }\n}"
  },
  {
    "function_name": "flushToWidget(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "167-231",
    "snippet": "oid ProtocolLoggerWidget::flushToWidget(const uint parserId, Common::RingBuffer<Common::LogMessage> &buf)\n{\n    using namespace Common;\n\n    QPlainTextEdit *w = getLogger(parserId);\n\n    if (buf.skippedCount()) {\n        w->appendHtml(tr(\"<p style='color: #bb0000'><i><b>%n message(s)</b> were skipped because this widget was hidden.</i></p>\",\n                         \"\", buf.skippedCount()));\n    }\n\n    for (RingBuffer<LogMessage>::const_iterator it = buf.begin(); it != buf.end(); ++it) {\n        QString message = QString::fromUtf8(\"<pre><span style='color: #808080'>%1</span> %2<span style='color: %3;%4'>%5</span>%6</pre>\");\n        QString direction;\n        QString textColor;\n        QString bgColor;\n        QString trimmedInfo;\n\n        switch (it->kind) {\n        case LOG_IO_WRITTEN:\n            if (it->message.startsWith(QLatin1String(\"***\"))) {\n                textColor = \"#800080\";\n                bgColor = \"#d0d0d0\";\n            } else {\n                textColor = \"#800000\";\n                direction = \"<span style='color: #c0c0c0;'>&gt;&gt;&gt;&nbsp;</span>\";\n            }\n            break;\n        case LOG_IO_READ:\n            if (it->message.startsWith(QLatin1String(\"***\"))) {\n                textColor = \"#808000\";\n                bgColor = \"#d0d0d0\";\n            } else {\n                textColor = \"#008000\";\n                direction = \"<span style='color: #c0c0c0;'>&lt;&lt;&lt;&nbsp;</span>\";\n            }\n            break;\n        case LOG_MAILBOX_SYNC:\n        case LOG_MESSAGES:\n        case LOG_OTHER:\n        case LOG_PARSE_ERROR:\n        case LOG_TASKS:\n            direction = QLatin1String(\"<span style='color: #c0c0c0;'>\") + it->source + QLatin1String(\"</span> \");\n            break;\n        }\n\n        if (it->truncatedBytes) {\n            trimmedInfo = tr(\"<br/><span style='color: #808080; font-style: italic;'>(+ %n more bytes)</span>\", \"\", it->truncatedBytes);\n        }\n\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n        QString niceLine = it->message.toHtmlEscaped();\n#else\n        QString niceLine = Qt::escape(it->message);\n#endif\n        niceLine.replace(QChar('\\r'), 0x240d /* SYMBOL FOR CARRIAGE RETURN */)\n        .replace(QChar('\\n'), 0x240a /* SYMBOL FOR LINE FEED */);\n\n        w->appendHtml(message.arg(it->timestamp.toString(QLatin1String(\"hh:mm:ss.zzz\")),\n                                  direction, textColor,\n                                  bgColor.isEmpty() ? QString() : QString::fromUtf8(\"background-color: %1\").arg(bgColor),\n                                  niceLine, trimmedInfo));\n    }\n    buf.clear();\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uf.clear",
          "args": [],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->appendHtml",
          "args": [
            "essage.arg(it->timestamp.toString(QLatin1String(\"hh:mm:ss.zzz\")),\n                                  direction, textColor,\n                                  bgColor.isEmpty() ? QString() : QString::fromUtf8(\"background-color: %1\").arg(bgColor),\n                                  niceLine, trimmedInfo))"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.arg",
          "args": [
            "t->timestamp.toString(QLatin1String(\"hh:mm:ss.zzz\")),",
            "irection,",
            "extColor,",
            "gColor.isEmpty() ? QString() : QString::fromUtf8(\"background-color: %1\").arg(bgColor),",
            "iceLine,",
            "rimmedInfo)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "gColor)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "background-color: %1\")"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gColor.isEmpty",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->timestamp.toString",
          "args": [
            "Latin1String(\"hh:mm:ss.zzz\"))"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "hh:mm:ss.zzz\")"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iceLine.replace",
          "args": [
            "Char('\\n'),",
            "x240a * SYMBOL FOR LINE FEED */)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Char(",
          "args": [
            "\\n')"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "exValueOfChar(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Encoders.cpp",
          "lines": "131-142",
          "snippet": "tatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }",
          "includes": [
            "include \"Parser/3rdparty/kcodecs.h\"",
            "include \"Parser/3rdparty/rfccodecs.h\"\n#",
            "include \"Encoders.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Parser/3rdparty/kcodecs.h\"\ninclude \"Parser/3rdparty/rfccodecs.h\"\n#\ninclude \"Encoders.h\"\n#\n\ntatic inline int hexValueOfChar(const char input)\n    {\n        if (input >= '0' && input <= '9') {\n            return input - '0';\n        } else if (input >= 'A' && input <= 'F') {\n            return 0x0a + input - 'A';\n        } else if (input >= 'a' && input <= 'f') {\n            return 0x0a + input - 'a';\n        } else {\n            return -1;\n        }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "iceLine.replace",
          "args": [
            "Char('\\r'),",
            "x240d * SYMBOL FOR CARRIAGE RETURN */)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t::escape(",
          "args": [
            "t->message)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->message.toHtmlEscaped",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "<br/><span style='color: #808080; font-style: italic;'>(+ %n more bytes)</span>\",",
            "\",",
            "t->truncatedBytes)"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ReplaceCharValidator(",
          "container": "eplaceCharValidator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ReplaceCharValidator.cpp",
          "lines": "27-30",
          "snippet": "eplaceCharValidator::ReplaceCharValidator(const QChar replaceWhat, const QChar replaceBy, QObject *parent):\n    QValidator(parent), m_replaceWhat(replaceWhat), m_replaceBy(replaceBy)\n{\n}",
          "includes": [
            "include \"ReplaceCharValidator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ReplaceCharValidator.h\"\n\neplaceCharValidator {\n  eplaceCharValidator::ReplaceCharValidator(const QChar replaceWhat, const QChar replaceBy, QObject *parent):\n      QValidator(parent), m_replaceWhat(replaceWhat), m_replaceBy(replaceBy)\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "</span> \")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "<span style='color: #c0c0c0;'>\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->message.startsWith",
          "args": [
            "Latin1String(\"***\"))"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "***\")"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->message.startsWith",
          "args": [
            "Latin1String(\"***\"))"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "***\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "<pre><span style='color: #808080'>%1</span> %2<span style='color: %3;%4'>%5</span>%6</pre>\")"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.end",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.begin",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->appendHtml",
          "args": [
            "r(\"<p style='color: #bb0000'><i><b>%n message(s)</b> were skipped because this widget was hidden.</i></p>\",\n                         \"\", buf.skippedCount()))"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.skippedCount",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf.skippedCount",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etLogger(",
          "args": [
            "arserId)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::flushToWidget(const uint parserId, Common::RingBuffer<Common::LogMessage> &buf)\n  {\n      using namespace Common;\n  \n      QPlainTextEdit *w = getLogger(parserId);\n  \n      if (buf.skippedCount()) {\n          w->appendHtml(tr(\"<p style='color: #bb0000'><i><b>%n message(s)</b> were skipped because this widget was hidden.</i></p>\",\n                           \"\", buf.skippedCount()));\n      }\n  \n      for (RingBuffer<LogMessage>::const_iterator it = buf.begin(); it != buf.end(); ++it) {\n          QString message = QString::fromUtf8(\"<pre><span style='color: #808080'>%1</span> %2<span style='color: %3;%4'>%5</span>%6</pre>\");\n          QString direction;\n          QString textColor;\n          QString bgColor;\n          QString trimmedInfo;\n  \n          switch (it->kind) {\n          case LOG_IO_WRITTEN:\n              if (it->message.startsWith(QLatin1String(\"***\"))) {\n                  textColor = \"#800080\";\n                  bgColor = \"#d0d0d0\";\n              } else {\n                  textColor = \"#800000\";\n                  direction = \"<span style='color: #c0c0c0;'>&gt;&gt;&gt;&nbsp;</span>\";\n              }\n              break;\n          case LOG_IO_READ:\n              if (it->message.startsWith(QLatin1String(\"***\"))) {\n                  textColor = \"#808000\";\n                  bgColor = \"#d0d0d0\";\n              } else {\n                  textColor = \"#008000\";\n                  direction = \"<span style='color: #c0c0c0;'>&lt;&lt;&lt;&nbsp;</span>\";\n              }\n              break;\n          case LOG_MAILBOX_SYNC:\n          case LOG_MESSAGES:\n          case LOG_OTHER:\n          case LOG_PARSE_ERROR:\n          case LOG_TASKS:\n              direction = QLatin1String(\"<span style='color: #c0c0c0;'>\") + it->source + QLatin1String(\"</span> \");\n              break;\n          }\n  \n          if (it->truncatedBytes) {\n              trimmedInfo = tr(\"<br/><span style='color: #808080; font-style: italic;'>(+ %n more bytes)</span>\", \"\", it->truncatedBytes);\n          }\n  \n  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n          QString niceLine = it->message.toHtmlEscaped();\n  #else\n          QString niceLine = Qt::escape(it->message);\n  #endif\n          niceLine.replace(QChar('\\r'), 0x240d /* SYMBOL FOR CARRIAGE RETURN */)\n          .replace(QChar('\\n'), 0x240a /* SYMBOL FOR LINE FEED */);\n  \n          w->appendHtml(message.arg(it->timestamp.toString(QLatin1String(\"hh:mm:ss.zzz\")),\n                                    direction, textColor,\n                                    bgColor.isEmpty() ? QString() : QString::fromUtf8(\"background-color: %1\").arg(bgColor),\n                                    niceLine, trimmedInfo));\n      }\n      buf.clear();\n  }\n}"
  },
  {
    "function_name": "slotImapLogged(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "145-165",
    "snippet": "oid ProtocolLoggerWidget::slotImapLogged(uint parser, Common::LogMessage message)\n{\n    using namespace Common;\n\n    QMap<uint, RingBuffer<LogMessage> >::iterator bufIt = buffers.find(parser);\n    if (bufIt == buffers.end()) {\n        // FIXME: don't hard-code that\n        bufIt = buffers.insert(parser, RingBuffer<LogMessage>(900));\n    }\n    if (m_fileLogger) {\n        m_fileLogger->slotImapLogged(parser, message);\n    }\n    enum {CUTOFF=200};\n    if (message.message.size() > CUTOFF) {\n        message.truncatedBytes = message.message.size() - CUTOFF;\n        message.message = message.message.left(CUTOFF);\n    }\n    bufIt->append(message);\n    if (loggingActive && !delayedDisplay->isActive())\n        delayedDisplay->start();\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elayedDisplay->start",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedDisplay->isActive",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufIt->append",
          "args": [
            "essage)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.message.left",
          "args": [
            "UTOFF)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.message.size",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essage.message.size",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_fileLogger->slotImapLogged",
          "args": [
            "arser,",
            "essage)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uffers.insert",
          "args": [
            "arser,",
            "ingBuffer<LogMessage>(900))"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ingBuffer<LogMessage>",
          "args": [
            "00)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ppend(",
          "container": "ingBuffer\n",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Common/RingBuffer.h",
          "lines": "117-127",
          "snippet": "oid append(const T &what)\n    {\n        if (appendPos_ == buf_.size()) {\n            wrapped_ = true;\n            appendPos_ = 0;\n        }\n        if (wrapped_)\n            ++skipped_;\n        buf_[appendPos_] = what;\n        ++appendPos_;\n    }",
          "includes": [
            "include <QVector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QVector>\n\ningBuffer\n {\n  oid append(const T &what)\n      {\n          if (appendPos_ == buf_.size()) {\n              wrapped_ = true;\n              appendPos_ = 0;\n          }\n          if (wrapped_)\n              ++skipped_;\n          buf_[appendPos_] = what;\n          ++appendPos_;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uffers.end",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uffers.find",
          "args": [
            "arser)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "FindBar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FindBar.cpp",
          "lines": "180-186",
          "snippet": "void FindBar::find(const QString & search)\n{\n    _lastStringSearched = search;\n\n    updateHighlight();\n    findNext();\n}",
          "includes": [
            "#include \"Gui/Util.h\"",
            "#include \"LineEdit.h\"",
            "#include <QWebView>",
            "#include <QWebFrame>",
            "#include <QToolButton>",
            "#include <QPushButton>",
            "#include <QLabel>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QCheckBox>",
            "#include \"FindBar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Gui/Util.h\"\n#include \"LineEdit.h\"\n#include <QWebView>\n#include <QWebFrame>\n#include <QToolButton>\n#include <QPushButton>\n#include <QLabel>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QCheckBox>\n#include \"FindBar.h\"\n\nFindBar {\n  void FindBar::find(const QString & search)\n  {\n      _lastStringSearched = search;\n  \n      updateHighlight();\n      findNext();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::slotImapLogged(uint parser, Common::LogMessage message)\n  {\n      using namespace Common;\n  \n      QMap<uint, RingBuffer<LogMessage> >::iterator bufIt = buffers.find(parser);\n      if (bufIt == buffers.end()) {\n          // FIXME: don't hard-code that\n          bufIt = buffers.insert(parser, RingBuffer<LogMessage>(900));\n      }\n      if (m_fileLogger) {\n          m_fileLogger->slotImapLogged(parser, message);\n      }\n      enum {CUTOFF=200};\n      if (message.message.size() > CUTOFF) {\n          message.truncatedBytes = message.message.size() - CUTOFF;\n          message.message = message.message.left(CUTOFF);\n      }\n      bufIt->append(message);\n      if (loggingActive && !delayedDisplay->isActive())\n          delayedDisplay->start();\n  }\n}"
  },
  {
    "function_name": "hideEvent(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "139-143",
    "snippet": "oid ProtocolLoggerWidget::hideEvent(QHideEvent *e)\n{\n    loggingActive = false;\n    QWidget::hideEvent(e);\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Widget::hideEvent(",
          "args": [
            ")"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "hideEvent(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "139-143",
          "snippet": "oid ProtocolLoggerWidget::hideEvent(QHideEvent *e)\n{\n    loggingActive = false;\n    QWidget::hideEvent(e);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::hideEvent(QHideEvent *e)\n  {\n      loggingActive = false;\n      QWidget::hideEvent(e);\n  }\n}"
  },
  {
    "function_name": "showEvent(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "132-137",
    "snippet": "oid ProtocolLoggerWidget::showEvent(QShowEvent *e)\n{\n    loggingActive = true;\n    QWidget::showEvent(e);\n    slotShowLogs();\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lotShowLogs(",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "slotShowLogs(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "233-239",
          "snippet": "oid ProtocolLoggerWidget::slotShowLogs()\n{\n    // Please note that we can't return to the event loop from this context, as the log buffer has to be read atomically\n    for (QMap<uint, Common::RingBuffer<Common::LogMessage> >::iterator it = buffers.begin(); it != buffers.end(); ++it) {\n        flushToWidget(it.key(), *it);\n    }\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::slotShowLogs()\n  {\n      // Please note that we can't return to the event loop from this context, as the log buffer has to be read atomically\n      for (QMap<uint, Common::RingBuffer<Common::LogMessage> >::iterator it = buffers.begin(); it != buffers.end(); ++it) {\n          flushToWidget(it.key(), *it);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Widget::showEvent(",
          "args": [
            ")"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "showEvent(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "132-137",
          "snippet": "oid ProtocolLoggerWidget::showEvent(QShowEvent *e)\n{\n    loggingActive = true;\n    QWidget::showEvent(e);\n    slotShowLogs();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::showEvent(QShowEvent *e)\n  {\n      loggingActive = true;\n      QWidget::showEvent(e);\n      slotShowLogs();\n  }\n}"
  },
  {
    "function_name": "clearLogDisplay(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "115-130",
    "snippet": "oid ProtocolLoggerWidget::clearLogDisplay()\n{\n    // These will be freed from the GUI\n    loggerWidgets.clear();\n\n    // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n    // so it's much better to clean up the GUI at first and only after that purge the underlying data\n    while (tabs->count()) {\n        QWidget *w = tabs->widget(0);\n        Q_ASSERT(w);\n        tabs->removeTab(0);\n        w->deleteLater();\n    }\n\n    buffers.clear();\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffers.clear",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "->deleteLater",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->removeTab",
          "args": [
            ")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            ")"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->widget",
          "args": [
            ")"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->count",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::clearLogDisplay()\n  {\n      // These will be freed from the GUI\n      loggerWidgets.clear();\n  \n      // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n      // so it's much better to clean up the GUI at first and only after that purge the underlying data\n      while (tabs->count()) {\n          QWidget *w = tabs->widget(0);\n          Q_ASSERT(w);\n          tabs->removeTab(0);\n          w->deleteLater();\n      }\n  \n      buffers.clear();\n  }\n}"
  },
  {
    "function_name": "closeTab(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "99-113",
    "snippet": "oid ProtocolLoggerWidget::closeTab(int index)\n{\n    QPlainTextEdit *w = qobject_cast<QPlainTextEdit *>(tabs->widget(index));\n    Q_ASSERT(w);\n    for (QMap<uint, QPlainTextEdit *>::iterator it = loggerWidgets.begin(); it != loggerWidgets.end(); ++it) {\n        if (*it != w)\n            continue;\n        const uint key = it.key();\n        loggerWidgets.erase(it);\n        tabs->removeTab(index);\n        w->deleteLater();\n        buffers.remove(key);\n        return;\n    }\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffers.remove",
          "args": [
            "ey)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->deleteLater",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->removeTab",
          "args": [
            "ndex)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oggerWidgets.erase",
          "args": [
            "t)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oggerWidgets.end",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oggerWidgets.begin",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            ")"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<QPlainTextEdit *>",
          "args": [
            "abs->widget(index))"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->widget",
          "args": [
            "ndex)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::closeTab(int index)\n  {\n      QPlainTextEdit *w = qobject_cast<QPlainTextEdit *>(tabs->widget(index));\n      Q_ASSERT(w);\n      for (QMap<uint, QPlainTextEdit *>::iterator it = loggerWidgets.begin(); it != loggerWidgets.end(); ++it) {\n          if (*it != w)\n              continue;\n          const uint key = it.key();\n          loggerWidgets.erase(it);\n          tabs->removeTab(index);\n          w->deleteLater();\n          buffers.remove(key);\n          return;\n      }\n  }\n}"
  },
  {
    "function_name": "~ProtocolLoggerWidget(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "73-75",
    "snippet": "rotocolLoggerWidget::~ProtocolLoggerWidget()\n{\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  rotocolLoggerWidget::~ProtocolLoggerWidget()\n  {\n  }\n}"
  },
  {
    "function_name": "slotSetPersistentLogging(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "58-71",
    "snippet": "oid ProtocolLoggerWidget::slotSetPersistentLogging(const bool enabled)\n{\n    if (enabled) {\n        if (m_fileLogger)\n            return;\n\n        m_fileLogger = new Common::FileLogger(this);\n        m_fileLogger->setFileLogging(true, Imap::Mailbox::persistentLogFileName());\n        m_fileLogger->setAutoFlush(true);\n    } else {\n        delete m_fileLogger;\n        m_fileLogger = 0;\n    }\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_fileLogger->setAutoFlush",
          "args": [
            "rue)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_fileLogger->setFileLogging",
          "args": [
            "rue,",
            "map::Mailbox::persistentLogFileName())"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Mailbox::persistentLogFileName(",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::slotSetPersistentLogging(const bool enabled)\n  {\n      if (enabled) {\n          if (m_fileLogger)\n              return;\n  \n          m_fileLogger = new Common::FileLogger(this);\n          m_fileLogger->setFileLogging(true, Imap::Mailbox::persistentLogFileName());\n          m_fileLogger->setAutoFlush(true);\n      } else {\n          delete m_fileLogger;\n          m_fileLogger = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "ProtocolLoggerWidget(",
    "container": "rotocolLoggerWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
    "lines": "38-56",
    "snippet": "rotocolLoggerWidget::ProtocolLoggerWidget(QWidget *parent) :\n    QWidget(parent), loggingActive(false), m_fileLogger(0)\n{\n    QVBoxLayout *layout = new QVBoxLayout(this);\n    tabs = new QTabWidget(this);\n    tabs->setTabsClosable(true);\n    tabs->setTabPosition(QTabWidget::South);\n    layout->addWidget(tabs);\n    connect(tabs, SIGNAL(tabCloseRequested(int)), this, SLOT(closeTab(int)));\n\n    clearAll = new QPushButton(tr(\"Clear all\"), this);\n    connect(clearAll, SIGNAL(clicked()), this, SLOT(clearLogDisplay()));\n    tabs->setCornerWidget(clearAll, Qt::BottomRightCorner);\n\n    delayedDisplay = new QTimer(this);\n    delayedDisplay->setSingleShot(true);\n    delayedDisplay->setInterval(300);\n    connect(delayedDisplay, SIGNAL(timeout()), this, SLOT(slotShowLogs()));\n}",
    "includes": [
      "include \"Imap/Model/Utils.h\"",
      "include \"Common/FileLogger.h\"\n#",
      "include \"ProtocolLoggerWidget.h\"\n#",
      "include <QVBoxLayout>\n#",
      "include <QTimer>\n#",
      "include <QTextStream>\n#",
      "include <QTabWidget>\n#",
      "include <QPushButton>\n#",
      "include <QPlainTextEdit>\n#",
      "include <QFile>\n#",
      "include <QDateTime>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "elayedDisplay,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotShowLogs()))"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotShowLogs())"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotShowLogs(",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "slotShowLogs(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "233-239",
          "snippet": "oid ProtocolLoggerWidget::slotShowLogs()\n{\n    // Please note that we can't return to the event loop from this context, as the log buffer has to be read atomically\n    for (QMap<uint, Common::RingBuffer<Common::LogMessage> >::iterator it = buffers.begin(); it != buffers.end(); ++it) {\n        flushToWidget(it.key(), *it);\n    }\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::slotShowLogs()\n  {\n      // Please note that we can't return to the event loop from this context, as the log buffer has to be read atomically\n      for (QMap<uint, Common::RingBuffer<Common::LogMessage> >::iterator it = buffers.begin(); it != buffers.end(); ++it) {\n          flushToWidget(it.key(), *it);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedDisplay->setInterval",
          "args": [
            "00)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elayedDisplay->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->setCornerWidget",
          "args": [
            "learAll,",
            "t::BottomRightCorner)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "learAll,",
            "IGNAL(clicked()),",
            "his,",
            "LOT(clearLogDisplay()))"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "learLogDisplay())"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "learLogDisplay(",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "clearLogDisplay(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "115-130",
          "snippet": "oid ProtocolLoggerWidget::clearLogDisplay()\n{\n    // These will be freed from the GUI\n    loggerWidgets.clear();\n\n    // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n    // so it's much better to clean up the GUI at first and only after that purge the underlying data\n    while (tabs->count()) {\n        QWidget *w = tabs->widget(0);\n        Q_ASSERT(w);\n        tabs->removeTab(0);\n        w->deleteLater();\n    }\n\n    buffers.clear();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::clearLogDisplay()\n  {\n      // These will be freed from the GUI\n      loggerWidgets.clear();\n  \n      // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n      // so it's much better to clean up the GUI at first and only after that purge the underlying data\n      while (tabs->count()) {\n          QWidget *w = tabs->widget(0);\n          Q_ASSERT(w);\n          tabs->removeTab(0);\n          w->deleteLater();\n      }\n  \n      buffers.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "licked())"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "licked(",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "loadClicked(",
          "container": "oadablePartWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LoadablePartWidget.cpp",
          "lines": "55-74",
          "snippet": "oid LoadablePartWidget::loadClicked()\n{\n    if (!partIndex.isValid()) {\n        if (loadButton) {\n            loadButton->setEnabled(false);\n        }\n        return;\n    }\n    if (loadButton) {\n        loadButton->deleteLater();\n        loadButton = 0;\n    }\n\n    // We have to disable any flags which might cause recursion here\n    realPart = m_factory->create(partIndex, m_recursionDepth + 1,\n                                 (m_loadingMode | PartWidgetFactory::PART_IGNORE_CLICKTHROUGH\n                                  | PartWidgetFactory::PART_IGNORE_LOAD_ON_SHOW) ^ PartWidgetFactory::PART_IS_HIDDEN);\n    addWidget(realPart);\n    setCurrentIndex(1);\n}",
          "includes": [
            "include <QPushButton>",
            "include \"Imap/Model/Utils.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Gui/MessageView.h\" // so that the compiler knows that it's a QObject\n#",
            "include \"LoadablePartWidget.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QPushButton>\ninclude \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Gui/MessageView.h\" // so that the compiler knows that it's a QObject\n#\ninclude \"LoadablePartWidget.h\"\n#\n\noadablePartWidget {\n  oid LoadablePartWidget::loadClicked()\n  {\n      if (!partIndex.isValid()) {\n          if (loadButton) {\n              loadButton->setEnabled(false);\n          }\n          return;\n      }\n      if (loadButton) {\n          loadButton->deleteLater();\n          loadButton = 0;\n      }\n  \n      // We have to disable any flags which might cause recursion here\n      realPart = m_factory->create(partIndex, m_recursionDepth + 1,\n                                   (m_loadingMode | PartWidgetFactory::PART_IGNORE_CLICKTHROUGH\n                                    | PartWidgetFactory::PART_IGNORE_LOAD_ON_SHOW) ^ PartWidgetFactory::PART_IS_HIDDEN);\n      addWidget(realPart);\n      setCurrentIndex(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Clear all\")"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "Spinner(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "36-41",
          "snippet": "pinner::Spinner(QWidget *parent) : QWidget(parent), m_step(0), m_fadeStep(0), m_timer(0),\n                                    m_startTimer(0), m_textCols(0), m_type(Sun), m_geometryDirty(false)\n{\n    updateAncestors();\n    hide();\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  pinner::Spinner(QWidget *parent) : QWidget(parent), m_step(0), m_fadeStep(0), m_timer(0),\n                                      m_startTimer(0), m_textCols(0), m_type(Sun), m_geometryDirty(false)\n  {\n      updateAncestors();\n      hide();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ayout->addWidget",
          "args": [
            "abs)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->setTabPosition",
          "args": [
            "TabWidget::South)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs->setTabsClosable",
          "args": [
            "rue)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  rotocolLoggerWidget::ProtocolLoggerWidget(QWidget *parent) :\n      QWidget(parent), loggingActive(false), m_fileLogger(0)\n  {\n      QVBoxLayout *layout = new QVBoxLayout(this);\n      tabs = new QTabWidget(this);\n      tabs->setTabsClosable(true);\n      tabs->setTabPosition(QTabWidget::South);\n      layout->addWidget(tabs);\n      connect(tabs, SIGNAL(tabCloseRequested(int)), this, SLOT(closeTab(int)));\n  \n      clearAll = new QPushButton(tr(\"Clear all\"), this);\n      connect(clearAll, SIGNAL(clicked()), this, SLOT(clearLogDisplay()));\n      tabs->setCornerWidget(clearAll, Qt::BottomRightCorner);\n  \n      delayedDisplay = new QTimer(this);\n      delayedDisplay->setSingleShot(true);\n      delayedDisplay->setInterval(300);\n      connect(delayedDisplay, SIGNAL(timeout()), this, SLOT(slotShowLogs()));\n  }\n}"
  }
]