[
  {
    "function_name": "writtenStuff(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "130-136",
    "snippet": "ByteArray FakeSocket::writtenStuff()\n{\n    QByteArray res = w;\n    w.clear();\n    writeChannel->seek(0);\n    return res;\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "riteChannel->seek",
          "args": [
            ")"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".clear",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "clearLogDisplay(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "115-130",
          "snippet": "oid ProtocolLoggerWidget::clearLogDisplay()\n{\n    // These will be freed from the GUI\n    loggerWidgets.clear();\n\n    // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n    // so it's much better to clean up the GUI at first and only after that purge the underlying data\n    while (tabs->count()) {\n        QWidget *w = tabs->widget(0);\n        Q_ASSERT(w);\n        tabs->removeTab(0);\n        w->deleteLater();\n    }\n\n    buffers.clear();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::clearLogDisplay()\n  {\n      // These will be freed from the GUI\n      loggerWidgets.clear();\n  \n      // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n      // so it's much better to clean up the GUI at first and only after that purge the underlying data\n      while (tabs->count()) {\n          QWidget *w = tabs->widget(0);\n          Q_ASSERT(w);\n          tabs->removeTab(0);\n          w->deleteLater();\n      }\n  \n      buffers.clear();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ByteArray FakeSocket::writtenStuff()\n  {\n      QByteArray res = w;\n      w.clear();\n      writeChannel->seek(0);\n      return res;\n  }\n}"
  },
  {
    "function_name": "close(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "124-128",
    "snippet": "oid FakeSocket::close()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** close ***]\"));\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "riteChannel->write",
          "args": [
            "ByteArray(\"[*** close ***]\"))"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "[*** close ***]\")"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::close()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** close ***]\"));\n  }\n}"
  },
  {
    "function_name": "isDead(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "118-122",
    "snippet": "ool FakeSocket::isDead()\n{\n    // Can't really die (yet)\n    return false;\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ool FakeSocket::isDead()\n  {\n      // Can't really die (yet)\n      return false;\n  }\n}"
  },
  {
    "function_name": "startDeflate(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "112-116",
    "snippet": "oid FakeSocket::startDeflate()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** DEFLATE ***]\"));\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "riteChannel->write",
          "args": [
            "ByteArray(\"[*** DEFLATE ***]\"))"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "[*** DEFLATE ***]\")"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::startDeflate()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** DEFLATE ***]\"));\n  }\n}"
  },
  {
    "function_name": "startTls(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "105-110",
    "snippet": "oid FakeSocket::startTls()\n{\n    // fake it\n    writeChannel->write(QByteArray(\"[*** STARTTLS ***]\"));\n    QTimer::singleShot(0, this, SLOT(slotEmitEncrypted()));\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(slotEmitEncrypted()))"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotEmitEncrypted())"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotEmitEncrypted(",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "slotEmitEncrypted(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "57-60",
          "snippet": "oid FakeSocket::slotEmitEncrypted()\n{\n    emit encrypted();\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::slotEmitEncrypted()\n  {\n      emit encrypted();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "riteChannel->write",
          "args": [
            "ByteArray(\"[*** STARTTLS ***]\"))"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [
            "[*** STARTTLS ***]\")"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "htmlHexifyByteArray(",
          "container": "ertificateUtils",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "321-337",
          "snippet": "ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n{\n    QByteArray inHex = rawInput.toHex();\n    QByteArray res;\n    const int stepping = 4;\n    for (int i = 0; i < inHex.length(); i += stepping) {\n        // The individual blocks are formatted separately to allow line breaks to happen\n        res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n        res.append(inHex.mid(i, stepping));\n        if (i + stepping < inHex.size()) {\n            res.append(\":\");\n        }\n        // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n        res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n    }\n    return res;\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nertificateUtils {\n  ByteArray CertificateUtils::htmlHexifyByteArray(const QByteArray &rawInput)\n  {\n      QByteArray inHex = rawInput.toHex();\n      QByteArray res;\n      const int stepping = 4;\n      for (int i = 0; i < inHex.length(); i += stepping) {\n          // The individual blocks are formatted separately to allow line breaks to happen\n          res.append(\"<code style=\\\"font-family: monospace;\\\">\");\n          res.append(inHex.mid(i, stepping));\n          if (i + stepping < inHex.size()) {\n              res.append(\":\");\n          }\n          // Produce the smallest possible space. \"display: none\" won't notice the space at all, leading to overly long lines\n          res.append(\"</code><span style=\\\"font-size: 1px\\\"> </span>\");\n      }\n      return res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::startTls()\n  {\n      // fake it\n      writeChannel->write(QByteArray(\"[*** STARTTLS ***]\"));\n      QTimer::singleShot(0, this, SLOT(slotEmitEncrypted()));\n  }\n}"
  },
  {
    "function_name": "write(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "100-103",
    "snippet": "int64 FakeSocket::write(const QByteArray &byteArray)\n{\n    return writeChannel->write(byteArray);\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "riteChannel->write",
          "args": [
            "yteArray)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  int64 FakeSocket::write(const QByteArray &byteArray)\n  {\n      return writeChannel->write(byteArray);\n  }\n}"
  },
  {
    "function_name": "readLine(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "95-98",
    "snippet": "ByteArray FakeSocket::readLine(qint64 maxSize)\n{\n    return readChannel->readLine(maxSize);\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eadChannel->readLine",
          "args": [
            "axSize)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ByteArray FakeSocket::readLine(qint64 maxSize)\n  {\n      return readChannel->readLine(maxSize);\n  }\n}"
  },
  {
    "function_name": "read(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "90-93",
    "snippet": "ByteArray FakeSocket::read(qint64 maxSize)\n{\n    return readChannel->read(maxSize);\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eadChannel->read",
          "args": [
            "axSize)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ByteArray FakeSocket::read(qint64 maxSize)\n  {\n      return readChannel->read(maxSize);\n  }\n}"
  },
  {
    "function_name": "canReadLine(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "85-88",
    "snippet": "ool FakeSocket::canReadLine()\n{\n    return readChannel->canReadLine();\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eadChannel->canReadLine",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  ool FakeSocket::canReadLine()\n  {\n      return readChannel->canReadLine();\n  }\n}"
  },
  {
    "function_name": "fakeReading(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "62-83",
    "snippet": "oid FakeSocket::fakeReading(const QByteArray &what)\n{\n    // The position of the cursor is shared for both reading and writing, and therefore\n    // we have to save and restore it after appending data, otherwise the pointer will\n    // be left scrolled to after the actual data, failing further attempts to read the\n    // data back. It's pretty obvious when you think about it, but took sime time to\n    // debug nevertheless :).\n    qint64 pos = readChannel->pos();\n    if (pos > 1024 * 1024) {\n        // There's too much stale data in the socket already, let's cut it\n        QByteArray unProcessedData = readChannel->readAll();\n        r.clear();\n        readChannel->close();\n        static_cast<QBuffer *>(readChannel)->setBuffer(&r);\n        readChannel->open(QIODevice::ReadWrite);\n        readChannel->write(unProcessedData);\n        pos = unProcessedData.size();\n    }\n    readChannel->seek(r.size());\n    readChannel->write(what);\n    readChannel->seek(pos);\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eadChannel->seek",
          "args": [
            "os)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->write",
          "args": [
            "hat)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->seek",
          "args": [
            ".size())"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".size",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "sizeHint",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "131-134",
          "snippet": "QSize FlowLayout::sizeHint() const\n{\n    return minimumSize();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  QSize FlowLayout::sizeHint() const\n  {\n      return minimumSize();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nProcessedData.size",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->write",
          "args": [
            "nProcessedData)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->open",
          "args": [
            "IODevice::ReadWrite)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<QBuffer *>",
          "args": [
            "r)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<QBuffer *>",
          "args": [
            "eadChannel)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->close",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".clear",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "clearLogDisplay(",
          "container": "rotocolLoggerWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ProtocolLoggerWidget.cpp",
          "lines": "115-130",
          "snippet": "oid ProtocolLoggerWidget::clearLogDisplay()\n{\n    // These will be freed from the GUI\n    loggerWidgets.clear();\n\n    // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n    // so it's much better to clean up the GUI at first and only after that purge the underlying data\n    while (tabs->count()) {\n        QWidget *w = tabs->widget(0);\n        Q_ASSERT(w);\n        tabs->removeTab(0);\n        w->deleteLater();\n    }\n\n    buffers.clear();\n}",
          "includes": [
            "include \"Imap/Model/Utils.h\"",
            "include \"Common/FileLogger.h\"\n#",
            "include \"ProtocolLoggerWidget.h\"\n#",
            "include <QVBoxLayout>\n#",
            "include <QTimer>\n#",
            "include <QTextStream>\n#",
            "include <QTabWidget>\n#",
            "include <QPushButton>\n#",
            "include <QPlainTextEdit>\n#",
            "include <QFile>\n#",
            "include <QDateTime>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/Utils.h\"\ninclude \"Common/FileLogger.h\"\n#\ninclude \"ProtocolLoggerWidget.h\"\n#\ninclude <QVBoxLayout>\n#\ninclude <QTimer>\n#\ninclude <QTextStream>\n#\ninclude <QTabWidget>\n#\ninclude <QPushButton>\n#\ninclude <QPlainTextEdit>\n#\ninclude <QFile>\n#\ninclude <QDateTime>\n#\n\nrotocolLoggerWidget {\n  oid ProtocolLoggerWidget::clearLogDisplay()\n  {\n      // These will be freed from the GUI\n      loggerWidgets.clear();\n  \n      // We use very different indexing internally, to an extent where QTabWidget's ints are not easily obtainable from that,\n      // so it's much better to clean up the GUI at first and only after that purge the underlying data\n      while (tabs->count()) {\n          QWidget *w = tabs->widget(0);\n          Q_ASSERT(w);\n          tabs->removeTab(0);\n          w->deleteLater();\n      }\n  \n      buffers.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eadChannel->readAll",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->pos",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::fakeReading(const QByteArray &what)\n  {\n      // The position of the cursor is shared for both reading and writing, and therefore\n      // we have to save and restore it after appending data, otherwise the pointer will\n      // be left scrolled to after the actual data, failing further attempts to read the\n      // data back. It's pretty obvious when you think about it, but took sime time to\n      // debug nevertheless :).\n      qint64 pos = readChannel->pos();\n      if (pos > 1024 * 1024) {\n          // There's too much stale data in the socket already, let's cut it\n          QByteArray unProcessedData = readChannel->readAll();\n          r.clear();\n          readChannel->close();\n          static_cast<QBuffer *>(readChannel)->setBuffer(&r);\n          readChannel->open(QIODevice::ReadWrite);\n          readChannel->write(unProcessedData);\n          pos = unProcessedData.size();\n      }\n      readChannel->seek(r.size());\n      readChannel->write(what);\n      readChannel->seek(pos);\n  }\n}"
  },
  {
    "function_name": "slotEmitEncrypted(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "57-60",
    "snippet": "oid FakeSocket::slotEmitEncrypted()\n{\n    emit encrypted();\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::slotEmitEncrypted()\n  {\n      emit encrypted();\n  }\n}"
  },
  {
    "function_name": "slotEmitConnected(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "43-55",
    "snippet": "oid FakeSocket::slotEmitConnected()\n{\n    if (m_initialState == Imap::CONN_STATE_LOGOUT) {\n        // Special case: a fake socket factory for unconfigured accounts.\n        emit disconnected(QString());\n        return;\n    }\n\n    // We have to use both conventions for letting the world know that \"we're finally usable\"\n    if (m_initialState != Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS)\n        emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, QString());\n    emit stateChanged(m_initialState, QString());\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tateChanged(",
          "args": [
            "map::CONN_STATE_CONNECTED_PRETLS_PRECAPS,",
            "String())"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "slotSocketStateChanged(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "1157-1172",
          "snippet": "oid Parser::slotSocketStateChanged(const Imap::ConnectionState connState, const QString &message)\n{\n    if (connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n#ifdef PRINT_TRAFFIC_TX\n        qDebug() << m_parserId << \"*** Connection established\";\n#endif\n        emit lineReceived(this, \"*** Connection established\");\n        waitingForConnection = false;\n        QTimer::singleShot(0, this, SLOT(executeCommands()));\n    } else if (connState == CONN_STATE_AUTHENTICATED) {\n        // unit tests: don't wait for the initial untagged response greetings\n        m_expectsInitialGreeting = false;\n    }\n    emit lineReceived(this, \"*** \" + message.toUtf8());\n    emit connectionStateChanged(this, connState);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::slotSocketStateChanged(const Imap::ConnectionState connState, const QString &message)\n  {\n      if (connState == CONN_STATE_CONNECTED_PRETLS_PRECAPS) {\n  #ifdef PRINT_TRAFFIC_TX\n          qDebug() << m_parserId << \"*** Connection established\";\n  #endif\n          emit lineReceived(this, \"*** Connection established\");\n          waitingForConnection = false;\n          QTimer::singleShot(0, this, SLOT(executeCommands()));\n      } else if (connState == CONN_STATE_AUTHENTICATED) {\n          // unit tests: don't wait for the initial untagged response greetings\n          m_expectsInitialGreeting = false;\n      }\n      emit lineReceived(this, \"*** \" + message.toUtf8());\n      emit connectionStateChanged(this, connState);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::slotEmitConnected()\n  {\n      if (m_initialState == Imap::CONN_STATE_LOGOUT) {\n          // Special case: a fake socket factory for unconfigured accounts.\n          emit disconnected(QString());\n          return;\n      }\n  \n      // We have to use both conventions for letting the world know that \"we're finally usable\"\n      if (m_initialState != Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS)\n          emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, QString());\n      emit stateChanged(m_initialState, QString());\n  }\n}"
  },
  {
    "function_name": "~FakeSocket(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "39-41",
    "snippet": "akeSocket::~FakeSocket()\n{\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  akeSocket::~FakeSocket()\n  {\n  }\n}"
  },
  {
    "function_name": "FakeSocket(",
    "container": "akeSocket",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
    "lines": "29-37",
    "snippet": "akeSocket::FakeSocket(const Imap::ConnectionState initialState): m_initialState(initialState)\n{\n    readChannel = new QBuffer(&r, this);\n    readChannel->open(QIODevice::ReadWrite);\n    writeChannel = new QBuffer(&w, this);\n    writeChannel->open(QIODevice::WriteOnly);\n    QTimer::singleShot(0, this, SLOT(slotEmitConnected()));\n    connect(readChannel, SIGNAL(readyRead()), this, SIGNAL(readyRead()));\n}",
    "includes": [
      "include \"FakeSocket.h\"",
      "include <QTimer>\n#",
      "include <QBuffer>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "eadChannel,",
            "IGNAL(readyRead()),",
            "his,",
            "IGNAL(readyRead()))"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "eadyRead())"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadyRead(",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "handleReadyRead(",
          "container": "ODeviceSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/IODeviceSocket.cpp",
          "lines": "124-132",
          "snippet": "oid IODeviceSocket::handleReadyRead()\n{\n#if TROJITA_COMPRESS_DEFLATE\n    if (m_decompressor) {\n        m_decompressor->consume(d);\n    }\n#endif\n    emit readyRead();\n}",
          "includes": [
            "include \"3rdparty/rfc1951.h\"\n#",
            "include \"TrojitaZlibStatus.h\"\n#",
            "include <QTimer>\n#",
            "include <QSslSocket>\n#",
            "include <QSslConfiguration>\n#",
            "include <QNetworkProxyQuery>\n#",
            "include <QNetworkProxyFactory>\n#",
            "include <QNetworkProxy>\n#",
            "include <stdexcept>\n#",
            "include \"IODeviceSocket.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"3rdparty/rfc1951.h\"\n#\ninclude \"TrojitaZlibStatus.h\"\n#\ninclude <QTimer>\n#\ninclude <QSslSocket>\n#\ninclude <QSslConfiguration>\n#\ninclude <QNetworkProxyQuery>\n#\ninclude <QNetworkProxyFactory>\n#\ninclude <QNetworkProxy>\n#\ninclude <stdexcept>\n#\ninclude \"IODeviceSocket.h\"\n#\n\nODeviceSocket {\n  oid IODeviceSocket::handleReadyRead()\n  {\n  #if TROJITA_COMPRESS_DEFLATE\n      if (m_decompressor) {\n          m_decompressor->consume(d);\n      }\n  #endif\n      emit readyRead();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "eadyRead())"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(slotEmitConnected()))"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotEmitConnected())"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotEmitConnected(",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "slotEmitConnected(",
          "container": "akeSocket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Streams/FakeSocket.cpp",
          "lines": "43-55",
          "snippet": "oid FakeSocket::slotEmitConnected()\n{\n    if (m_initialState == Imap::CONN_STATE_LOGOUT) {\n        // Special case: a fake socket factory for unconfigured accounts.\n        emit disconnected(QString());\n        return;\n    }\n\n    // We have to use both conventions for letting the world know that \"we're finally usable\"\n    if (m_initialState != Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS)\n        emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, QString());\n    emit stateChanged(m_initialState, QString());\n}",
          "includes": [
            "include \"FakeSocket.h\"",
            "include <QTimer>\n#",
            "include <QBuffer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  oid FakeSocket::slotEmitConnected()\n  {\n      if (m_initialState == Imap::CONN_STATE_LOGOUT) {\n          // Special case: a fake socket factory for unconfigured accounts.\n          emit disconnected(QString());\n          return;\n      }\n  \n      // We have to use both conventions for letting the world know that \"we're finally usable\"\n      if (m_initialState != Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS)\n          emit stateChanged(Imap::CONN_STATE_CONNECTED_PRETLS_PRECAPS, QString());\n      emit stateChanged(m_initialState, QString());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "riteChannel->open",
          "args": [
            "IODevice::WriteOnly)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eadChannel->open",
          "args": [
            "IODevice::ReadWrite)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"FakeSocket.h\"\ninclude <QTimer>\n#\ninclude <QBuffer>\n#\n\nakeSocket {\n  akeSocket::FakeSocket(const Imap::ConnectionState initialState): m_initialState(initialState)\n  {\n      readChannel = new QBuffer(&r, this);\n      readChannel->open(QIODevice::ReadWrite);\n      writeChannel = new QBuffer(&w, this);\n      writeChannel->open(QIODevice::WriteOnly);\n      QTimer::singleShot(0, this, SLOT(slotEmitConnected()));\n      connect(readChannel, SIGNAL(readyRead()), this, SIGNAL(readyRead()));\n  }\n}"
  }
]