[
  {
    "function_name": "writeSettings()",
    "container": "ortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "294-313",
    "snippet": "id ShortcutConfigWidget::writeSettings()\n{\n    QSettings *settings = ShortcutHandler::instance()->settingsObject();\n    Q_ASSERT_X(settings, \"ShortcutHandler\", \"no QSettings object found: a settings object should first be set using setSettingsObject() and then readSettings() should be called when initializing your program; note that this QSettings object should exist during the entire lifetime of the ShortcutHandler object and therefore not be deleted first\");\n    Common::SettingsCategoryGuard guard(settings, QLatin1String(\"ShortcutHandler\"));\n    settings->remove(QString());\n    settings->beginWriteArray(QLatin1String(\"Shortcuts\"));\n    int index = 0;\n    for (QHash<QString, ActionDescription>::const_iterator it = m_actionDescriptions.constBegin(); it != m_actionDescriptions.constEnd(); ++it) {\n        ActionDescription actionDescription = it.value();\n        const QString shortcut = actionDescription.shortcut;\n        if (shortcut != actionDescription.defaultShortcut) {\n            settings->setArrayIndex(index);\n            settings->setValue(QLatin1String(\"Action\"), it.key());\n            settings->setValue(QLatin1String(\"Shortcut\"), actionDescription.shortcut);\n            ++index;\n        }\n    }\n    settings->endArray();\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ttings->endArray",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttings->setValue",
          "args": [
            "atin1String(\"Shortcut\"),",
            "tionDescription.shortcut);"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "hortcut\"),"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttings->setValue",
          "args": [
            "atin1String(\"Action\"),",
            ".key());"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".key",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "ction\"),"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttings->setArrayIndex",
          "args": [
            "dex);"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".value",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "actionDescriptions.constEnd",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actionDescriptions.constBegin",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttings->beginWriteArray",
          "args": [
            "atin1String(\"Shortcuts\"));"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "hortcuts\"))"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttings->remove",
          "args": [
            "tring());"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atin1String(\"",
          "args": [
            "hortcutHandler\"))"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_X(s",
          "args": [
            "ttings,",
            "hortcutHandler\",",
            "o QSettings object found: a settings object should first be set using setSettingsObject() and then readSettings() should be called when initializing your program; note that this QSettings object should exist during the entire lifetime of the ShortcutHandler object and therefore not be deleted first\");"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortcutHandler::instance",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortcutHandler::instance()",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::writeSettings()\n  {\n      QSettings *settings = ShortcutHandler::instance()->settingsObject();\n      Q_ASSERT_X(settings, \"ShortcutHandler\", \"no QSettings object found: a settings object should first be set using setSettingsObject() and then readSettings() should be called when initializing your program; note that this QSettings object should exist during the entire lifetime of the ShortcutHandler object and therefore not be deleted first\");\n      Common::SettingsCategoryGuard guard(settings, QLatin1String(\"ShortcutHandler\"));\n      settings->remove(QString());\n      settings->beginWriteArray(QLatin1String(\"Shortcuts\"));\n      int index = 0;\n      for (QHash<QString, ActionDescription>::const_iterator it = m_actionDescriptions.constBegin(); it != m_actionDescriptions.constEnd(); ++it) {\n          ActionDescription actionDescription = it.value();\n          const QString shortcut = actionDescription.shortcut;\n          if (shortcut != actionDescription.defaultShortcut) {\n              settings->setArrayIndex(index);\n              settings->setValue(QLatin1String(\"Action\"), it.key());\n              settings->setValue(QLatin1String(\"Shortcut\"), actionDescription.shortcut);\n              ++index;\n          }\n      }\n      settings->endArray();\n  }\n}"
  },
  {
    "function_name": "showEvent(Q",
    "container": "ortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "281-287",
    "snippet": "id ShortcutConfigWidget::showEvent(QShowEvent *event)\n{\n    Q_UNUSED(event);\n    reject(); // restore unsaved shortcuts in the tree widget before the configuration dialog is shown again\n    m_shortcutsShouldBeRestored = true;\n    ui.shortcutTreeWidget->sortByColumn(0, Qt::AscendingOrder);\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->sortByColumn",
          "args": [
            "::AscendingOrder);"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ject()",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "reject()",
          "container": "ortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "262-279",
          "snippet": "id ShortcutConfigWidget::reject()\n{\n    if (!m_shortcutsShouldBeRestored)\n        return;\n\n    // restore unsaved shortcuts in the tree widget\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            const QString actionName = childItem->data(1, Qt::UserRole).toString();\n            childItem->setText(1, m_actionDescriptions[actionName].shortcut);\n        }\n    }\n    m_shortcutsShouldBeRestored = false;\n}",
          "includes": [
            "#include \"Common/SettingsCategoryGuard.h\"",
            "#include \"ShortcutHandler.h\"",
            "#include \"IconLoader.h\"",
            "#include <QSettings>",
            "#include <QMessageBox>",
            "#include <QKeyEvent>",
            "#include \"ShortcutConfigWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::reject()\n  {\n      if (!m_shortcutsShouldBeRestored)\n          return;\n  \n      // restore unsaved shortcuts in the tree widget\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          const int childCount = topLevelItem->childCount();\n          for (int j = 0; j < childCount; ++j) {\n              QTreeWidgetItem *childItem = topLevelItem->child(j);\n              const QString actionName = childItem->data(1, Qt::UserRole).toString();\n              childItem->setText(1, m_actionDescriptions[actionName].shortcut);\n          }\n      }\n      m_shortcutsShouldBeRestored = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UNUSED(e",
          "args": [
            "ent);"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::showEvent(QShowEvent *event)\n  {\n      Q_UNUSED(event);\n      reject(); // restore unsaved shortcuts in the tree widget before the configuration dialog is shown again\n      m_shortcutsShouldBeRestored = true;\n      ui.shortcutTreeWidget->sortByColumn(0, Qt::AscendingOrder);\n  }\n}"
  },
  {
    "function_name": "reject()",
    "container": "ortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "262-279",
    "snippet": "id ShortcutConfigWidget::reject()\n{\n    if (!m_shortcutsShouldBeRestored)\n        return;\n\n    // restore unsaved shortcuts in the tree widget\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            const QString actionName = childItem->data(1, Qt::UserRole).toString();\n            childItem->setText(1, m_actionDescriptions[actionName].shortcut);\n        }\n    }\n    m_shortcutsShouldBeRestored = false;\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ildItem->setText",
          "args": [
            "actionDescriptions[actionName].shortcut);"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ildItem->data",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ildItem->data",
          "args": [
            "::UserRole)."
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pLevelItem->child",
          "args": [
            ";"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pLevelItem->childCount",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->topLevelItem",
          "args": [
            ";"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->topLevelItemCount",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::reject()\n  {\n      if (!m_shortcutsShouldBeRestored)\n          return;\n  \n      // restore unsaved shortcuts in the tree widget\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          const int childCount = topLevelItem->childCount();\n          for (int j = 0; j < childCount; ++j) {\n              QTreeWidgetItem *childItem = topLevelItem->child(j);\n              const QString actionName = childItem->data(1, Qt::UserRole).toString();\n              childItem->setText(1, m_actionDescriptions[actionName].shortcut);\n          }\n      }\n      m_shortcutsShouldBeRestored = false;\n  }\n}"
  },
  {
    "function_name": "accept()",
    "container": "ortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "245-260",
    "snippet": "id ShortcutConfigWidget::accept()\n{\n    // set shortcuts for real (but they are not yet saved in the settings on disk, this is done in writeSettings())\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            const QString actionName = childItem->data(1, Qt::UserRole).toString();\n            m_actionDescriptions[actionName].shortcut = childItem->text(1);\n        }\n    }\n    writeSettings();\n    Q_EMIT(shortcutsChanged(m_actionDescriptions));\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EMIT(s",
          "args": [
            "ortcutsChanged(m_actionDescriptions));"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortcutsChanged(m",
          "args": [
            "actionDescriptions))"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iteSettings()",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "writeSettings()",
          "container": "ortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "294-313",
          "snippet": "id ShortcutConfigWidget::writeSettings()\n{\n    QSettings *settings = ShortcutHandler::instance()->settingsObject();\n    Q_ASSERT_X(settings, \"ShortcutHandler\", \"no QSettings object found: a settings object should first be set using setSettingsObject() and then readSettings() should be called when initializing your program; note that this QSettings object should exist during the entire lifetime of the ShortcutHandler object and therefore not be deleted first\");\n    Common::SettingsCategoryGuard guard(settings, QLatin1String(\"ShortcutHandler\"));\n    settings->remove(QString());\n    settings->beginWriteArray(QLatin1String(\"Shortcuts\"));\n    int index = 0;\n    for (QHash<QString, ActionDescription>::const_iterator it = m_actionDescriptions.constBegin(); it != m_actionDescriptions.constEnd(); ++it) {\n        ActionDescription actionDescription = it.value();\n        const QString shortcut = actionDescription.shortcut;\n        if (shortcut != actionDescription.defaultShortcut) {\n            settings->setArrayIndex(index);\n            settings->setValue(QLatin1String(\"Action\"), it.key());\n            settings->setValue(QLatin1String(\"Shortcut\"), actionDescription.shortcut);\n            ++index;\n        }\n    }\n    settings->endArray();\n}",
          "includes": [
            "#include \"Common/SettingsCategoryGuard.h\"",
            "#include \"ShortcutHandler.h\"",
            "#include \"IconLoader.h\"",
            "#include <QSettings>",
            "#include <QMessageBox>",
            "#include <QKeyEvent>",
            "#include \"ShortcutConfigWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::writeSettings()\n  {\n      QSettings *settings = ShortcutHandler::instance()->settingsObject();\n      Q_ASSERT_X(settings, \"ShortcutHandler\", \"no QSettings object found: a settings object should first be set using setSettingsObject() and then readSettings() should be called when initializing your program; note that this QSettings object should exist during the entire lifetime of the ShortcutHandler object and therefore not be deleted first\");\n      Common::SettingsCategoryGuard guard(settings, QLatin1String(\"ShortcutHandler\"));\n      settings->remove(QString());\n      settings->beginWriteArray(QLatin1String(\"Shortcuts\"));\n      int index = 0;\n      for (QHash<QString, ActionDescription>::const_iterator it = m_actionDescriptions.constBegin(); it != m_actionDescriptions.constEnd(); ++it) {\n          ActionDescription actionDescription = it.value();\n          const QString shortcut = actionDescription.shortcut;\n          if (shortcut != actionDescription.defaultShortcut) {\n              settings->setArrayIndex(index);\n              settings->setValue(QLatin1String(\"Action\"), it.key());\n              settings->setValue(QLatin1String(\"Shortcut\"), actionDescription.shortcut);\n              ++index;\n          }\n      }\n      settings->endArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ildItem->text",
          "args": [
            ";"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ildItem->data",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ildItem->data",
          "args": [
            "::UserRole)."
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pLevelItem->child",
          "args": [
            ";"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pLevelItem->childCount",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->topLevelItem",
          "args": [
            ";"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->topLevelItemCount",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::accept()\n  {\n      // set shortcuts for real (but they are not yet saved in the settings on disk, this is done in writeSettings())\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          const int childCount = topLevelItem->childCount();\n          for (int j = 0; j < childCount; ++j) {\n              QTreeWidgetItem *childItem = topLevelItem->child(j);\n              const QString actionName = childItem->data(1, Qt::UserRole).toString();\n              m_actionDescriptions[actionName].shortcut = childItem->text(1);\n          }\n      }\n      writeSettings();\n      Q_EMIT(shortcutsChanged(m_actionDescriptions));\n  }\n}"
  },
  {
    "function_name": "restoreDefaultShortcut()",
    "container": "ortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "234-241",
    "snippet": "id ShortcutConfigWidget::restoreDefaultShortcut()\n{\n    QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n    const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n    if (actionName.isEmpty())\n        return;\n    currentItem->setText(1, m_actionDescriptions[actionName].defaultShortcut);\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rrentItem->setText",
          "args": [
            "actionDescriptions[actionName].defaultShortcut);"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tionName.isEmpty",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrentItem->data",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrentItem->data",
          "args": [
            "::UserRole)."
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->currentItem",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::restoreDefaultShortcut()\n  {\n      QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n      const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n      if (actionName.isEmpty())\n          return;\n      currentItem->setText(1, m_actionDescriptions[actionName].defaultShortcut);\n  }\n}"
  },
  {
    "function_name": "clearShortcut()",
    "container": "ortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "225-232",
    "snippet": "id ShortcutConfigWidget::clearShortcut()\n{\n    QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n    const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n    if (actionName.isEmpty())\n        return;\n    currentItem->setText(1, QString());\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rrentItem->setText",
          "args": [
            "tring());"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tionName.isEmpty",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrentItem->data",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rrentItem->data",
          "args": [
            "::UserRole)."
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".shortcutTreeWidget->currentItem",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::clearShortcut()\n  {\n      QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n      const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n      if (actionName.isEmpty())\n          return;\n      currentItem->setText(1, QString());\n  }\n}"
  },
  {
    "function_name": "eventFilter(",
    "container": "hortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "155-223",
    "snippet": "ool ShortcutConfigWidget::eventFilter(QObject *obj, QEvent *event)\n{\n    Q_UNUSED(obj);\n    if (event->type() != QEvent::KeyPress)\n        return false;\n\n    QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);\n    QString keySequence;\n    // don't allow modifiers to be handled as single keys and skip CapsLock and NumLock\n    if (keyEvent->key() == Qt::Key_Control || keyEvent->key() == Qt::Key_Shift\n            || keyEvent->key() == Qt::Key_Meta || keyEvent->key() == Qt::Key_Alt\n            || keyEvent->key() == Qt::Key_Super_L || keyEvent->key() == Qt::Key_AltGr\n            || keyEvent->key() == Qt::Key_CapsLock || keyEvent->key() == Qt::Key_NumLock)\n        return false;\n    // skip some particular keys (note that Qt::Key_Up and friends are used to navigate the list, in order to avoid that they interfere with the shortcut changing, we skip them)\n    if (keyEvent->modifiers() == Qt::NoModifier\n            && (keyEvent->key() == Qt::Key_Up || keyEvent->key() == Qt::Key_Down\n                || keyEvent->key() == Qt::Key_Left || keyEvent->key() == Qt::Key_Right\n                || keyEvent->key() == Qt::Key_PageUp || keyEvent->key() == Qt::Key_PageDown\n                || keyEvent->key() == Qt::Key_Tab || keyEvent->key() == Qt::Key_Backtab\n                || keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Escape))\n        return false;\n    if (keyEvent->key() == Qt::Key_Backtab) // the above doesn't catch \"Shift+Tab\"\n        return false;\n\n    // create string representation of the new shortcut\n    if (keyEvent->modifiers() & Qt::ControlModifier)\n        keySequence += tr(\"Ctrl+\", \"Shortcut modifier\");\n    if (keyEvent->modifiers() & Qt::AltModifier)\n        keySequence += tr(\"Alt+\", \"Shortcut modifier\");\n    if (keyEvent->modifiers() & Qt::ShiftModifier)\n        keySequence += tr(\"Shift+\", \"Shortcut modifier\");\n    keySequence += QKeySequence(keyEvent->key()).toString(QKeySequence::PortableText);\n\n    // replace shortcut in the list (but not yet for real, this is done when the user accepts the dialog)\n    QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n    if (!currentItem) // this is the case when ui.shortcutTreeWidget is empty\n        return false;\n    const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n    if (actionName.isEmpty()) // this is the case when a toplevel item is selected\n        return false;\n    // test whether the new shortcut is already defined for another action, if yes then ask the user to set an empty shortcut for the old action\n    const QVariant parentId = currentItem->parent()->data(1, Qt::UserRole);\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        if (topLevelItem->data(1, Qt::UserRole) != parentId) // only deal with actions in the same exclusivity group\n            continue;\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            if (keySequence == childItem->text(1) && childItem->data(1, Qt::UserRole).toString() != actionName) {\n                QMessageBox::StandardButton result = QMessageBox::warning(this,\n                                                     tr(\"Shortcut Conflicts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"),\n                                                     tr(\"<p>The \\\"%1\\\" shortcut is ambiguous with the following shortcut:</p>\"\n                                                        \"<p>%2</p><p>Do you want to assign an empty shortcut to this action?</p>\")\n                                                     .arg(keySequence).arg(childItem->text(0)),\n                                                     QMessageBox::Ok | QMessageBox::Cancel, QMessageBox::Ok);\n                if (result == QMessageBox::Ok)\n                    childItem->setText(1, QString());\n                else\n                    return false;\n            }\n        }\n    }\n    // finally we can set the new shortcut\n    currentItem->setText(1, keySequence);\n    return true;\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rrentItem->setText",
          "args": [
            "ySequence);"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ildItem->setText",
          "args": [
            "tring());"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring()",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageBox::warning(",
          "args": [
            "his,",
            "r(\"Shortcut Conflicts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"),",
            "(\"<p>The \\\"%1\\\" shortcut is ambiguous with the following shortcut:</p>\"\n                                                        \"<p>%2</p><p>Do you want to assign an empty shortcut to this action?</p>\")\n                                                     .arg(keySequence).arg(childItem->text(0)),",
            "essageBox::Ok | QMessageBox::Cancel,",
            "essageBox::Ok);"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ildItem->text(0)),"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ildItem->text",
          "args": [
            ")"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ySequence)."
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(\"",
          "args": [
            "p>The \\\"%1\\\" shortcut is ambiguous with the following shortcut:</p>\"\n                                                        \"<p>%2</p><p>Do you want to assign an empty shortcut to this action?</p>\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rUtf8(",
          "args": [
            "Trojit\"),"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "- \")"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Shortcut Conflicts\")"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "Spinner(",
          "container": "pinner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/Spinner.cpp",
          "lines": "36-41",
          "snippet": "pinner::Spinner(QWidget *parent) : QWidget(parent), m_step(0), m_fadeStep(0), m_timer(0),\n                                    m_startTimer(0), m_textCols(0), m_type(Sun), m_geometryDirty(false)\n{\n    updateAncestors();\n    hide();\n}",
          "includes": [
            "include <QtDebug>",
            "include <qmath.h>\n#",
            "include <QTimerEvent>\n#",
            "include <QTimer>\n#",
            "include <QPainter>\n#",
            "include <QFontMetricsF>\n#",
            "include \"Util.h\"",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Spinner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude <qmath.h>\n#\ninclude <QTimerEvent>\n#\ninclude <QTimer>\n#\ninclude <QPainter>\n#\ninclude <QFontMetricsF>\n#\ninclude \"Util.h\"\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Spinner.h\"\n#\n\npinner {\n  pinner::Spinner(QWidget *parent) : QWidget(parent), m_step(0), m_fadeStep(0), m_timer(0),\n                                      m_startTimer(0), m_textCols(0), m_type(Sun), m_geometryDirty(false)\n  {\n      updateAncestors();\n      hide();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hildItem->data",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hildItem->data",
          "args": [
            ",",
            "t::UserRole)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->text",
          "args": [
            ")"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLevelItem->child",
          "args": [
            ")"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLevelItem->childCount",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLevelItem->data",
          "args": [
            ",",
            "t::UserRole)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItem",
          "args": [
            ")"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItemCount",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentItem->parent",
          "args": [
            ",",
            "t::UserRole)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentItem->parent",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "parent",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "229-268",
          "snippet": "void ModelTest::parent()\n{\n    // Make sure the model wont crash and will return an invalid QModelIndex\n    // when asked for the parent of an invalid index.\n    Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // Column 0                | Column 1    |\n    // QModelIndex()           |             |\n    //    \\- topIndex          | topIndex1   |\n    //         \\- childIndex   | childIndex1 |\n\n    // Common error test #1, make sure that a top level index has a parent\n    // that is a invalid QModelIndex.\n    QModelIndex topIndex = model->index(0, 0, QModelIndex());\n    Q_ASSERT(model->parent(topIndex) == QModelIndex());\n\n    // Common error test #2, make sure that a second level index has a parent\n    // that is the first level index.\n    if (model->rowCount(topIndex) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        Q_ASSERT(model->parent(childIndex) == topIndex);\n    }\n\n    // Common error test #3, the second column should NOT have the same children\n    // as the first column in a row.\n    // Usually the second column shouldn't have children.\n    QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n    if (model->rowCount(topIndex1) > 0) {\n        QModelIndex childIndex = model->index(0, 0, topIndex);\n        QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n        Q_ASSERT(childIndex != childIndex1);\n    }\n\n    // Full test, walk n levels deep through the model making sure that all\n    // parent's children correctly specify their parent.\n    checkChildren(QModelIndex());\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::parent()\n  {\n      // Make sure the model wont crash and will return an invalid QModelIndex\n      // when asked for the parent of an invalid index.\n      Q_ASSERT(model->parent(QModelIndex()) == QModelIndex());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // Column 0                | Column 1    |\n      // QModelIndex()           |             |\n      //    \\- topIndex          | topIndex1   |\n      //         \\- childIndex   | childIndex1 |\n  \n      // Common error test #1, make sure that a top level index has a parent\n      // that is a invalid QModelIndex.\n      QModelIndex topIndex = model->index(0, 0, QModelIndex());\n      Q_ASSERT(model->parent(topIndex) == QModelIndex());\n  \n      // Common error test #2, make sure that a second level index has a parent\n      // that is the first level index.\n      if (model->rowCount(topIndex) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          Q_ASSERT(model->parent(childIndex) == topIndex);\n      }\n  \n      // Common error test #3, the second column should NOT have the same children\n      // as the first column in a row.\n      // Usually the second column shouldn't have children.\n      QModelIndex topIndex1 = model->index(0, 1, QModelIndex());\n      if (model->rowCount(topIndex1) > 0) {\n          QModelIndex childIndex = model->index(0, 0, topIndex);\n          QModelIndex childIndex1 = model->index(0, 0, topIndex1);\n          Q_ASSERT(childIndex != childIndex1);\n      }\n  \n      // Full test, walk n levels deep through the model making sure that all\n      // parent's children correctly specify their parent.\n      checkChildren(QModelIndex());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctionName.isEmpty",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrentItem->data",
          "args": [
            ",",
            "t::UserRole)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->currentItem",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeySequence",
          "args": [
            "KeySequence::PortableText)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeySequence(",
          "args": [
            "eyEvent->key())"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Shift+\",",
            "Shortcut modifier\")"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "eventFilter(",
          "container": "hortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "155-223",
          "snippet": "ool ShortcutConfigWidget::eventFilter(QObject *obj, QEvent *event)\n{\n    Q_UNUSED(obj);\n    if (event->type() != QEvent::KeyPress)\n        return false;\n\n    QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);\n    QString keySequence;\n    // don't allow modifiers to be handled as single keys and skip CapsLock and NumLock\n    if (keyEvent->key() == Qt::Key_Control || keyEvent->key() == Qt::Key_Shift\n            || keyEvent->key() == Qt::Key_Meta || keyEvent->key() == Qt::Key_Alt\n            || keyEvent->key() == Qt::Key_Super_L || keyEvent->key() == Qt::Key_AltGr\n            || keyEvent->key() == Qt::Key_CapsLock || keyEvent->key() == Qt::Key_NumLock)\n        return false;\n    // skip some particular keys (note that Qt::Key_Up and friends are used to navigate the list, in order to avoid that they interfere with the shortcut changing, we skip them)\n    if (keyEvent->modifiers() == Qt::NoModifier\n            && (keyEvent->key() == Qt::Key_Up || keyEvent->key() == Qt::Key_Down\n                || keyEvent->key() == Qt::Key_Left || keyEvent->key() == Qt::Key_Right\n                || keyEvent->key() == Qt::Key_PageUp || keyEvent->key() == Qt::Key_PageDown\n                || keyEvent->key() == Qt::Key_Tab || keyEvent->key() == Qt::Key_Backtab\n                || keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Escape))\n        return false;\n    if (keyEvent->key() == Qt::Key_Backtab) // the above doesn't catch \"Shift+Tab\"\n        return false;\n\n    // create string representation of the new shortcut\n    if (keyEvent->modifiers() & Qt::ControlModifier)\n        keySequence += tr(\"Ctrl+\", \"Shortcut modifier\");\n    if (keyEvent->modifiers() & Qt::AltModifier)\n        keySequence += tr(\"Alt+\", \"Shortcut modifier\");\n    if (keyEvent->modifiers() & Qt::ShiftModifier)\n        keySequence += tr(\"Shift+\", \"Shortcut modifier\");\n    keySequence += QKeySequence(keyEvent->key()).toString(QKeySequence::PortableText);\n\n    // replace shortcut in the list (but not yet for real, this is done when the user accepts the dialog)\n    QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n    if (!currentItem) // this is the case when ui.shortcutTreeWidget is empty\n        return false;\n    const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n    if (actionName.isEmpty()) // this is the case when a toplevel item is selected\n        return false;\n    // test whether the new shortcut is already defined for another action, if yes then ask the user to set an empty shortcut for the old action\n    const QVariant parentId = currentItem->parent()->data(1, Qt::UserRole);\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        if (topLevelItem->data(1, Qt::UserRole) != parentId) // only deal with actions in the same exclusivity group\n            continue;\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            if (keySequence == childItem->text(1) && childItem->data(1, Qt::UserRole).toString() != actionName) {\n                QMessageBox::StandardButton result = QMessageBox::warning(this,\n                                                     tr(\"Shortcut Conflicts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"),\n                                                     tr(\"<p>The \\\"%1\\\" shortcut is ambiguous with the following shortcut:</p>\"\n                                                        \"<p>%2</p><p>Do you want to assign an empty shortcut to this action?</p>\")\n                                                     .arg(keySequence).arg(childItem->text(0)),\n                                                     QMessageBox::Ok | QMessageBox::Cancel, QMessageBox::Ok);\n                if (result == QMessageBox::Ok)\n                    childItem->setText(1, QString());\n                else\n                    return false;\n            }\n        }\n    }\n    // finally we can set the new shortcut\n    currentItem->setText(1, keySequence);\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "eyEvent->modifiers",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->modifiers",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->modifiers",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->modifiers",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eyEvent->key",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<QKeyEvent*>",
          "args": [
            "vent)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vent->type",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "328-331",
          "snippet": "QMimeMagicRule::Type QMimeMagicRule::type() const\n{\n    return d->type;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QMimeMagicRule::Type QMimeMagicRule::type() const\n  {\n      return d->type;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "bj)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  ool ShortcutConfigWidget::eventFilter(QObject *obj, QEvent *event)\n  {\n      Q_UNUSED(obj);\n      if (event->type() != QEvent::KeyPress)\n          return false;\n  \n      QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);\n      QString keySequence;\n      // don't allow modifiers to be handled as single keys and skip CapsLock and NumLock\n      if (keyEvent->key() == Qt::Key_Control || keyEvent->key() == Qt::Key_Shift\n              || keyEvent->key() == Qt::Key_Meta || keyEvent->key() == Qt::Key_Alt\n              || keyEvent->key() == Qt::Key_Super_L || keyEvent->key() == Qt::Key_AltGr\n              || keyEvent->key() == Qt::Key_CapsLock || keyEvent->key() == Qt::Key_NumLock)\n          return false;\n      // skip some particular keys (note that Qt::Key_Up and friends are used to navigate the list, in order to avoid that they interfere with the shortcut changing, we skip them)\n      if (keyEvent->modifiers() == Qt::NoModifier\n              && (keyEvent->key() == Qt::Key_Up || keyEvent->key() == Qt::Key_Down\n                  || keyEvent->key() == Qt::Key_Left || keyEvent->key() == Qt::Key_Right\n                  || keyEvent->key() == Qt::Key_PageUp || keyEvent->key() == Qt::Key_PageDown\n                  || keyEvent->key() == Qt::Key_Tab || keyEvent->key() == Qt::Key_Backtab\n                  || keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Escape))\n          return false;\n      if (keyEvent->key() == Qt::Key_Backtab) // the above doesn't catch \"Shift+Tab\"\n          return false;\n  \n      // create string representation of the new shortcut\n      if (keyEvent->modifiers() & Qt::ControlModifier)\n          keySequence += tr(\"Ctrl+\", \"Shortcut modifier\");\n      if (keyEvent->modifiers() & Qt::AltModifier)\n          keySequence += tr(\"Alt+\", \"Shortcut modifier\");\n      if (keyEvent->modifiers() & Qt::ShiftModifier)\n          keySequence += tr(\"Shift+\", \"Shortcut modifier\");\n      keySequence += QKeySequence(keyEvent->key()).toString(QKeySequence::PortableText);\n  \n      // replace shortcut in the list (but not yet for real, this is done when the user accepts the dialog)\n      QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n      if (!currentItem) // this is the case when ui.shortcutTreeWidget is empty\n          return false;\n      const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n      if (actionName.isEmpty()) // this is the case when a toplevel item is selected\n          return false;\n      // test whether the new shortcut is already defined for another action, if yes then ask the user to set an empty shortcut for the old action\n      const QVariant parentId = currentItem->parent()->data(1, Qt::UserRole);\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          if (topLevelItem->data(1, Qt::UserRole) != parentId) // only deal with actions in the same exclusivity group\n              continue;\n          const int childCount = topLevelItem->childCount();\n          for (int j = 0; j < childCount; ++j) {\n              QTreeWidgetItem *childItem = topLevelItem->child(j);\n              if (keySequence == childItem->text(1) && childItem->data(1, Qt::UserRole).toString() != actionName) {\n                  QMessageBox::StandardButton result = QMessageBox::warning(this,\n                                                       tr(\"Shortcut Conflicts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"),\n                                                       tr(\"<p>The \\\"%1\\\" shortcut is ambiguous with the following shortcut:</p>\"\n                                                          \"<p>%2</p><p>Do you want to assign an empty shortcut to this action?</p>\")\n                                                       .arg(keySequence).arg(childItem->text(0)),\n                                                       QMessageBox::Ok | QMessageBox::Cancel, QMessageBox::Ok);\n                  if (result == QMessageBox::Ok)\n                      childItem->setText(1, QString());\n                  else\n                      return false;\n              }\n          }\n      }\n      // finally we can set the new shortcut\n      currentItem->setText(1, keySequence);\n      return true;\n  }\n}"
  },
  {
    "function_name": "searchItems(",
    "container": "hortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "137-151",
    "snippet": "oid ShortcutConfigWidget::searchItems(const QString &text)\n{\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            if (childItem->text(0).contains(text, Qt::CaseInsensitive) || childItem->text(1).contains(text, Qt::CaseInsensitive))\n                childItem->setHidden(false);\n            else\n                childItem->setHidden(true);\n        }\n    }\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hildItem->setHidden",
          "args": [
            "rue)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->setHidden",
          "args": [
            "alse)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->text",
          "args": [
            "ext,",
            "t::CaseInsensitive)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->text",
          "args": [
            ")"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->text",
          "args": [
            "ext,",
            "t::CaseInsensitive)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hildItem->text",
          "args": [
            ")"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLevelItem->child",
          "args": [
            ")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLevelItem->childCount",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItem",
          "args": [
            ")"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItemCount",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  oid ShortcutConfigWidget::searchItems(const QString &text)\n  {\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          const int childCount = topLevelItem->childCount();\n          for (int j = 0; j < childCount; ++j) {\n              QTreeWidgetItem *childItem = topLevelItem->child(j);\n              if (childItem->text(0).contains(text, Qt::CaseInsensitive) || childItem->text(1).contains(text, Qt::CaseInsensitive))\n                  childItem->setHidden(false);\n              else\n                  childItem->setHidden(true);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "setActionDescriptions(",
    "container": "hortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "123-133",
    "snippet": "oid ShortcutConfigWidget::setActionDescriptions(const QHash<QString, ActionDescription> &actionDescriptions)\n{\n    m_actionDescriptions = actionDescriptions;\n    ui.shortcutTreeWidget->scrollToItem(ui.shortcutTreeWidget->invisibleRootItem()->child(0));\n    ui.shortcutTreeWidget->clear();\n    for (QHash<QString, ActionDescription>::const_iterator it = m_actionDescriptions.constBegin(); it != m_actionDescriptions.constEnd(); ++it) {\n        ActionDescription actionDescription = it.value();\n        addItem(it.key(), actionDescription.text, actionDescription.shortcut, loadIcon(actionDescription.iconName), actionDescription.parentId);\n    }\n    ui.shortcutTreeWidget->expandAll();\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->expandAll",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ddItem(",
          "args": [
            "t.key(),",
            "ctionDescription.text,",
            "ctionDescription.shortcut,",
            "oadIcon(actionDescription.iconName),",
            "ctionDescription.parentId)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "addItem(",
          "container": "hortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "95-121",
          "snippet": "oid ShortcutConfigWidget::addItem(const QString &actionName, const QString &text, const QString &shortcut, const QIcon &icon, const QString &parentId)\n{\n    // search correct toplevel item\n    int topLevelItemNumber = -1;\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        if (ui.shortcutTreeWidget->topLevelItem(i)->text(0) == parentId) {\n            topLevelItemNumber = i;\n            break;\n        }\n    }\n    if (topLevelItemNumber < 0) { // toplevel item with name parentId doesn't exist yet, so create\n        QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget);\n        item->setText(0, parentId);\n        topLevelItemNumber = topLevelItemCount;\n        item->setSizeHint(1, QSize(0, 1.5 * qApp->fontMetrics().height())); // since the second column is stretchable, it doesn't matter that the width of the size hint is set to 0\n        item->setData(1, Qt::UserRole, QString());\n    }\n\n    // create item\n    QString textWithoutAccelerator = text;\n    QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget->topLevelItem(topLevelItemNumber));\n    item->setText(0, textWithoutAccelerator.remove(QLatin1Char('&')));\n    item->setIcon(0, icon);\n    item->setText(1, shortcut);\n    item->setData(1, Qt::UserRole, actionName); // store objectName of the current action\n}",
          "includes": [
            "#include \"Common/SettingsCategoryGuard.h\"",
            "#include \"ShortcutHandler.h\"",
            "#include \"IconLoader.h\"",
            "#include <QSettings>",
            "#include <QMessageBox>",
            "#include <QKeyEvent>",
            "#include \"ShortcutConfigWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  oid ShortcutConfigWidget::addItem(const QString &actionName, const QString &text, const QString &shortcut, const QIcon &icon, const QString &parentId)\n  {\n      // search correct toplevel item\n      int topLevelItemNumber = -1;\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          if (ui.shortcutTreeWidget->topLevelItem(i)->text(0) == parentId) {\n              topLevelItemNumber = i;\n              break;\n          }\n      }\n      if (topLevelItemNumber < 0) { // toplevel item with name parentId doesn't exist yet, so create\n          QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget);\n          item->setText(0, parentId);\n          topLevelItemNumber = topLevelItemCount;\n          item->setSizeHint(1, QSize(0, 1.5 * qApp->fontMetrics().height())); // since the second column is stretchable, it doesn't matter that the width of the size hint is set to 0\n          item->setData(1, Qt::UserRole, QString());\n      }\n  \n      // create item\n      QString textWithoutAccelerator = text;\n      QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget->topLevelItem(topLevelItemNumber));\n      item->setText(0, textWithoutAccelerator.remove(QLatin1Char('&')));\n      item->setIcon(0, icon);\n      item->setText(1, shortcut);\n      item->setData(1, Qt::UserRole, actionName); // store objectName of the current action\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oadIcon(",
          "args": [
            "ctionDescription.iconName)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.value",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_actionDescriptions.constEnd",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_actionDescriptions.constBegin",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->clear",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->scrollToItem",
          "args": [
            "i.shortcutTreeWidget->invisibleRootItem()->child(0))"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->invisibleRootItem",
          "args": [
            ")"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->invisibleRootItem",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  oid ShortcutConfigWidget::setActionDescriptions(const QHash<QString, ActionDescription> &actionDescriptions)\n  {\n      m_actionDescriptions = actionDescriptions;\n      ui.shortcutTreeWidget->scrollToItem(ui.shortcutTreeWidget->invisibleRootItem()->child(0));\n      ui.shortcutTreeWidget->clear();\n      for (QHash<QString, ActionDescription>::const_iterator it = m_actionDescriptions.constBegin(); it != m_actionDescriptions.constEnd(); ++it) {\n          ActionDescription actionDescription = it.value();\n          addItem(it.key(), actionDescription.text, actionDescription.shortcut, loadIcon(actionDescription.iconName), actionDescription.parentId);\n      }\n      ui.shortcutTreeWidget->expandAll();\n  }\n}"
  },
  {
    "function_name": "addItem(",
    "container": "hortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "95-121",
    "snippet": "oid ShortcutConfigWidget::addItem(const QString &actionName, const QString &text, const QString &shortcut, const QIcon &icon, const QString &parentId)\n{\n    // search correct toplevel item\n    int topLevelItemNumber = -1;\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        if (ui.shortcutTreeWidget->topLevelItem(i)->text(0) == parentId) {\n            topLevelItemNumber = i;\n            break;\n        }\n    }\n    if (topLevelItemNumber < 0) { // toplevel item with name parentId doesn't exist yet, so create\n        QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget);\n        item->setText(0, parentId);\n        topLevelItemNumber = topLevelItemCount;\n        item->setSizeHint(1, QSize(0, 1.5 * qApp->fontMetrics().height())); // since the second column is stretchable, it doesn't matter that the width of the size hint is set to 0\n        item->setData(1, Qt::UserRole, QString());\n    }\n\n    // create item\n    QString textWithoutAccelerator = text;\n    QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget->topLevelItem(topLevelItemNumber));\n    item->setText(0, textWithoutAccelerator.remove(QLatin1Char('&')));\n    item->setIcon(0, icon);\n    item->setText(1, shortcut);\n    item->setData(1, Qt::UserRole, actionName); // store objectName of the current action\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tem->setData",
          "args": [
            ",",
            "t::UserRole,",
            "ctionName)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setText",
          "args": [
            ",",
            "hortcut)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setIcon",
          "args": [
            ",",
            "con)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setText",
          "args": [
            ",",
            "extWithoutAccelerator.remove(QLatin1Char('&')))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extWithoutAccelerator.remove",
          "args": [
            "Latin1Char('&'))"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1Char(",
          "args": [
            "&')"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItem",
          "args": [
            "opLevelItemNumber)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setData",
          "args": [
            ",",
            "t::UserRole,",
            "String())"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tem->setSizeHint",
          "args": [
            ",",
            "Size(0, 1.5 * qApp->fontMetrics().height()))"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Size(",
          "args": [
            ",",
            ".5 * qApp->fontMetrics().height())"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "prettySize(",
          "container": "rettySize",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "50-76",
          "snippet": "String PrettySize::prettySize(uint bytes, const ShowBytesSuffix compactUnitFormat)\n{\n    if (bytes == 0) {\n        return tr(\"0\");\n    }\n    int order = std::log(static_cast<double>(bytes)) / std::log(1024.0);\n    double number = bytes / std::pow(1024.0, order);\n\n    QString suffix;\n    if (order <= 0) {\n        if (compactUnitFormat == COMPACT_FORM)\n            return QString::number(bytes);\n        else\n            return tr(\"%1 bytes\").arg(QString::number(bytes));\n    } else if (order == 1) {\n        suffix = tr(\"kB\");\n    } else if (order == 2) {\n        suffix = tr(\"MB\");\n    } else if (order == 3) {\n        suffix = tr(\"GB\");\n    } else {\n        // make sure not to show wrong size for those that have > 1024 TB e-mail messages\n        order = 4;\n        suffix = tr(\"TB\"); // shame on you for such mails\n    }\n    return tr(\"%1 %2\").arg(QString::number(number, 'f', number < 100 ? 1 : 0), suffix);\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nrettySize {\n  String PrettySize::prettySize(uint bytes, const ShowBytesSuffix compactUnitFormat)\n  {\n      if (bytes == 0) {\n          return tr(\"0\");\n      }\n      int order = std::log(static_cast<double>(bytes)) / std::log(1024.0);\n      double number = bytes / std::pow(1024.0, order);\n  \n      QString suffix;\n      if (order <= 0) {\n          if (compactUnitFormat == COMPACT_FORM)\n              return QString::number(bytes);\n          else\n              return tr(\"%1 bytes\").arg(QString::number(bytes));\n      } else if (order == 1) {\n          suffix = tr(\"kB\");\n      } else if (order == 2) {\n          suffix = tr(\"MB\");\n      } else if (order == 3) {\n          suffix = tr(\"GB\");\n      } else {\n          // make sure not to show wrong size for those that have > 1024 TB e-mail messages\n          order = 4;\n          suffix = tr(\"TB\"); // shame on you for such mails\n      }\n      return tr(\"%1 %2\").arg(QString::number(number, 'f', number < 100 ? 1 : 0), suffix);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "App->fontMetrics",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "App->fontMetrics",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tem->setText",
          "args": [
            ",",
            "arentId)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItem",
          "args": [
            ")"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItem",
          "args": [
            ")"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItemCount",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  oid ShortcutConfigWidget::addItem(const QString &actionName, const QString &text, const QString &shortcut, const QIcon &icon, const QString &parentId)\n  {\n      // search correct toplevel item\n      int topLevelItemNumber = -1;\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          if (ui.shortcutTreeWidget->topLevelItem(i)->text(0) == parentId) {\n              topLevelItemNumber = i;\n              break;\n          }\n      }\n      if (topLevelItemNumber < 0) { // toplevel item with name parentId doesn't exist yet, so create\n          QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget);\n          item->setText(0, parentId);\n          topLevelItemNumber = topLevelItemCount;\n          item->setSizeHint(1, QSize(0, 1.5 * qApp->fontMetrics().height())); // since the second column is stretchable, it doesn't matter that the width of the size hint is set to 0\n          item->setData(1, Qt::UserRole, QString());\n      }\n  \n      // create item\n      QString textWithoutAccelerator = text;\n      QTreeWidgetItem *item = new QTreeWidgetItem(ui.shortcutTreeWidget->topLevelItem(topLevelItemNumber));\n      item->setText(0, textWithoutAccelerator.remove(QLatin1Char('&')));\n      item->setIcon(0, icon);\n      item->setText(1, shortcut);\n      item->setData(1, Qt::UserRole, actionName); // store objectName of the current action\n  }\n}"
  },
  {
    "function_name": "setExclusivityGroups(",
    "container": "hortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "79-93",
    "snippet": "oid ShortcutConfigWidget::setExclusivityGroups(const QList<QStringList> &groups)\n{\n    // this function must be called after all actions are added\n    // we set a unique ID for each exclusivity group and we set the data of each toplevel item to the ID of the group to which it belongs\n    // the ID must be a negative number, since eventFilter() assumes that the ID is either a negative number or the index of the corresponding action in m_actions\n    m_exclusivityGroups = groups;\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        const QString parentId = topLevelItem->text(0);\n        for (int j = 0; j < m_exclusivityGroups.size(); ++j)\n            if (m_exclusivityGroups.at(j).contains(parentId))\n                topLevelItem->setData(1, Qt::UserRole, -j-1);\n    }\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opLevelItem->setData",
          "args": [
            ",",
            "t::UserRole,",
            "j-1)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exclusivityGroups.at",
          "args": [
            "arentId)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exclusivityGroups.at",
          "args": [
            ")"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exclusivityGroups.size",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLevelItem->text",
          "args": [
            ")"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItem",
          "args": [
            ")"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->topLevelItemCount",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  oid ShortcutConfigWidget::setExclusivityGroups(const QList<QStringList> &groups)\n  {\n      // this function must be called after all actions are added\n      // we set a unique ID for each exclusivity group and we set the data of each toplevel item to the ID of the group to which it belongs\n      // the ID must be a negative number, since eventFilter() assumes that the ID is either a negative number or the index of the corresponding action in m_actions\n      m_exclusivityGroups = groups;\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          const QString parentId = topLevelItem->text(0);\n          for (int j = 0; j < m_exclusivityGroups.size(); ++j)\n              if (m_exclusivityGroups.at(j).contains(parentId))\n                  topLevelItem->setData(1, Qt::UserRole, -j-1);\n      }\n  }\n}"
  },
  {
    "function_name": "~ShortcutConfigWidget(",
    "container": "hortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "63-65",
    "snippet": "hortcutConfigWidget::~ShortcutConfigWidget()\n{\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  hortcutConfigWidget::~ShortcutConfigWidget()\n  {\n  }\n}"
  },
  {
    "function_name": "ShortcutConfigWidget",
    "container": "ShortcutConfigWidget",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
    "lines": "36-61",
    "snippet": "ShortcutConfigWidget::ShortcutConfigWidget(QWidget *parent)\n    : QWidget(parent)\n    , m_shortcutsShouldBeRestored(false)\n{\n    ui.setupUi(this);\n    setWindowTitle(tr(\"Configure Shortcuts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"));\n\n#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n    ui.shortcutTreeWidget->header()->setSectionResizeMode(0, QHeaderView::ResizeToContents);\n    ui.shortcutTreeWidget->header()->setSectionResizeMode(1, QHeaderView::Stretch);\n#else\n    ui.shortcutTreeWidget->header()->setResizeMode(0, QHeaderView::ResizeToContents);\n    ui.shortcutTreeWidget->header()->setResizeMode(1, QHeaderView::Stretch);\n#endif\n    ui.shortcutTreeWidget->setUniformRowHeights(true); // all rows have the same height\n    ui.shortcutTreeWidget->installEventFilter(this);\n\n    ui.gridLayout->setColumnStretch(2, 1); // make sure the buttons are not too large\n    ui.gridLayout->setContentsMargins(0, 0, 0, 0);\n\n    setFocusProxy(ui.shortcutTreeWidget);\n\n    connect(ui.searchLineEdit, SIGNAL(textChanged(QString)), this, SLOT(searchItems(QString)));\n    connect(ui.clearPushButton, SIGNAL(clicked()), this, SLOT(clearShortcut()));\n    connect(ui.useDefaultPushButton, SIGNAL(clicked()), this, SLOT(restoreDefaultShortcut()));\n}",
    "includes": [
      "#include \"Common/SettingsCategoryGuard.h\"",
      "#include \"ShortcutHandler.h\"",
      "#include \"IconLoader.h\"",
      "#include <QSettings>",
      "#include <QMessageBox>",
      "#include <QKeyEvent>",
      "#include \"ShortcutConfigWidget.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "i.useDefaultPushButton,",
            "IGNAL(clicked()),",
            "his,",
            "LOT(restoreDefaultShortcut()))"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "estoreDefaultShortcut())"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estoreDefaultShortcut(",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "restoreDefaultShortcut()",
          "container": "ortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "234-241",
          "snippet": "id ShortcutConfigWidget::restoreDefaultShortcut()\n{\n    QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n    const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n    if (actionName.isEmpty())\n        return;\n    currentItem->setText(1, m_actionDescriptions[actionName].defaultShortcut);\n}",
          "includes": [
            "#include \"Common/SettingsCategoryGuard.h\"",
            "#include \"ShortcutHandler.h\"",
            "#include \"IconLoader.h\"",
            "#include <QSettings>",
            "#include <QMessageBox>",
            "#include <QKeyEvent>",
            "#include \"ShortcutConfigWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::restoreDefaultShortcut()\n  {\n      QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n      const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n      if (actionName.isEmpty())\n          return;\n      currentItem->setText(1, m_actionDescriptions[actionName].defaultShortcut);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "licked())"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "licked(",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "loadClicked(",
          "container": "oadablePartWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/LoadablePartWidget.cpp",
          "lines": "55-74",
          "snippet": "oid LoadablePartWidget::loadClicked()\n{\n    if (!partIndex.isValid()) {\n        if (loadButton) {\n            loadButton->setEnabled(false);\n        }\n        return;\n    }\n    if (loadButton) {\n        loadButton->deleteLater();\n        loadButton = 0;\n    }\n\n    // We have to disable any flags which might cause recursion here\n    realPart = m_factory->create(partIndex, m_recursionDepth + 1,\n                                 (m_loadingMode | PartWidgetFactory::PART_IGNORE_CLICKTHROUGH\n                                  | PartWidgetFactory::PART_IGNORE_LOAD_ON_SHOW) ^ PartWidgetFactory::PART_IS_HIDDEN);\n    addWidget(realPart);\n    setCurrentIndex(1);\n}",
          "includes": [
            "include <QPushButton>",
            "include \"Imap/Model/Utils.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Gui/MessageView.h\" // so that the compiler knows that it's a QObject\n#",
            "include \"LoadablePartWidget.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QPushButton>\ninclude \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Gui/MessageView.h\" // so that the compiler knows that it's a QObject\n#\ninclude \"LoadablePartWidget.h\"\n#\n\noadablePartWidget {\n  oid LoadablePartWidget::loadClicked()\n  {\n      if (!partIndex.isValid()) {\n          if (loadButton) {\n              loadButton->setEnabled(false);\n          }\n          return;\n      }\n      if (loadButton) {\n          loadButton->deleteLater();\n          loadButton = 0;\n      }\n  \n      // We have to disable any flags which might cause recursion here\n      realPart = m_factory->create(partIndex, m_recursionDepth + 1,\n                                   (m_loadingMode | PartWidgetFactory::PART_IGNORE_CLICKTHROUGH\n                                    | PartWidgetFactory::PART_IGNORE_LOAD_ON_SHOW) ^ PartWidgetFactory::PART_IS_HIDDEN);\n      addWidget(realPart);\n      setCurrentIndex(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "i.clearPushButton,",
            "IGNAL(clicked()),",
            "his,",
            "LOT(clearShortcut()))"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "learShortcut())"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "learShortcut(",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "clearShortcut()",
          "container": "ortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "225-232",
          "snippet": "id ShortcutConfigWidget::clearShortcut()\n{\n    QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n    const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n    if (actionName.isEmpty())\n        return;\n    currentItem->setText(1, QString());\n}",
          "includes": [
            "#include \"Common/SettingsCategoryGuard.h\"",
            "#include \"ShortcutHandler.h\"",
            "#include \"IconLoader.h\"",
            "#include <QSettings>",
            "#include <QMessageBox>",
            "#include <QKeyEvent>",
            "#include \"ShortcutConfigWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nortcutConfigWidget {\n  id ShortcutConfigWidget::clearShortcut()\n  {\n      QTreeWidgetItem *currentItem = ui.shortcutTreeWidget->currentItem();\n      const QString actionName = currentItem->data(1, Qt::UserRole).toString();\n      if (actionName.isEmpty())\n          return;\n      currentItem->setText(1, QString());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "licked())"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "i.searchLineEdit,",
            "IGNAL(textChanged(QString)),",
            "his,",
            "LOT(searchItems(QString)))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "earchItems(QString))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchItems(",
          "args": [
            "String)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "searchItems(",
          "container": "hortcutConfigWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/ShortcutHandler/ShortcutConfigWidget.cpp",
          "lines": "137-151",
          "snippet": "oid ShortcutConfigWidget::searchItems(const QString &text)\n{\n    const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n    for (int i = 0; i < topLevelItemCount; ++i) {\n        QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n        const int childCount = topLevelItem->childCount();\n        for (int j = 0; j < childCount; ++j) {\n            QTreeWidgetItem *childItem = topLevelItem->child(j);\n            if (childItem->text(0).contains(text, Qt::CaseInsensitive) || childItem->text(1).contains(text, Qt::CaseInsensitive))\n                childItem->setHidden(false);\n            else\n                childItem->setHidden(true);\n        }\n    }\n}",
          "includes": [
            "#include \"Common/SettingsCategoryGuard.h\"",
            "#include \"ShortcutHandler.h\"",
            "#include \"IconLoader.h\"",
            "#include <QSettings>",
            "#include <QMessageBox>",
            "#include <QKeyEvent>",
            "#include \"ShortcutConfigWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nhortcutConfigWidget {\n  oid ShortcutConfigWidget::searchItems(const QString &text)\n  {\n      const int topLevelItemCount = ui.shortcutTreeWidget->topLevelItemCount();\n      for (int i = 0; i < topLevelItemCount; ++i) {\n          QTreeWidgetItem *topLevelItem = ui.shortcutTreeWidget->topLevelItem(i);\n          const int childCount = topLevelItem->childCount();\n          for (int j = 0; j < childCount; ++j) {\n              QTreeWidgetItem *childItem = topLevelItem->child(j);\n              if (childItem->text(0).contains(text, Qt::CaseInsensitive) || childItem->text(1).contains(text, Qt::CaseInsensitive))\n                  childItem->setHidden(false);\n              else\n                  childItem->setHidden(true);\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "extChanged(QString))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extChanged(",
          "args": [
            "String)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etFocusProxy(",
          "args": [
            "i.shortcutTreeWidget)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.gridLayout->setContentsMargins",
          "args": [
            ",",
            ",",
            ",",
            ")"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.gridLayout->setColumnStretch",
          "args": [
            ",",
            ")"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->installEventFilter",
          "args": [
            "his)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->setUniformRowHeights",
          "args": [
            "rue)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [
            ",",
            "HeaderView::Stretch)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [
            ",",
            "HeaderView::ResizeToContents)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [
            ",",
            "HeaderView::Stretch)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [
            ",",
            "HeaderView::ResizeToContents)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.shortcutTreeWidget->header",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_VERSION_CHECK(",
          "args": [
            ",",
            ",",
            ")"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setWindowTitle",
          "args": [
            "tr(\"Configure Shortcuts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"))"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trUtf8",
          "args": [
            "\"Trojit\")"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\" - \""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [
            "\"Configure Shortcuts\""
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "setGeometry",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "125-129",
          "snippet": "void FlowLayout::setGeometry(const QRect &rect)\n{\n    QLayout::setGeometry(rect);\n    doLayout(rect, false);\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  void FlowLayout::setGeometry(const QRect &rect)\n  {\n      QLayout::setGeometry(rect);\n      doLayout(rect, false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ui.setupUi",
          "args": [
            "this"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"Common/SettingsCategoryGuard.h\"\n#include \"ShortcutHandler.h\"\n#include \"IconLoader.h\"\n#include <QSettings>\n#include <QMessageBox>\n#include <QKeyEvent>\n#include \"ShortcutConfigWidget.h\"\n\nShortcutConfigWidget {\n  ShortcutConfigWidget::ShortcutConfigWidget(QWidget *parent)\n      : QWidget(parent)\n      , m_shortcutsShouldBeRestored(false)\n  {\n      ui.setupUi(this);\n      setWindowTitle(tr(\"Configure Shortcuts\") + QLatin1String(\" - \") + trUtf8(\"Trojit\"));\n  \n  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)\n      ui.shortcutTreeWidget->header()->setSectionResizeMode(0, QHeaderView::ResizeToContents);\n      ui.shortcutTreeWidget->header()->setSectionResizeMode(1, QHeaderView::Stretch);\n  #else\n      ui.shortcutTreeWidget->header()->setResizeMode(0, QHeaderView::ResizeToContents);\n      ui.shortcutTreeWidget->header()->setResizeMode(1, QHeaderView::Stretch);\n  #endif\n      ui.shortcutTreeWidget->setUniformRowHeights(true); // all rows have the same height\n      ui.shortcutTreeWidget->installEventFilter(this);\n  \n      ui.gridLayout->setColumnStretch(2, 1); // make sure the buttons are not too large\n      ui.gridLayout->setContentsMargins(0, 0, 0, 0);\n  \n      setFocusProxy(ui.shortcutTreeWidget);\n  \n      connect(ui.searchLineEdit, SIGNAL(textChanged(QString)), this, SLOT(searchItems(QString)));\n      connect(ui.clearPushButton, SIGNAL(clicked()), this, SLOT(clearShortcut()));\n      connect(ui.useDefaultPushButton, SIGNAL(clicked()), this, SLOT(restoreDefaultShortcut()));\n  }\n}"
  }
]