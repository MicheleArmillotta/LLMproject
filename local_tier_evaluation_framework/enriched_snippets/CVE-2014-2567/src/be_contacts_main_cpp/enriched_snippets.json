[
  {
    "function_name": "ain(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/be.contacts/main.cpp",
    "lines": "32-111",
    "snippet": "nt main(int argc, char **argv) {\n    if (argc > 1 && argv[1][0] != '-') {\n        QCoreApplication a(argc, argv);\n        if (qstrcmp(argv[1], \"import\")) {\n            qWarning(\"unknown command \\\"%s\\\"\", argv[1]);\n            return 1;\n        }\n        if (argc == 2) {\n            qWarning(\"you must specify an address string to import, eg.\\n\"\n            \"%s import \\\"Joe User <joe@users.com>\\\"\", argv[0]);\n            return 2;\n        }\n        QMap<QString, QString> imports;\n        for (int i = 2; i < argc; ++i) {\n            QString arg = QString::fromLocal8Bit(argv[i]);\n            QString mail, name;\n            QStringList contact = arg.split(\" \", QString::SkipEmptyParts);\n            foreach (const QString &token, contact) {\n                if (token.contains('@'))\n                    mail = token;\n                else\n                    name = name.isEmpty() ? token : name + \" \" + token;\n            }\n            if (mail.isEmpty()) {\n                qWarning(\"error, \\\"%s\\\" does not seem to contain a mail address\", arg.toLocal8Bit().data());\n                continue;\n            }\n            mail.remove('<');\n            mail.remove('>');\n            if (name.isEmpty())\n                name = mail;\n            imports.insert(name, mail);\n        }\n        if (imports.isEmpty()) {\n            qWarning(\"nothing to import\");\n            return 2;\n        }\n\n        int lastContact = -1, updates = 0, adds = 0;\n        QSettings abook(QDir::homePath() + \"/.abook/addressbook\", QSettings::IniFormat);\n        abook.setIniCodec(\"UTF-8\");\n        QStringList contacts = abook.childGroups();\n        foreach (const QString &contact, contacts) {\n            Common::SettingsCategoryGuard guard(&abook, contact);\n            int id = contact.toInt();\n            if (id > lastContact)\n                lastContact = id;\n            const QString name = abook.value(\"name\", QString()).toString();\n            QMap<QString,QString>::iterator it = imports.begin(), end = imports.end();\n            while (it != end) {\n                if (it.key() == name) {\n                    QStringList mails = abook.value(\"email\", QString()).toStringList();\n                    if (!mails.contains(it.value())) {\n                        ++updates;\n                        mails << it.value();\n                        abook.setValue(\"email\", mails);\n                    }\n                    it = imports.erase(it);\n                    continue;\n                }\n                else\n                    ++it;\n            }\n        }\n        QMap<QString,QString>::const_iterator it = imports.constBegin(), end = imports.constEnd();\n        while (it != end) {\n            ++adds;\n            Common::SettingsCategoryGuard guard(&abook, QString::number(++lastContact));\n            abook.setValue(\"name\", it.key());\n            abook.setValue(\"email\", it.value());\n            ++it;\n        }\n        qWarning(\"updated %d and added %d contacts\", updates, adds);\n        return 0;\n    }\n    QApplication a(argc, argv);\n    BE::Contacts w(new Gui::AbookAddressbook());\n    w.show();\n    return a.exec();\n}",
    "includes": [
      "include \"Common/SettingsCategoryGuard.h\"",
      "include \"AbookAddressbook/be-contacts.h\"\n#",
      "include \"AbookAddressbook/AbookAddressbook.h\"\n#",
      "include <QSettings>\n#",
      "include <QDir>\n#",
      "include <QApplication>\n#",
      "include <QDateTime>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ".exec",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "executeACommand(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "781-921",
          "snippet": "oid Parser::executeACommand()\n{\n    Q_ASSERT(! cmdQueue.isEmpty());\n    Commands::Command &cmd = cmdQueue.first();\n\n    QByteArray buf;\n\n    bool sensitiveCommand = (cmd.cmds.size() > 2 && cmd.cmds[1].text == \"LOGIN\");\n    QByteArray privateMessage = sensitiveCommand ? QByteArray(\"[LOGIN command goes here]\") : QByteArray();\n\n#ifdef PRINT_TRAFFIC_TX\n#ifdef PRINT_TRAFFIC_SENSITIVE\n    bool printThisCommand = true;\n#else\n    bool printThisCommand = ! sensitiveCommand;\n#endif\n#endif\n\n    if (cmd.cmds[ cmd.currentPart ].kind == Commands::IDLE_DONE) {\n        // Handling of the IDLE_DONE is a bit special, as we have to check and update the idling flag...\n        Q_ASSERT(idling);\n        buf.append(\"DONE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n        qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n        socket->write(buf);\n        idling = false;\n        cmdQueue.pop_front();\n        emit lineSent(this, buf);\n        buf.clear();\n        return;\n    }\n\n    Q_ASSERT(! idling);\n\n    while (1) {\n        Commands::PartOfCommand &part = cmd.cmds[ cmd.currentPart ];\n        switch (part.kind) {\n        case Commands::ATOM:\n        case Commands::ATOM_NO_SPACE_AROUND:\n            buf.append(part.text);\n            break;\n        case Commands::QUOTED_STRING:\n        {\n            QByteArray item = part.text;\n            item.replace('\\\\', \"\\\\\\\\\");\n            buf.append('\"');\n            buf.append(item);\n            buf.append('\"');\n        }\n        break;\n        case Commands::LITERAL:\n            if (literalPlus) {\n                buf.append('{');\n                buf.append(QByteArray::number(part.text.size()));\n                buf.append(\"+}\\r\\n\");\n                buf.append(part.text);\n            } else if (part.numberSent) {\n                buf.append(part.text);\n            } else {\n                buf.append('{');\n                buf.append(QByteArray::number(part.text.size()));\n                buf.append(\"}\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n                if (printThisCommand)\n                    qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n                else\n                    qDebug() << m_parserId << \">>> [sensitive command] -- added literal\";\n#endif\n                socket->write(buf);\n                part.numberSent = true;\n                waitingForContinuation = true;\n                Q_ASSERT(literalCommandTag.isEmpty());\n                literalCommandTag = cmd.cmds.first().text;\n                Q_ASSERT(!literalCommandTag.isEmpty());\n                emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n                return; // and wait for continuation request\n            }\n            break;\n        case Commands::IDLE_DONE:\n            Q_ASSERT(false); // is handled above\n            break;\n        case Commands::IDLE:\n            buf.append(\"IDLE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            idling = true;\n            waitForInitialIdle = true;\n            cmdQueue.pop_front();\n            emit lineSent(this, buf);\n            return;\n            break;\n        case Commands::STARTTLS:\n            startTlsCommand = buf;\n            buf.append(\"STARTTLS\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            startTlsInProgress = true;\n            emit lineSent(this, buf);\n            return;\n            break;\n        case Commands::COMPRESS_DEFLATE:\n            compressDeflateCommand = buf;\n            buf.append(\"COMPRESS DEFLATE\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n#endif\n            socket->write(buf);\n            compressDeflateInProgress = true;\n            cmdQueue.pop_front();\n            emit lineSent(this, buf);\n            return;\n            break;\n        }\n        if (cmd.currentPart == cmd.cmds.size() - 1) {\n            // finalize\n            buf.append(\"\\r\\n\");\n#ifdef PRINT_TRAFFIC_TX\n            if (printThisCommand)\n                qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n            else\n                qDebug() << m_parserId << \">>> [sensitive command]\";\n#endif\n            socket->write(buf);\n            cmdQueue.pop_front();\n            emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n            break;\n        } else {\n            if (part.kind == Commands::ATOM_NO_SPACE_AROUND || cmd.cmds[cmd.currentPart + 1].kind == Commands::ATOM_NO_SPACE_AROUND) {\n                // Skip the extra space if asked to do so\n            } else {\n                buf.append(' ');\n            }\n            ++cmd.currentPart;\n        }\n    }\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  oid Parser::executeACommand()\n  {\n      Q_ASSERT(! cmdQueue.isEmpty());\n      Commands::Command &cmd = cmdQueue.first();\n  \n      QByteArray buf;\n  \n      bool sensitiveCommand = (cmd.cmds.size() > 2 && cmd.cmds[1].text == \"LOGIN\");\n      QByteArray privateMessage = sensitiveCommand ? QByteArray(\"[LOGIN command goes here]\") : QByteArray();\n  \n  #ifdef PRINT_TRAFFIC_TX\n  #ifdef PRINT_TRAFFIC_SENSITIVE\n      bool printThisCommand = true;\n  #else\n      bool printThisCommand = ! sensitiveCommand;\n  #endif\n  #endif\n  \n      if (cmd.cmds[ cmd.currentPart ].kind == Commands::IDLE_DONE) {\n          // Handling of the IDLE_DONE is a bit special, as we have to check and update the idling flag...\n          Q_ASSERT(idling);\n          buf.append(\"DONE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n          qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n          socket->write(buf);\n          idling = false;\n          cmdQueue.pop_front();\n          emit lineSent(this, buf);\n          buf.clear();\n          return;\n      }\n  \n      Q_ASSERT(! idling);\n  \n      while (1) {\n          Commands::PartOfCommand &part = cmd.cmds[ cmd.currentPart ];\n          switch (part.kind) {\n          case Commands::ATOM:\n          case Commands::ATOM_NO_SPACE_AROUND:\n              buf.append(part.text);\n              break;\n          case Commands::QUOTED_STRING:\n          {\n              QByteArray item = part.text;\n              item.replace('\\\\', \"\\\\\\\\\");\n              buf.append('\"');\n              buf.append(item);\n              buf.append('\"');\n          }\n          break;\n          case Commands::LITERAL:\n              if (literalPlus) {\n                  buf.append('{');\n                  buf.append(QByteArray::number(part.text.size()));\n                  buf.append(\"+}\\r\\n\");\n                  buf.append(part.text);\n              } else if (part.numberSent) {\n                  buf.append(part.text);\n              } else {\n                  buf.append('{');\n                  buf.append(QByteArray::number(part.text.size()));\n                  buf.append(\"}\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n                  if (printThisCommand)\n                      qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n                  else\n                      qDebug() << m_parserId << \">>> [sensitive command] -- added literal\";\n  #endif\n                  socket->write(buf);\n                  part.numberSent = true;\n                  waitingForContinuation = true;\n                  Q_ASSERT(literalCommandTag.isEmpty());\n                  literalCommandTag = cmd.cmds.first().text;\n                  Q_ASSERT(!literalCommandTag.isEmpty());\n                  emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n                  return; // and wait for continuation request\n              }\n              break;\n          case Commands::IDLE_DONE:\n              Q_ASSERT(false); // is handled above\n              break;\n          case Commands::IDLE:\n              buf.append(\"IDLE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              idling = true;\n              waitForInitialIdle = true;\n              cmdQueue.pop_front();\n              emit lineSent(this, buf);\n              return;\n              break;\n          case Commands::STARTTLS:\n              startTlsCommand = buf;\n              buf.append(\"STARTTLS\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              startTlsInProgress = true;\n              emit lineSent(this, buf);\n              return;\n              break;\n          case Commands::COMPRESS_DEFLATE:\n              compressDeflateCommand = buf;\n              buf.append(\"COMPRESS DEFLATE\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n  #endif\n              socket->write(buf);\n              compressDeflateInProgress = true;\n              cmdQueue.pop_front();\n              emit lineSent(this, buf);\n              return;\n              break;\n          }\n          if (cmd.currentPart == cmd.cmds.size() - 1) {\n              // finalize\n              buf.append(\"\\r\\n\");\n  #ifdef PRINT_TRAFFIC_TX\n              if (printThisCommand)\n                  qDebug() << m_parserId << \">>>\" << buf.left(PRINT_TRAFFIC_TX).trimmed();\n              else\n                  qDebug() << m_parserId << \">>> [sensitive command]\";\n  #endif\n              socket->write(buf);\n              cmdQueue.pop_front();\n              emit lineSent(this, sensitiveCommand ? privateMessage : buf);\n              break;\n          } else {\n              if (part.kind == Commands::ATOM_NO_SPACE_AROUND || cmd.cmds[cmd.currentPart + 1].kind == Commands::ATOM_NO_SPACE_AROUND) {\n                  // Skip the extra space if asked to do so\n              } else {\n                  buf.append(' ');\n              }\n              ++cmd.currentPart;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".show",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "showMenu(",
          "container": "ttachmentView",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/AttachmentView.cpp",
          "lines": "257-265",
          "snippet": "oid AttachmentView::showMenu()\n{\n    if (QToolButton *btn = qobject_cast<QToolButton*>(sender())) {\n        btn->setDown(false);\n    }\n    QPoint p = QCursor::pos();\n    p.rx() -= m_menu->width()/2;\n    m_menu->popup(p);\n}",
          "includes": [
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QToolButton>\n#",
            "include <QTimer>\n#",
            "include <QTemporaryFile>\n#",
            "include <QStyleOption>\n#",
            "include <QStyle>\n#",
            "include <QLabel>\n#",
            "include <QPushButton>\n#",
            "include <QPainter>\n#",
            "include <QMouseEvent>\n#",
            "include <QMimeData>\n#",
            "include <QMenu>\n#",
            "include <QHBoxLayout>\n#",
            "include <QFileDialog>\n#",
            "include <QDrag>\n#",
            "include <QDesktopServices>\n#",
            "include <QApplication>\n#",
            "include <QAction>\n#",
            "include \"Imap/Model/Utils.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/DragAndDrop.h\"\n#",
            "include \"Imap/Network/FileDownloadManager.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/DeleteAfter.h\"\n#",
            "include \"MessageView.h\" // so that the compiler knows it's a QObject\n#",
            "include \"IconLoader.h\"\n#",
            "include \"AttachmentView.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QToolButton>\n#\ninclude <QTimer>\n#\ninclude <QTemporaryFile>\n#\ninclude <QStyleOption>\n#\ninclude <QStyle>\n#\ninclude <QLabel>\n#\ninclude <QPushButton>\n#\ninclude <QPainter>\n#\ninclude <QMouseEvent>\n#\ninclude <QMimeData>\n#\ninclude <QMenu>\n#\ninclude <QHBoxLayout>\n#\ninclude <QFileDialog>\n#\ninclude <QDrag>\n#\ninclude <QDesktopServices>\n#\ninclude <QApplication>\n#\ninclude <QAction>\n#\ninclude \"Imap/Model/Utils.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/DragAndDrop.h\"\n#\ninclude \"Imap/Network/FileDownloadManager.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/DeleteAfter.h\"\n#\ninclude \"MessageView.h\" // so that the compiler knows it's a QObject\n#\ninclude \"IconLoader.h\"\n#\ninclude \"AttachmentView.h\"\n#\n\nttachmentView {\n  oid AttachmentView::showMenu()\n  {\n      if (QToolButton *btn = qobject_cast<QToolButton*>(sender())) {\n          btn->setDown(false);\n      }\n      QPoint p = QCursor::pos();\n      p.rx() -= m_menu->width()/2;\n      m_menu->popup(p);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [
            "updated %d and added %d contacts\",",
            "pdates,",
            "dds)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "book.setValue",
          "args": [
            "email\",",
            "t.value())"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.value",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "333-336",
          "snippet": "QByteArray QMimeMagicRule::value() const\n{\n    return d->value;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  QByteArray QMimeMagicRule::value() const\n  {\n      return d->value;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "book.setValue",
          "args": [
            "name\",",
            "t.key())"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::number(",
          "args": [
            "+lastContact)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.constEnd",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.constBegin",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.erase",
          "args": [
            "t)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "book.setValue",
          "args": [
            "email\",",
            "ails)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ails.contains",
          "args": [
            "t.value())"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "book.value",
          "args": [
            "email\",",
            "String())"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.end",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.begin",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "book.value",
          "args": [
            "name\",",
            "String())"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ontact.toInt",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "book.childGroups",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "book.setIniCodec",
          "args": [
            "UTF-8\")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dir::homePath(",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [
            "nothing to import\")"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.isEmpty",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mports.insert",
          "args": [
            "ame,",
            "ail)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.isEmpty",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ail.remove",
          "args": [
            ">')"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ail.remove",
          "args": [
            "<')"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [
            "error, \\\"%s\\\" does not seem to contain a mail address\",",
            "rg.toLocal8Bit().data())"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.toLocal8Bit",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.toLocal8Bit",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ail.isEmpty",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame.isEmpty",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oken.contains",
          "args": [
            "@')"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rg.split",
          "args": [
            "\",",
            "String::SkipEmptyParts)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromLocal8Bit(",
          "args": [
            "rgv[i])"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [
            "you must specify an address string to import, eg.\\n\"\n            \"%s import \\\"Joe User <joe@users.com>\\\"\",",
            "rgv[0])"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Warning(",
          "args": [
            "unknown command \\\"%s\\\"\",",
            "rgv[1])"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp(",
          "args": [
            "rgv[1],",
            "import\")"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Common/SettingsCategoryGuard.h\"\ninclude \"AbookAddressbook/be-contacts.h\"\n#\ninclude \"AbookAddressbook/AbookAddressbook.h\"\n#\ninclude <QSettings>\n#\ninclude <QDir>\n#\ninclude <QApplication>\n#\ninclude <QDateTime>\n\nnt main(int argc, char **argv) {\n    if (argc > 1 && argv[1][0] != '-') {\n        QCoreApplication a(argc, argv);\n        if (qstrcmp(argv[1], \"import\")) {\n            qWarning(\"unknown command \\\"%s\\\"\", argv[1]);\n            return 1;\n        }\n        if (argc == 2) {\n            qWarning(\"you must specify an address string to import, eg.\\n\"\n            \"%s import \\\"Joe User <joe@users.com>\\\"\", argv[0]);\n            return 2;\n        }\n        QMap<QString, QString> imports;\n        for (int i = 2; i < argc; ++i) {\n            QString arg = QString::fromLocal8Bit(argv[i]);\n            QString mail, name;\n            QStringList contact = arg.split(\" \", QString::SkipEmptyParts);\n            foreach (const QString &token, contact) {\n                if (token.contains('@'))\n                    mail = token;\n                else\n                    name = name.isEmpty() ? token : name + \" \" + token;\n            }\n            if (mail.isEmpty()) {\n                qWarning(\"error, \\\"%s\\\" does not seem to contain a mail address\", arg.toLocal8Bit().data());\n                continue;\n            }\n            mail.remove('<');\n            mail.remove('>');\n            if (name.isEmpty())\n                name = mail;\n            imports.insert(name, mail);\n        }\n        if (imports.isEmpty()) {\n            qWarning(\"nothing to import\");\n            return 2;\n        }\n\n        int lastContact = -1, updates = 0, adds = 0;\n        QSettings abook(QDir::homePath() + \"/.abook/addressbook\", QSettings::IniFormat);\n        abook.setIniCodec(\"UTF-8\");\n        QStringList contacts = abook.childGroups();\n        foreach (const QString &contact, contacts) {\n            Common::SettingsCategoryGuard guard(&abook, contact);\n            int id = contact.toInt();\n            if (id > lastContact)\n                lastContact = id;\n            const QString name = abook.value(\"name\", QString()).toString();\n            QMap<QString,QString>::iterator it = imports.begin(), end = imports.end();\n            while (it != end) {\n                if (it.key() == name) {\n                    QStringList mails = abook.value(\"email\", QString()).toStringList();\n                    if (!mails.contains(it.value())) {\n                        ++updates;\n                        mails << it.value();\n                        abook.setValue(\"email\", mails);\n                    }\n                    it = imports.erase(it);\n                    continue;\n                }\n                else\n                    ++it;\n            }\n        }\n        QMap<QString,QString>::const_iterator it = imports.constBegin(), end = imports.constEnd();\n        while (it != end) {\n            ++adds;\n            Common::SettingsCategoryGuard guard(&abook, QString::number(++lastContact));\n            abook.setValue(\"name\", it.key());\n            abook.setValue(\"email\", it.value());\n            ++it;\n        }\n        qWarning(\"updated %d and added %d contacts\", updates, adds);\n        return 0;\n    }\n    QApplication a(argc, argv);\n    BE::Contacts w(new Gui::AbookAddressbook());\n    w.show();\n    return a.exec();\n}"
  }
]