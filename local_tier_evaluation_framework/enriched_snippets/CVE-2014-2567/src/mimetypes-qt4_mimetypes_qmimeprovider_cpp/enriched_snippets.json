[
  {
    "function_name": "addMagicMatcher",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "830-833",
    "snippet": "void QMimeXMLProvider::addMagicMatcher(const QMimeMagicRuleMatcher &matcher)\n{\n    m_magicMatchers.append(matcher);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_magicMatchers.append",
          "args": [
            "matcher"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addMagicMatcher(const QMimeMagicRuleMatcher &matcher)\n  {\n      m_magicMatchers.append(matcher);\n  }\n}"
  },
  {
    "function_name": "allMimeTypes",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "824-828",
    "snippet": "QList<QMimeType> QMimeXMLProvider::allMimeTypes()\n{\n    ensureLoaded();\n    return m_nameMimeTypeMap.values();\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_nameMimeTypeMap.values",
          "args": [],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureLoaded",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "ensureLoaded",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "719-759",
          "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QList<QMimeType> QMimeXMLProvider::allMimeTypes()\n  {\n      ensureLoaded();\n      return m_nameMimeTypeMap.values();\n  }\n}"
  },
  {
    "function_name": "addAlias",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "819-822",
    "snippet": "void QMimeXMLProvider::addAlias(const QString &alias, const QString &name)\n{\n    m_aliases.insert(alias, name);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_aliases.insert",
          "args": [
            "alias",
            "name"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addAlias(const QString &alias, const QString &name)\n  {\n      m_aliases.insert(alias, name);\n  }\n}"
  },
  {
    "function_name": "resolveAlias",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "813-817",
    "snippet": "QString QMimeXMLProvider::resolveAlias(const QString &name)\n{\n    ensureLoaded();\n    return m_aliases.value(name, name);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_aliases.value",
          "args": [
            "name",
            "name"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureLoaded",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "ensureLoaded",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "719-759",
          "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QString QMimeXMLProvider::resolveAlias(const QString &name)\n  {\n      ensureLoaded();\n      return m_aliases.value(name, name);\n  }\n}"
  },
  {
    "function_name": "addParent",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "808-811",
    "snippet": "void QMimeXMLProvider::addParent(const QString &child, const QString &parent)\n{\n    m_parents[child].append(parent);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_parents[child].append",
          "args": [
            "parent"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addParent(const QString &child, const QString &parent)\n  {\n      m_parents[child].append(parent);\n  }\n}"
  },
  {
    "function_name": "parents",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "796-806",
    "snippet": "QStringList QMimeXMLProvider::parents(const QString &mime)\n{\n    ensureLoaded();\n    QStringList result = m_parents.value(mime);\n    if (result.isEmpty()) {\n        const QString parent = fallbackParent(mime);\n        if (!parent.isEmpty())\n            result.append(parent);\n    }\n    return result;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.append",
          "args": [
            "parent"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.isEmpty",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fallbackParent",
          "args": [
            "mime"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "fallbackParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "56-72",
          "snippet": "QT_BEGIN_NAMESPACE\n\nstatic QString fallbackParent(const QString &mimeTypeName)\n{\n    const QString myGroup = mimeTypeName.left(mimeTypeName.indexOf(QLatin1Char('/')));\n    // All text/* types are subclasses of text/plain.\n    if (myGroup == QLatin1String(\"text\") && mimeTypeName != QLatin1String(\"text/plain\"))\n        return QLatin1String(\"text/plain\");\n    // All real-file mimetypes implicitly derive from application/octet-stream\n    if (myGroup != QLatin1String(\"inode\") &&\n        // ignore non-file extensions\n        myGroup != QLatin1String(\"all\") && myGroup != QLatin1String(\"fonts\") && myGroup != QLatin1String(\"print\") && myGroup != QLatin1String(\"uri\")\n        && mimeTypeName != QLatin1String(\"application/octet-stream\")) {\n        return QLatin1String(\"application/octet-stream\");\n    }\n    return QString();\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQT_BEGIN_NAMESPACE\n\nstatic QString fallbackParent(const QString &mimeTypeName)\n{\n    const QString myGroup = mimeTypeName.left(mimeTypeName.indexOf(QLatin1Char('/')));\n    // All text/* types are subclasses of text/plain.\n    if (myGroup == QLatin1String(\"text\") && mimeTypeName != QLatin1String(\"text/plain\"))\n        return QLatin1String(\"text/plain\");\n    // All real-file mimetypes implicitly derive from application/octet-stream\n    if (myGroup != QLatin1String(\"inode\") &&\n        // ignore non-file extensions\n        myGroup != QLatin1String(\"all\") && myGroup != QLatin1String(\"fonts\") && myGroup != QLatin1String(\"print\") && myGroup != QLatin1String(\"uri\")\n        && mimeTypeName != QLatin1String(\"application/octet-stream\")) {\n        return QLatin1String(\"application/octet-stream\");\n    }\n    return QString();\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.isEmpty",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_parents.value",
          "args": [
            "mime"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensureLoaded",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ensureLoaded",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "719-759",
          "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QStringList QMimeXMLProvider::parents(const QString &mime)\n  {\n      ensureLoaded();\n      QStringList result = m_parents.value(mime);\n      if (result.isEmpty()) {\n          const QString parent = fallbackParent(mime);\n          if (!parent.isEmpty())\n              result.append(parent);\n      }\n      return result;\n  }\n}"
  },
  {
    "function_name": "addMimeType",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "791-794",
    "snippet": "void QMimeXMLProvider::addMimeType(const QMimeType &mt)\n{\n    m_nameMimeTypeMap.insert(mt.name(), mt);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_nameMimeTypeMap.insert",
          "args": [
            "mt.name()",
            "mt"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mt.name",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "208-211",
          "snippet": "QString QMimeType::name() const\n{\n    return d->name;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::name() const\n  {\n      return d->name;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addMimeType(const QMimeType &mt)\n  {\n      m_nameMimeTypeMap.insert(mt.name(), mt);\n  }\n}"
  },
  {
    "function_name": "addGlobPattern",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "786-789",
    "snippet": "void QMimeXMLProvider::addGlobPattern(const QMimeGlobPattern &glob)\n{\n    m_mimeTypeGlobs.addGlob(glob);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_mimeTypeGlobs.addGlob",
          "args": [
            "glob"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "addGlob",
          "container": "QMimeAllGlobPatterns",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeglobpattern.cpp",
          "lines": "153-177",
          "snippet": "void QMimeAllGlobPatterns::addGlob(const QMimeGlobPattern &glob)\n{\n    const QString &pattern = glob.pattern();\n    Q_ASSERT(!pattern.isEmpty());\n\n    // Store each patterns into either m_fastPatternDict (*.txt, *.html etc. with default weight 50)\n    // or for the rest, like core.*, *.tar.bz2, *~, into highWeightPatternOffset (>50)\n    // or lowWeightPatternOffset (<=50)\n\n    if (glob.weight() == 50 && isFastPattern(pattern) && !glob.isCaseSensitive()) {\n        // The bulk of the patterns is *.foo with weight 50 --> those go into the fast patterns hash.\n        const QString extension = pattern.mid(2).toLower();\n        QStringList &patterns = m_fastPatterns[extension]; // find or create\n        // This would just slow things down: if (!patterns.contains(glob.mimeType()))\n        patterns.append(glob.mimeType());\n    } else {\n        if (glob.weight() > 50) {\n            // This would just slow things down: if (!m_highWeightGlobs.hasPattern(glob.mimeType(), glob.pattern()))\n            m_highWeightGlobs.append(glob);\n        } else {\n            //This would just slow things down: if (!m_lowWeightGlobs.hasPattern(glob.mimeType(), glob.pattern()))\n            m_lowWeightGlobs.append(glob);\n        }\n    }\n}",
          "includes": [
            "#include <QDebug>",
            "#include <QStringList>",
            "#include <QRegExp>",
            "#include \"qmimeglobpattern_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QDebug>\n#include <QStringList>\n#include <QRegExp>\n#include \"qmimeglobpattern_p.h\"\n\nQMimeAllGlobPatterns {\n  void QMimeAllGlobPatterns::addGlob(const QMimeGlobPattern &glob)\n  {\n      const QString &pattern = glob.pattern();\n      Q_ASSERT(!pattern.isEmpty());\n  \n      // Store each patterns into either m_fastPatternDict (*.txt, *.html etc. with default weight 50)\n      // or for the rest, like core.*, *.tar.bz2, *~, into highWeightPatternOffset (>50)\n      // or lowWeightPatternOffset (<=50)\n  \n      if (glob.weight() == 50 && isFastPattern(pattern) && !glob.isCaseSensitive()) {\n          // The bulk of the patterns is *.foo with weight 50 --> those go into the fast patterns hash.\n          const QString extension = pattern.mid(2).toLower();\n          QStringList &patterns = m_fastPatterns[extension]; // find or create\n          // This would just slow things down: if (!patterns.contains(glob.mimeType()))\n          patterns.append(glob.mimeType());\n      } else {\n          if (glob.weight() > 50) {\n              // This would just slow things down: if (!m_highWeightGlobs.hasPattern(glob.mimeType(), glob.pattern()))\n              m_highWeightGlobs.append(glob);\n          } else {\n              //This would just slow things down: if (!m_lowWeightGlobs.hasPattern(glob.mimeType(), glob.pattern()))\n              m_lowWeightGlobs.append(glob);\n          }\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::addGlobPattern(const QMimeGlobPattern &glob)\n  {\n      m_mimeTypeGlobs.addGlob(glob);\n  }\n}"
  },
  {
    "function_name": "load",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "768-784",
    "snippet": "bool QMimeXMLProvider::load(const QString &fileName, QString *errorMessage)\n{\n    m_loaded = true;\n\n    QFile file(fileName);\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        if (errorMessage)\n            *errorMessage = QString::fromLatin1(\"Cannot open %1: %2\").arg(fileName, file.errorString());\n        return false;\n    }\n\n    if (errorMessage)\n        errorMessage->clear();\n\n    QMimeTypeParser parser(*this);\n    return parser.parse(&file, fileName, errorMessage);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parser.parse",
          "args": [
            "&file",
            "fileName",
            "errorMessage"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "QMimeTypeParserBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetypeparser.cpp",
          "lines": "204-339",
          "snippet": "bool QMimeTypeParserBase::parse(QIODevice *dev, const QString &fileName, QString *errorMessage)\n{\n    QMimeTypePrivate data;\n    int priority = 50;\n    QStack<QMimeMagicRule *> currentRules; // stack for the nesting of rules\n    QList<QMimeMagicRule> rules; // toplevel rules\n    QXmlStreamReader reader(dev);\n    ParseState ps = ParseBeginning;\n    QXmlStreamAttributes atts;\n    while (!reader.atEnd()) {\n        switch (reader.readNext()) {\n        case QXmlStreamReader::StartElement:\n            ps = nextState(ps, reader.name());\n            atts = reader.attributes();\n            switch (ps) {\n            case ParseMimeType: { // start parsing a MIME type name\n                const QString name = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                if (name.isEmpty()) {\n                    reader.raiseError(QString::fromLatin1(\"Missing '%1'-attribute\").arg(QString::fromLatin1(mimeTypeAttributeC)));\n                } else {\n                    data.name = name;\n                }\n            }\n                break;\n            case ParseGenericIcon:\n                data.genericIconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                break;\n            case ParseIcon:\n                data.iconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                break;\n            case ParseGlobPattern: {\n                const QString pattern = atts.value(QLatin1String(patternAttributeC)).toString();\n                unsigned weight = atts.value(QLatin1String(weightAttributeC)).toString().toInt();\n                const bool caseSensitive = atts.value(QLatin1String(caseSensitiveAttributeC)).toString() == QLatin1String(\"true\");\n\n                if (weight == 0)\n                    weight = QMimeGlobPattern::DefaultWeight;\n\n                Q_ASSERT(!data.name.isEmpty());\n                const QMimeGlobPattern glob(pattern, data.name, weight, caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive);\n                if (!process(glob, errorMessage))   // for actual glob matching\n                    return false;\n                data.addGlobPattern(pattern); // just for QMimeType::globPatterns()\n            }\n                break;\n            case ParseSubClass: {\n                const QString inheritsFrom = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                if (!inheritsFrom.isEmpty())\n                    processParent(data.name, inheritsFrom);\n            }\n                break;\n            case ParseComment: {\n                // comments have locale attributes. We want the default, English one\n                QString locale = atts.value(QLatin1String(localeAttributeC)).toString();\n                const QString comment = reader.readElementText();\n                if (locale.isEmpty())\n                    locale = QString::fromLatin1(\"en_US\");\n                data.localeComments.insert(locale, comment);\n            }\n                break;\n            case ParseAlias: {\n                const QString alias = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                if (!alias.isEmpty())\n                    processAlias(alias, data.name);\n            }\n                break;\n            case ParseMagic: {\n                priority = 50;\n                const QString priorityS = atts.value(QLatin1String(priorityAttributeC)).toString();\n                if (!priorityS.isEmpty()) {\n                    if (!parseNumber(priorityS, &priority, errorMessage))\n                        return false;\n\n                }\n                currentRules.clear();\n                //qDebug() << \"MAGIC start for mimetype\" << data.name;\n            }\n                break;\n            case ParseMagicMatchRule: {\n                QMimeMagicRule *rule = 0;\n                if (!createMagicMatchRule(atts, errorMessage, rule))\n                    return false;\n                QList<QMimeMagicRule> *ruleList;\n                if (currentRules.isEmpty())\n                    ruleList = &rules;\n                else // nest this rule into the proper parent\n                    ruleList = &currentRules.top()->m_subMatches;\n                ruleList->append(*rule);\n                //qDebug() << \" MATCH added. Stack size was\" << currentRules.size();\n                currentRules.push(&ruleList->last());\n                delete rule;\n                break;\n            }\n            case ParseError:\n                reader.raiseError(QString::fromLatin1(\"Unexpected element <%1>\").\n                                  arg(reader.name().toString()));\n                break;\n            default:\n                break;\n            }\n            break;\n        // continue switch QXmlStreamReader::Token...\n        case QXmlStreamReader::EndElement: // Finished element\n        {\n            const QStringRef elementName = reader.name();\n            if (elementName == QLatin1String(mimeTypeTagC)) {\n                if (!process(QMimeType(data), errorMessage))\n                    return false;\n                data.clear();\n            } else if (elementName == QLatin1String(matchTagC)) {\n                // Closing a <match> tag, pop stack\n                currentRules.pop();\n                //qDebug() << \" MATCH closed. Stack size is now\" << currentRules.size();\n            } else if (elementName == QLatin1String(magicTagC)) {\n                //qDebug() << \"MAGIC ended, we got\" << rules.count() << \"rules, with prio\" << priority;\n                // Finished a <magic> sequence\n                QMimeMagicRuleMatcher ruleMatcher(data.name, priority);\n                ruleMatcher.addRules(rules);\n                processMagicMatcher(ruleMatcher);\n                rules.clear();\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    }\n\n    if (reader.hasError()) {\n        if (errorMessage)\n            *errorMessage = QString::fromLatin1(\"An error has been encountered at line %1 of %2: %3:\").arg(reader.lineNumber()).arg(fileName, reader.errorString());\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <QStack>",
            "#include <QXmlStreamWriter>",
            "#include <QXmlStreamReader>",
            "#include <QPair>",
            "#include <QDir>",
            "#include <QDebug>",
            "#include <QCoreApplication>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetypeparser_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char mimeTypeTagC[] = \"mime-type\";",
            "static const char mimeTypeAttributeC[] = \"type\";",
            "static const char nameAttributeC[] = \"name\";",
            "static const char patternAttributeC[] = \"pattern\";",
            "static const char weightAttributeC[] = \"weight\";",
            "static const char caseSensitiveAttributeC[] = \"case-sensitive\";",
            "static const char localeAttributeC[] = \"xml:lang\";",
            "static const char magicTagC[] = \"magic\";",
            "static const char priorityAttributeC[] = \"priority\";",
            "static const char matchTagC[] = \"match\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QStack>\n#include <QXmlStreamWriter>\n#include <QXmlStreamReader>\n#include <QPair>\n#include <QDir>\n#include <QDebug>\n#include <QCoreApplication>\n#include \"qmimemagicrulematcher_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetypeparser_p.h\"\n\nstatic const char mimeTypeTagC[] = \"mime-type\";\nstatic const char mimeTypeAttributeC[] = \"type\";\nstatic const char nameAttributeC[] = \"name\";\nstatic const char patternAttributeC[] = \"pattern\";\nstatic const char weightAttributeC[] = \"weight\";\nstatic const char caseSensitiveAttributeC[] = \"case-sensitive\";\nstatic const char localeAttributeC[] = \"xml:lang\";\nstatic const char magicTagC[] = \"magic\";\nstatic const char priorityAttributeC[] = \"priority\";\nstatic const char matchTagC[] = \"match\";\n\nQMimeTypeParserBase {\n  bool QMimeTypeParserBase::parse(QIODevice *dev, const QString &fileName, QString *errorMessage)\n  {\n      QMimeTypePrivate data;\n      int priority = 50;\n      QStack<QMimeMagicRule *> currentRules; // stack for the nesting of rules\n      QList<QMimeMagicRule> rules; // toplevel rules\n      QXmlStreamReader reader(dev);\n      ParseState ps = ParseBeginning;\n      QXmlStreamAttributes atts;\n      while (!reader.atEnd()) {\n          switch (reader.readNext()) {\n          case QXmlStreamReader::StartElement:\n              ps = nextState(ps, reader.name());\n              atts = reader.attributes();\n              switch (ps) {\n              case ParseMimeType: { // start parsing a MIME type name\n                  const QString name = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                  if (name.isEmpty()) {\n                      reader.raiseError(QString::fromLatin1(\"Missing '%1'-attribute\").arg(QString::fromLatin1(mimeTypeAttributeC)));\n                  } else {\n                      data.name = name;\n                  }\n              }\n                  break;\n              case ParseGenericIcon:\n                  data.genericIconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                  break;\n              case ParseIcon:\n                  data.iconName = atts.value(QLatin1String(nameAttributeC)).toString();\n                  break;\n              case ParseGlobPattern: {\n                  const QString pattern = atts.value(QLatin1String(patternAttributeC)).toString();\n                  unsigned weight = atts.value(QLatin1String(weightAttributeC)).toString().toInt();\n                  const bool caseSensitive = atts.value(QLatin1String(caseSensitiveAttributeC)).toString() == QLatin1String(\"true\");\n  \n                  if (weight == 0)\n                      weight = QMimeGlobPattern::DefaultWeight;\n  \n                  Q_ASSERT(!data.name.isEmpty());\n                  const QMimeGlobPattern glob(pattern, data.name, weight, caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive);\n                  if (!process(glob, errorMessage))   // for actual glob matching\n                      return false;\n                  data.addGlobPattern(pattern); // just for QMimeType::globPatterns()\n              }\n                  break;\n              case ParseSubClass: {\n                  const QString inheritsFrom = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                  if (!inheritsFrom.isEmpty())\n                      processParent(data.name, inheritsFrom);\n              }\n                  break;\n              case ParseComment: {\n                  // comments have locale attributes. We want the default, English one\n                  QString locale = atts.value(QLatin1String(localeAttributeC)).toString();\n                  const QString comment = reader.readElementText();\n                  if (locale.isEmpty())\n                      locale = QString::fromLatin1(\"en_US\");\n                  data.localeComments.insert(locale, comment);\n              }\n                  break;\n              case ParseAlias: {\n                  const QString alias = atts.value(QLatin1String(mimeTypeAttributeC)).toString();\n                  if (!alias.isEmpty())\n                      processAlias(alias, data.name);\n              }\n                  break;\n              case ParseMagic: {\n                  priority = 50;\n                  const QString priorityS = atts.value(QLatin1String(priorityAttributeC)).toString();\n                  if (!priorityS.isEmpty()) {\n                      if (!parseNumber(priorityS, &priority, errorMessage))\n                          return false;\n  \n                  }\n                  currentRules.clear();\n                  //qDebug() << \"MAGIC start for mimetype\" << data.name;\n              }\n                  break;\n              case ParseMagicMatchRule: {\n                  QMimeMagicRule *rule = 0;\n                  if (!createMagicMatchRule(atts, errorMessage, rule))\n                      return false;\n                  QList<QMimeMagicRule> *ruleList;\n                  if (currentRules.isEmpty())\n                      ruleList = &rules;\n                  else // nest this rule into the proper parent\n                      ruleList = &currentRules.top()->m_subMatches;\n                  ruleList->append(*rule);\n                  //qDebug() << \" MATCH added. Stack size was\" << currentRules.size();\n                  currentRules.push(&ruleList->last());\n                  delete rule;\n                  break;\n              }\n              case ParseError:\n                  reader.raiseError(QString::fromLatin1(\"Unexpected element <%1>\").\n                                    arg(reader.name().toString()));\n                  break;\n              default:\n                  break;\n              }\n              break;\n          // continue switch QXmlStreamReader::Token...\n          case QXmlStreamReader::EndElement: // Finished element\n          {\n              const QStringRef elementName = reader.name();\n              if (elementName == QLatin1String(mimeTypeTagC)) {\n                  if (!process(QMimeType(data), errorMessage))\n                      return false;\n                  data.clear();\n              } else if (elementName == QLatin1String(matchTagC)) {\n                  // Closing a <match> tag, pop stack\n                  currentRules.pop();\n                  //qDebug() << \" MATCH closed. Stack size is now\" << currentRules.size();\n              } else if (elementName == QLatin1String(magicTagC)) {\n                  //qDebug() << \"MAGIC ended, we got\" << rules.count() << \"rules, with prio\" << priority;\n                  // Finished a <magic> sequence\n                  QMimeMagicRuleMatcher ruleMatcher(data.name, priority);\n                  ruleMatcher.addRules(rules);\n                  processMagicMatcher(ruleMatcher);\n                  rules.clear();\n              }\n              break;\n          }\n          default:\n              break;\n          }\n      }\n  \n      if (reader.hasError()) {\n          if (errorMessage)\n              *errorMessage = QString::fromLatin1(\"An error has been encountered at line %1 of %2: %3:\").arg(reader.lineNumber()).arg(fileName, reader.errorString());\n          return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "errorMessage->clear",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "fileName",
            "file.errorString()"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.errorString",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "errorString",
          "container": "QwwSmtpClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/qwwsmtpclient/qwwsmtpclient.cpp",
          "lines": "712-714",
          "snippet": "QString QwwSmtpClient::errorString() const{\n    return d->errorString;\n}",
          "includes": [
            "#include \"moc_qwwsmtpclient.cpp\"",
            "#include <QStringList>",
            "#include <QVariant>",
            "#include <QQueue>",
            "#include <QtDebug>",
            "#include <QSslSocket>",
            "#include \"qwwsmtpclient.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"moc_qwwsmtpclient.cpp\"\n#include <QStringList>\n#include <QVariant>\n#include <QQueue>\n#include <QtDebug>\n#include <QSslSocket>\n#include \"qwwsmtpclient.h\"\n\nQwwSmtpClient {\n  QString QwwSmtpClient::errorString() const{\n      return d->errorString;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"Cannot open %1: %2\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "QIODevice::ReadOnly | QIODevice::Text"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::load(const QString &fileName, QString *errorMessage)\n  {\n      m_loaded = true;\n  \n      QFile file(fileName);\n      if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n          if (errorMessage)\n              *errorMessage = QString::fromLatin1(\"Cannot open %1: %2\").arg(fileName, file.errorString());\n          return false;\n      }\n  \n      if (errorMessage)\n          errorMessage->clear();\n  \n      QMimeTypeParser parser(*this);\n      return parser.parse(&file, fileName, errorMessage);\n  }\n}"
  },
  {
    "function_name": "load",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "761-766",
    "snippet": "void QMimeXMLProvider::load(const QString &fileName)\n{\n    QString errorMessage;\n    if (!load(fileName, &errorMessage))\n        qWarning(\"QMimeDatabase: Error loading %s\\n%s\", qPrintable(fileName), qPrintable(errorMessage));\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qWarning",
          "args": [
            "\"QMimeDatabase: Error loading %s\\n%s\"",
            "qPrintable(fileName)",
            "qPrintable(errorMessage)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qPrintable",
          "args": [
            "errorMessage"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qPrintable",
          "args": [
            "fileName"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load",
          "args": [
            "fileName",
            "&errorMessage"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "load",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "768-784",
          "snippet": "bool QMimeXMLProvider::load(const QString &fileName, QString *errorMessage)\n{\n    m_loaded = true;\n\n    QFile file(fileName);\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        if (errorMessage)\n            *errorMessage = QString::fromLatin1(\"Cannot open %1: %2\").arg(fileName, file.errorString());\n        return false;\n    }\n\n    if (errorMessage)\n        errorMessage->clear();\n\n    QMimeTypeParser parser(*this);\n    return parser.parse(&file, fileName, errorMessage);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::load(const QString &fileName)\n  {\n      QString errorMessage;\n      if (!load(fileName, &errorMessage))\n          qWarning(\"QMimeDatabase: Error loading %s\\n%s\", qPrintable(fileName), qPrintable(errorMessage));\n  }\n}"
  },
  {
    "function_name": "ensureLoaded",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "719-759",
    "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load",
          "args": [
            "file"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "load",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "761-766",
          "snippet": "void QMimeXMLProvider::load(const QString &fileName)\n{\n    QString errorMessage;\n    if (!load(fileName, &errorMessage))\n        qWarning(\"QMimeDatabase: Error loading %s\\n%s\", qPrintable(fileName), qPrintable(errorMessage));\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::load(const QString &fileName)\n  {\n      QString errorMessage;\n      if (!load(fileName, &errorMessage))\n          qWarning(\"QMimeDatabase: Error loading %s\\n%s\", qPrintable(fileName), qPrintable(errorMessage));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_magicMatchers.clear",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "allFiles.prepend",
          "args": [
            "QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\")"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\":/qt-project.org/qmime/freedesktop.org.xml\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allFiles.append",
          "args": [
            "packageDir + QLatin1Char('/') + *it"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'/'"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files.constBegin",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files.constEnd",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files.contains",
          "args": [
            "QLatin1String(\"freedesktop.org.xml\")"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"freedesktop.org.xml\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir.entryList",
          "args": [
            "QDir::Files | QDir::NoDotAndDotDot"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStandardPaths::locateAll",
          "args": [
            "QStandardPaths::GenericDataLocation",
            "QLatin1String(\"mime/packages\")",
            "QStandardPaths::LocateDirectory"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "locateAll",
          "container": "QStandardPaths",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/io/qstandardpaths.cpp",
          "lines": "167-177",
          "snippet": "QStringList QStandardPaths::locateAll(StandardLocation type, const QString &fileName, LocateOptions options)\n{\n    const QStringList &dirs = standardLocations(type);\n    QStringList result;\n    for (QStringList::const_iterator dir = dirs.constBegin(); dir != dirs.constEnd(); ++dir) {\n        const QString path = *dir + QLatin1Char('/') + fileName;\n        if (existsAsSpecified(path, options))\n            result.append(path);\n    }\n    return result;\n}",
          "includes": [
            "#include <qcoreapplication.h>",
            "#include <qobject.h>",
            "#include <qhash.h>",
            "#include <qfileinfo.h>",
            "#include <qdir.h>",
            "#include \"qstandardpaths.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qcoreapplication.h>\n#include <qobject.h>\n#include <qhash.h>\n#include <qfileinfo.h>\n#include <qdir.h>\n#include \"qstandardpaths.h\"\n\nQStandardPaths {\n  QStringList QStandardPaths::locateAll(StandardLocation type, const QString &fileName, LocateOptions options)\n  {\n      const QStringList &dirs = standardLocations(type);\n      QStringList result;\n      for (QStringList::const_iterator dir = dirs.constBegin(); dir != dirs.constEnd(); ++dir) {\n          const QString path = *dir + QLatin1Char('/') + fileName;\n          if (existsAsSpecified(path, options))\n              result.append(path);\n      }\n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"mime/packages\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shouldCheck",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "shouldCheck",
          "container": "QMimeProviderBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "81-88",
          "snippet": "bool QMimeProviderBase::shouldCheck()\n{\n    const QDateTime now = QDateTime::currentDateTime();\n    if (m_lastCheck.isValid() && m_lastCheck.secsTo(now) < qmime_secondsBetweenChecks)\n        return false;\n    m_lastCheck = now;\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int qmime_secondsBetweenChecks = 5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nint qmime_secondsBetweenChecks = 5;\n\nQMimeProviderBase {\n  bool QMimeProviderBase::shouldCheck()\n  {\n      const QDateTime now = QDateTime::currentDateTime();\n      if (m_lastCheck.isValid() && m_lastCheck.secsTo(now) < qmime_secondsBetweenChecks)\n          return false;\n      m_lastCheck = now;\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
  },
  {
    "function_name": "findByMagic",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "701-717",
    "snippet": "QMimeType QMimeXMLProvider::findByMagic(const QByteArray &data, int *accuracyPtr)\n{\n    ensureLoaded();\n\n    QString candidate;\n\n    foreach (const QMimeMagicRuleMatcher &matcher, m_magicMatchers) {\n        if (matcher.matches(data)) {\n            const int priority = matcher.priority();\n            if (priority > *accuracyPtr) {\n                *accuracyPtr = priority;\n                candidate = matcher.mimetype();\n            }\n        }\n    }\n    return mimeTypeForName(candidate);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimeTypeForName",
          "args": [
            "candidate"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForName",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "686-691",
          "snippet": "QMimeType QMimeXMLProvider::mimeTypeForName(const QString &name)\n{\n    ensureLoaded();\n\n    return m_nameMimeTypeMap.value(name);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QMimeType QMimeXMLProvider::mimeTypeForName(const QString &name)\n  {\n      ensureLoaded();\n  \n      return m_nameMimeTypeMap.value(name);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "matcher.mimetype",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matcher.priority",
          "args": [],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "priority",
          "container": "QMimeMagicRuleMatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrulematcher.cpp",
          "lines": "102-105",
          "snippet": "unsigned QMimeMagicRuleMatcher::priority() const\n{\n    return m_priority;\n}",
          "includes": [
            "#include \"qmimetype_p.h\"",
            "#include \"qmimemagicrulematcher_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimetype_p.h\"\n#include \"qmimemagicrulematcher_p.h\"\n\nQMimeMagicRuleMatcher {\n  unsigned QMimeMagicRuleMatcher::priority() const\n  {\n      return m_priority;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "matcher.matches",
          "args": [
            "data"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "matches",
          "container": "QMimeMagicRuleMatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrulematcher.cpp",
          "lines": "91-99",
          "snippet": "bool QMimeMagicRuleMatcher::matches(const QByteArray &data) const\n{\n    foreach (const QMimeMagicRule &magicRule, m_list) {\n        if (magicRule.matches(data))\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"qmimetype_p.h\"",
            "#include \"qmimemagicrulematcher_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qmimetype_p.h\"\n#include \"qmimemagicrulematcher_p.h\"\n\nQMimeMagicRuleMatcher {\n  bool QMimeMagicRuleMatcher::matches(const QByteArray &data) const\n  {\n      foreach (const QMimeMagicRule &magicRule, m_list) {\n          if (magicRule.matches(data))\n              return true;\n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensureLoaded",
          "args": [],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ensureLoaded",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "719-759",
          "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QMimeType QMimeXMLProvider::findByMagic(const QByteArray &data, int *accuracyPtr)\n  {\n      ensureLoaded();\n  \n      QString candidate;\n  \n      foreach (const QMimeMagicRuleMatcher &matcher, m_magicMatchers) {\n          if (matcher.matches(data)) {\n              const int priority = matcher.priority();\n              if (priority > *accuracyPtr) {\n                  *accuracyPtr = priority;\n                  candidate = matcher.mimetype();\n              }\n          }\n      }\n      return mimeTypeForName(candidate);\n  }\n}"
  },
  {
    "function_name": "findByFileName",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "693-699",
    "snippet": "QStringList QMimeXMLProvider::findByFileName(const QString &fileName, QString *foundSuffix)\n{\n    ensureLoaded();\n\n    const QStringList matchingMimeTypes = m_mimeTypeGlobs.matchingGlobs(fileName, foundSuffix);\n    return matchingMimeTypes;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_mimeTypeGlobs.matchingGlobs",
          "args": [
            "fileName",
            "foundSuffix"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "matchingGlobs",
          "container": "QMimeAllGlobPatterns",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeglobpattern.cpp",
          "lines": "202-231",
          "snippet": "QStringList QMimeAllGlobPatterns::matchingGlobs(const QString &fileName, QString *foundSuffix) const\n{\n    // First try the high weight matches (>50), if any.\n    QMimeGlobMatchResult result;\n    m_highWeightGlobs.match(result, fileName);\n    if (result.m_matchingMimeTypes.isEmpty()) {\n\n        // Now use the \"fast patterns\" dict, for simple *.foo patterns with weight 50\n        // (which is most of them, so this optimization is definitely worth it)\n        const int lastDot = fileName.lastIndexOf(QLatin1Char('.'));\n        if (lastDot != -1) { // if no '.', skip the extension lookup\n            const int ext_len = fileName.length() - lastDot - 1;\n            const QString simpleExtension = fileName.right(ext_len).toLower();\n            // (toLower because fast patterns are always case-insensitive and saved as lowercase)\n\n            const QStringList matchingMimeTypes = m_fastPatterns.value(simpleExtension);\n            foreach (const QString &mime, matchingMimeTypes) {\n                result.addMatch(mime, 50, QLatin1String(\"*.\") + simpleExtension);\n            }\n            // Can't return yet; *.tar.bz2 has to win over *.bz2, so we need the low-weight mimetypes anyway,\n            // at least those with weight 50.\n        }\n\n        // Finally, try the low weight matches (<=50)\n        m_lowWeightGlobs.match(result, fileName);\n    }\n    if (foundSuffix)\n        *foundSuffix = result.m_foundSuffix;\n    return result.m_matchingMimeTypes;\n}",
          "includes": [
            "#include <QDebug>",
            "#include <QStringList>",
            "#include <QRegExp>",
            "#include \"qmimeglobpattern_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QDebug>\n#include <QStringList>\n#include <QRegExp>\n#include \"qmimeglobpattern_p.h\"\n\nQMimeAllGlobPatterns {\n  QStringList QMimeAllGlobPatterns::matchingGlobs(const QString &fileName, QString *foundSuffix) const\n  {\n      // First try the high weight matches (>50), if any.\n      QMimeGlobMatchResult result;\n      m_highWeightGlobs.match(result, fileName);\n      if (result.m_matchingMimeTypes.isEmpty()) {\n  \n          // Now use the \"fast patterns\" dict, for simple *.foo patterns with weight 50\n          // (which is most of them, so this optimization is definitely worth it)\n          const int lastDot = fileName.lastIndexOf(QLatin1Char('.'));\n          if (lastDot != -1) { // if no '.', skip the extension lookup\n              const int ext_len = fileName.length() - lastDot - 1;\n              const QString simpleExtension = fileName.right(ext_len).toLower();\n              // (toLower because fast patterns are always case-insensitive and saved as lowercase)\n  \n              const QStringList matchingMimeTypes = m_fastPatterns.value(simpleExtension);\n              foreach (const QString &mime, matchingMimeTypes) {\n                  result.addMatch(mime, 50, QLatin1String(\"*.\") + simpleExtension);\n              }\n              // Can't return yet; *.tar.bz2 has to win over *.bz2, so we need the low-weight mimetypes anyway,\n              // at least those with weight 50.\n          }\n  \n          // Finally, try the low weight matches (<=50)\n          m_lowWeightGlobs.match(result, fileName);\n      }\n      if (foundSuffix)\n          *foundSuffix = result.m_foundSuffix;\n      return result.m_matchingMimeTypes;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensureLoaded",
          "args": [],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "ensureLoaded",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "719-759",
          "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QStringList QMimeXMLProvider::findByFileName(const QString &fileName, QString *foundSuffix)\n  {\n      ensureLoaded();\n  \n      const QStringList matchingMimeTypes = m_mimeTypeGlobs.matchingGlobs(fileName, foundSuffix);\n      return matchingMimeTypes;\n  }\n}"
  },
  {
    "function_name": "mimeTypeForName",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "686-691",
    "snippet": "QMimeType QMimeXMLProvider::mimeTypeForName(const QString &name)\n{\n    ensureLoaded();\n\n    return m_nameMimeTypeMap.value(name);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_nameMimeTypeMap.value",
          "args": [
            "name"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "187-205",
          "snippet": "QVariant XSqlQuery::value(const QString & name) const\n{\n    if (name.isEmpty())\n        return QVariant();\n\n    if (_data && !_data->_currRecord.isEmpty())\n    {\n        int i = _data->_currRecord.indexOf(name);\n        if(i<0)\n        {\n            QString err = \"Column \" + name + \" not found in record\";\n            qWarning(\"%s\", err.toLocal8Bit().constData());\n            return QVariant(_nameErrorValue);\n        }\n        return value(_data->_currRecord.indexOf(name));\n    }\n\n    return QVariant();\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [
            "static QString _nameErrorValue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nstatic QString _nameErrorValue;\n\nXSqlQuery {\n  QVariant XSqlQuery::value(const QString & name) const\n  {\n      if (name.isEmpty())\n          return QVariant();\n  \n      if (_data && !_data->_currRecord.isEmpty())\n      {\n          int i = _data->_currRecord.indexOf(name);\n          if(i<0)\n          {\n              QString err = \"Column \" + name + \" not found in record\";\n              qWarning(\"%s\", err.toLocal8Bit().constData());\n              return QVariant(_nameErrorValue);\n          }\n          return value(_data->_currRecord.indexOf(name));\n      }\n  \n      return QVariant();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensureLoaded",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ensureLoaded",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "719-759",
          "snippet": "void QMimeXMLProvider::ensureLoaded()\n{\n    if (!m_loaded || shouldCheck()) {\n        bool fdoXmlFound = false;\n        QStringList allFiles;\n\n        const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n        //qDebug() << \"packageDirs=\" << packageDirs;\n        foreach (const QString &packageDir, packageDirs) {\n            QDir dir(packageDir);\n            const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n            //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n            if (!fdoXmlFound)\n                fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n            QStringList::const_iterator endIt(files.constEnd());\n            for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                allFiles.append(packageDir + QLatin1Char('/') + *it);\n            }\n        }\n\n        if (!fdoXmlFound) {\n            // We could instead install the file as part of installing Qt?\n            allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n        }\n\n        if (m_allFiles == allFiles)\n            return;\n        m_allFiles = allFiles;\n\n        m_nameMimeTypeMap.clear();\n        m_aliases.clear();\n        m_parents.clear();\n        m_mimeTypeGlobs.clear();\n        m_magicMatchers.clear();\n\n        //qDebug() << \"Loading\" << m_allFiles;\n\n        foreach (const QString &file, allFiles)\n            load(file);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  void QMimeXMLProvider::ensureLoaded()\n  {\n      if (!m_loaded || shouldCheck()) {\n          bool fdoXmlFound = false;\n          QStringList allFiles;\n  \n          const QStringList packageDirs = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/packages\"), QStandardPaths::LocateDirectory);\n          //qDebug() << \"packageDirs=\" << packageDirs;\n          foreach (const QString &packageDir, packageDirs) {\n              QDir dir(packageDir);\n              const QStringList files = dir.entryList(QDir::Files | QDir::NoDotAndDotDot);\n              //qDebug() << static_cast<const void *>(this) << Q_FUNC_INFO << packageDir << files;\n              if (!fdoXmlFound)\n                  fdoXmlFound = files.contains(QLatin1String(\"freedesktop.org.xml\"));\n              QStringList::const_iterator endIt(files.constEnd());\n              for (QStringList::const_iterator it(files.constBegin()); it != endIt; ++it) {\n                  allFiles.append(packageDir + QLatin1Char('/') + *it);\n              }\n          }\n  \n          if (!fdoXmlFound) {\n              // We could instead install the file as part of installing Qt?\n              allFiles.prepend(QLatin1String(\":/qt-project.org/qmime/freedesktop.org.xml\"));\n          }\n  \n          if (m_allFiles == allFiles)\n              return;\n          m_allFiles = allFiles;\n  \n          m_nameMimeTypeMap.clear();\n          m_aliases.clear();\n          m_parents.clear();\n          m_mimeTypeGlobs.clear();\n          m_magicMatchers.clear();\n  \n          //qDebug() << \"Loading\" << m_allFiles;\n  \n          foreach (const QString &file, allFiles)\n              load(file);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QMimeType QMimeXMLProvider::mimeTypeForName(const QString &name)\n  {\n      ensureLoaded();\n  \n      return m_nameMimeTypeMap.value(name);\n  }\n}"
  },
  {
    "function_name": "isValid",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "681-684",
    "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
  },
  {
    "function_name": "QMimeXMLProvider",
    "container": "QMimeXMLProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "676-679",
    "snippet": "QMimeXMLProvider::QMimeXMLProvider(QMimeDatabasePrivate *db)\n    : QMimeProviderBase(db), m_loaded(false)\n{\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  QMimeXMLProvider::QMimeXMLProvider(QMimeDatabasePrivate *db)\n      : QMimeProviderBase(db), m_loaded(false)\n  {\n  }\n}"
  },
  {
    "function_name": "loadGenericIcon",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "661-672",
    "snippet": "void QMimeBinaryProvider::loadGenericIcon(QMimeTypePrivate &data)\n{\n    checkCache();\n    const QByteArray inputMime = data.name.toLatin1();\n    foreach (CacheFile *cacheFile, m_cacheFiles) {\n        const QString icon = iconForMime(cacheFile, PosGenericIconsListOffset, inputMime);\n        if (!icon.isEmpty()) {\n            data.genericIconName = icon;\n            return;\n        }\n    }\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "icon.isEmpty",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iconForMime",
          "args": [
            "cacheFile",
            "PosGenericIconsListOffset",
            "inputMime"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "iconForMime",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "624-646",
          "snippet": "QString QMimeBinaryProvider::iconForMime(CacheFile *cacheFile, int posListOffset, const QByteArray &inputMime)\n{\n    const int iconsListOffset = cacheFile->getUint32(posListOffset);\n    const int numIcons = cacheFile->getUint32(iconsListOffset);\n    int begin = 0;\n    int end = numIcons - 1;\n    while (begin <= end) {\n        const int medium = (begin + end) / 2;\n        const int off = iconsListOffset + 4 + 8 * medium;\n        const int mimeOffset = cacheFile->getUint32(off);\n        const char *mime = cacheFile->getCharStar(mimeOffset);\n        const int cmp = qstrcmp(mime, inputMime);\n        if (cmp < 0)\n            begin = medium + 1;\n        else if (cmp > 0)\n            end = medium - 1;\n        else {\n            const int iconOffset = cacheFile->getUint32(off + 4);\n            return QLatin1String(cacheFile->getCharStar(iconOffset));\n        }\n    }\n    return QString();\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QString QMimeBinaryProvider::iconForMime(CacheFile *cacheFile, int posListOffset, const QByteArray &inputMime)\n  {\n      const int iconsListOffset = cacheFile->getUint32(posListOffset);\n      const int numIcons = cacheFile->getUint32(iconsListOffset);\n      int begin = 0;\n      int end = numIcons - 1;\n      while (begin <= end) {\n          const int medium = (begin + end) / 2;\n          const int off = iconsListOffset + 4 + 8 * medium;\n          const int mimeOffset = cacheFile->getUint32(off);\n          const char *mime = cacheFile->getCharStar(mimeOffset);\n          const int cmp = qstrcmp(mime, inputMime);\n          if (cmp < 0)\n              begin = medium + 1;\n          else if (cmp > 0)\n              end = medium - 1;\n          else {\n              const int iconOffset = cacheFile->getUint32(off + 4);\n              return QLatin1String(cacheFile->getCharStar(iconOffset));\n          }\n      }\n      return QString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.name.toLatin1",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadGenericIcon(QMimeTypePrivate &data)\n  {\n      checkCache();\n      const QByteArray inputMime = data.name.toLatin1();\n      foreach (CacheFile *cacheFile, m_cacheFiles) {\n          const QString icon = iconForMime(cacheFile, PosGenericIconsListOffset, inputMime);\n          if (!icon.isEmpty()) {\n              data.genericIconName = icon;\n              return;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "loadIcon",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "648-659",
    "snippet": "void QMimeBinaryProvider::loadIcon(QMimeTypePrivate &data)\n{\n    checkCache();\n    const QByteArray inputMime = data.name.toLatin1();\n    foreach (CacheFile *cacheFile, m_cacheFiles) {\n        const QString icon = iconForMime(cacheFile, PosIconsListOffset, inputMime);\n        if (!icon.isEmpty()) {\n            data.iconName = icon;\n            return;\n        }\n    }\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "icon.isEmpty",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iconForMime",
          "args": [
            "cacheFile",
            "PosIconsListOffset",
            "inputMime"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "iconForMime",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "624-646",
          "snippet": "QString QMimeBinaryProvider::iconForMime(CacheFile *cacheFile, int posListOffset, const QByteArray &inputMime)\n{\n    const int iconsListOffset = cacheFile->getUint32(posListOffset);\n    const int numIcons = cacheFile->getUint32(iconsListOffset);\n    int begin = 0;\n    int end = numIcons - 1;\n    while (begin <= end) {\n        const int medium = (begin + end) / 2;\n        const int off = iconsListOffset + 4 + 8 * medium;\n        const int mimeOffset = cacheFile->getUint32(off);\n        const char *mime = cacheFile->getCharStar(mimeOffset);\n        const int cmp = qstrcmp(mime, inputMime);\n        if (cmp < 0)\n            begin = medium + 1;\n        else if (cmp > 0)\n            end = medium - 1;\n        else {\n            const int iconOffset = cacheFile->getUint32(off + 4);\n            return QLatin1String(cacheFile->getCharStar(iconOffset));\n        }\n    }\n    return QString();\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QString QMimeBinaryProvider::iconForMime(CacheFile *cacheFile, int posListOffset, const QByteArray &inputMime)\n  {\n      const int iconsListOffset = cacheFile->getUint32(posListOffset);\n      const int numIcons = cacheFile->getUint32(iconsListOffset);\n      int begin = 0;\n      int end = numIcons - 1;\n      while (begin <= end) {\n          const int medium = (begin + end) / 2;\n          const int off = iconsListOffset + 4 + 8 * medium;\n          const int mimeOffset = cacheFile->getUint32(off);\n          const char *mime = cacheFile->getCharStar(mimeOffset);\n          const int cmp = qstrcmp(mime, inputMime);\n          if (cmp < 0)\n              begin = medium + 1;\n          else if (cmp > 0)\n              end = medium - 1;\n          else {\n              const int iconOffset = cacheFile->getUint32(off + 4);\n              return QLatin1String(cacheFile->getCharStar(iconOffset));\n          }\n      }\n      return QString();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.name.toLatin1",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadIcon(QMimeTypePrivate &data)\n  {\n      checkCache();\n      const QByteArray inputMime = data.name.toLatin1();\n      foreach (CacheFile *cacheFile, m_cacheFiles) {\n          const QString icon = iconForMime(cacheFile, PosIconsListOffset, inputMime);\n          if (!icon.isEmpty()) {\n              data.iconName = icon;\n              return;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "iconForMime",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "624-646",
    "snippet": "QString QMimeBinaryProvider::iconForMime(CacheFile *cacheFile, int posListOffset, const QByteArray &inputMime)\n{\n    const int iconsListOffset = cacheFile->getUint32(posListOffset);\n    const int numIcons = cacheFile->getUint32(iconsListOffset);\n    int begin = 0;\n    int end = numIcons - 1;\n    while (begin <= end) {\n        const int medium = (begin + end) / 2;\n        const int off = iconsListOffset + 4 + 8 * medium;\n        const int mimeOffset = cacheFile->getUint32(off);\n        const char *mime = cacheFile->getCharStar(mimeOffset);\n        const int cmp = qstrcmp(mime, inputMime);\n        if (cmp < 0)\n            begin = medium + 1;\n        else if (cmp > 0)\n            end = medium - 1;\n        else {\n            const int iconOffset = cacheFile->getUint32(off + 4);\n            return QLatin1String(cacheFile->getCharStar(iconOffset));\n        }\n    }\n    return QString();\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QString",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "cacheFile->getCharStar(iconOffset)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "iconOffset"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "off + 4"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "qstrcmp",
          "args": [
            "mime",
            "inputMime"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "mimeOffset"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QString QMimeBinaryProvider::iconForMime(CacheFile *cacheFile, int posListOffset, const QByteArray &inputMime)\n  {\n      const int iconsListOffset = cacheFile->getUint32(posListOffset);\n      const int numIcons = cacheFile->getUint32(iconsListOffset);\n      int begin = 0;\n      int end = numIcons - 1;\n      while (begin <= end) {\n          const int medium = (begin + end) / 2;\n          const int off = iconsListOffset + 4 + 8 * medium;\n          const int mimeOffset = cacheFile->getUint32(off);\n          const char *mime = cacheFile->getCharStar(mimeOffset);\n          const int cmp = qstrcmp(mime, inputMime);\n          if (cmp < 0)\n              begin = medium + 1;\n          else if (cmp > 0)\n              end = medium - 1;\n          else {\n              const int iconOffset = cacheFile->getUint32(off + 4);\n              return QLatin1String(cacheFile->getCharStar(iconOffset));\n          }\n      }\n      return QString();\n  }\n}"
  },
  {
    "function_name": "loadMimeTypePrivate",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "530-621",
    "snippet": "void QMimeBinaryProvider::loadMimeTypePrivate(QMimeTypePrivate &data)\n{\n    if (data.loaded)\n        return;\n    data.loaded = true;\n    // load comment and globPatterns\n\n    const QString file = data.name + QLatin1String(\".xml\");\n    const QStringList mimeFiles = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QString::fromLatin1(\"mime/\") + file);\n    if (mimeFiles.isEmpty()) {\n        // TODO: ask Thiago about this\n        qWarning() << \"No file found for\" << file << \", even though the file appeared in a directory listing.\";\n        qWarning() << \"Either it was just removed, or the directory doesn't have executable permission...\";\n        qWarning() << QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime\"), QStandardPaths::LocateDirectory);\n        return;\n    }\n\n    QString comment;\n    QString mainPattern;\n    const QString preferredLanguage = QLocale::system().name();\n\n    QListIterator<QString> mimeFilesIter(mimeFiles);\n    mimeFilesIter.toBack();\n    while (mimeFilesIter.hasPrevious()) { // global first, then local.\n        const QString fullPath = mimeFilesIter.previous();\n        QFile qfile(fullPath);\n        if (!qfile.open(QFile::ReadOnly))\n            continue;\n\n        QXmlStreamReader xml(&qfile);\n        if (xml.readNextStartElement()) {\n            if (xml.name() != QLatin1String(\"mime-type\")) {\n                continue;\n            }\n            const QString name = xml.attributes().value(QLatin1String(\"type\")).toString();\n            if (name.isEmpty())\n                continue;\n            if (name != data.name) {\n                qWarning() << \"Got name\" << name << \"in file\" << file << \"expected\" << data.name;\n            }\n\n            while (xml.readNextStartElement()) {\n                const QStringRef tag = xml.name();\n                if (tag == QLatin1String(\"comment\")) {\n                    QString lang = xml.attributes().value(QLatin1String(\"xml:lang\")).toString();\n                    const QString text = xml.readElementText();\n                    if (lang.isEmpty()) {\n                        lang = QLatin1String(\"en_US\");\n                    }\n                    data.localeComments.insert(lang, text);\n                    continue; // we called readElementText, so we're at the EndElement already.\n                } else if (tag == QLatin1String(\"icon\")) { // as written out by shared-mime-info >= 0.40\n                    data.iconName = xml.attributes().value(QLatin1String(\"name\")).toString();\n                } else if (tag == QLatin1String(\"glob-deleteall\")) { // as written out by shared-mime-info >= 0.70\n                    data.globPatterns.clear();\n                } else if (tag == QLatin1String(\"glob\")) { // as written out by shared-mime-info >= 0.70\n                    const QString pattern = xml.attributes().value(QLatin1String(\"pattern\")).toString();\n                    if (mainPattern.isEmpty() && pattern.startsWith(QLatin1Char('*'))) {\n                        mainPattern = pattern;\n                    }\n                    if (!data.globPatterns.contains(pattern))\n                        data.globPatterns.append(pattern);\n                }\n                xml.skipCurrentElement();\n            }\n            Q_ASSERT(xml.name() == QLatin1String(\"mime-type\"));\n        }\n    }\n\n    // Let's assume that shared-mime-info is at least version 0.70\n    // Otherwise we would need 1) a version check, and 2) code for parsing patterns from the globs file.\n#if 1\n    if (!mainPattern.isEmpty() && data.globPatterns.first() != mainPattern) {\n        // ensure it's first in the list of patterns\n        data.globPatterns.removeAll(mainPattern);\n        data.globPatterns.prepend(mainPattern);\n    }\n#else\n    const bool globsInXml = sharedMimeInfoVersion() >= QT_VERSION_CHECK(0, 70, 0);\n    if (globsInXml) {\n        if (!mainPattern.isEmpty() && data.globPatterns.first() != mainPattern) {\n            // ensure it's first in the list of patterns\n            data.globPatterns.removeAll(mainPattern);\n            data.globPatterns.prepend(mainPattern);\n        }\n    } else {\n        // Fallback: get the patterns from the globs file\n        // TODO: This would be the only way to support shared-mime-info < 0.70\n        // But is this really worth the effort?\n    }\n#endif\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.globPatterns.prepend",
          "args": [
            "mainPattern"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.removeAll",
          "args": [
            "mainPattern"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.first",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mainPattern.isEmpty",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QT_VERSION_CHECK",
          "args": [
            "0",
            "70",
            "0"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sharedMimeInfoVersion",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.prepend",
          "args": [
            "mainPattern"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.removeAll",
          "args": [
            "mainPattern"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mainPattern.isEmpty",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "xml.name() == QLatin1String(\"mime-type\")"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"mime-type\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.name",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "name",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "208-211",
          "snippet": "QString QMimeType::name() const\n{\n    return d->name;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::name() const\n  {\n      return d->name;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xml.skipCurrentElement",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.append",
          "args": [
            "pattern"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.contains",
          "args": [
            "pattern"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pattern.startsWith",
          "args": [
            "QLatin1Char('*')"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'*'"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mainPattern.isEmpty",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [
            "QLatin1String(\"pattern\")"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"pattern\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"glob\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.globPatterns.clear",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"glob-deleteall\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [
            "QLatin1String(\"name\")"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"name\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"icon\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.localeComments.insert",
          "args": [
            "lang",
            "text"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"en_US\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lang.isEmpty",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.readElementText",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [
            "QLatin1String(\"xml:lang\")"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"xml:lang\""
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"comment\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.readNextStartElement",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.isEmpty",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [
            "QLatin1String(\"type\")"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"type\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.attributes",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"mime-type\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xml.readNextStartElement",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qfile.open",
          "args": [
            "QFile::ReadOnly"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeFilesIter.previous",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "previous",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "342-375",
          "snippet": "bool XSqlQuery::previous()\n{\n  if (!_data)\n    return QSqlQuery::previous();\n\n  bool returnVal = false;\n\n  if (_data->_keepTotals && isValid())\n  {\n    QMap<QString,double> delta;\n    QMapIterator<QString,double> mit(_data->_fieldTotals);\n    while(mit.hasNext())\n    {\n      mit.next();\n      delta[mit.key()] = value(mit.key()).toDouble();\n    }\n    returnVal = QSqlQuery::previous();\n    if (returnVal)\n    {\n      mit = delta;\n      while(mit.hasNext())\n      {\n        mit.next();\n        _data->_fieldTotals[mit.key()] -= mit.value();\n        _data->_fieldSubTotals[mit.key()] -= mit.value();\n      }\n    }\n  }\n  else\n    returnVal = QSqlQuery::previous();\n\n  _data->_currRecord = record();\n  return returnVal;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::previous()\n  {\n    if (!_data)\n      return QSqlQuery::previous();\n  \n    bool returnVal = false;\n  \n    if (_data->_keepTotals && isValid())\n    {\n      QMap<QString,double> delta;\n      QMapIterator<QString,double> mit(_data->_fieldTotals);\n      while(mit.hasNext())\n      {\n        mit.next();\n        delta[mit.key()] = value(mit.key()).toDouble();\n      }\n      returnVal = QSqlQuery::previous();\n      if (returnVal)\n      {\n        mit = delta;\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] -= mit.value();\n          _data->_fieldSubTotals[mit.key()] -= mit.value();\n        }\n      }\n    }\n    else\n      returnVal = QSqlQuery::previous();\n  \n    _data->_currRecord = record();\n    return returnVal;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mimeFilesIter.hasPrevious",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeFilesIter.toBack",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLocale::system",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLocale::system",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStandardPaths::locateAll",
          "args": [
            "QStandardPaths::GenericDataLocation",
            "QLatin1String(\"mime\")",
            "QStandardPaths::LocateDirectory"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "locateAll",
          "container": "QStandardPaths",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/io/qstandardpaths.cpp",
          "lines": "167-177",
          "snippet": "QStringList QStandardPaths::locateAll(StandardLocation type, const QString &fileName, LocateOptions options)\n{\n    const QStringList &dirs = standardLocations(type);\n    QStringList result;\n    for (QStringList::const_iterator dir = dirs.constBegin(); dir != dirs.constEnd(); ++dir) {\n        const QString path = *dir + QLatin1Char('/') + fileName;\n        if (existsAsSpecified(path, options))\n            result.append(path);\n    }\n    return result;\n}",
          "includes": [
            "#include <qcoreapplication.h>",
            "#include <qobject.h>",
            "#include <qhash.h>",
            "#include <qfileinfo.h>",
            "#include <qdir.h>",
            "#include \"qstandardpaths.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qcoreapplication.h>\n#include <qobject.h>\n#include <qhash.h>\n#include <qfileinfo.h>\n#include <qdir.h>\n#include \"qstandardpaths.h\"\n\nQStandardPaths {\n  QStringList QStandardPaths::locateAll(StandardLocation type, const QString &fileName, LocateOptions options)\n  {\n      const QStringList &dirs = standardLocations(type);\n      QStringList result;\n      for (QStringList::const_iterator dir = dirs.constBegin(); dir != dirs.constEnd(); ++dir) {\n          const QString path = *dir + QLatin1Char('/') + fileName;\n          if (existsAsSpecified(path, options))\n              result.append(path);\n      }\n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"mime\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qWarning",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeFiles.isEmpty",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStandardPaths::locateAll",
          "args": [
            "QStandardPaths::GenericDataLocation",
            "QString::fromLatin1(\"mime/\") + file"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "\"mime/\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\".xml\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadMimeTypePrivate(QMimeTypePrivate &data)\n  {\n      if (data.loaded)\n          return;\n      data.loaded = true;\n      // load comment and globPatterns\n  \n      const QString file = data.name + QLatin1String(\".xml\");\n      const QStringList mimeFiles = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QString::fromLatin1(\"mime/\") + file);\n      if (mimeFiles.isEmpty()) {\n          // TODO: ask Thiago about this\n          qWarning() << \"No file found for\" << file << \", even though the file appeared in a directory listing.\";\n          qWarning() << \"Either it was just removed, or the directory doesn't have executable permission...\";\n          qWarning() << QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime\"), QStandardPaths::LocateDirectory);\n          return;\n      }\n  \n      QString comment;\n      QString mainPattern;\n      const QString preferredLanguage = QLocale::system().name();\n  \n      QListIterator<QString> mimeFilesIter(mimeFiles);\n      mimeFilesIter.toBack();\n      while (mimeFilesIter.hasPrevious()) { // global first, then local.\n          const QString fullPath = mimeFilesIter.previous();\n          QFile qfile(fullPath);\n          if (!qfile.open(QFile::ReadOnly))\n              continue;\n  \n          QXmlStreamReader xml(&qfile);\n          if (xml.readNextStartElement()) {\n              if (xml.name() != QLatin1String(\"mime-type\")) {\n                  continue;\n              }\n              const QString name = xml.attributes().value(QLatin1String(\"type\")).toString();\n              if (name.isEmpty())\n                  continue;\n              if (name != data.name) {\n                  qWarning() << \"Got name\" << name << \"in file\" << file << \"expected\" << data.name;\n              }\n  \n              while (xml.readNextStartElement()) {\n                  const QStringRef tag = xml.name();\n                  if (tag == QLatin1String(\"comment\")) {\n                      QString lang = xml.attributes().value(QLatin1String(\"xml:lang\")).toString();\n                      const QString text = xml.readElementText();\n                      if (lang.isEmpty()) {\n                          lang = QLatin1String(\"en_US\");\n                      }\n                      data.localeComments.insert(lang, text);\n                      continue; // we called readElementText, so we're at the EndElement already.\n                  } else if (tag == QLatin1String(\"icon\")) { // as written out by shared-mime-info >= 0.40\n                      data.iconName = xml.attributes().value(QLatin1String(\"name\")).toString();\n                  } else if (tag == QLatin1String(\"glob-deleteall\")) { // as written out by shared-mime-info >= 0.70\n                      data.globPatterns.clear();\n                  } else if (tag == QLatin1String(\"glob\")) { // as written out by shared-mime-info >= 0.70\n                      const QString pattern = xml.attributes().value(QLatin1String(\"pattern\")).toString();\n                      if (mainPattern.isEmpty() && pattern.startsWith(QLatin1Char('*'))) {\n                          mainPattern = pattern;\n                      }\n                      if (!data.globPatterns.contains(pattern))\n                          data.globPatterns.append(pattern);\n                  }\n                  xml.skipCurrentElement();\n              }\n              Q_ASSERT(xml.name() == QLatin1String(\"mime-type\"));\n          }\n      }\n  \n      // Let's assume that shared-mime-info is at least version 0.70\n      // Otherwise we would need 1) a version check, and 2) code for parsing patterns from the globs file.\n  #if 1\n      if (!mainPattern.isEmpty() && data.globPatterns.first() != mainPattern) {\n          // ensure it's first in the list of patterns\n          data.globPatterns.removeAll(mainPattern);\n          data.globPatterns.prepend(mainPattern);\n      }\n  #else\n      const bool globsInXml = sharedMimeInfoVersion() >= QT_VERSION_CHECK(0, 70, 0);\n      if (globsInXml) {\n          if (!mainPattern.isEmpty() && data.globPatterns.first() != mainPattern) {\n              // ensure it's first in the list of patterns\n              data.globPatterns.removeAll(mainPattern);\n              data.globPatterns.prepend(mainPattern);\n          }\n      } else {\n          // Fallback: get the patterns from the globs file\n          // TODO: This would be the only way to support shared-mime-info < 0.70\n          // But is this really worth the effort?\n      }\n  #endif\n  }\n}"
  },
  {
    "function_name": "allMimeTypes",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "518-528",
    "snippet": "QList<QMimeType> QMimeBinaryProvider::allMimeTypes()\n{\n    QList<QMimeType> result;\n    loadMimeTypeList();\n\n    for (QSet<QString>::const_iterator it = m_mimetypeNames.constBegin();\n          it != m_mimetypeNames.constEnd(); ++it)\n        result.append(mimeTypeForNameUnchecked(*it));\n\n    return result;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.append",
          "args": [
            "mimeTypeForNameUnchecked(*it)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeForNameUnchecked",
          "args": [
            "*it"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForNameUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "262-271",
          "snippet": "static QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nstatic QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_mimetypeNames.constEnd",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_mimetypeNames.constBegin",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadMimeTypeList",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "loadMimeTypeList",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "497-516",
          "snippet": "void QMimeBinaryProvider::loadMimeTypeList()\n{\n    if (!m_mimetypeListLoaded) {\n        m_mimetypeListLoaded = true;\n        m_mimetypeNames.clear();\n        // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n        // So we have to parse the plain-text files called \"types\".\n        const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n        foreach (const QString &typeFilename, typesFilenames) {\n            QFile file(typeFilename);\n            if (file.open(QIODevice::ReadOnly)) {\n                while (!file.atEnd()) {\n                    QByteArray line = file.readLine();\n                    line.chop(1);\n                    m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadMimeTypeList()\n  {\n      if (!m_mimetypeListLoaded) {\n          m_mimetypeListLoaded = true;\n          m_mimetypeNames.clear();\n          // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n          // So we have to parse the plain-text files called \"types\".\n          const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n          foreach (const QString &typeFilename, typesFilenames) {\n              QFile file(typeFilename);\n              if (file.open(QIODevice::ReadOnly)) {\n                  while (!file.atEnd()) {\n                      QByteArray line = file.readLine();\n                      line.chop(1);\n                      m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QList<QMimeType> QMimeBinaryProvider::allMimeTypes()\n  {\n      QList<QMimeType> result;\n      loadMimeTypeList();\n  \n      for (QSet<QString>::const_iterator it = m_mimetypeNames.constBegin();\n            it != m_mimetypeNames.constEnd(); ++it)\n          result.append(mimeTypeForNameUnchecked(*it));\n  \n      return result;\n  }\n}"
  },
  {
    "function_name": "loadMimeTypeList",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "497-516",
    "snippet": "void QMimeBinaryProvider::loadMimeTypeList()\n{\n    if (!m_mimetypeListLoaded) {\n        m_mimetypeListLoaded = true;\n        m_mimetypeNames.clear();\n        // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n        // So we have to parse the plain-text files called \"types\".\n        const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n        foreach (const QString &typeFilename, typesFilenames) {\n            QFile file(typeFilename);\n            if (file.open(QIODevice::ReadOnly)) {\n                while (!file.atEnd()) {\n                    QByteArray line = file.readLine();\n                    line.chop(1);\n                    m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                }\n            }\n        }\n    }\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_mimetypeNames.insert",
          "args": [
            "QString::fromLatin1(line.constData(), line.size())"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "line.constData()",
            "line.size()"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.size",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.constData",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.chop",
          "args": [
            "1"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.readLine",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.atEnd",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStandardPaths::locateAll",
          "args": [
            "QStandardPaths::GenericDataLocation",
            "QLatin1String(\"mime/types\")"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"mime/types\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_mimetypeNames.clear",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadMimeTypeList()\n  {\n      if (!m_mimetypeListLoaded) {\n          m_mimetypeListLoaded = true;\n          m_mimetypeNames.clear();\n          // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n          // So we have to parse the plain-text files called \"types\".\n          const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n          foreach (const QString &typeFilename, typesFilenames) {\n              QFile file(typeFilename);\n              if (file.open(QIODevice::ReadOnly)) {\n                  while (!file.atEnd()) {\n                      QByteArray line = file.readLine();\n                      line.chop(1);\n                      m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                  }\n              }\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "resolveAlias",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "467-495",
    "snippet": "QString QMimeBinaryProvider::resolveAlias(const QString &name)\n{\n    checkCache();\n    const QByteArray input = name.toLatin1();\n    foreach (CacheFile *cacheFile, m_cacheFiles) {\n        const int aliasListOffset = cacheFile->getUint32(PosAliasListOffset);\n        const int numEntries = cacheFile->getUint32(aliasListOffset);\n        int begin = 0;\n        int end = numEntries - 1;\n        while (begin <= end) {\n            const int medium = (begin + end) / 2;\n            const int off = aliasListOffset + 4 + 8 * medium;\n            const int aliasOffset = cacheFile->getUint32(off);\n            const char *alias = cacheFile->getCharStar(aliasOffset);\n            const int cmp = qstrcmp(alias, input);\n            if (cmp < 0) {\n                begin = medium + 1;\n            } else if (cmp > 0) {\n                end = medium - 1;\n            } else {\n                const int mimeOffset = cacheFile->getUint32(off + 4);\n                const char *mimeType = cacheFile->getCharStar(mimeOffset);\n                return QLatin1String(mimeType);\n            }\n        }\n    }\n\n    return name;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeType"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "mimeOffset"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "off + 4"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "qstrcmp",
          "args": [
            "alias",
            "input"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "aliasOffset"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.toLatin1",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QString QMimeBinaryProvider::resolveAlias(const QString &name)\n  {\n      checkCache();\n      const QByteArray input = name.toLatin1();\n      foreach (CacheFile *cacheFile, m_cacheFiles) {\n          const int aliasListOffset = cacheFile->getUint32(PosAliasListOffset);\n          const int numEntries = cacheFile->getUint32(aliasListOffset);\n          int begin = 0;\n          int end = numEntries - 1;\n          while (begin <= end) {\n              const int medium = (begin + end) / 2;\n              const int off = aliasListOffset + 4 + 8 * medium;\n              const int aliasOffset = cacheFile->getUint32(off);\n              const char *alias = cacheFile->getCharStar(aliasOffset);\n              const int cmp = qstrcmp(alias, input);\n              if (cmp < 0) {\n                  begin = medium + 1;\n              } else if (cmp > 0) {\n                  end = medium - 1;\n              } else {\n                  const int mimeOffset = cacheFile->getUint32(off + 4);\n                  const char *mimeType = cacheFile->getCharStar(mimeOffset);\n                  return QLatin1String(mimeType);\n              }\n          }\n      }\n  \n      return name;\n  }\n}"
  },
  {
    "function_name": "parents",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "426-465",
    "snippet": "QStringList QMimeBinaryProvider::parents(const QString &mime)\n{\n    checkCache();\n    const QByteArray mimeStr = mime.toLatin1();\n    QStringList result;\n    foreach (CacheFile *cacheFile, m_cacheFiles) {\n        const int parentListOffset = cacheFile->getUint32(PosParentListOffset);\n        const int numEntries = cacheFile->getUint32(parentListOffset);\n\n        int begin = 0;\n        int end = numEntries - 1;\n        while (begin <= end) {\n            const int medium = (begin + end) / 2;\n            const int off = parentListOffset + 4 + 8 * medium;\n            const int mimeOffset = cacheFile->getUint32(off);\n            const char *aMime = cacheFile->getCharStar(mimeOffset);\n            const int cmp = qstrcmp(aMime, mimeStr);\n            if (cmp < 0) {\n                begin = medium + 1;\n            } else if (cmp > 0) {\n                end = medium - 1;\n            } else {\n                const int parentsOffset = cacheFile->getUint32(off + 4);\n                const int numParents = cacheFile->getUint32(parentsOffset);\n                for (int i = 0; i < numParents; ++i) {\n                    const int parentOffset = cacheFile->getUint32(parentsOffset + 4 + 4 * i);\n                    const char *aParent = cacheFile->getCharStar(parentOffset);\n                    result.append(QString::fromLatin1(aParent));\n                }\n                break;\n            }\n        }\n    }\n    if (result.isEmpty()) {\n        const QString parent = fallbackParent(mime);\n        if (!parent.isEmpty())\n            result.append(parent);\n    }\n    return result;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.append",
          "args": [
            "parent"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.isEmpty",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fallbackParent",
          "args": [
            "mime"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "fallbackParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "56-72",
          "snippet": "QT_BEGIN_NAMESPACE\n\nstatic QString fallbackParent(const QString &mimeTypeName)\n{\n    const QString myGroup = mimeTypeName.left(mimeTypeName.indexOf(QLatin1Char('/')));\n    // All text/* types are subclasses of text/plain.\n    if (myGroup == QLatin1String(\"text\") && mimeTypeName != QLatin1String(\"text/plain\"))\n        return QLatin1String(\"text/plain\");\n    // All real-file mimetypes implicitly derive from application/octet-stream\n    if (myGroup != QLatin1String(\"inode\") &&\n        // ignore non-file extensions\n        myGroup != QLatin1String(\"all\") && myGroup != QLatin1String(\"fonts\") && myGroup != QLatin1String(\"print\") && myGroup != QLatin1String(\"uri\")\n        && mimeTypeName != QLatin1String(\"application/octet-stream\")) {\n        return QLatin1String(\"application/octet-stream\");\n    }\n    return QString();\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQT_BEGIN_NAMESPACE\n\nstatic QString fallbackParent(const QString &mimeTypeName)\n{\n    const QString myGroup = mimeTypeName.left(mimeTypeName.indexOf(QLatin1Char('/')));\n    // All text/* types are subclasses of text/plain.\n    if (myGroup == QLatin1String(\"text\") && mimeTypeName != QLatin1String(\"text/plain\"))\n        return QLatin1String(\"text/plain\");\n    // All real-file mimetypes implicitly derive from application/octet-stream\n    if (myGroup != QLatin1String(\"inode\") &&\n        // ignore non-file extensions\n        myGroup != QLatin1String(\"all\") && myGroup != QLatin1String(\"fonts\") && myGroup != QLatin1String(\"print\") && myGroup != QLatin1String(\"uri\")\n        && mimeTypeName != QLatin1String(\"application/octet-stream\")) {\n        return QLatin1String(\"application/octet-stream\");\n    }\n    return QString();\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.isEmpty",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.append",
          "args": [
            "QString::fromLatin1(aParent)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromLatin1",
          "args": [
            "aParent"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "parentOffset"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "parentsOffset + 4 + 4 * i"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "qstrcmp",
          "args": [
            "aMime",
            "mimeStr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "mimeOffset"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mime.toLatin1",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QStringList QMimeBinaryProvider::parents(const QString &mime)\n  {\n      checkCache();\n      const QByteArray mimeStr = mime.toLatin1();\n      QStringList result;\n      foreach (CacheFile *cacheFile, m_cacheFiles) {\n          const int parentListOffset = cacheFile->getUint32(PosParentListOffset);\n          const int numEntries = cacheFile->getUint32(parentListOffset);\n  \n          int begin = 0;\n          int end = numEntries - 1;\n          while (begin <= end) {\n              const int medium = (begin + end) / 2;\n              const int off = parentListOffset + 4 + 8 * medium;\n              const int mimeOffset = cacheFile->getUint32(off);\n              const char *aMime = cacheFile->getCharStar(mimeOffset);\n              const int cmp = qstrcmp(aMime, mimeStr);\n              if (cmp < 0) {\n                  begin = medium + 1;\n              } else if (cmp > 0) {\n                  end = medium - 1;\n              } else {\n                  const int parentsOffset = cacheFile->getUint32(off + 4);\n                  const int numParents = cacheFile->getUint32(parentsOffset);\n                  for (int i = 0; i < numParents; ++i) {\n                      const int parentOffset = cacheFile->getUint32(parentsOffset + 4 + 4 * i);\n                      const char *aParent = cacheFile->getCharStar(parentOffset);\n                      result.append(QString::fromLatin1(aParent));\n                  }\n                  break;\n              }\n          }\n      }\n      if (result.isEmpty()) {\n          const QString parent = fallbackParent(mime);\n          if (!parent.isEmpty())\n              result.append(parent);\n      }\n      return result;\n  }\n}"
  },
  {
    "function_name": "findByMagic",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "400-424",
    "snippet": "QMimeType QMimeBinaryProvider::findByMagic(const QByteArray &data, int *accuracyPtr)\n{\n    checkCache();\n    foreach (CacheFile *cacheFile, m_cacheFiles) {\n        const int magicListOffset = cacheFile->getUint32(PosMagicListOffset);\n        const int numMatches = cacheFile->getUint32(magicListOffset);\n        //const int maxExtent = cacheFile->getUint32(magicListOffset + 4);\n        const int firstMatchOffset = cacheFile->getUint32(magicListOffset + 8);\n\n        for (int i = 0; i < numMatches; ++i) {\n            const int off = firstMatchOffset + i * 16;\n            const int numMatchlets = cacheFile->getUint32(off + 8);\n            const int firstMatchletOffset = cacheFile->getUint32(off + 12);\n            if (matchMagicRule(cacheFile, numMatchlets, firstMatchletOffset, data)) {\n                const int mimeTypeOffset = cacheFile->getUint32(off + 4);\n                const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                *accuracyPtr = cacheFile->getUint32(off);\n                // Return the first match. We have no rules for conflicting magic data...\n                // (mime.cache itself is sorted, but what about local overrides with a lower prio?)\n                return mimeTypeForNameUnchecked(QLatin1String(mimeType));\n            }\n        }\n    }\n    return QMimeType();\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QMimeType",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "filterString",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "390-406",
          "snippet": "QString QMimeType::filterString() const\n{\n    QMimeDatabasePrivate::instance()->provider()->loadMimeTypePrivate(*d);\n    QString filter;\n\n    if (!d->globPatterns.empty()) {\n        filter += comment() + QLatin1String(\" (\");\n        for (int i = 0; i < d->globPatterns.size(); ++i) {\n            if (i != 0)\n                filter += QLatin1Char(' ');\n            filter += d->globPatterns.at(i);\n        }\n        filter +=  QLatin1Char(')');\n    }\n\n    return filter;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::filterString() const\n  {\n      QMimeDatabasePrivate::instance()->provider()->loadMimeTypePrivate(*d);\n      QString filter;\n  \n      if (!d->globPatterns.empty()) {\n          filter += comment() + QLatin1String(\" (\");\n          for (int i = 0; i < d->globPatterns.size(); ++i) {\n              if (i != 0)\n                  filter += QLatin1Char(' ');\n              filter += d->globPatterns.at(i);\n          }\n          filter +=  QLatin1Char(')');\n      }\n  \n      return filter;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mimeTypeForNameUnchecked",
          "args": [
            "QLatin1String(mimeType)"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForNameUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "262-271",
          "snippet": "static QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nstatic QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeType"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "off"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "mimeTypeOffset"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchMagicRule",
          "args": [
            "cacheFile",
            "numMatchlets",
            "firstMatchletOffset",
            "data"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "matchMagicRule",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "372-398",
          "snippet": "bool QMimeBinaryProvider::matchMagicRule(QMimeBinaryProvider::CacheFile *cacheFile, int numMatchlets, int firstOffset, const QByteArray &data)\n{\n    const char *dataPtr = data.constData();\n    const int dataSize = data.size();\n    for (int matchlet = 0; matchlet < numMatchlets; ++matchlet) {\n        const int off = firstOffset + matchlet * 32;\n        const int rangeStart = cacheFile->getUint32(off);\n        const int rangeLength = cacheFile->getUint32(off + 4);\n        //const int wordSize = cacheFile->getUint32(off + 8);\n        const int valueLength = cacheFile->getUint32(off + 12);\n        const int valueOffset = cacheFile->getUint32(off + 16);\n        const int maskOffset = cacheFile->getUint32(off + 20);\n        const char *mask = maskOffset ? cacheFile->getCharStar(maskOffset) : NULL;\n\n        if (!QMimeMagicRule::matchSubstring(dataPtr, dataSize, rangeStart, rangeLength, valueLength, cacheFile->getCharStar(valueOffset), mask))\n            continue;\n\n        const int numChildren = cacheFile->getUint32(off + 24);\n        const int firstChildOffset = cacheFile->getUint32(off + 28);\n        if (numChildren == 0) // No submatch? Then we are done.\n            return true;\n        // Check that one of the submatches matches too\n        if (matchMagicRule(cacheFile, numChildren, firstChildOffset, data))\n            return true;\n    }\n    return false;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  bool QMimeBinaryProvider::matchMagicRule(QMimeBinaryProvider::CacheFile *cacheFile, int numMatchlets, int firstOffset, const QByteArray &data)\n  {\n      const char *dataPtr = data.constData();\n      const int dataSize = data.size();\n      for (int matchlet = 0; matchlet < numMatchlets; ++matchlet) {\n          const int off = firstOffset + matchlet * 32;\n          const int rangeStart = cacheFile->getUint32(off);\n          const int rangeLength = cacheFile->getUint32(off + 4);\n          //const int wordSize = cacheFile->getUint32(off + 8);\n          const int valueLength = cacheFile->getUint32(off + 12);\n          const int valueOffset = cacheFile->getUint32(off + 16);\n          const int maskOffset = cacheFile->getUint32(off + 20);\n          const char *mask = maskOffset ? cacheFile->getCharStar(maskOffset) : NULL;\n  \n          if (!QMimeMagicRule::matchSubstring(dataPtr, dataSize, rangeStart, rangeLength, valueLength, cacheFile->getCharStar(valueOffset), mask))\n              continue;\n  \n          const int numChildren = cacheFile->getUint32(off + 24);\n          const int firstChildOffset = cacheFile->getUint32(off + 28);\n          if (numChildren == 0) // No submatch? Then we are done.\n              return true;\n          // Check that one of the submatches matches too\n          if (matchMagicRule(cacheFile, numChildren, firstChildOffset, data))\n              return true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QMimeType QMimeBinaryProvider::findByMagic(const QByteArray &data, int *accuracyPtr)\n  {\n      checkCache();\n      foreach (CacheFile *cacheFile, m_cacheFiles) {\n          const int magicListOffset = cacheFile->getUint32(PosMagicListOffset);\n          const int numMatches = cacheFile->getUint32(magicListOffset);\n          //const int maxExtent = cacheFile->getUint32(magicListOffset + 4);\n          const int firstMatchOffset = cacheFile->getUint32(magicListOffset + 8);\n  \n          for (int i = 0; i < numMatches; ++i) {\n              const int off = firstMatchOffset + i * 16;\n              const int numMatchlets = cacheFile->getUint32(off + 8);\n              const int firstMatchletOffset = cacheFile->getUint32(off + 12);\n              if (matchMagicRule(cacheFile, numMatchlets, firstMatchletOffset, data)) {\n                  const int mimeTypeOffset = cacheFile->getUint32(off + 4);\n                  const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                  *accuracyPtr = cacheFile->getUint32(off);\n                  // Return the first match. We have no rules for conflicting magic data...\n                  // (mime.cache itself is sorted, but what about local overrides with a lower prio?)\n                  return mimeTypeForNameUnchecked(QLatin1String(mimeType));\n              }\n          }\n      }\n      return QMimeType();\n  }\n}"
  },
  {
    "function_name": "matchMagicRule",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "372-398",
    "snippet": "bool QMimeBinaryProvider::matchMagicRule(QMimeBinaryProvider::CacheFile *cacheFile, int numMatchlets, int firstOffset, const QByteArray &data)\n{\n    const char *dataPtr = data.constData();\n    const int dataSize = data.size();\n    for (int matchlet = 0; matchlet < numMatchlets; ++matchlet) {\n        const int off = firstOffset + matchlet * 32;\n        const int rangeStart = cacheFile->getUint32(off);\n        const int rangeLength = cacheFile->getUint32(off + 4);\n        //const int wordSize = cacheFile->getUint32(off + 8);\n        const int valueLength = cacheFile->getUint32(off + 12);\n        const int valueOffset = cacheFile->getUint32(off + 16);\n        const int maskOffset = cacheFile->getUint32(off + 20);\n        const char *mask = maskOffset ? cacheFile->getCharStar(maskOffset) : NULL;\n\n        if (!QMimeMagicRule::matchSubstring(dataPtr, dataSize, rangeStart, rangeLength, valueLength, cacheFile->getCharStar(valueOffset), mask))\n            continue;\n\n        const int numChildren = cacheFile->getUint32(off + 24);\n        const int firstChildOffset = cacheFile->getUint32(off + 28);\n        if (numChildren == 0) // No submatch? Then we are done.\n            return true;\n        // Check that one of the submatches matches too\n        if (matchMagicRule(cacheFile, numChildren, firstChildOffset, data))\n            return true;\n    }\n    return false;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "matchMagicRule",
          "args": [
            "cacheFile",
            "numChildren",
            "firstChildOffset",
            "data"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "matchMagicRule",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "372-398",
          "snippet": "bool QMimeBinaryProvider::matchMagicRule(QMimeBinaryProvider::CacheFile *cacheFile, int numMatchlets, int firstOffset, const QByteArray &data)\n{\n    const char *dataPtr = data.constData();\n    const int dataSize = data.size();\n    for (int matchlet = 0; matchlet < numMatchlets; ++matchlet) {\n        const int off = firstOffset + matchlet * 32;\n        const int rangeStart = cacheFile->getUint32(off);\n        const int rangeLength = cacheFile->getUint32(off + 4);\n        //const int wordSize = cacheFile->getUint32(off + 8);\n        const int valueLength = cacheFile->getUint32(off + 12);\n        const int valueOffset = cacheFile->getUint32(off + 16);\n        const int maskOffset = cacheFile->getUint32(off + 20);\n        const char *mask = maskOffset ? cacheFile->getCharStar(maskOffset) : NULL;\n\n        if (!QMimeMagicRule::matchSubstring(dataPtr, dataSize, rangeStart, rangeLength, valueLength, cacheFile->getCharStar(valueOffset), mask))\n            continue;\n\n        const int numChildren = cacheFile->getUint32(off + 24);\n        const int firstChildOffset = cacheFile->getUint32(off + 28);\n        if (numChildren == 0) // No submatch? Then we are done.\n            return true;\n        // Check that one of the submatches matches too\n        if (matchMagicRule(cacheFile, numChildren, firstChildOffset, data))\n            return true;\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "off + 28"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "QMimeMagicRule::matchSubstring",
          "args": [
            "dataPtr",
            "dataSize",
            "rangeStart",
            "rangeLength",
            "valueLength",
            "cacheFile->getCharStar(valueOffset)",
            "mask"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "matchSubstring",
          "container": "QMimeMagicRule",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimemagicrule.cpp",
          "lines": "117-164",
          "snippet": "bool QMimeMagicRule::matchSubstring(const char *dataPtr, int dataSize, int rangeStart, int rangeLength,\n                                    int valueLength, const char *valueData, const char *mask)\n{\n    // Size of searched data.\n    // Example: value=\"ABC\", rangeLength=3 -> we need 3+3-1=5 bytes (ABCxx,xABCx,xxABC would match)\n    const int dataNeeded = qMin(rangeLength + valueLength - 1, dataSize - rangeStart);\n\n    if (!mask) {\n        // callgrind says QByteArray::indexOf is much slower, since our strings are typically too\n        // short for be worth Boyer-Moore matching (1 to 71 bytes, 11 bytes on average).\n        bool found = false;\n        for (int i = rangeStart; i < rangeStart + rangeLength; ++i) {\n            if (i + valueLength > dataSize)\n                break;\n\n            if (memcmp(valueData, dataPtr + i, valueLength) == 0) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            return false;\n    } else {\n        bool found = false;\n        const char *readDataBase = dataPtr + rangeStart;\n        // Example (continued from above):\n        // deviceSize is 4, so dataNeeded was max'ed to 4.\n        // maxStartPos = 4 - 3 + 1 = 2, and indeed\n        // we need to check for a match a positions 0 and 1 (ABCx and xABC).\n        const int maxStartPos = dataNeeded - valueLength + 1;\n        for (int i = 0; i < maxStartPos; ++i) {\n            const char *d = readDataBase + i;\n            bool valid = true;\n            for (int idx = 0; idx < valueLength; ++idx) {\n                if (((*d++) & mask[idx]) != (valueData[idx] & mask[idx])) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid)\n                found = true;\n        }\n        if (!found)\n            return false;\n    }\n    //qDebug() << \"Found\" << value << \"in\" << searchedData;\n    return true;\n}",
          "includes": [
            "#include <qendian.h>",
            "#include <QDebug>",
            "#include <QList>",
            "#include \"qmimemagicrule_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qendian.h>\n#include <QDebug>\n#include <QList>\n#include \"qmimemagicrule_p.h\"\n\nQMimeMagicRule {\n  bool QMimeMagicRule::matchSubstring(const char *dataPtr, int dataSize, int rangeStart, int rangeLength,\n                                      int valueLength, const char *valueData, const char *mask)\n  {\n      // Size of searched data.\n      // Example: value=\"ABC\", rangeLength=3 -> we need 3+3-1=5 bytes (ABCxx,xABCx,xxABC would match)\n      const int dataNeeded = qMin(rangeLength + valueLength - 1, dataSize - rangeStart);\n  \n      if (!mask) {\n          // callgrind says QByteArray::indexOf is much slower, since our strings are typically too\n          // short for be worth Boyer-Moore matching (1 to 71 bytes, 11 bytes on average).\n          bool found = false;\n          for (int i = rangeStart; i < rangeStart + rangeLength; ++i) {\n              if (i + valueLength > dataSize)\n                  break;\n  \n              if (memcmp(valueData, dataPtr + i, valueLength) == 0) {\n                  found = true;\n                  break;\n              }\n          }\n          if (!found)\n              return false;\n      } else {\n          bool found = false;\n          const char *readDataBase = dataPtr + rangeStart;\n          // Example (continued from above):\n          // deviceSize is 4, so dataNeeded was max'ed to 4.\n          // maxStartPos = 4 - 3 + 1 = 2, and indeed\n          // we need to check for a match a positions 0 and 1 (ABCx and xABC).\n          const int maxStartPos = dataNeeded - valueLength + 1;\n          for (int i = 0; i < maxStartPos; ++i) {\n              const char *d = readDataBase + i;\n              bool valid = true;\n              for (int idx = 0; idx < valueLength; ++idx) {\n                  if (((*d++) & mask[idx]) != (valueData[idx] & mask[idx])) {\n                      valid = false;\n                      break;\n                  }\n              }\n              if (valid)\n                  found = true;\n          }\n          if (!found)\n              return false;\n      }\n      //qDebug() << \"Found\" << value << \"in\" << searchedData;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "valueOffset"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "maskOffset"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.constData",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  bool QMimeBinaryProvider::matchMagicRule(QMimeBinaryProvider::CacheFile *cacheFile, int numMatchlets, int firstOffset, const QByteArray &data)\n  {\n      const char *dataPtr = data.constData();\n      const int dataSize = data.size();\n      for (int matchlet = 0; matchlet < numMatchlets; ++matchlet) {\n          const int off = firstOffset + matchlet * 32;\n          const int rangeStart = cacheFile->getUint32(off);\n          const int rangeLength = cacheFile->getUint32(off + 4);\n          //const int wordSize = cacheFile->getUint32(off + 8);\n          const int valueLength = cacheFile->getUint32(off + 12);\n          const int valueOffset = cacheFile->getUint32(off + 16);\n          const int maskOffset = cacheFile->getUint32(off + 20);\n          const char *mask = maskOffset ? cacheFile->getCharStar(maskOffset) : NULL;\n  \n          if (!QMimeMagicRule::matchSubstring(dataPtr, dataSize, rangeStart, rangeLength, valueLength, cacheFile->getCharStar(valueOffset), mask))\n              continue;\n  \n          const int numChildren = cacheFile->getUint32(off + 24);\n          const int firstChildOffset = cacheFile->getUint32(off + 28);\n          if (numChildren == 0) // No submatch? Then we are done.\n              return true;\n          // Check that one of the submatches matches too\n          if (matchMagicRule(cacheFile, numChildren, firstChildOffset, data))\n              return true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "matchSuffixTree",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "329-370",
    "snippet": "bool QMimeBinaryProvider::matchSuffixTree(QMimeGlobMatchResult &result, QMimeBinaryProvider::CacheFile *cacheFile, int numEntries, int firstOffset, const QString &fileName, int charPos, bool caseSensitiveCheck)\n{\n    QChar fileChar = fileName[charPos];\n    int min = 0;\n    int max = numEntries - 1;\n    while (min <= max) {\n        const int mid = (min + max) / 2;\n        const int off = firstOffset + 12 * mid;\n        const QChar ch = cacheFile->getUint32(off);\n        if (ch < fileChar)\n            min = mid + 1;\n        else if (ch > fileChar)\n            max = mid - 1;\n        else {\n            --charPos;\n            int numChildren = cacheFile->getUint32(off + 4);\n            int childrenOffset = cacheFile->getUint32(off + 8);\n            bool success = false;\n            if (charPos > 0)\n                success = matchSuffixTree(result, cacheFile, numChildren, childrenOffset, fileName, charPos, caseSensitiveCheck);\n            if (!success) {\n                for (int i = 0; i < numChildren; ++i) {\n                    const int childOff = childrenOffset + 12 * i;\n                    const int mch = cacheFile->getUint32(childOff);\n                    if (mch != 0)\n                        break;\n                    const int mimeTypeOffset = cacheFile->getUint32(childOff + 4);\n                    const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                    const int flagsAndWeight = cacheFile->getUint32(childOff + 8);\n                    const int weight = flagsAndWeight & 0xff;\n                    const bool caseSensitive = flagsAndWeight & 0x100;\n                    if (caseSensitiveCheck || !caseSensitive) {\n                        result.addMatch(QLatin1String(mimeType), weight, QLatin1Char('*') + fileName.mid(charPos+1));\n                        success = true;\n                    }\n                }\n            }\n            return success;\n        }\n    }\n    return false;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.addMatch",
          "args": [
            "QLatin1String(mimeType)",
            "weight",
            "QLatin1Char('*') + fileName.mid(charPos+1)"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "addMatch",
          "container": "QMimeGlobMatchResult",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeglobpattern.cpp",
          "lines": "48-82",
          "snippet": "QT_BEGIN_NAMESPACE\n\n/*!\n    \\internal\n    \\class QMimeGlobMatchResult\n    \\brief The QMimeGlobMatchResult class accumulates results from glob matching.\n\n    Handles glob weights, and preferring longer matches over shorter matches.\n*/\n\nvoid QMimeGlobMatchResult::addMatch(const QString &mimeType, int weight, const QString &pattern)\n{\n    // Is this a lower-weight pattern than the last match? Skip this match then.\n    if (weight < m_weight)\n        return;\n    bool replace = weight > m_weight;\n    if (!replace) {\n        // Compare the length of the match\n        if (pattern.length() < m_matchingPatternLength)\n            return; // too short, ignore\n        else if (pattern.length() > m_matchingPatternLength) {\n            // longer: clear any previous match (like *.bz2, when pattern is *.tar.bz2)\n            replace = true;\n        }\n    }\n    if (replace) {\n        m_matchingMimeTypes.clear();\n        // remember the new \"longer\" length\n        m_matchingPatternLength = pattern.length();\n        m_weight = weight;\n    }\n    m_matchingMimeTypes.append(mimeType);\n    if (pattern.startsWith(QLatin1String(\"*.\")))\n        m_foundSuffix = pattern.mid(2);\n}",
          "includes": [
            "#include <QDebug>",
            "#include <QStringList>",
            "#include <QRegExp>",
            "#include \"qmimeglobpattern_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QDebug>\n#include <QStringList>\n#include <QRegExp>\n#include \"qmimeglobpattern_p.h\"\n\nQMimeGlobMatchResult {\n  QT_BEGIN_NAMESPACE\n  \n  /*!\n      \\internal\n      \\class QMimeGlobMatchResult\n      \\brief The QMimeGlobMatchResult class accumulates results from glob matching.\n  \n      Handles glob weights, and preferring longer matches over shorter matches.\n  */\n  \n  void QMimeGlobMatchResult::addMatch(const QString &mimeType, int weight, const QString &pattern)\n  {\n      // Is this a lower-weight pattern than the last match? Skip this match then.\n      if (weight < m_weight)\n          return;\n      bool replace = weight > m_weight;\n      if (!replace) {\n          // Compare the length of the match\n          if (pattern.length() < m_matchingPatternLength)\n              return; // too short, ignore\n          else if (pattern.length() > m_matchingPatternLength) {\n              // longer: clear any previous match (like *.bz2, when pattern is *.tar.bz2)\n              replace = true;\n          }\n      }\n      if (replace) {\n          m_matchingMimeTypes.clear();\n          // remember the new \"longer\" length\n          m_matchingPatternLength = pattern.length();\n          m_weight = weight;\n      }\n      m_matchingMimeTypes.append(mimeType);\n      if (pattern.startsWith(QLatin1String(\"*.\")))\n          m_foundSuffix = pattern.mid(2);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileName.mid",
          "args": [
            "charPos+1"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'*'"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeType"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "childOff + 8"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "mimeTypeOffset"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matchSuffixTree",
          "args": [
            "result",
            "cacheFile",
            "numChildren",
            "childrenOffset",
            "fileName",
            "charPos",
            "caseSensitiveCheck"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "matchSuffixTree",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "329-370",
          "snippet": "bool QMimeBinaryProvider::matchSuffixTree(QMimeGlobMatchResult &result, QMimeBinaryProvider::CacheFile *cacheFile, int numEntries, int firstOffset, const QString &fileName, int charPos, bool caseSensitiveCheck)\n{\n    QChar fileChar = fileName[charPos];\n    int min = 0;\n    int max = numEntries - 1;\n    while (min <= max) {\n        const int mid = (min + max) / 2;\n        const int off = firstOffset + 12 * mid;\n        const QChar ch = cacheFile->getUint32(off);\n        if (ch < fileChar)\n            min = mid + 1;\n        else if (ch > fileChar)\n            max = mid - 1;\n        else {\n            --charPos;\n            int numChildren = cacheFile->getUint32(off + 4);\n            int childrenOffset = cacheFile->getUint32(off + 8);\n            bool success = false;\n            if (charPos > 0)\n                success = matchSuffixTree(result, cacheFile, numChildren, childrenOffset, fileName, charPos, caseSensitiveCheck);\n            if (!success) {\n                for (int i = 0; i < numChildren; ++i) {\n                    const int childOff = childrenOffset + 12 * i;\n                    const int mch = cacheFile->getUint32(childOff);\n                    if (mch != 0)\n                        break;\n                    const int mimeTypeOffset = cacheFile->getUint32(childOff + 4);\n                    const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                    const int flagsAndWeight = cacheFile->getUint32(childOff + 8);\n                    const int weight = flagsAndWeight & 0xff;\n                    const bool caseSensitive = flagsAndWeight & 0x100;\n                    if (caseSensitiveCheck || !caseSensitive) {\n                        result.addMatch(QLatin1String(mimeType), weight, QLatin1Char('*') + fileName.mid(charPos+1));\n                        success = true;\n                    }\n                }\n            }\n            return success;\n        }\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  bool QMimeBinaryProvider::matchSuffixTree(QMimeGlobMatchResult &result, QMimeBinaryProvider::CacheFile *cacheFile, int numEntries, int firstOffset, const QString &fileName, int charPos, bool caseSensitiveCheck)\n  {\n      QChar fileChar = fileName[charPos];\n      int min = 0;\n      int max = numEntries - 1;\n      while (min <= max) {\n          const int mid = (min + max) / 2;\n          const int off = firstOffset + 12 * mid;\n          const QChar ch = cacheFile->getUint32(off);\n          if (ch < fileChar)\n              min = mid + 1;\n          else if (ch > fileChar)\n              max = mid - 1;\n          else {\n              --charPos;\n              int numChildren = cacheFile->getUint32(off + 4);\n              int childrenOffset = cacheFile->getUint32(off + 8);\n              bool success = false;\n              if (charPos > 0)\n                  success = matchSuffixTree(result, cacheFile, numChildren, childrenOffset, fileName, charPos, caseSensitiveCheck);\n              if (!success) {\n                  for (int i = 0; i < numChildren; ++i) {\n                      const int childOff = childrenOffset + 12 * i;\n                      const int mch = cacheFile->getUint32(childOff);\n                      if (mch != 0)\n                          break;\n                      const int mimeTypeOffset = cacheFile->getUint32(childOff + 4);\n                      const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                      const int flagsAndWeight = cacheFile->getUint32(childOff + 8);\n                      const int weight = flagsAndWeight & 0xff;\n                      const bool caseSensitive = flagsAndWeight & 0x100;\n                      if (caseSensitiveCheck || !caseSensitive) {\n                          result.addMatch(QLatin1String(mimeType), weight, QLatin1Char('*') + fileName.mid(charPos+1));\n                          success = true;\n                      }\n                  }\n              }\n              return success;\n          }\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "matchGlobList",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "306-327",
    "snippet": "void QMimeBinaryProvider::matchGlobList(QMimeGlobMatchResult &result, CacheFile *cacheFile, int off, const QString &fileName)\n{\n    const int numGlobs = cacheFile->getUint32(off);\n    //qDebug() << \"Loading\" << numGlobs << \"globs from\" << cacheFile->file.fileName() << \"at offset\" << cacheFile->globListOffset;\n    for (int i = 0; i < numGlobs; ++i) {\n        const int globOffset = cacheFile->getUint32(off + 4 + 12 * i);\n        const int mimeTypeOffset = cacheFile->getUint32(off + 4 + 12 * i + 4);\n        const int flagsAndWeight = cacheFile->getUint32(off + 4 + 12 * i + 8);\n        const int weight = flagsAndWeight & 0xff;\n        const bool caseSensitive = flagsAndWeight & 0x100;\n        const Qt::CaseSensitivity qtCaseSensitive = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;\n        const QString pattern = QLatin1String(cacheFile->getCharStar(globOffset));\n\n        const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n        //qDebug() << pattern << mimeType << weight << caseSensitive;\n        QMimeGlobPattern glob(pattern, QString() /*unused*/, weight, qtCaseSensitive);\n\n        // TODO: this could be done faster for literals where a simple == would do.\n        if (glob.matchFileName(fileName))\n            result.addMatch(QLatin1String(mimeType), weight, pattern);\n    }\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.addMatch",
          "args": [
            "QLatin1String(mimeType)",
            "weight",
            "pattern"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "addMatch",
          "container": "QMimeGlobMatchResult",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeglobpattern.cpp",
          "lines": "48-82",
          "snippet": "QT_BEGIN_NAMESPACE\n\n/*!\n    \\internal\n    \\class QMimeGlobMatchResult\n    \\brief The QMimeGlobMatchResult class accumulates results from glob matching.\n\n    Handles glob weights, and preferring longer matches over shorter matches.\n*/\n\nvoid QMimeGlobMatchResult::addMatch(const QString &mimeType, int weight, const QString &pattern)\n{\n    // Is this a lower-weight pattern than the last match? Skip this match then.\n    if (weight < m_weight)\n        return;\n    bool replace = weight > m_weight;\n    if (!replace) {\n        // Compare the length of the match\n        if (pattern.length() < m_matchingPatternLength)\n            return; // too short, ignore\n        else if (pattern.length() > m_matchingPatternLength) {\n            // longer: clear any previous match (like *.bz2, when pattern is *.tar.bz2)\n            replace = true;\n        }\n    }\n    if (replace) {\n        m_matchingMimeTypes.clear();\n        // remember the new \"longer\" length\n        m_matchingPatternLength = pattern.length();\n        m_weight = weight;\n    }\n    m_matchingMimeTypes.append(mimeType);\n    if (pattern.startsWith(QLatin1String(\"*.\")))\n        m_foundSuffix = pattern.mid(2);\n}",
          "includes": [
            "#include <QDebug>",
            "#include <QStringList>",
            "#include <QRegExp>",
            "#include \"qmimeglobpattern_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QDebug>\n#include <QStringList>\n#include <QRegExp>\n#include \"qmimeglobpattern_p.h\"\n\nQMimeGlobMatchResult {\n  QT_BEGIN_NAMESPACE\n  \n  /*!\n      \\internal\n      \\class QMimeGlobMatchResult\n      \\brief The QMimeGlobMatchResult class accumulates results from glob matching.\n  \n      Handles glob weights, and preferring longer matches over shorter matches.\n  */\n  \n  void QMimeGlobMatchResult::addMatch(const QString &mimeType, int weight, const QString &pattern)\n  {\n      // Is this a lower-weight pattern than the last match? Skip this match then.\n      if (weight < m_weight)\n          return;\n      bool replace = weight > m_weight;\n      if (!replace) {\n          // Compare the length of the match\n          if (pattern.length() < m_matchingPatternLength)\n              return; // too short, ignore\n          else if (pattern.length() > m_matchingPatternLength) {\n              // longer: clear any previous match (like *.bz2, when pattern is *.tar.bz2)\n              replace = true;\n          }\n      }\n      if (replace) {\n          m_matchingMimeTypes.clear();\n          // remember the new \"longer\" length\n          m_matchingPatternLength = pattern.length();\n          m_weight = weight;\n      }\n      m_matchingMimeTypes.append(mimeType);\n      if (pattern.startsWith(QLatin1String(\"*.\")))\n          m_foundSuffix = pattern.mid(2);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "mimeType"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob.matchFileName",
          "args": [
            "fileName"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "matchFileName",
          "container": "QMimeGlobPattern",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeglobpattern.cpp",
          "lines": "92-140",
          "snippet": "bool QMimeGlobPattern::matchFileName(const QString &inputFilename) const\n{\n    // \"Applications MUST match globs case-insensitively, except when the case-sensitive\n    // attribute is set to true.\"\n    // The constructor takes care of putting case-insensitive patterns in lowercase.\n    const QString filename = m_caseSensitivity == Qt::CaseInsensitive ? inputFilename.toLower() : inputFilename;\n\n    const int pattern_len = m_pattern.length();\n    if (!pattern_len)\n        return false;\n    const int len = filename.length();\n\n    const int starCount = m_pattern.count(QLatin1Char('*'));\n\n    // Patterns like \"*~\", \"*.extension\"\n    if (m_pattern[0] == QLatin1Char('*') && m_pattern.indexOf(QLatin1Char('[')) == -1 && starCount == 1)\n    {\n        if (len + 1 < pattern_len) return false;\n\n        const QChar *c1 = m_pattern.unicode() + pattern_len - 1;\n        const QChar *c2 = filename.unicode() + len - 1;\n        int cnt = 1;\n        while (cnt < pattern_len && *c1-- == *c2--)\n            ++cnt;\n        return cnt == pattern_len;\n    }\n\n    // Patterns like \"README*\" (well this is currently the only one like that...)\n    if (starCount == 1 && m_pattern.at(pattern_len - 1) == QLatin1Char('*')) {\n        if (len + 1 < pattern_len) return false;\n        if (m_pattern.at(0) == QLatin1Char('*'))\n            return filename.indexOf(m_pattern.mid(1, pattern_len - 2)) != -1;\n\n        const QChar *c1 = m_pattern.unicode();\n        const QChar *c2 = filename.unicode();\n        int cnt = 1;\n        while (cnt < pattern_len && *c1++ == *c2++)\n           ++cnt;\n        return cnt == pattern_len;\n    }\n\n    // Names without any wildcards like \"README\"\n    if (m_pattern.indexOf(QLatin1Char('[')) == -1 && starCount == 0 && m_pattern.indexOf(QLatin1Char('?')))\n        return (m_pattern == filename);\n\n    // Other (quite rare) patterns, like \"*.anim[1-9j]\": use slow but correct method\n    QRegExp rx(m_pattern, Qt::CaseSensitive, QRegExp::WildcardUnix);\n    return rx.exactMatch(filename);\n}",
          "includes": [
            "#include <QDebug>",
            "#include <QStringList>",
            "#include <QRegExp>",
            "#include \"qmimeglobpattern_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QDebug>\n#include <QStringList>\n#include <QRegExp>\n#include \"qmimeglobpattern_p.h\"\n\nQMimeGlobPattern {\n  bool QMimeGlobPattern::matchFileName(const QString &inputFilename) const\n  {\n      // \"Applications MUST match globs case-insensitively, except when the case-sensitive\n      // attribute is set to true.\"\n      // The constructor takes care of putting case-insensitive patterns in lowercase.\n      const QString filename = m_caseSensitivity == Qt::CaseInsensitive ? inputFilename.toLower() : inputFilename;\n  \n      const int pattern_len = m_pattern.length();\n      if (!pattern_len)\n          return false;\n      const int len = filename.length();\n  \n      const int starCount = m_pattern.count(QLatin1Char('*'));\n  \n      // Patterns like \"*~\", \"*.extension\"\n      if (m_pattern[0] == QLatin1Char('*') && m_pattern.indexOf(QLatin1Char('[')) == -1 && starCount == 1)\n      {\n          if (len + 1 < pattern_len) return false;\n  \n          const QChar *c1 = m_pattern.unicode() + pattern_len - 1;\n          const QChar *c2 = filename.unicode() + len - 1;\n          int cnt = 1;\n          while (cnt < pattern_len && *c1-- == *c2--)\n              ++cnt;\n          return cnt == pattern_len;\n      }\n  \n      // Patterns like \"README*\" (well this is currently the only one like that...)\n      if (starCount == 1 && m_pattern.at(pattern_len - 1) == QLatin1Char('*')) {\n          if (len + 1 < pattern_len) return false;\n          if (m_pattern.at(0) == QLatin1Char('*'))\n              return filename.indexOf(m_pattern.mid(1, pattern_len - 2)) != -1;\n  \n          const QChar *c1 = m_pattern.unicode();\n          const QChar *c2 = filename.unicode();\n          int cnt = 1;\n          while (cnt < pattern_len && *c1++ == *c2++)\n             ++cnt;\n          return cnt == pattern_len;\n      }\n  \n      // Names without any wildcards like \"README\"\n      if (m_pattern.indexOf(QLatin1Char('[')) == -1 && starCount == 0 && m_pattern.indexOf(QLatin1Char('?')))\n          return (m_pattern == filename);\n  \n      // Other (quite rare) patterns, like \"*.anim[1-9j]\": use slow but correct method\n      QRegExp rx(m_pattern, Qt::CaseSensitive, QRegExp::WildcardUnix);\n      return rx.exactMatch(filename);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "mimeTypeOffset"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "cacheFile->getCharStar(globOffset)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getCharStar",
          "args": [
            "globOffset"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "off + 4 + 12 * i + 8"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::matchGlobList(QMimeGlobMatchResult &result, CacheFile *cacheFile, int off, const QString &fileName)\n  {\n      const int numGlobs = cacheFile->getUint32(off);\n      //qDebug() << \"Loading\" << numGlobs << \"globs from\" << cacheFile->file.fileName() << \"at offset\" << cacheFile->globListOffset;\n      for (int i = 0; i < numGlobs; ++i) {\n          const int globOffset = cacheFile->getUint32(off + 4 + 12 * i);\n          const int mimeTypeOffset = cacheFile->getUint32(off + 4 + 12 * i + 4);\n          const int flagsAndWeight = cacheFile->getUint32(off + 4 + 12 * i + 8);\n          const int weight = flagsAndWeight & 0xff;\n          const bool caseSensitive = flagsAndWeight & 0x100;\n          const Qt::CaseSensitivity qtCaseSensitive = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;\n          const QString pattern = QLatin1String(cacheFile->getCharStar(globOffset));\n  \n          const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n          //qDebug() << pattern << mimeType << weight << caseSensitive;\n          QMimeGlobPattern glob(pattern, QString() /*unused*/, weight, qtCaseSensitive);\n  \n          // TODO: this could be done faster for literals where a simple == would do.\n          if (glob.matchFileName(fileName))\n              result.addMatch(QLatin1String(mimeType), weight, pattern);\n      }\n  }\n}"
  },
  {
    "function_name": "findByFileName",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "283-304",
    "snippet": "QStringList QMimeBinaryProvider::findByFileName(const QString &fileName, QString *foundSuffix)\n{\n    checkCache();\n    if (fileName.isEmpty())\n        return QStringList();\n    const QString lowerFileName = fileName.toLower();\n    QMimeGlobMatchResult result;\n    // TODO this parses in the order (local, global). Check that it handles \"NOGLOBS\" correctly.\n    foreach (CacheFile *cacheFile, m_cacheFiles) {\n        matchGlobList(result, cacheFile, cacheFile->getUint32(PosLiteralListOffset), fileName);\n        matchGlobList(result, cacheFile, cacheFile->getUint32(PosGlobListOffset), fileName);\n        const int reverseSuffixTreeOffset = cacheFile->getUint32(PosReverseSuffixTreeOffset);\n        const int numRoots = cacheFile->getUint32(reverseSuffixTreeOffset);\n        const int firstRootOffset = cacheFile->getUint32(reverseSuffixTreeOffset + 4);\n        matchSuffixTree(result, cacheFile, numRoots, firstRootOffset, lowerFileName, fileName.length() - 1, false);\n        if (result.m_matchingMimeTypes.isEmpty())\n            matchSuffixTree(result, cacheFile, numRoots, firstRootOffset, fileName, fileName.length() - 1, true);\n    }\n    if (foundSuffix)\n        *foundSuffix = result.m_foundSuffix;\n    return result.m_matchingMimeTypes;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "matchSuffixTree",
          "args": [
            "result",
            "cacheFile",
            "numRoots",
            "firstRootOffset",
            "fileName",
            "fileName.length() - 1",
            "true"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "matchSuffixTree",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "329-370",
          "snippet": "bool QMimeBinaryProvider::matchSuffixTree(QMimeGlobMatchResult &result, QMimeBinaryProvider::CacheFile *cacheFile, int numEntries, int firstOffset, const QString &fileName, int charPos, bool caseSensitiveCheck)\n{\n    QChar fileChar = fileName[charPos];\n    int min = 0;\n    int max = numEntries - 1;\n    while (min <= max) {\n        const int mid = (min + max) / 2;\n        const int off = firstOffset + 12 * mid;\n        const QChar ch = cacheFile->getUint32(off);\n        if (ch < fileChar)\n            min = mid + 1;\n        else if (ch > fileChar)\n            max = mid - 1;\n        else {\n            --charPos;\n            int numChildren = cacheFile->getUint32(off + 4);\n            int childrenOffset = cacheFile->getUint32(off + 8);\n            bool success = false;\n            if (charPos > 0)\n                success = matchSuffixTree(result, cacheFile, numChildren, childrenOffset, fileName, charPos, caseSensitiveCheck);\n            if (!success) {\n                for (int i = 0; i < numChildren; ++i) {\n                    const int childOff = childrenOffset + 12 * i;\n                    const int mch = cacheFile->getUint32(childOff);\n                    if (mch != 0)\n                        break;\n                    const int mimeTypeOffset = cacheFile->getUint32(childOff + 4);\n                    const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                    const int flagsAndWeight = cacheFile->getUint32(childOff + 8);\n                    const int weight = flagsAndWeight & 0xff;\n                    const bool caseSensitive = flagsAndWeight & 0x100;\n                    if (caseSensitiveCheck || !caseSensitive) {\n                        result.addMatch(QLatin1String(mimeType), weight, QLatin1Char('*') + fileName.mid(charPos+1));\n                        success = true;\n                    }\n                }\n            }\n            return success;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  bool QMimeBinaryProvider::matchSuffixTree(QMimeGlobMatchResult &result, QMimeBinaryProvider::CacheFile *cacheFile, int numEntries, int firstOffset, const QString &fileName, int charPos, bool caseSensitiveCheck)\n  {\n      QChar fileChar = fileName[charPos];\n      int min = 0;\n      int max = numEntries - 1;\n      while (min <= max) {\n          const int mid = (min + max) / 2;\n          const int off = firstOffset + 12 * mid;\n          const QChar ch = cacheFile->getUint32(off);\n          if (ch < fileChar)\n              min = mid + 1;\n          else if (ch > fileChar)\n              max = mid - 1;\n          else {\n              --charPos;\n              int numChildren = cacheFile->getUint32(off + 4);\n              int childrenOffset = cacheFile->getUint32(off + 8);\n              bool success = false;\n              if (charPos > 0)\n                  success = matchSuffixTree(result, cacheFile, numChildren, childrenOffset, fileName, charPos, caseSensitiveCheck);\n              if (!success) {\n                  for (int i = 0; i < numChildren; ++i) {\n                      const int childOff = childrenOffset + 12 * i;\n                      const int mch = cacheFile->getUint32(childOff);\n                      if (mch != 0)\n                          break;\n                      const int mimeTypeOffset = cacheFile->getUint32(childOff + 4);\n                      const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n                      const int flagsAndWeight = cacheFile->getUint32(childOff + 8);\n                      const int weight = flagsAndWeight & 0xff;\n                      const bool caseSensitive = flagsAndWeight & 0x100;\n                      if (caseSensitiveCheck || !caseSensitive) {\n                          result.addMatch(QLatin1String(mimeType), weight, QLatin1Char('*') + fileName.mid(charPos+1));\n                          success = true;\n                      }\n                  }\n              }\n              return success;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileName.length",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.m_matchingMimeTypes.isEmpty",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileName.length",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->getUint32",
          "args": [
            "reverseSuffixTreeOffset + 4"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "getUint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "109-112",
          "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "matchGlobList",
          "args": [
            "result",
            "cacheFile",
            "cacheFile->getUint32(PosGlobListOffset)",
            "fileName"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "matchGlobList",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "306-327",
          "snippet": "void QMimeBinaryProvider::matchGlobList(QMimeGlobMatchResult &result, CacheFile *cacheFile, int off, const QString &fileName)\n{\n    const int numGlobs = cacheFile->getUint32(off);\n    //qDebug() << \"Loading\" << numGlobs << \"globs from\" << cacheFile->file.fileName() << \"at offset\" << cacheFile->globListOffset;\n    for (int i = 0; i < numGlobs; ++i) {\n        const int globOffset = cacheFile->getUint32(off + 4 + 12 * i);\n        const int mimeTypeOffset = cacheFile->getUint32(off + 4 + 12 * i + 4);\n        const int flagsAndWeight = cacheFile->getUint32(off + 4 + 12 * i + 8);\n        const int weight = flagsAndWeight & 0xff;\n        const bool caseSensitive = flagsAndWeight & 0x100;\n        const Qt::CaseSensitivity qtCaseSensitive = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;\n        const QString pattern = QLatin1String(cacheFile->getCharStar(globOffset));\n\n        const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n        //qDebug() << pattern << mimeType << weight << caseSensitive;\n        QMimeGlobPattern glob(pattern, QString() /*unused*/, weight, qtCaseSensitive);\n\n        // TODO: this could be done faster for literals where a simple == would do.\n        if (glob.matchFileName(fileName))\n            result.addMatch(QLatin1String(mimeType), weight, pattern);\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::matchGlobList(QMimeGlobMatchResult &result, CacheFile *cacheFile, int off, const QString &fileName)\n  {\n      const int numGlobs = cacheFile->getUint32(off);\n      //qDebug() << \"Loading\" << numGlobs << \"globs from\" << cacheFile->file.fileName() << \"at offset\" << cacheFile->globListOffset;\n      for (int i = 0; i < numGlobs; ++i) {\n          const int globOffset = cacheFile->getUint32(off + 4 + 12 * i);\n          const int mimeTypeOffset = cacheFile->getUint32(off + 4 + 12 * i + 4);\n          const int flagsAndWeight = cacheFile->getUint32(off + 4 + 12 * i + 8);\n          const int weight = flagsAndWeight & 0xff;\n          const bool caseSensitive = flagsAndWeight & 0x100;\n          const Qt::CaseSensitivity qtCaseSensitive = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;\n          const QString pattern = QLatin1String(cacheFile->getCharStar(globOffset));\n  \n          const char *mimeType = cacheFile->getCharStar(mimeTypeOffset);\n          //qDebug() << pattern << mimeType << weight << caseSensitive;\n          QMimeGlobPattern glob(pattern, QString() /*unused*/, weight, qtCaseSensitive);\n  \n          // TODO: this could be done faster for literals where a simple == would do.\n          if (glob.matchFileName(fileName))\n              result.addMatch(QLatin1String(mimeType), weight, pattern);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileName.toLower",
          "args": [],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStringList",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileName.isEmpty",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QStringList QMimeBinaryProvider::findByFileName(const QString &fileName, QString *foundSuffix)\n  {\n      checkCache();\n      if (fileName.isEmpty())\n          return QStringList();\n      const QString lowerFileName = fileName.toLower();\n      QMimeGlobMatchResult result;\n      // TODO this parses in the order (local, global). Check that it handles \"NOGLOBS\" correctly.\n      foreach (CacheFile *cacheFile, m_cacheFiles) {\n          matchGlobList(result, cacheFile, cacheFile->getUint32(PosLiteralListOffset), fileName);\n          matchGlobList(result, cacheFile, cacheFile->getUint32(PosGlobListOffset), fileName);\n          const int reverseSuffixTreeOffset = cacheFile->getUint32(PosReverseSuffixTreeOffset);\n          const int numRoots = cacheFile->getUint32(reverseSuffixTreeOffset);\n          const int firstRootOffset = cacheFile->getUint32(reverseSuffixTreeOffset + 4);\n          matchSuffixTree(result, cacheFile, numRoots, firstRootOffset, lowerFileName, fileName.length() - 1, false);\n          if (result.m_matchingMimeTypes.isEmpty())\n              matchSuffixTree(result, cacheFile, numRoots, firstRootOffset, fileName, fileName.length() - 1, true);\n      }\n      if (foundSuffix)\n          *foundSuffix = result.m_foundSuffix;\n      return result.m_matchingMimeTypes;\n  }\n}"
  },
  {
    "function_name": "mimeTypeForName",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "273-281",
    "snippet": "QMimeType QMimeBinaryProvider::mimeTypeForName(const QString &name)\n{\n    checkCache();\n    if (!m_mimetypeListLoaded)\n        loadMimeTypeList();\n    if (!m_mimetypeNames.contains(name))\n        return QMimeType(); // unknown mimetype\n    return mimeTypeForNameUnchecked(name);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mimeTypeForNameUnchecked",
          "args": [
            "name"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "mimeTypeForNameUnchecked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "262-271",
          "snippet": "static QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nstatic QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QMimeType",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "filterString",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "390-406",
          "snippet": "QString QMimeType::filterString() const\n{\n    QMimeDatabasePrivate::instance()->provider()->loadMimeTypePrivate(*d);\n    QString filter;\n\n    if (!d->globPatterns.empty()) {\n        filter += comment() + QLatin1String(\" (\");\n        for (int i = 0; i < d->globPatterns.size(); ++i) {\n            if (i != 0)\n                filter += QLatin1Char(' ');\n            filter += d->globPatterns.at(i);\n        }\n        filter +=  QLatin1Char(')');\n    }\n\n    return filter;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  QString QMimeType::filterString() const\n  {\n      QMimeDatabasePrivate::instance()->provider()->loadMimeTypePrivate(*d);\n      QString filter;\n  \n      if (!d->globPatterns.empty()) {\n          filter += comment() + QLatin1String(\" (\");\n          for (int i = 0; i < d->globPatterns.size(); ++i) {\n              if (i != 0)\n                  filter += QLatin1Char(' ');\n              filter += d->globPatterns.at(i);\n          }\n          filter +=  QLatin1Char(')');\n      }\n  \n      return filter;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_mimetypeNames.contains",
          "args": [
            "name"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadMimeTypeList",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "loadMimeTypeList",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "497-516",
          "snippet": "void QMimeBinaryProvider::loadMimeTypeList()\n{\n    if (!m_mimetypeListLoaded) {\n        m_mimetypeListLoaded = true;\n        m_mimetypeNames.clear();\n        // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n        // So we have to parse the plain-text files called \"types\".\n        const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n        foreach (const QString &typeFilename, typesFilenames) {\n            QFile file(typeFilename);\n            if (file.open(QIODevice::ReadOnly)) {\n                while (!file.atEnd()) {\n                    QByteArray line = file.readLine();\n                    line.chop(1);\n                    m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadMimeTypeList()\n  {\n      if (!m_mimetypeListLoaded) {\n          m_mimetypeListLoaded = true;\n          m_mimetypeNames.clear();\n          // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n          // So we have to parse the plain-text files called \"types\".\n          const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n          foreach (const QString &typeFilename, typesFilenames) {\n              QFile file(typeFilename);\n              if (file.open(QIODevice::ReadOnly)) {\n                  while (!file.atEnd()) {\n                      QByteArray line = file.readLine();\n                      line.chop(1);\n                      m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QMimeType QMimeBinaryProvider::mimeTypeForName(const QString &name)\n  {\n      checkCache();\n      if (!m_mimetypeListLoaded)\n          loadMimeTypeList();\n      if (!m_mimetypeNames.contains(name))\n          return QMimeType(); // unknown mimetype\n      return mimeTypeForNameUnchecked(name);\n  }\n}"
  },
  {
    "function_name": "mimeTypeForNameUnchecked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "262-271",
    "snippet": "static QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QMimeType",
          "args": [
            "data"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "inherits",
          "container": "QMimeType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "414-419",
          "snippet": "bool QMimeType::inherits(const QString &mimeTypeName) const\n{\n    if (d->name == mimeTypeName)\n        return true;\n    return QMimeDatabasePrivate::instance()->inherits(d->name, mimeTypeName);\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQMimeType {\n  bool QMimeType::inherits(const QString &mimeTypeName) const\n  {\n      if (d->name == mimeTypeName)\n          return true;\n      return QMimeDatabasePrivate::instance()->inherits(d->name, mimeTypeName);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nstatic QMimeType mimeTypeForNameUnchecked(const QString &name)\n{\n    QMimeTypePrivate data;\n    data.name = name;\n    // The rest is retrieved on demand.\n    // comment and globPatterns: in loadMimeTypePrivate\n    // iconName: in loadIcon\n    // genericIconName: in loadGenericIcon\n    return QMimeType(data);\n}"
  },
  {
    "function_name": "checkCache",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "234-260",
    "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_cacheFiles.append",
          "args": [
            "cacheFile"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->isValid",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cacheFiles.findCacheFile",
          "args": [
            "cacheFileName"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStandardPaths::locateAll",
          "args": [
            "QStandardPaths::GenericDataLocation",
            "QLatin1String(\"mime/mime.cache\")"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"mime/mime.cache\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cacheFiles.checkCacheChanged",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "checkCacheChanged",
          "container": "QMimeBinaryProvider::CacheFileList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "212-232",
          "snippet": "bool QMimeBinaryProvider::CacheFileList::checkCacheChanged()\n{\n    bool somethingChanged = false;\n    QMutableListIterator<CacheFile *> it(*this);\n    while (it.hasNext()) {\n        CacheFile *cacheFile = it.next();\n        QFileInfo fileInfo(cacheFile->file);\n        if (!fileInfo.exists()) { // This can't happen by just running update-mime-database. But the user could use rm -rf :-)\n            delete cacheFile;\n            it.remove();\n            somethingChanged = true;\n        } else if (fileInfo.lastModified() > cacheFile->m_mtime) {\n            if (!cacheFile->reload()) {\n                delete cacheFile;\n                it.remove();\n            }\n            somethingChanged = true;\n        }\n    }\n    return somethingChanged;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFileList {\n    bool QMimeBinaryProvider::CacheFileList::checkCacheChanged()\n    {\n        bool somethingChanged = false;\n        QMutableListIterator<CacheFile *> it(*this);\n        while (it.hasNext()) {\n            CacheFile *cacheFile = it.next();\n            QFileInfo fileInfo(cacheFile->file);\n            if (!fileInfo.exists()) { // This can't happen by just running update-mime-database. But the user could use rm -rf :-)\n                delete cacheFile;\n                it.remove();\n                somethingChanged = true;\n            } else if (fileInfo.lastModified() > cacheFile->m_mtime) {\n                if (!cacheFile->reload()) {\n                    delete cacheFile;\n                    it.remove();\n                }\n                somethingChanged = true;\n            }\n        }\n        return somethingChanged;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shouldCheck",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "shouldCheck",
          "container": "QMimeProviderBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "81-88",
          "snippet": "bool QMimeProviderBase::shouldCheck()\n{\n    const QDateTime now = QDateTime::currentDateTime();\n    if (m_lastCheck.isValid() && m_lastCheck.secsTo(now) < qmime_secondsBetweenChecks)\n        return false;\n    m_lastCheck = now;\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int qmime_secondsBetweenChecks = 5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nint qmime_secondsBetweenChecks = 5;\n\nQMimeProviderBase {\n  bool QMimeProviderBase::shouldCheck()\n  {\n      const QDateTime now = QDateTime::currentDateTime();\n      if (m_lastCheck.isValid() && m_lastCheck.secsTo(now) < qmime_secondsBetweenChecks)\n          return false;\n      m_lastCheck = now;\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
  },
  {
    "function_name": "checkCacheChanged",
    "container": "QMimeBinaryProvider::CacheFileList",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "212-232",
    "snippet": "bool QMimeBinaryProvider::CacheFileList::checkCacheChanged()\n{\n    bool somethingChanged = false;\n    QMutableListIterator<CacheFile *> it(*this);\n    while (it.hasNext()) {\n        CacheFile *cacheFile = it.next();\n        QFileInfo fileInfo(cacheFile->file);\n        if (!fileInfo.exists()) { // This can't happen by just running update-mime-database. But the user could use rm -rf :-)\n            delete cacheFile;\n            it.remove();\n            somethingChanged = true;\n        } else if (fileInfo.lastModified() > cacheFile->m_mtime) {\n            if (!cacheFile->reload()) {\n                delete cacheFile;\n                it.remove();\n            }\n            somethingChanged = true;\n        }\n    }\n    return somethingChanged;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "it.remove",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cacheFile->reload",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "reload",
          "container": "QMimeBinaryProvider::CacheFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "150-159",
          "snippet": "bool QMimeBinaryProvider::CacheFile::reload()\n{\n    //qDebug() << \"reload!\" << file->fileName();\n    m_valid = false;\n    if (file.isOpen()) {\n        file.close();\n    }\n    data = 0;\n    return load();\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFile {\n    bool QMimeBinaryProvider::CacheFile::reload()\n    {\n        //qDebug() << \"reload!\" << file->fileName();\n        m_valid = false;\n        if (file.isOpen()) {\n            file.close();\n        }\n        data = 0;\n        return load();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileInfo.lastModified",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it.remove",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileInfo.exists",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it.next",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "318-340",
          "snippet": "bool XSqlQuery::next()\n{\n  if (QSqlQuery::next())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // increment all our values\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::next()\n  {\n    if (QSqlQuery::next())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // increment all our values\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] += value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] += value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "it.hasNext",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFileList {\n    bool QMimeBinaryProvider::CacheFileList::checkCacheChanged()\n    {\n        bool somethingChanged = false;\n        QMutableListIterator<CacheFile *> it(*this);\n        while (it.hasNext()) {\n            CacheFile *cacheFile = it.next();\n            QFileInfo fileInfo(cacheFile->file);\n            if (!fileInfo.exists()) { // This can't happen by just running update-mime-database. But the user could use rm -rf :-)\n                delete cacheFile;\n                it.remove();\n                somethingChanged = true;\n            } else if (fileInfo.lastModified() > cacheFile->m_mtime) {\n                if (!cacheFile->reload()) {\n                    delete cacheFile;\n                    it.remove();\n                }\n                somethingChanged = true;\n            }\n        }\n        return somethingChanged;\n    }\n  }\n}"
  },
  {
    "function_name": "isValid",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "188-210",
    "snippet": "bool QMimeBinaryProvider::isValid()\n{\n#if defined(QT_USE_MMAP)\n    if (!qgetenv(\"QT_NO_MIME_CACHE\").isEmpty())\n        return false;\n\n    Q_ASSERT(m_cacheFiles.isEmpty()); // this method is only ever called once\n    checkCache();\n\n    if (m_cacheFiles.count() > 1)\n        return true;\n    if (m_cacheFiles.isEmpty())\n        return false;\n\n    // We found exactly one file; is it the user-modified mimes, or a system file?\n    const QString foundFile = m_cacheFiles.first()->file.fileName();\n    const QString localCacheFile = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String(\"/mime/mime.cache\");\n\n    return foundFile != localCacheFile;\n#else\n    return false;\n#endif\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [
      "#define QT_USE_MMAP"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"/mime/mime.cache\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QStandardPaths::writableLocation",
          "args": [
            "QStandardPaths::GenericDataLocation"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "writableLocation",
          "container": "QStandardPaths",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/io/qstandardpaths_mac.cpp",
          "lines": "128-167",
          "snippet": "QString QStandardPaths::writableLocation(StandardLocation type)\n{\n    if (isTestModeEnabled()) {\n        const QString qttestDir = QDir::homePath() + QLatin1String(\"/.qttest\");\n        QString path;\n        switch (type) {\n        case GenericDataLocation:\n        case DataLocation:\n            path = qttestDir + QLatin1String(\"/Application Support\");\n            if (type == DataLocation)\n                appendOrganizationAndApp(path);\n            return path;\n        case GenericCacheLocation:\n        case CacheLocation:\n            path = qttestDir + QLatin1String(\"/Cache\");\n            if (type == CacheLocation)\n                appendOrganizationAndApp(path);\n            return path;\n        case ConfigLocation:\n            return qttestDir + QLatin1String(\"/Preferences\");\n        default:\n            break;\n        }\n    }\n\n    switch (type) {\n    case HomeLocation:\n        return QDir::homePath();\n    case TempLocation:\n        return QDir::tempPath();\n    case GenericDataLocation:\n    case DataLocation:\n    case GenericCacheLocation:\n    case CacheLocation:\n    case RuntimeLocation:\n        return macLocation(type, kUserDomain);\n    default:\n        return macLocation(type, kOnAppropriateDisk);\n    }\n}",
          "includes": [
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <qcoreapplication.h>",
            "#include <qdir.h>",
            "#include \"qstandardpaths.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ApplicationServices/ApplicationServices.h>\n#include <qcoreapplication.h>\n#include <qdir.h>\n#include \"qstandardpaths.h\"\n\nQStandardPaths {\n  QString QStandardPaths::writableLocation(StandardLocation type)\n  {\n      if (isTestModeEnabled()) {\n          const QString qttestDir = QDir::homePath() + QLatin1String(\"/.qttest\");\n          QString path;\n          switch (type) {\n          case GenericDataLocation:\n          case DataLocation:\n              path = qttestDir + QLatin1String(\"/Application Support\");\n              if (type == DataLocation)\n                  appendOrganizationAndApp(path);\n              return path;\n          case GenericCacheLocation:\n          case CacheLocation:\n              path = qttestDir + QLatin1String(\"/Cache\");\n              if (type == CacheLocation)\n                  appendOrganizationAndApp(path);\n              return path;\n          case ConfigLocation:\n              return qttestDir + QLatin1String(\"/Preferences\");\n          default:\n              break;\n          }\n      }\n  \n      switch (type) {\n      case HomeLocation:\n          return QDir::homePath();\n      case TempLocation:\n          return QDir::tempPath();\n      case GenericDataLocation:\n      case DataLocation:\n      case GenericCacheLocation:\n      case CacheLocation:\n      case RuntimeLocation:\n          return macLocation(type, kUserDomain);\n      default:\n          return macLocation(type, kOnAppropriateDisk);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cacheFiles.first",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "first",
          "container": "XSqlQuery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/xsqlquery.cpp",
          "lines": "293-316",
          "snippet": "bool XSqlQuery::first()\n{\n  if (QSqlQuery::first())\n  {\n    if (_data)\n    {\n      if (_data->_keepTotals)\n      {\n        // initial all our values\n        resetSubTotals();\n        QMapIterator<QString,double> mit(_data->_fieldTotals);\n        while(mit.hasNext())\n        {\n          mit.next();\n          _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n          _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n        }\n      }\n      _data->_currRecord = record();\n    }\n    return true;\n  }\n  return false;\n}",
          "includes": [
            "#include \"xsqlquery.h\"",
            "#include <QMap>",
            "#include <QCursor>",
            "#include <QSqlResult>",
            "#include <QSqlDriver>",
            "#include <QVariant>",
            "#include <QSqlError>",
            "#include <QSqlQuery>",
            "#include <QSqlRecord>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xsqlquery.h\"\n#include <QMap>\n#include <QCursor>\n#include <QSqlResult>\n#include <QSqlDriver>\n#include <QVariant>\n#include <QSqlError>\n#include <QSqlQuery>\n#include <QSqlRecord>\n\nXSqlQuery {\n  bool XSqlQuery::first()\n  {\n    if (QSqlQuery::first())\n    {\n      if (_data)\n      {\n        if (_data->_keepTotals)\n        {\n          // initial all our values\n          resetSubTotals();\n          QMapIterator<QString,double> mit(_data->_fieldTotals);\n          while(mit.hasNext())\n          {\n            mit.next();\n            _data->_fieldTotals[mit.key()] = value(mit.key()).toDouble();\n            _data->_fieldSubTotals[mit.key()] = value(mit.key()).toDouble();\n          }\n        }\n        _data->_currRecord = record();\n      }\n      return true;\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cacheFiles.isEmpty",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cacheFiles.count",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "91-94",
          "snippet": "int FlowLayout::count() const\n{\n    return itemList.size();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  int FlowLayout::count() const\n  {\n      return itemList.size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkCache",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "checkCache",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "234-260",
          "snippet": "void QMimeBinaryProvider::checkCache()\n{\n    if (!shouldCheck())\n        return;\n\n    // First iterate over existing known cache files and check for uptodate\n    if (m_cacheFiles.checkCacheChanged())\n        m_mimetypeListLoaded = false;\n\n    // Then check if new cache files appeared\n    const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n    if (cacheFileNames != m_cacheFileNames) {\n        foreach (const QString &cacheFileName, cacheFileNames) {\n            CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n            if (!cacheFile) {\n                //qDebug() << \"new file:\" << cacheFileName;\n                cacheFile = new CacheFile(cacheFileName);\n                if (cacheFile->isValid()) // verify version\n                    m_cacheFiles.append(cacheFile);\n                else\n                    delete cacheFile;\n            }\n        }\n        m_cacheFileNames = cacheFileNames;\n        m_mimetypeListLoaded = false;\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::checkCache()\n  {\n      if (!shouldCheck())\n          return;\n  \n      // First iterate over existing known cache files and check for uptodate\n      if (m_cacheFiles.checkCacheChanged())\n          m_mimetypeListLoaded = false;\n  \n      // Then check if new cache files appeared\n      const QStringList cacheFileNames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/mime.cache\"));\n      if (cacheFileNames != m_cacheFileNames) {\n          foreach (const QString &cacheFileName, cacheFileNames) {\n              CacheFile *cacheFile = m_cacheFiles.findCacheFile(cacheFileName);\n              if (!cacheFile) {\n                  //qDebug() << \"new file:\" << cacheFileName;\n                  cacheFile = new CacheFile(cacheFileName);\n                  if (cacheFile->isValid()) // verify version\n                      m_cacheFiles.append(cacheFile);\n                  else\n                      delete cacheFile;\n              }\n          }\n          m_cacheFileNames = cacheFileNames;\n          m_mimetypeListLoaded = false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Q_ASSERT",
          "args": [
            "m_cacheFiles.isEmpty()"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cacheFiles.isEmpty",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qgetenv",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qgetenv",
          "args": [
            "\"QT_NO_MIME_CACHE\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\n#define QT_USE_MMAP\n\nQMimeBinaryProvider {\n  bool QMimeBinaryProvider::isValid()\n  {\n  #if defined(QT_USE_MMAP)\n      if (!qgetenv(\"QT_NO_MIME_CACHE\").isEmpty())\n          return false;\n  \n      Q_ASSERT(m_cacheFiles.isEmpty()); // this method is only ever called once\n      checkCache();\n  \n      if (m_cacheFiles.count() > 1)\n          return true;\n      if (m_cacheFiles.isEmpty())\n          return false;\n  \n      // We found exactly one file; is it the user-modified mimes, or a system file?\n      const QString foundFile = m_cacheFiles.first()->file.fileName();\n      const QString localCacheFile = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String(\"/mime/mime.cache\");\n  \n      return foundFile != localCacheFile;\n  #else\n      return false;\n  #endif\n  }\n}"
  },
  {
    "function_name": "~QMimeBinaryProvider",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "170-173",
    "snippet": "QMimeBinaryProvider::~QMimeBinaryProvider()\n{\n    qDeleteAll(m_cacheFiles);\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qDeleteAll",
          "args": [
            "m_cacheFiles"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QMimeBinaryProvider::~QMimeBinaryProvider()\n  {\n      qDeleteAll(m_cacheFiles);\n  }\n}"
  },
  {
    "function_name": "reload",
    "container": "QMimeBinaryProvider::CacheFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "150-159",
    "snippet": "bool QMimeBinaryProvider::CacheFile::reload()\n{\n    //qDebug() << \"reload!\" << file->fileName();\n    m_valid = false;\n    if (file.isOpen()) {\n        file.close();\n    }\n    data = 0;\n    return load();\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "loadMimeTypeList",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "497-516",
          "snippet": "void QMimeBinaryProvider::loadMimeTypeList()\n{\n    if (!m_mimetypeListLoaded) {\n        m_mimetypeListLoaded = true;\n        m_mimetypeNames.clear();\n        // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n        // So we have to parse the plain-text files called \"types\".\n        const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n        foreach (const QString &typeFilename, typesFilenames) {\n            QFile file(typeFilename);\n            if (file.open(QIODevice::ReadOnly)) {\n                while (!file.atEnd()) {\n                    QByteArray line = file.readLine();\n                    line.chop(1);\n                    m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadMimeTypeList()\n  {\n      if (!m_mimetypeListLoaded) {\n          m_mimetypeListLoaded = true;\n          m_mimetypeNames.clear();\n          // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n          // So we have to parse the plain-text files called \"types\".\n          const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n          foreach (const QString &typeFilename, typesFilenames) {\n              QFile file(typeFilename);\n              if (file.open(QIODevice::ReadOnly)) {\n                  while (!file.atEnd()) {\n                      QByteArray line = file.readLine();\n                      line.chop(1);\n                      m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.close",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.isOpen",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFile {\n    bool QMimeBinaryProvider::CacheFile::reload()\n    {\n        //qDebug() << \"reload!\" << file->fileName();\n        m_valid = false;\n        if (file.isOpen()) {\n            file.close();\n        }\n        data = 0;\n        return load();\n    }\n  }\n}"
  },
  {
    "function_name": "load",
    "container": "QMimeBinaryProvider::CacheFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "136-148",
    "snippet": "bool QMimeBinaryProvider::CacheFile::load()\n{\n    if (!file.open(QIODevice::ReadOnly))\n        return false;\n    data = file.map(0, file.size());\n    if (data) {\n        const int major = getUint16(0);\n        const int minor = getUint16(2);\n        m_valid = (major == 1 && minor >= 1 && minor <= 2);\n    }\n    m_mtime = QFileInfo(file).lastModified();\n    return m_valid;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QFileInfo",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QFileInfo",
          "args": [
            "file"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUint16",
          "args": [
            "2"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "getUint16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "105-108",
          "snippet": "inline quint16 getUint16(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint16 *>(data + offset));\n    }",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint16 getUint16(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint16 *>(data + offset));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "file.map",
          "args": [
            "0",
            "file.size()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.size",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "QIODevice::ReadOnly"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFile {\n    bool QMimeBinaryProvider::CacheFile::load()\n    {\n        if (!file.open(QIODevice::ReadOnly))\n            return false;\n        data = file.map(0, file.size());\n        if (data) {\n            const int major = getUint16(0);\n            const int minor = getUint16(2);\n            m_valid = (major == 1 && minor >= 1 && minor <= 2);\n        }\n        m_mtime = QFileInfo(file).lastModified();\n        return m_valid;\n    }\n  }\n}"
  },
  {
    "function_name": "~CacheFile",
    "container": "QMimeBinaryProvider::CacheFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "132-134",
    "snippet": "QMimeBinaryProvider::CacheFile::~CacheFile()\n{\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFile {\n    QMimeBinaryProvider::CacheFile::~CacheFile()\n    {\n    }\n  }\n}"
  },
  {
    "function_name": "CacheFile",
    "container": "QMimeBinaryProvider::CacheFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "126-130",
    "snippet": "QMimeBinaryProvider::CacheFile::CacheFile(const QString &fileName)\n    : file(fileName), m_valid(false)\n{\n    load();\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "loadMimeTypeList",
          "container": "QMimeBinaryProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "497-516",
          "snippet": "void QMimeBinaryProvider::loadMimeTypeList()\n{\n    if (!m_mimetypeListLoaded) {\n        m_mimetypeListLoaded = true;\n        m_mimetypeNames.clear();\n        // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n        // So we have to parse the plain-text files called \"types\".\n        const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n        foreach (const QString &typeFilename, typesFilenames) {\n            QFile file(typeFilename);\n            if (file.open(QIODevice::ReadOnly)) {\n                while (!file.atEnd()) {\n                    QByteArray line = file.readLine();\n                    line.chop(1);\n                    m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                }\n            }\n        }\n    }\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  void QMimeBinaryProvider::loadMimeTypeList()\n  {\n      if (!m_mimetypeListLoaded) {\n          m_mimetypeListLoaded = true;\n          m_mimetypeNames.clear();\n          // Unfortunately mime.cache doesn't have a full list of all mimetypes.\n          // So we have to parse the plain-text files called \"types\".\n          const QStringList typesFilenames = QStandardPaths::locateAll(QStandardPaths::GenericDataLocation, QLatin1String(\"mime/types\"));\n          foreach (const QString &typeFilename, typesFilenames) {\n              QFile file(typeFilename);\n              if (file.open(QIODevice::ReadOnly)) {\n                  while (!file.atEnd()) {\n                      QByteArray line = file.readLine();\n                      line.chop(1);\n                      m_mimetypeNames.insert(QString::fromLatin1(line.constData(), line.size()));\n                  }\n              }\n          }\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  CacheFile {\n    QMimeBinaryProvider::CacheFile::CacheFile(const QString &fileName)\n        : file(fileName), m_valid(false)\n    {\n        load();\n    }\n  }\n}"
  },
  {
    "function_name": "getUint32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "109-112",
    "snippet": "inline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qFromBigEndian",
          "args": [
            "*reinterpret_cast<quint32 *>(data + offset)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<quint32 *>",
          "args": [
            "data + offset"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint32 getUint32(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint32 *>(data + offset));\n    }"
  },
  {
    "function_name": "getUint16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "105-108",
    "snippet": "inline quint16 getUint16(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint16 *>(data + offset));\n    }",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qFromBigEndian",
          "args": [
            "*reinterpret_cast<quint16 *>(data + offset)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<quint16 *>",
          "args": [
            "data + offset"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\ninline quint16 getUint16(int offset) const\n    {\n        return qFromBigEndian(*reinterpret_cast<quint16 *>(data + offset));\n    }"
  },
  {
    "function_name": "isValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "104-104",
    "snippet": "bool isValid() const { return m_valid; }",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nbool isValid() const { return m_valid; }"
  },
  {
    "function_name": "QMimeBinaryProvider",
    "container": "QMimeBinaryProvider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "90-93",
    "snippet": "QMimeBinaryProvider::QMimeBinaryProvider(QMimeDatabasePrivate *db)\n    : QMimeProviderBase(db), m_mimetypeListLoaded(false)\n{\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeBinaryProvider {\n  QMimeBinaryProvider::QMimeBinaryProvider(QMimeDatabasePrivate *db)\n      : QMimeProviderBase(db), m_mimetypeListLoaded(false)\n  {\n  }\n}"
  },
  {
    "function_name": "shouldCheck",
    "container": "QMimeProviderBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "81-88",
    "snippet": "bool QMimeProviderBase::shouldCheck()\n{\n    const QDateTime now = QDateTime::currentDateTime();\n    if (m_lastCheck.isValid() && m_lastCheck.secsTo(now) < qmime_secondsBetweenChecks)\n        return false;\n    m_lastCheck = now;\n    return true;\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int qmime_secondsBetweenChecks = 5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_lastCheck.secsTo",
          "args": [
            "now"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_lastCheck.isValid",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QDateTime::currentDateTime",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nint qmime_secondsBetweenChecks = 5;\n\nQMimeProviderBase {\n  bool QMimeProviderBase::shouldCheck()\n  {\n      const QDateTime now = QDateTime::currentDateTime();\n      if (m_lastCheck.isValid() && m_lastCheck.secsTo(now) < qmime_secondsBetweenChecks)\n          return false;\n      m_lastCheck = now;\n      return true;\n  }\n}"
  },
  {
    "function_name": "QMimeProviderBase",
    "container": "QMimeProviderBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "74-77",
    "snippet": "QMimeProviderBase::QMimeProviderBase(QMimeDatabasePrivate *db)\n    : m_db(db)\n{\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeProviderBase {\n  QMimeProviderBase::QMimeProviderBase(QMimeDatabasePrivate *db)\n      : m_db(db)\n  {\n  }\n}"
  },
  {
    "function_name": "fallbackParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
    "lines": "56-72",
    "snippet": "QT_BEGIN_NAMESPACE\n\nstatic QString fallbackParent(const QString &mimeTypeName)\n{\n    const QString myGroup = mimeTypeName.left(mimeTypeName.indexOf(QLatin1Char('/')));\n    // All text/* types are subclasses of text/plain.\n    if (myGroup == QLatin1String(\"text\") && mimeTypeName != QLatin1String(\"text/plain\"))\n        return QLatin1String(\"text/plain\");\n    // All real-file mimetypes implicitly derive from application/octet-stream\n    if (myGroup != QLatin1String(\"inode\") &&\n        // ignore non-file extensions\n        myGroup != QLatin1String(\"all\") && myGroup != QLatin1String(\"fonts\") && myGroup != QLatin1String(\"print\") && myGroup != QLatin1String(\"uri\")\n        && mimeTypeName != QLatin1String(\"application/octet-stream\")) {\n        return QLatin1String(\"application/octet-stream\");\n    }\n    return QString();\n}",
    "includes": [
      "#include <QtEndian>",
      "#include <QDateTime>",
      "#include <QDebug>",
      "#include <QByteArrayMatcher>",
      "#include <QFile>",
      "#include <QDir>",
      "#include <QXmlStreamReader>",
      "#include \"qmimemagicrulematcher_p.h\"",
      "#include <qstandardpaths.h>",
      "#include \"qmimetypeparser_p.h\"",
      "#include \"qmimeprovider_p.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QString",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"application/octet-stream\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"application/octet-stream\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"uri\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"print\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"fonts\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"all\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"inode\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"text/plain\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"text/plain\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1String",
          "args": [
            "\"text\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeName.left",
          "args": [
            "mimeTypeName.indexOf(QLatin1Char('/'))"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mimeTypeName.indexOf",
          "args": [
            "QLatin1Char('/')"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'/'"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQT_BEGIN_NAMESPACE\n\nstatic QString fallbackParent(const QString &mimeTypeName)\n{\n    const QString myGroup = mimeTypeName.left(mimeTypeName.indexOf(QLatin1Char('/')));\n    // All text/* types are subclasses of text/plain.\n    if (myGroup == QLatin1String(\"text\") && mimeTypeName != QLatin1String(\"text/plain\"))\n        return QLatin1String(\"text/plain\");\n    // All real-file mimetypes implicitly derive from application/octet-stream\n    if (myGroup != QLatin1String(\"inode\") &&\n        // ignore non-file extensions\n        myGroup != QLatin1String(\"all\") && myGroup != QLatin1String(\"fonts\") && myGroup != QLatin1String(\"print\") && myGroup != QLatin1String(\"uri\")\n        && mimeTypeName != QLatin1String(\"application/octet-stream\")) {\n        return QLatin1String(\"application/octet-stream\");\n    }\n    return QString();\n}"
  }
]