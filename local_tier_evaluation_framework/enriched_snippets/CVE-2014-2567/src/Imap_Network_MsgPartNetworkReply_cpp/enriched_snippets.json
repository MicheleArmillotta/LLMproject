[
  {
    "function_name": "disconnectBufferIfVanished(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "137-143",
    "snippet": "oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n{\n    if (!part.isValid()) {\n        buffer.close();\n        buffer.setBuffer(0);\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffer.setBuffer",
          "args": [
            ")"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uffer.close",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.isValid",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n  {\n      if (!part.isValid()) {\n          buffer.close();\n          buffer.setBuffer(0);\n      }\n  }\n}"
  },
  {
    "function_name": "readData(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "129-133",
    "snippet": "int64 MsgPartNetworkReply::readData(char *data, qint64 maxSize)\n{\n    disconnectBufferIfVanished();\n    return buffer.read(data, maxSize);\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffer.read",
          "args": [
            "ata,",
            "axSize)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isconnectBufferIfVanished(",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "disconnectBufferIfVanished(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "137-143",
          "snippet": "oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n{\n    if (!part.isValid()) {\n        buffer.close();\n        buffer.setBuffer(0);\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n  {\n      if (!part.isValid()) {\n          buffer.close();\n          buffer.setBuffer(0);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  int64 MsgPartNetworkReply::readData(char *data, qint64 maxSize)\n  {\n      disconnectBufferIfVanished();\n      return buffer.read(data, maxSize);\n  }\n}"
  },
  {
    "function_name": "bytesAvailable(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "122-126",
    "snippet": "int64 MsgPartNetworkReply::bytesAvailable() const\n{\n    disconnectBufferIfVanished();\n    return buffer.bytesAvailable() + QNetworkReply::bytesAvailable();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NetworkReply::bytesAvailable(",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "bytesAvailable(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "122-126",
          "snippet": "int64 MsgPartNetworkReply::bytesAvailable() const\n{\n    disconnectBufferIfVanished();\n    return buffer.bytesAvailable() + QNetworkReply::bytesAvailable();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "uffer.bytesAvailable",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isconnectBufferIfVanished(",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "disconnectBufferIfVanished(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "137-143",
          "snippet": "oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n{\n    if (!part.isValid()) {\n        buffer.close();\n        buffer.setBuffer(0);\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n  {\n      if (!part.isValid()) {\n          buffer.close();\n          buffer.setBuffer(0);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  int64 MsgPartNetworkReply::bytesAvailable() const\n  {\n      disconnectBufferIfVanished();\n      return buffer.bytesAvailable() + QNetworkReply::bytesAvailable();\n  }\n}"
  },
  {
    "function_name": "close(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "115-119",
    "snippet": "oid MsgPartNetworkReply::close()\n{\n    disconnectBufferIfVanished();\n    buffer.close();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffer.close",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isconnectBufferIfVanished(",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "disconnectBufferIfVanished(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "137-143",
          "snippet": "oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n{\n    if (!part.isValid()) {\n        buffer.close();\n        buffer.setBuffer(0);\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::disconnectBufferIfVanished() const\n  {\n      if (!part.isValid()) {\n          buffer.close();\n          buffer.setBuffer(0);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::close()\n  {\n      disconnectBufferIfVanished();\n      buffer.close();\n  }\n}"
  },
  {
    "function_name": "abort(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "109-112",
    "snippet": "oid MsgPartNetworkReply::abort()\n{\n    close();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lose(",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "close(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "115-119",
          "snippet": "oid MsgPartNetworkReply::close()\n{\n    disconnectBufferIfVanished();\n    buffer.close();\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::close()\n  {\n      disconnectBufferIfVanished();\n      buffer.close();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::abort()\n  {\n      close();\n  }\n}"
  },
  {
    "function_name": "slotMyDataChanged(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "81-106",
    "snippet": "oid MsgPartNetworkReply::slotMyDataChanged()\n{\n    if (part.data(Mailbox::RoleIsUnavailable).toBool()) {\n        setError(TimeoutError, tr(\"Offline\"));\n        emit error(TimeoutError);\n        emit finished();\n        return;\n    }\n\n    if (!part.data(Mailbox::RoleIsFetched).toBool())\n        return;\n\n    MsgPartNetAccessManager *netAccess = qobject_cast<MsgPartNetAccessManager*>(manager());\n    Q_ASSERT(netAccess);\n    QString mimeType = netAccess->translateToSupportedMimeType(part.data(Mailbox::RolePartMimeType).toString());\n    QString charset = part.data(Mailbox::RolePartCharset).toString();\n    if (mimeType.startsWith(QLatin1String(\"text/\"))) {\n        setHeader(QNetworkRequest::ContentTypeHeader,\n                  charset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)\n                 );\n    } else {\n        setHeader(QNetworkRequest::ContentTypeHeader, mimeType);\n    }\n    emit readyRead();\n    emit finished();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etHeader(",
          "args": [
            "NetworkRequest::ContentTypeHeader,",
            "imeType)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etHeader(",
          "args": [
            "NetworkRequest::ContentTypeHeader,",
            "harset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "imeType,",
            "harset)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "%1; charset=%2\")"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "harset.isEmpty",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeType.startsWith",
          "args": [
            "Latin1String(\"text/\"))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "text/\")"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [
            "ailbox::RolePartCharset)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etAccess->translateToSupportedMimeType",
          "args": [
            "art.data(Mailbox::RolePartMimeType).toString())"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [
            "ailbox::RolePartMimeType)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "etAccess)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<MsgPartNetAccessManager*>",
          "args": [
            "anager())"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anager(",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "~PluginManager(",
          "container": "luginManager",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Plugins/PluginManager.cpp",
          "lines": "53-55",
          "snippet": "luginManager::~PluginManager()\n{\n}",
          "includes": [
            "include \"PluginManager.h\"",
            "include \"Plugins/PluginInterface.h\"",
            "include \"Plugins/PasswordPlugin.h\"\n#",
            "include \"Plugins/AddressbookPlugin.h\"\n#",
            "include \"configure.cmake.h\"",
            "include <QStringList>",
            "include <QString>\n#",
            "include <QSettings>\n#",
            "include <QPluginLoader>\n#",
            "include <QMap>\n#",
            "include <QLibraryInfo>\n#",
            "include <QFileInfo>\n#",
            "include <QDir>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"PluginManager.h\"\ninclude \"Plugins/PluginInterface.h\"\ninclude \"Plugins/PasswordPlugin.h\"\n#\ninclude \"Plugins/AddressbookPlugin.h\"\n#\ninclude \"configure.cmake.h\"\ninclude <QStringList>\ninclude <QString>\n#\ninclude <QSettings>\n#\ninclude <QPluginLoader>\n#\ninclude <QMap>\n#\ninclude <QLibraryInfo>\n#\ninclude <QFileInfo>\n#\ninclude <QDir>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\n\nluginManager {\n  luginManager::~PluginManager()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [
            "ailbox::RoleIsFetched)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etError(",
          "args": [
            "imeoutError,",
            "r(\"Offline\"))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Offline\")"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "onCombinerTransferError(",
          "container": "ileDownloadManager",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/FileDownloadManager.cpp",
          "lines": "158-161",
          "snippet": "oid FileDownloadManager::onCombinerTransferError(const QString &message)\n{\n    emit transferError(message);\n}",
          "includes": [
            "include <QDir>",
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"FileDownloadManager.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QDir>\ninclude \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"FileDownloadManager.h\"\n#\n\nileDownloadManager {\n  oid FileDownloadManager::onCombinerTransferError(const QString &message)\n  {\n      emit transferError(message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [
            "ailbox::RoleIsUnavailable)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::slotMyDataChanged()\n  {\n      if (part.data(Mailbox::RoleIsUnavailable).toBool()) {\n          setError(TimeoutError, tr(\"Offline\"));\n          emit error(TimeoutError);\n          emit finished();\n          return;\n      }\n  \n      if (!part.data(Mailbox::RoleIsFetched).toBool())\n          return;\n  \n      MsgPartNetAccessManager *netAccess = qobject_cast<MsgPartNetAccessManager*>(manager());\n      Q_ASSERT(netAccess);\n      QString mimeType = netAccess->translateToSupportedMimeType(part.data(Mailbox::RolePartMimeType).toString());\n      QString charset = part.data(Mailbox::RolePartCharset).toString();\n      if (mimeType.startsWith(QLatin1String(\"text/\"))) {\n          setHeader(QNetworkRequest::ContentTypeHeader,\n                    charset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)\n                   );\n      } else {\n          setHeader(QNetworkRequest::ContentTypeHeader, mimeType);\n      }\n      emit readyRead();\n      emit finished();\n  }\n}"
  },
  {
    "function_name": "slotModelDataChanged(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "68-78",
    "snippet": "oid MsgPartNetworkReply::slotModelDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n{\n    Q_UNUSED(bottomRight);\n    // FIXME: use bottomRight as well!\n    if (topLeft.model() != part.model()) {\n        return;\n    }\n    if (topLeft == part) {\n        slotMyDataChanged();\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lotMyDataChanged(",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "slotMyDataChanged(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "81-106",
          "snippet": "oid MsgPartNetworkReply::slotMyDataChanged()\n{\n    if (part.data(Mailbox::RoleIsUnavailable).toBool()) {\n        setError(TimeoutError, tr(\"Offline\"));\n        emit error(TimeoutError);\n        emit finished();\n        return;\n    }\n\n    if (!part.data(Mailbox::RoleIsFetched).toBool())\n        return;\n\n    MsgPartNetAccessManager *netAccess = qobject_cast<MsgPartNetAccessManager*>(manager());\n    Q_ASSERT(netAccess);\n    QString mimeType = netAccess->translateToSupportedMimeType(part.data(Mailbox::RolePartMimeType).toString());\n    QString charset = part.data(Mailbox::RolePartCharset).toString();\n    if (mimeType.startsWith(QLatin1String(\"text/\"))) {\n        setHeader(QNetworkRequest::ContentTypeHeader,\n                  charset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)\n                 );\n    } else {\n        setHeader(QNetworkRequest::ContentTypeHeader, mimeType);\n    }\n    emit readyRead();\n    emit finished();\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::slotMyDataChanged()\n  {\n      if (part.data(Mailbox::RoleIsUnavailable).toBool()) {\n          setError(TimeoutError, tr(\"Offline\"));\n          emit error(TimeoutError);\n          emit finished();\n          return;\n      }\n  \n      if (!part.data(Mailbox::RoleIsFetched).toBool())\n          return;\n  \n      MsgPartNetAccessManager *netAccess = qobject_cast<MsgPartNetAccessManager*>(manager());\n      Q_ASSERT(netAccess);\n      QString mimeType = netAccess->translateToSupportedMimeType(part.data(Mailbox::RolePartMimeType).toString());\n      QString charset = part.data(Mailbox::RolePartCharset).toString();\n      if (mimeType.startsWith(QLatin1String(\"text/\"))) {\n          setHeader(QNetworkRequest::ContentTypeHeader,\n                    charset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)\n                   );\n      } else {\n          setHeader(QNetworkRequest::ContentTypeHeader, mimeType);\n      }\n      emit readyRead();\n      emit finished();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "art.model",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opLeft.model",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ottomRight)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::slotModelDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n  {\n      Q_UNUSED(bottomRight);\n      // FIXME: use bottomRight as well!\n      if (topLeft.model() != part.model()) {\n          return;\n      }\n      if (topLeft == part) {\n          slotMyDataChanged();\n      }\n  }\n}"
  },
  {
    "function_name": "MsgPartNetworkReply(",
    "container": "sgPartNetworkReply",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
    "lines": "38-65",
    "snippet": "sgPartNetworkReply::MsgPartNetworkReply(MsgPartNetAccessManager *parent, const QPersistentModelIndex &part):\n    QNetworkReply(parent), part(part)\n{\n    QUrl url;\n    url.setScheme(QLatin1String(\"trojita-imap\"));\n    url.setHost(QLatin1String(\"msg\"));\n    url.setPath(part.data(Imap::Mailbox::RolePartPathToPart).toString());\n    setUrl(url);\n\n    setOpenMode(QIODevice::ReadOnly | QIODevice::Unbuffered);\n    Q_ASSERT(part.isValid());\n    const Mailbox::Model *model = 0;\n    Mailbox::Model::realTreeItem(part, &model);\n    Q_ASSERT(model);\n\n    connect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotModelDataChanged(QModelIndex,QModelIndex)));\n\n    Mailbox::TreeItemPart *partPtr = dynamic_cast<Mailbox::TreeItemPart *>(static_cast<Mailbox::TreeItem *>(part.internalPointer()));\n    Q_ASSERT(partPtr);\n\n    // We have to ask for contents before we check whether it's already fetched\n    partPtr->fetch(const_cast<Mailbox::Model *>(model));\n    // The part data might be already unavailable or already fetched\n    QTimer::singleShot(0, this, SLOT(slotMyDataChanged()));\n\n    buffer.setBuffer(partPtr->dataPtr());\n    buffer.open(QIODevice::ReadOnly);\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"MsgPartNetworkReply.h\"\n#",
      "include <QTimer>",
      "include <QStringList>\n#",
      "include <QDebug>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uffer.open",
          "args": [
            "IODevice::ReadOnly)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uffer.setBuffer",
          "args": [
            "artPtr->dataPtr())"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "artPtr->dataPtr",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(slotMyDataChanged()))"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotMyDataChanged())"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotMyDataChanged(",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "slotMyDataChanged(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "81-106",
          "snippet": "oid MsgPartNetworkReply::slotMyDataChanged()\n{\n    if (part.data(Mailbox::RoleIsUnavailable).toBool()) {\n        setError(TimeoutError, tr(\"Offline\"));\n        emit error(TimeoutError);\n        emit finished();\n        return;\n    }\n\n    if (!part.data(Mailbox::RoleIsFetched).toBool())\n        return;\n\n    MsgPartNetAccessManager *netAccess = qobject_cast<MsgPartNetAccessManager*>(manager());\n    Q_ASSERT(netAccess);\n    QString mimeType = netAccess->translateToSupportedMimeType(part.data(Mailbox::RolePartMimeType).toString());\n    QString charset = part.data(Mailbox::RolePartCharset).toString();\n    if (mimeType.startsWith(QLatin1String(\"text/\"))) {\n        setHeader(QNetworkRequest::ContentTypeHeader,\n                  charset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)\n                 );\n    } else {\n        setHeader(QNetworkRequest::ContentTypeHeader, mimeType);\n    }\n    emit readyRead();\n    emit finished();\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::slotMyDataChanged()\n  {\n      if (part.data(Mailbox::RoleIsUnavailable).toBool()) {\n          setError(TimeoutError, tr(\"Offline\"));\n          emit error(TimeoutError);\n          emit finished();\n          return;\n      }\n  \n      if (!part.data(Mailbox::RoleIsFetched).toBool())\n          return;\n  \n      MsgPartNetAccessManager *netAccess = qobject_cast<MsgPartNetAccessManager*>(manager());\n      Q_ASSERT(netAccess);\n      QString mimeType = netAccess->translateToSupportedMimeType(part.data(Mailbox::RolePartMimeType).toString());\n      QString charset = part.data(Mailbox::RolePartCharset).toString();\n      if (mimeType.startsWith(QLatin1String(\"text/\"))) {\n          setHeader(QNetworkRequest::ContentTypeHeader,\n                    charset.isEmpty() ? mimeType : QString::fromUtf8(\"%1; charset=%2\").arg(mimeType, charset)\n                   );\n      } else {\n          setHeader(QNetworkRequest::ContentTypeHeader, mimeType);\n      }\n      emit readyRead();\n      emit finished();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "artPtr->fetch",
          "args": [
            "onst_cast<Mailbox::Model *>(model))"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onst_cast<Mailbox::Model *>",
          "args": [
            "odel)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "artPtr)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<Mailbox::TreeItemPart *>",
          "args": [
            "tatic_cast<Mailbox::TreeItem *>(part.internalPointer()))"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<Mailbox::TreeItem *>",
          "args": [
            "art.internalPointer())"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.internalPointer",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "odel,",
            "IGNAL(dataChanged(QModelIndex,QModelIndex)),",
            "his,",
            "LOT(slotModelDataChanged(QModelIndex,QModelIndex)))"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotModelDataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotModelDataChanged(",
          "args": [
            "ModelIndex,",
            "ModelIndex)"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "slotModelDataChanged(",
          "container": "sgPartNetworkReply",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Network/MsgPartNetworkReply.cpp",
          "lines": "68-78",
          "snippet": "oid MsgPartNetworkReply::slotModelDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n{\n    Q_UNUSED(bottomRight);\n    // FIXME: use bottomRight as well!\n    if (topLeft.model() != part.model()) {\n        return;\n    }\n    if (topLeft == part) {\n        slotMyDataChanged();\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"MsgPartNetworkReply.h\"\n#",
            "include <QTimer>",
            "include <QStringList>\n#",
            "include <QDebug>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  oid MsgPartNetworkReply::slotModelDataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight)\n  {\n      Q_UNUSED(bottomRight);\n      // FIXME: use bottomRight as well!\n      if (topLeft.model() != part.model()) {\n          return;\n      }\n      if (topLeft == part) {\n          slotMyDataChanged();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ataChanged(QModelIndex,QModelIndex))"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox::Model::realTreeItem(",
          "args": [
            "art,",
            "model)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "art.isValid())"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.isValid",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etOpenMode(",
          "args": [
            "IODevice::ReadOnly | QIODevice::Unbuffered)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etUrl(",
          "args": [
            "rl)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.setPath",
          "args": [
            "art.data(Imap::Mailbox::RolePartPathToPart).toString())"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "art.data",
          "args": [
            "map::Mailbox::RolePartPathToPart)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.setHost",
          "args": [
            "Latin1String(\"msg\"))"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "msg\")"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rl.setScheme",
          "args": [
            "Latin1String(\"trojita-imap\"))"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "trojita-imap\")"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"MsgPartNetworkReply.h\"\n#\ninclude <QTimer>\ninclude <QStringList>\n#\ninclude <QDebug>\n#\n\nsgPartNetworkReply {\n  sgPartNetworkReply::MsgPartNetworkReply(MsgPartNetAccessManager *parent, const QPersistentModelIndex &part):\n      QNetworkReply(parent), part(part)\n  {\n      QUrl url;\n      url.setScheme(QLatin1String(\"trojita-imap\"));\n      url.setHost(QLatin1String(\"msg\"));\n      url.setPath(part.data(Imap::Mailbox::RolePartPathToPart).toString());\n      setUrl(url);\n  \n      setOpenMode(QIODevice::ReadOnly | QIODevice::Unbuffered);\n      Q_ASSERT(part.isValid());\n      const Mailbox::Model *model = 0;\n      Mailbox::Model::realTreeItem(part, &model);\n      Q_ASSERT(model);\n  \n      connect(model, SIGNAL(dataChanged(QModelIndex,QModelIndex)), this, SLOT(slotModelDataChanged(QModelIndex,QModelIndex)));\n  \n      Mailbox::TreeItemPart *partPtr = dynamic_cast<Mailbox::TreeItemPart *>(static_cast<Mailbox::TreeItem *>(part.internalPointer()));\n      Q_ASSERT(partPtr);\n  \n      // We have to ask for contents before we check whether it's already fetched\n      partPtr->fetch(const_cast<Mailbox::Model *>(model));\n      // The part data might be already unavailable or already fetched\n      QTimer::singleShot(0, this, SLOT(slotMyDataChanged()));\n  \n      buffer.setBuffer(partPtr->dataPtr());\n      buffer.open(QIODevice::ReadOnly);\n  }\n}"
  }
]