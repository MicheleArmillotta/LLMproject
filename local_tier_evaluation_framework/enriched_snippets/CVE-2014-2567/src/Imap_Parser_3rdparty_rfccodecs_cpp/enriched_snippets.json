[
  {
    "function_name": "encodeImapFolderName",
    "container": "KIMAP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/rfccodecs.cpp",
    "lines": "156-252",
    "snippet": "QString KIMAP::encodeImapFolderName( const QString &inSrc )\n{\n  unsigned int utf8pos, utf8total, c, utf7mode, bitstogo, utf16flag;\n  unsigned int ucs4, bitbuf;\n  QByteArray src = inSrc.toUtf8 ();\n  QString dst;\n\n  int srcPtr = 0;\n  utf7mode = 0;\n  utf8total = 0;\n  bitstogo = 0;\n  utf8pos = 0;\n  bitbuf = 0;\n  ucs4 = 0;\n  while ( srcPtr < src.length () ) {\n    c = (unsigned char)src[srcPtr++];\n    /* normal character? */\n    if ( c >= ' ' && c <= '~' ) {\n      /* switch out of UTF-7 mode */\n      if ( utf7mode ) {\n        if ( bitstogo ) {\n          dst += QChar::fromLatin1(base64chars[( bitbuf << ( 6 - bitstogo ) ) & 0x3F]);\n          bitstogo = 0;\n        }\n        dst += QLatin1Char('-');\n        utf7mode = 0;\n      }\n      dst += c;\n      /* encode '&' as '&-' */\n      if ( c == '&' ) {\n        dst += QLatin1Char('-');\n      }\n      continue;\n    }\n    /* switch to UTF-7 mode */\n    if ( !utf7mode ) {\n      dst += '&';\n      utf7mode = 1;\n    }\n    /* Encode US-ASCII characters as themselves */\n    if ( c < 0x80 ) {\n      ucs4 = c;\n      utf8total = 1;\n    } else if ( utf8total ) {\n      /* save UTF8 bits into UCS4 */\n      ucs4 = ( ucs4 << 6 ) | ( c & 0x3FUL );\n      if ( ++utf8pos < utf8total ) {\n        continue;\n      }\n    } else {\n      utf8pos = 1;\n      if ( c < 0xE0 ) {\n        utf8total = 2;\n        ucs4 = c & 0x1F;\n      } else if ( c < 0xF0 ) {\n        utf8total = 3;\n        ucs4 = c & 0x0F;\n      } else {\n        /* NOTE: can't convert UTF8 sequences longer than 4 */\n        utf8total = 4;\n        ucs4 = c & 0x03;\n      }\n      continue;\n    }\n    /* loop to split ucs4 into two utf16 chars if necessary */\n    utf8total = 0;\n    do\n    {\n      if ( ucs4 >= UTF16BASE ) {\n        ucs4 -= UTF16BASE;\n        bitbuf =\n          ( bitbuf << 16 ) | ( ( ucs4 >> UTF16SHIFT ) + UTF16HIGHSTART );\n        ucs4 = ( ucs4 & UTF16MASK ) + UTF16LOSTART;\n        utf16flag = 1;\n      } else {\n        bitbuf = ( bitbuf << 16 ) | ucs4;\n        utf16flag = 0;\n      }\n      bitstogo += 16;\n      /* spew out base64 */\n      while ( bitstogo >= 6 ) {\n        bitstogo -= 6;\n        dst +=\n          base64chars[( bitstogo ? ( bitbuf >> bitstogo ) : bitbuf ) & 0x3F];\n      }\n    }\n    while ( utf16flag );\n  }\n  /* if in UTF-7 mode, finish in ASCII */\n  if ( utf7mode ) {\n    if ( bitstogo ) {\n      dst += base64chars[( bitbuf << ( 6 - bitstogo ) ) & 0x3F];\n    }\n    dst += '-';\n  }\n  return dst;\n}",
    "includes": [
      "#include \"kcodecs.h\"",
      "#include <QtCore/QLatin1Char>",
      "#include <QtCore/QByteArray>",
      "#include <QtCore/QRegExp>",
      "#include <QtCore/QBuffer>",
      "#include <QtCore/QTextCodec>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"rfccodecs.h\""
    ],
    "macros_used": [
      "#define UTF16LOSTART    0xDC00UL",
      "#define UTF16HIGHSTART  0xD800UL",
      "#define UTF16BASE       0x10000UL",
      "#define UTF16SHIFT      10",
      "#define UTF16MASK       0x03FFUL"
    ],
    "globals_used": [
      "static const unsigned char base64chars[] =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'-'"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'-'"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QChar::fromLatin1",
          "args": [
            "base64chars[( bitbuf << ( 6 - bitstogo ) ) & 0x3F]"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.length",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inSrc.toUtf8",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcodecs.h\"\n#include <QtCore/QLatin1Char>\n#include <QtCore/QByteArray>\n#include <QtCore/QRegExp>\n#include <QtCore/QBuffer>\n#include <QtCore/QTextCodec>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"rfccodecs.h\"\n\n#define UTF16LOSTART    0xDC00UL\n#define UTF16HIGHSTART  0xD800UL\n#define UTF16BASE       0x10000UL\n#define UTF16SHIFT      10\n#define UTF16MASK       0x03FFUL\n\nstatic const unsigned char base64chars[] =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\nKIMAP {\n  QString KIMAP::encodeImapFolderName( const QString &inSrc )\n  {\n    unsigned int utf8pos, utf8total, c, utf7mode, bitstogo, utf16flag;\n    unsigned int ucs4, bitbuf;\n    QByteArray src = inSrc.toUtf8 ();\n    QString dst;\n  \n    int srcPtr = 0;\n    utf7mode = 0;\n    utf8total = 0;\n    bitstogo = 0;\n    utf8pos = 0;\n    bitbuf = 0;\n    ucs4 = 0;\n    while ( srcPtr < src.length () ) {\n      c = (unsigned char)src[srcPtr++];\n      /* normal character? */\n      if ( c >= ' ' && c <= '~' ) {\n        /* switch out of UTF-7 mode */\n        if ( utf7mode ) {\n          if ( bitstogo ) {\n            dst += QChar::fromLatin1(base64chars[( bitbuf << ( 6 - bitstogo ) ) & 0x3F]);\n            bitstogo = 0;\n          }\n          dst += QLatin1Char('-');\n          utf7mode = 0;\n        }\n        dst += c;\n        /* encode '&' as '&-' */\n        if ( c == '&' ) {\n          dst += QLatin1Char('-');\n        }\n        continue;\n      }\n      /* switch to UTF-7 mode */\n      if ( !utf7mode ) {\n        dst += '&';\n        utf7mode = 1;\n      }\n      /* Encode US-ASCII characters as themselves */\n      if ( c < 0x80 ) {\n        ucs4 = c;\n        utf8total = 1;\n      } else if ( utf8total ) {\n        /* save UTF8 bits into UCS4 */\n        ucs4 = ( ucs4 << 6 ) | ( c & 0x3FUL );\n        if ( ++utf8pos < utf8total ) {\n          continue;\n        }\n      } else {\n        utf8pos = 1;\n        if ( c < 0xE0 ) {\n          utf8total = 2;\n          ucs4 = c & 0x1F;\n        } else if ( c < 0xF0 ) {\n          utf8total = 3;\n          ucs4 = c & 0x0F;\n        } else {\n          /* NOTE: can't convert UTF8 sequences longer than 4 */\n          utf8total = 4;\n          ucs4 = c & 0x03;\n        }\n        continue;\n      }\n      /* loop to split ucs4 into two utf16 chars if necessary */\n      utf8total = 0;\n      do\n      {\n        if ( ucs4 >= UTF16BASE ) {\n          ucs4 -= UTF16BASE;\n          bitbuf =\n            ( bitbuf << 16 ) | ( ( ucs4 >> UTF16SHIFT ) + UTF16HIGHSTART );\n          ucs4 = ( ucs4 & UTF16MASK ) + UTF16LOSTART;\n          utf16flag = 1;\n        } else {\n          bitbuf = ( bitbuf << 16 ) | ucs4;\n          utf16flag = 0;\n        }\n        bitstogo += 16;\n        /* spew out base64 */\n        while ( bitstogo >= 6 ) {\n          bitstogo -= 6;\n          dst +=\n            base64chars[( bitstogo ? ( bitbuf >> bitstogo ) : bitbuf ) & 0x3F];\n        }\n      }\n      while ( utf16flag );\n    }\n    /* if in UTF-7 mode, finish in ASCII */\n    if ( utf7mode ) {\n      if ( bitstogo ) {\n        dst += base64chars[( bitbuf << ( 6 - bitstogo ) ) & 0x3F];\n      }\n      dst += '-';\n    }\n    return dst;\n  }\n}"
  },
  {
    "function_name": "decodeImapFolderName",
    "container": "KIMAP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/3rdparty/rfccodecs.cpp",
    "lines": "71-153",
    "snippet": "QString KIMAP::decodeImapFolderName( const QString &inSrc )\n{\n  unsigned char c, i, bitcount;\n  unsigned long ucs4, utf16, bitbuf;\n  unsigned char base64[256], utf8[6];\n  unsigned int srcPtr = 0;\n  QByteArray dst;\n  QByteArray src = inSrc.toUtf8();\n  uint srcLen = inSrc.length();\n\n  /* initialize modified base64 decoding table */\n  memset( base64, UNDEFINED, sizeof( base64 ) );\n  for ( i = 0; i < sizeof( base64chars ); ++i ) {\n    base64[(int)base64chars[i]] = i;\n  }\n\n  /* loop until end of string */\n  while ( srcPtr < srcLen ) {\n    c = src[srcPtr++];\n    /* deal with literal characters and &- */\n    if ( c != '&' || src[srcPtr] == '-' ) {\n      /* encode literally */\n      dst += c;\n      /* skip over the '-' if this is an &- sequence */\n      if ( c == '&' ) {\n        srcPtr++;\n      }\n    } else {\n      /* convert modified UTF-7 -> UTF-16 -> UCS-4 -> UTF-8 -> HEX */\n      bitbuf = 0;\n      bitcount = 0;\n      ucs4 = 0;\n      while ( ( c = base64[(unsigned char)src[srcPtr]] ) != UNDEFINED ) {\n        ++srcPtr;\n        bitbuf = ( bitbuf << 6 ) | c;\n        bitcount += 6;\n        /* enough bits for a UTF-16 character? */\n        if ( bitcount >= 16 ) {\n          bitcount -= 16;\n          utf16 = ( bitcount ? bitbuf >> bitcount : bitbuf ) & 0xffff;\n          /* convert UTF16 to UCS4 */\n          if ( utf16 >= UTF16HIGHSTART && utf16 <= UTF16HIGHEND ) {\n            ucs4 = ( utf16 - UTF16HIGHSTART ) << UTF16SHIFT;\n            continue;\n          } else if ( utf16 >= UTF16LOSTART && utf16 <= UTF16LOEND ) {\n            ucs4 += utf16 - UTF16LOSTART + UTF16BASE;\n          } else {\n            ucs4 = utf16;\n          }\n          /* convert UTF-16 range of UCS4 to UTF-8 */\n          if ( ucs4 <= 0x7fUL ) {\n            utf8[0] = ucs4;\n            i = 1;\n          } else if ( ucs4 <= 0x7ffUL ) {\n            utf8[0] = 0xc0 | ( ucs4 >> 6 );\n            utf8[1] = 0x80 | ( ucs4 & 0x3f );\n            i = 2;\n          } else if ( ucs4 <= 0xffffUL ) {\n            utf8[0] = 0xe0 | ( ucs4 >> 12 );\n            utf8[1] = 0x80 | ( ( ucs4 >> 6 ) & 0x3f );\n            utf8[2] = 0x80 | ( ucs4 & 0x3f );\n            i = 3;\n          } else {\n            utf8[0] = 0xf0 | ( ucs4 >> 18 );\n            utf8[1] = 0x80 | ( ( ucs4 >> 12 ) & 0x3f );\n            utf8[2] = 0x80 | ( ( ucs4 >> 6 ) & 0x3f );\n            utf8[3] = 0x80 | ( ucs4 & 0x3f );\n            i = 4;\n          }\n          /* copy it */\n          for ( c = 0; c < i; ++c ) {\n            dst += utf8[c];\n          }\n        }\n      }\n      /* skip over trailing '-' in modified UTF-7 encoding */\n      if ( src[srcPtr] == '-' ) {\n        ++srcPtr;\n      }\n    }\n  }\n  return QString::fromUtf8( dst.data () );\n}",
    "includes": [
      "#include \"kcodecs.h\"",
      "#include <QtCore/QLatin1Char>",
      "#include <QtCore/QByteArray>",
      "#include <QtCore/QRegExp>",
      "#include <QtCore/QBuffer>",
      "#include <QtCore/QTextCodec>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>",
      "#include <ctype.h>",
      "#include \"rfccodecs.h\""
    ],
    "macros_used": [
      "#define UTF16LOEND      0xDFFFUL",
      "#define UTF16LOSTART    0xDC00UL",
      "#define UTF16HIGHEND    0xDBFFUL",
      "#define UTF16HIGHSTART  0xD800UL",
      "#define UTF16BASE       0x10000UL",
      "#define UTF16SHIFT      10",
      "#define UNDEFINED 64"
    ],
    "globals_used": [
      "static const unsigned char base64chars[] =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "dst.data ()"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.data",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "base64",
            "UNDEFINED",
            "sizeof( base64 )"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inSrc.length",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inSrc.toUtf8",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kcodecs.h\"\n#include <QtCore/QLatin1Char>\n#include <QtCore/QByteArray>\n#include <QtCore/QRegExp>\n#include <QtCore/QBuffer>\n#include <QtCore/QTextCodec>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"rfccodecs.h\"\n\n#define UTF16LOEND      0xDFFFUL\n#define UTF16LOSTART    0xDC00UL\n#define UTF16HIGHEND    0xDBFFUL\n#define UTF16HIGHSTART  0xD800UL\n#define UTF16BASE       0x10000UL\n#define UTF16SHIFT      10\n#define UNDEFINED 64\n\nstatic const unsigned char base64chars[] =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\nKIMAP {\n  QString KIMAP::decodeImapFolderName( const QString &inSrc )\n  {\n    unsigned char c, i, bitcount;\n    unsigned long ucs4, utf16, bitbuf;\n    unsigned char base64[256], utf8[6];\n    unsigned int srcPtr = 0;\n    QByteArray dst;\n    QByteArray src = inSrc.toUtf8();\n    uint srcLen = inSrc.length();\n  \n    /* initialize modified base64 decoding table */\n    memset( base64, UNDEFINED, sizeof( base64 ) );\n    for ( i = 0; i < sizeof( base64chars ); ++i ) {\n      base64[(int)base64chars[i]] = i;\n    }\n  \n    /* loop until end of string */\n    while ( srcPtr < srcLen ) {\n      c = src[srcPtr++];\n      /* deal with literal characters and &- */\n      if ( c != '&' || src[srcPtr] == '-' ) {\n        /* encode literally */\n        dst += c;\n        /* skip over the '-' if this is an &- sequence */\n        if ( c == '&' ) {\n          srcPtr++;\n        }\n      } else {\n        /* convert modified UTF-7 -> UTF-16 -> UCS-4 -> UTF-8 -> HEX */\n        bitbuf = 0;\n        bitcount = 0;\n        ucs4 = 0;\n        while ( ( c = base64[(unsigned char)src[srcPtr]] ) != UNDEFINED ) {\n          ++srcPtr;\n          bitbuf = ( bitbuf << 6 ) | c;\n          bitcount += 6;\n          /* enough bits for a UTF-16 character? */\n          if ( bitcount >= 16 ) {\n            bitcount -= 16;\n            utf16 = ( bitcount ? bitbuf >> bitcount : bitbuf ) & 0xffff;\n            /* convert UTF16 to UCS4 */\n            if ( utf16 >= UTF16HIGHSTART && utf16 <= UTF16HIGHEND ) {\n              ucs4 = ( utf16 - UTF16HIGHSTART ) << UTF16SHIFT;\n              continue;\n            } else if ( utf16 >= UTF16LOSTART && utf16 <= UTF16LOEND ) {\n              ucs4 += utf16 - UTF16LOSTART + UTF16BASE;\n            } else {\n              ucs4 = utf16;\n            }\n            /* convert UTF-16 range of UCS4 to UTF-8 */\n            if ( ucs4 <= 0x7fUL ) {\n              utf8[0] = ucs4;\n              i = 1;\n            } else if ( ucs4 <= 0x7ffUL ) {\n              utf8[0] = 0xc0 | ( ucs4 >> 6 );\n              utf8[1] = 0x80 | ( ucs4 & 0x3f );\n              i = 2;\n            } else if ( ucs4 <= 0xffffUL ) {\n              utf8[0] = 0xe0 | ( ucs4 >> 12 );\n              utf8[1] = 0x80 | ( ( ucs4 >> 6 ) & 0x3f );\n              utf8[2] = 0x80 | ( ucs4 & 0x3f );\n              i = 3;\n            } else {\n              utf8[0] = 0xf0 | ( ucs4 >> 18 );\n              utf8[1] = 0x80 | ( ( ucs4 >> 12 ) & 0x3f );\n              utf8[2] = 0x80 | ( ( ucs4 >> 6 ) & 0x3f );\n              utf8[3] = 0x80 | ( ucs4 & 0x3f );\n              i = 4;\n            }\n            /* copy it */\n            for ( c = 0; c < i; ++c ) {\n              dst += utf8[c];\n            }\n          }\n        }\n        /* skip over trailing '-' in modified UTF-7 encoding */\n        if ( src[srcPtr] == '-' ) {\n          ++srcPtr;\n        }\n      }\n    }\n    return QString::fromUtf8( dst.data () );\n  }\n}"
  }
]