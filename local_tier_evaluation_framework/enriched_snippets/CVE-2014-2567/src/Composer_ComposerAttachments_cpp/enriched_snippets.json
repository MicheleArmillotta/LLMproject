[
  {
    "function_name": "asDroppableMimeData(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "438-443",
    "snippet": "oid ImapPartAttachmentItem::asDroppableMimeData(QDataStream &stream) const\n{\n    Q_ASSERT(index.isValid());\n    stream << ATTACHMENT_IMAP_PART << index.data(RoleMailboxName).toString() << index.data(RoleMailboxUidValidity).toUInt() <<\n              index.data(RoleMessageUid).toUInt() << index.data(RolePartPathToPart).toString();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartPathToPart)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageUid)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxUidValidity)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.isValid())"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  oid ImapPartAttachmentItem::asDroppableMimeData(QDataStream &stream) const\n  {\n      Q_ASSERT(index.isValid());\n      stream << ATTACHMENT_IMAP_PART << index.data(RoleMailboxName).toString() << index.data(RoleMailboxUidValidity).toUInt() <<\n                index.data(RoleMessageUid).toUInt() << index.data(RolePartPathToPart).toString();\n  }\n}"
  },
  {
    "function_name": "preload(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "433-436",
    "snippet": "oid ImapPartAttachmentItem::preload() const\n{\n    index.data(RolePartData);\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartData)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  oid ImapPartAttachmentItem::preload() const\n  {\n      index.data(RolePartData);\n  }\n}"
  },
  {
    "function_name": "imapUrl(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "423-431",
    "snippet": "ByteArray ImapPartAttachmentItem::imapUrl() const\n{\n    Q_ASSERT(index.isValid());\n    return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\").arg(\n                QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                index.data(RoleMailboxUidValidity).toString(),\n                index.data(RoleMessageUid).toString(),\n                index.data(RolePartId).toString()).toUtf8();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "Url::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),",
            "ndex.data(RoleMailboxUidValidity).toString(),",
            "ndex.data(RoleMessageUid).toString(),",
            "ndex.data(RolePartId).toString())"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartId)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageUid)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxUidValidity)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Url::toPercentEncoding(",
          "args": [
            "ndex.data(RoleMailboxName).toString().toUtf8())"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\")"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ndex.isValid())"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ByteArray ImapPartAttachmentItem::imapUrl() const\n  {\n      Q_ASSERT(index.isValid());\n      return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\").arg(\n                  QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                  index.data(RoleMailboxUidValidity).toString(),\n                  index.data(RoleMessageUid).toString(),\n                  index.data(RolePartId).toString()).toUtf8();\n  }\n}"
  },
  {
    "function_name": "isAvailableLocally(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "418-421",
    "snippet": "ool ImapPartAttachmentItem::isAvailableLocally() const\n{\n    return index.data(RoleIsFetched).toBool();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleIsFetched)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ool ImapPartAttachmentItem::isAvailableLocally() const\n  {\n      return index.data(RoleIsFetched).toBool();\n  }\n}"
  },
  {
    "function_name": "rawData(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "407-416",
    "snippet": "SharedPointer<QIODevice> ImapPartAttachmentItem::rawData() const\n{\n    if (!index.isValid() || !index.data(RoleIsFetched).toBool())\n        return QSharedPointer<QIODevice>();\n\n    QSharedPointer<QIODevice> io(new QBuffer());\n    static_cast<QBuffer*>(io.data())->setData(index.data(RolePartData).toByteArray());\n    io->open(QIODevice::ReadOnly);\n    return io;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o->open",
          "args": [
            "IODevice::ReadOnly)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<QBuffer*>",
          "args": [
            "ndex.data(RolePartData).toByteArray())"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartData)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<QBuffer*>",
          "args": [
            "o.data())"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SharedPointer<QIODevice>",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleIsFetched)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  SharedPointer<QIODevice> ImapPartAttachmentItem::rawData() const\n  {\n      if (!index.isValid() || !index.data(RoleIsFetched).toBool())\n          return QSharedPointer<QIODevice>();\n  \n      QSharedPointer<QIODevice> io(new QBuffer());\n      static_cast<QBuffer*>(io.data())->setData(index.data(RolePartData).toByteArray());\n      io->open(QIODevice::ReadOnly);\n      return io;\n  }\n}"
  },
  {
    "function_name": "suggestedCTE(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "397-405",
    "snippet": "ttachmentItem::ContentTransferEncoding ImapPartAttachmentItem::suggestedCTE() const\n{\n    if (index.data(RolePartMimeType).toString() == QLatin1String(\"message/rfc822\")) {\n        return CTEForContainers(index);\n    } else {\n        // FIXME: it would be cool to improve this so that we could e.g. use a quoted-printable for text files, etc\n        return CTE_BASE64;\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEForContainers(",
          "args": [
            "ndex)"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "TEForContainers(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "61-78",
          "snippet": "ttachmentItem::ContentTransferEncoding CTEForContainers(const QModelIndex &index)\n{\n    QByteArray cte = index.data(RolePartEncoding).toByteArray();\n    if (cte == \"7bit\") {\n        return AttachmentItem::CTE_7BIT;\n    } else if (cte == \"8bit\") {\n        return AttachmentItem::CTE_8BIT;\n    } else if (cte == \"binary\") {\n        return AttachmentItem::CTE_BINARY;\n    } else {\n        // Well, we're pretty screwed here :(, the original message is either gone now (which is the better outcome),\n        // or it does not specify a valid an allowed content encoding.\n        // The composite types, and message/rfc822 is one of them, are not allowed to be encoded in anything but\n        // 7bit, 8bit and binary (http://tools.ietf.org/html/rfc2045#page-17).\n        // Let's assume \"7bit\", which is the default in RFC 2045.\n        return AttachmentItem::CTE_7BIT;\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem::ContentTransferEncoding CTEForContainers(const QModelIndex &index)\n{\n    QByteArray cte = index.data(RolePartEncoding).toByteArray();\n    if (cte == \"7bit\") {\n        return AttachmentItem::CTE_7BIT;\n    } else if (cte == \"8bit\") {\n        return AttachmentItem::CTE_8BIT;\n    } else if (cte == \"binary\") {\n        return AttachmentItem::CTE_BINARY;\n    } else {\n        // Well, we're pretty screwed here :(, the original message is either gone now (which is the better outcome),\n        // or it does not specify a valid an allowed content encoding.\n        // The composite types, and message/rfc822 is one of them, are not allowed to be encoded in anything but\n        // 7bit, 8bit and binary (http://tools.ietf.org/html/rfc2045#page-17).\n        // Let's assume \"7bit\", which is the default in RFC 2045.\n        return AttachmentItem::CTE_7BIT;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "message/rfc822\")"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartMimeType)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ttachmentItem::ContentTransferEncoding ImapPartAttachmentItem::suggestedCTE() const\n  {\n      if (index.data(RolePartMimeType).toString() == QLatin1String(\"message/rfc822\")) {\n          return CTEForContainers(index);\n      } else {\n          // FIXME: it would be cool to improve this so that we could e.g. use a quoted-printable for text files, etc\n          return CTE_BASE64;\n      }\n  }\n}"
  },
  {
    "function_name": "setPreferredFileName(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "391-395",
    "snippet": "ool ImapPartAttachmentItem::setPreferredFileName(const QString &name)\n{\n    preferredName = name;\n    return true;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ool ImapPartAttachmentItem::setPreferredFileName(const QString &name)\n  {\n      preferredName = name;\n      return true;\n  }\n}"
  },
  {
    "function_name": "contentDispositionFilename(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "383-389",
    "snippet": "String ImapPartAttachmentItem::contentDispositionFilename() const\n{\n    if (!preferredName.isEmpty())\n        return preferredName;\n    QString res = index.data(RolePartFileName).toString();\n    return res.isEmpty() ? QLatin1String(\"attachment\") : res;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "attachment\")"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es.isEmpty",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartFileName)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  String ImapPartAttachmentItem::contentDispositionFilename() const\n  {\n      if (!preferredName.isEmpty())\n          return preferredName;\n      QString res = index.data(RolePartFileName).toString();\n      return res.isEmpty() ? QLatin1String(\"attachment\") : res;\n  }\n}"
  },
  {
    "function_name": "mimeType(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "378-381",
    "snippet": "ByteArray ImapPartAttachmentItem::mimeType() const\n{\n    return index.data(RolePartMimeType).toString().toUtf8();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartMimeType)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ByteArray ImapPartAttachmentItem::mimeType() const\n  {\n      return index.data(RolePartMimeType).toString().toUtf8();\n  }\n}"
  },
  {
    "function_name": "tooltip(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "370-376",
    "snippet": "String ImapPartAttachmentItem::tooltip() const\n{\n    if (!index.isValid())\n        return QString();\n    return MessageComposer::tr(\"%1, %2\").arg(index.data(RolePartMimeType).toString(),\n                                             PrettySize::prettySize(index.data(RolePartOctets).toUInt()));\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essageComposer::tr",
          "args": [
            "ndex.data(RolePartMimeType).toString(),",
            "rettySize::prettySize(index.data(RolePartOctets).toUInt()))"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rettySize::prettySize(",
          "args": [
            "ndex.data(RolePartOctets).toUInt())"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "prettySize(",
          "container": "mapAccess",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ImapAccess.cpp",
          "lines": "382-385",
          "snippet": "String ImapAccess::prettySize(const uint bytes) const\n{\n    return Imap::Mailbox::PrettySize::prettySize(bytes, Imap::Mailbox::PrettySize::WITH_BYTES_SUFFIX);\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Network/MsgPartNetAccessManager.h\"\n#",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/SystemNetworkWatcher.h\"\n#",
            "include \"Imap/Model/MemoryCache.h\"\n#",
            "include \"Imap/Model/DummyNetworkWatcher.h\"\n#",
            "include \"Imap/Model/CombinedCache.h\"\n#",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/PortNumbers.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include <QSettings>\n#",
            "include <QSslKey>\n#",
            "include <QFileInfo>\n#",
            "include <QDir>\n#",
            "include \"ImapAccess.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Network/MsgPartNetAccessManager.h\"\n#\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/SystemNetworkWatcher.h\"\n#\ninclude \"Imap/Model/MemoryCache.h\"\n#\ninclude \"Imap/Model/DummyNetworkWatcher.h\"\n#\ninclude \"Imap/Model/CombinedCache.h\"\n#\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/PortNumbers.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude <QSettings>\n#\ninclude <QSslKey>\n#\ninclude <QFileInfo>\n#\ninclude <QDir>\n#\ninclude \"ImapAccess.h\"\n#\n\nmapAccess {\n  String ImapAccess::prettySize(const uint bytes) const\n  {\n      return Imap::Mailbox::PrettySize::prettySize(bytes, Imap::Mailbox::PrettySize::WITH_BYTES_SUFFIX);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartOctets)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartMimeType)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "%1, %2\")"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  String ImapPartAttachmentItem::tooltip() const\n  {\n      if (!index.isValid())\n          return QString();\n      return MessageComposer::tr(\"%1, %2\").arg(index.data(RolePartMimeType).toString(),\n                                               PrettySize::prettySize(index.data(RolePartOctets).toUInt()));\n  }\n}"
  },
  {
    "function_name": "caption(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "358-368",
    "snippet": "String ImapPartAttachmentItem::caption() const\n{\n    QString partName = index.data(RolePartFileName).toString();\n    if (!index.isValid() || (preferredName.isEmpty() && partName.isEmpty())) {\n        return MessageComposer::tr(\"IMAP part %1\").arg(QString::fromUtf8(imapUrl()));\n    } else if (!preferredName.isEmpty()) {\n        return preferredName;\n    } else {\n        return partName;\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr",
          "args": [
            "String::fromUtf8(imapUrl()))"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "mapUrl())"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapUrl(",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "imapUrl(",
          "container": "mapPartAttachmentItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "423-431",
          "snippet": "ByteArray ImapPartAttachmentItem::imapUrl() const\n{\n    Q_ASSERT(index.isValid());\n    return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\").arg(\n                QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                index.data(RoleMailboxUidValidity).toString(),\n                index.data(RoleMessageUid).toString(),\n                index.data(RolePartId).toString()).toUtf8();\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ByteArray ImapPartAttachmentItem::imapUrl() const\n  {\n      Q_ASSERT(index.isValid());\n      return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\").arg(\n                  QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                  index.data(RoleMailboxUidValidity).toString(),\n                  index.data(RoleMessageUid).toString(),\n                  index.data(RolePartId).toString()).toUtf8();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "IMAP part %1\")"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "artName.isEmpty",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartFileName)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  String ImapPartAttachmentItem::caption() const\n  {\n      QString partName = index.data(RolePartFileName).toString();\n      if (!index.isValid() || (preferredName.isEmpty() && partName.isEmpty())) {\n          return MessageComposer::tr(\"IMAP part %1\").arg(QString::fromUtf8(imapUrl()));\n      } else if (!preferredName.isEmpty()) {\n          return preferredName;\n      } else {\n          return partName;\n      }\n  }\n}"
  },
  {
    "function_name": "~ImapPartAttachmentItem(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "354-356",
    "snippet": "mapPartAttachmentItem::~ImapPartAttachmentItem()\n{\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  mapPartAttachmentItem::~ImapPartAttachmentItem()\n  {\n  }\n}"
  },
  {
    "function_name": "ImapPartAttachmentItem(",
    "container": "mapPartAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "327-352",
    "snippet": "mapPartAttachmentItem::ImapPartAttachmentItem(Model *model, const QString &mailbox, const uint uidValidity, const uint uid,\n                                               const QString &trojitaPath)\n{\n    TreeItemMailbox *mboxPtr = model->findMailboxByName(mailbox);\n    if (!mboxPtr)\n        throw Imap::UnknownMessageIndex(\"No such mailbox\");\n\n    if (mboxPtr->syncState.uidValidity() != uidValidity)\n        throw Imap::UnknownMessageIndex(\"UIDVALIDITY mismatch\");\n\n    QList<TreeItemMessage*> messages = model->findMessagesByUids(mboxPtr, QList<uint>() << uid);\n    if (messages.isEmpty())\n        throw Imap::UnknownMessageIndex(\"UID not found\");\n\n    Q_ASSERT(messages.size() == 1);\n\n    TreeItemPart *part = Imap::Network::MsgPartNetAccessManager::pathToPart(messages.front()->toIndex(model), trojitaPath);\n    if (!part)\n        throw Imap::UnknownMessageIndex(\"No such part\");\n\n    if (part->mimeType().startsWith(QLatin1String(\"multipart/\"))) {\n        // Yes, we absolutely do abuse this exception now. Any better ideas?\n        throw Imap::UnknownMessageIndex(\"Cannot attach multipart/* MIME containers\");\n    }\n    index = part->toIndex(model);\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "art->toIndex",
          "args": [
            "odel)"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "toIndex(",
          "container": "reeItemModifiedPart",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1652-1657",
          "snippet": "ModelIndex TreeItemModifiedPart::toIndex(Model *const model) const\n{\n    Q_ASSERT(model);\n    // see TreeItem::toIndex() for the const_cast explanation\n    return model->createIndex(row(), static_cast<int>(kind()), const_cast<TreeItemModifiedPart *>(this));\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemModifiedPart {\n  ModelIndex TreeItemModifiedPart::toIndex(Model *const model) const\n  {\n      Q_ASSERT(model);\n      // see TreeItem::toIndex() for the const_cast explanation\n      return model->createIndex(row(), static_cast<int>(kind()), const_cast<TreeItemModifiedPart *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "Cannot attach multipart/* MIME containers\")"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art->mimeType",
          "args": [
            "Latin1String(\"multipart/\"))"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "multipart/\")"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art->mimeType",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "No such part\")"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::Network::MsgPartNetAccessManager::pathToPart(",
          "args": [
            "essages.front()->toIndex(model),",
            "rojitaPath)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.front",
          "args": [
            "odel)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.front",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essages.size() == 1)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.size",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "UID not found\")"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.isEmpty",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->findMessagesByUids",
          "args": [
            "boxPtr,",
            "List<uint>() << uid)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<uint>",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "newTagRequested",
          "container": "TagListWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/TagListWidget.cpp",
          "lines": "74-87",
          "snippet": "void TagListWidget::newTagRequested()\n{\n    QString tag = QInputDialog::getText(this, tr(\"New Label\"), tr(\"Label name:\"));\n    if (tag.isEmpty()) {\n        return;\n    }\n    if (m_ignoredFlags.contains(tag.toLower())) {\n        QMessageBox::warning(this, tr(\"Invalid tag value\"),\n                             tr(\"Tag name %1 is a reserved name which cannot be manipulated this way.\").arg(tag));\n        return;\n    }\n\n    emit tagAdded(tag);\n}",
          "includes": [
            "#include \"TagWidget.h\"",
            "#include \"FlowLayout.h\"",
            "#include \"TagListWidget.h\"",
            "#include <QPushButton>",
            "#include <QMessageBox>",
            "#include <QLabel>",
            "#include <QInputDialog>",
            "#include <QHBoxLayout>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"TagWidget.h\"\n#include \"FlowLayout.h\"\n#include \"TagListWidget.h\"\n#include <QPushButton>\n#include <QMessageBox>\n#include <QLabel>\n#include <QInputDialog>\n#include <QHBoxLayout>\n\nTagListWidget {\n  void TagListWidget::newTagRequested()\n  {\n      QString tag = QInputDialog::getText(this, tr(\"New Label\"), tr(\"Label name:\"));\n      if (tag.isEmpty()) {\n          return;\n      }\n      if (m_ignoredFlags.contains(tag.toLower())) {\n          QMessageBox::warning(this, tr(\"Invalid tag value\"),\n                               tr(\"Tag name %1 is a reserved name which cannot be manipulated this way.\").arg(tag));\n          return;\n      }\n  \n      emit tagAdded(tag);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "UIDVALIDITY mismatch\")"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boxPtr->syncState.uidValidity",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "No such mailbox\")"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->findMailboxByName",
          "args": [
            "ailbox)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  mapPartAttachmentItem::ImapPartAttachmentItem(Model *model, const QString &mailbox, const uint uidValidity, const uint uid,\n                                                 const QString &trojitaPath)\n  {\n      TreeItemMailbox *mboxPtr = model->findMailboxByName(mailbox);\n      if (!mboxPtr)\n          throw Imap::UnknownMessageIndex(\"No such mailbox\");\n  \n      if (mboxPtr->syncState.uidValidity() != uidValidity)\n          throw Imap::UnknownMessageIndex(\"UIDVALIDITY mismatch\");\n  \n      QList<TreeItemMessage*> messages = model->findMessagesByUids(mboxPtr, QList<uint>() << uid);\n      if (messages.isEmpty())\n          throw Imap::UnknownMessageIndex(\"UID not found\");\n  \n      Q_ASSERT(messages.size() == 1);\n  \n      TreeItemPart *part = Imap::Network::MsgPartNetAccessManager::pathToPart(messages.front()->toIndex(model), trojitaPath);\n      if (!part)\n          throw Imap::UnknownMessageIndex(\"No such part\");\n  \n      if (part->mimeType().startsWith(QLatin1String(\"multipart/\"))) {\n          // Yes, we absolutely do abuse this exception now. Any better ideas?\n          throw Imap::UnknownMessageIndex(\"Cannot attach multipart/* MIME containers\");\n      }\n      index = part->toIndex(model);\n  }\n}"
  },
  {
    "function_name": "asDroppableMimeData(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "320-324",
    "snippet": "oid ImapMessageAttachmentItem::asDroppableMimeData(QDataStream &stream) const\n{\n    stream << ATTACHMENT_IMAP_MESSAGE << index.data(RoleMailboxName).toString() <<\n              index.data(RoleMailboxUidValidity).toUInt() << (QList<uint>() <<index.data(RoleMessageUid).toUInt());\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageUid)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<uint>",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "newTagRequested",
          "container": "TagListWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/TagListWidget.cpp",
          "lines": "74-87",
          "snippet": "void TagListWidget::newTagRequested()\n{\n    QString tag = QInputDialog::getText(this, tr(\"New Label\"), tr(\"Label name:\"));\n    if (tag.isEmpty()) {\n        return;\n    }\n    if (m_ignoredFlags.contains(tag.toLower())) {\n        QMessageBox::warning(this, tr(\"Invalid tag value\"),\n                             tr(\"Tag name %1 is a reserved name which cannot be manipulated this way.\").arg(tag));\n        return;\n    }\n\n    emit tagAdded(tag);\n}",
          "includes": [
            "#include \"TagWidget.h\"",
            "#include \"FlowLayout.h\"",
            "#include \"TagListWidget.h\"",
            "#include <QPushButton>",
            "#include <QMessageBox>",
            "#include <QLabel>",
            "#include <QInputDialog>",
            "#include <QHBoxLayout>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"TagWidget.h\"\n#include \"FlowLayout.h\"\n#include \"TagListWidget.h\"\n#include <QPushButton>\n#include <QMessageBox>\n#include <QLabel>\n#include <QInputDialog>\n#include <QHBoxLayout>\n\nTagListWidget {\n  void TagListWidget::newTagRequested()\n  {\n      QString tag = QInputDialog::getText(this, tr(\"New Label\"), tr(\"Label name:\"));\n      if (tag.isEmpty()) {\n          return;\n      }\n      if (m_ignoredFlags.contains(tag.toLower())) {\n          QMessageBox::warning(this, tr(\"Invalid tag value\"),\n                               tr(\"Tag name %1 is a reserved name which cannot be manipulated this way.\").arg(tag));\n          return;\n      }\n  \n      emit tagAdded(tag);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxUidValidity)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  oid ImapMessageAttachmentItem::asDroppableMimeData(QDataStream &stream) const\n  {\n      stream << ATTACHMENT_IMAP_MESSAGE << index.data(RoleMailboxName).toString() <<\n                index.data(RoleMailboxUidValidity).toUInt() << (QList<uint>() <<index.data(RoleMessageUid).toUInt());\n  }\n}"
  },
  {
    "function_name": "preload(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "315-318",
    "snippet": "oid ImapMessageAttachmentItem::preload() const\n{\n    fullMessageCombiner->load();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ullMessageCombiner->load",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "load(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "67-74",
          "snippet": "oid FullMessageCombiner::load()\n{\n    Imap::Mailbox::TreeItemPart *headerPart = headerPartPtr();\n    headerPart->fetch(const_cast<Mailbox::Model *>(m_model));\n    Imap::Mailbox::TreeItemPart *bodyPart = bodyPartPtr();\n    bodyPart->fetch(const_cast<Mailbox::Model *>(m_model));\n    slotDataChanged(QModelIndex(), QModelIndex());\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"FullMessageCombiner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  oid FullMessageCombiner::load()\n  {\n      Imap::Mailbox::TreeItemPart *headerPart = headerPartPtr();\n      headerPart->fetch(const_cast<Mailbox::Model *>(m_model));\n      Imap::Mailbox::TreeItemPart *bodyPart = bodyPartPtr();\n      bodyPart->fetch(const_cast<Mailbox::Model *>(m_model));\n      slotDataChanged(QModelIndex(), QModelIndex());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  oid ImapMessageAttachmentItem::preload() const\n  {\n      fullMessageCombiner->load();\n  }\n}"
  },
  {
    "function_name": "imapUrl(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "307-313",
    "snippet": "ByteArray ImapMessageAttachmentItem::imapUrl() const\n{\n    return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3\").arg(\n                QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                index.data(RoleMailboxUidValidity).toString(),\n                index.data(RoleMessageUid).toString()).toUtf8();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "Url::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),",
            "ndex.data(RoleMailboxUidValidity).toString(),",
            "ndex.data(RoleMessageUid).toString())"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageUid)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxUidValidity)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Url::toPercentEncoding(",
          "args": [
            "ndex.data(RoleMailboxName).toString().toUtf8())"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "/%1;UIDVALIDITY=%2/;UID=%3\")"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  ByteArray ImapMessageAttachmentItem::imapUrl() const\n  {\n      return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3\").arg(\n                  QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                  index.data(RoleMailboxUidValidity).toString(),\n                  index.data(RoleMessageUid).toString()).toUtf8();\n  }\n}"
  },
  {
    "function_name": "suggestedCTE(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "288-305",
    "snippet": "ttachmentItem::ContentTransferEncoding ImapMessageAttachmentItem::suggestedCTE() const\n{\n    // The relevant thing is the CTE of the root MIME part, not the message itself.\n    // It's not even supported by Trojita for TreeItemMessage.\n\n    QModelIndex rootPart = index.child(0, 0);\n    if (rootPart.data(RolePartIsTopLevelMultipart).toBool()) {\n        // This was a desperate attempt; the BODYSTRUCTURE does *not* contain the body-fld-enc field for multiparts,\n        // so if our message happens to have a top-level multipart, we're out of luck and will produce an invalid result.\n        // See http://mailman2.u.washington.edu/pipermail/imap-protocol/2013-October/002109.html for details.\n        // Let's try to \"play it safe\" and assume that the children *might* contain 8bit data. We are still hoping for\n        // the best (i.e. if the message was actually using the \"binary\" CTE, we would be screwed), but I guess this is\n        // better than potentially lying by claiming that this is just a 7bit message. Suggestions welcome.\n        return CTE_8BIT;\n    } else {\n        return CTEForContainers(rootPart);\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEForContainers(",
          "args": [
            "ootPart)"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "TEForContainers(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "61-78",
          "snippet": "ttachmentItem::ContentTransferEncoding CTEForContainers(const QModelIndex &index)\n{\n    QByteArray cte = index.data(RolePartEncoding).toByteArray();\n    if (cte == \"7bit\") {\n        return AttachmentItem::CTE_7BIT;\n    } else if (cte == \"8bit\") {\n        return AttachmentItem::CTE_8BIT;\n    } else if (cte == \"binary\") {\n        return AttachmentItem::CTE_BINARY;\n    } else {\n        // Well, we're pretty screwed here :(, the original message is either gone now (which is the better outcome),\n        // or it does not specify a valid an allowed content encoding.\n        // The composite types, and message/rfc822 is one of them, are not allowed to be encoded in anything but\n        // 7bit, 8bit and binary (http://tools.ietf.org/html/rfc2045#page-17).\n        // Let's assume \"7bit\", which is the default in RFC 2045.\n        return AttachmentItem::CTE_7BIT;\n    }\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem::ContentTransferEncoding CTEForContainers(const QModelIndex &index)\n{\n    QByteArray cte = index.data(RolePartEncoding).toByteArray();\n    if (cte == \"7bit\") {\n        return AttachmentItem::CTE_7BIT;\n    } else if (cte == \"8bit\") {\n        return AttachmentItem::CTE_8BIT;\n    } else if (cte == \"binary\") {\n        return AttachmentItem::CTE_BINARY;\n    } else {\n        // Well, we're pretty screwed here :(, the original message is either gone now (which is the better outcome),\n        // or it does not specify a valid an allowed content encoding.\n        // The composite types, and message/rfc822 is one of them, are not allowed to be encoded in anything but\n        // 7bit, 8bit and binary (http://tools.ietf.org/html/rfc2045#page-17).\n        // Let's assume \"7bit\", which is the default in RFC 2045.\n        return AttachmentItem::CTE_7BIT;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ootPart.data",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ootPart.data",
          "args": [
            "olePartIsTopLevelMultipart)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.child",
          "args": [
            ",",
            ")"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  ttachmentItem::ContentTransferEncoding ImapMessageAttachmentItem::suggestedCTE() const\n  {\n      // The relevant thing is the CTE of the root MIME part, not the message itself.\n      // It's not even supported by Trojita for TreeItemMessage.\n  \n      QModelIndex rootPart = index.child(0, 0);\n      if (rootPart.data(RolePartIsTopLevelMultipart).toBool()) {\n          // This was a desperate attempt; the BODYSTRUCTURE does *not* contain the body-fld-enc field for multiparts,\n          // so if our message happens to have a top-level multipart, we're out of luck and will produce an invalid result.\n          // See http://mailman2.u.washington.edu/pipermail/imap-protocol/2013-October/002109.html for details.\n          // Let's try to \"play it safe\" and assume that the children *might* contain 8bit data. We are still hoping for\n          // the best (i.e. if the message was actually using the \"binary\" CTE, we would be screwed), but I guess this is\n          // better than potentially lying by claiming that this is just a 7bit message. Suggestions welcome.\n          return CTE_8BIT;\n      } else {\n          return CTEForContainers(rootPart);\n      }\n  }\n}"
  },
  {
    "function_name": "rawData(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "276-286",
    "snippet": "SharedPointer<QIODevice> ImapMessageAttachmentItem::rawData() const\n{\n    if (!index.isValid())\n        return QSharedPointer<QIODevice>();\n\n    QSharedPointer<QIODevice> io(new QBuffer());\n    // This can probably be optimized to allow zero-copy operation through a pair of two QIODevices\n    static_cast<QBuffer*>(io.data())->setData(fullMessageCombiner->data());\n    io->open(QIODevice::ReadOnly);\n    return io;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o->open",
          "args": [
            "IODevice::ReadOnly)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<QBuffer*>",
          "args": [
            "ullMessageCombiner->data())"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ullMessageCombiner->data",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "data(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "54-60",
          "snippet": "ByteArray FullMessageCombiner::data() const\n{\n    if (loaded())\n        return *(headerPartPtr()->dataPtr()) + *(bodyPartPtr()->dataPtr());\n\n    return QByteArray();\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"FullMessageCombiner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  ByteArray FullMessageCombiner::data() const\n  {\n      if (loaded())\n          return *(headerPartPtr()->dataPtr()) + *(bodyPartPtr()->dataPtr());\n  \n      return QByteArray();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<QBuffer*>",
          "args": [
            "o.data())"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o.data",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SharedPointer<QIODevice>",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  SharedPointer<QIODevice> ImapMessageAttachmentItem::rawData() const\n  {\n      if (!index.isValid())\n          return QSharedPointer<QIODevice>();\n  \n      QSharedPointer<QIODevice> io(new QBuffer());\n      // This can probably be optimized to allow zero-copy operation through a pair of two QIODevices\n      static_cast<QBuffer*>(io.data())->setData(fullMessageCombiner->data());\n      io->open(QIODevice::ReadOnly);\n      return io;\n  }\n}"
  },
  {
    "function_name": "isAvailableLocally(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "271-274",
    "snippet": "ool ImapMessageAttachmentItem::isAvailableLocally() const\n{\n    return fullMessageCombiner->loaded();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ullMessageCombiner->loaded",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "loaded(",
          "container": "ullMessageCombiner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/FullMessageCombiner.cpp",
          "lines": "62-65",
          "snippet": "ool FullMessageCombiner::loaded() const\n{\n    return headerPartPtr()->fetched() && bodyPartPtr()->fetched();\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"FullMessageCombiner.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"FullMessageCombiner.h\"\n#\n\nullMessageCombiner {\n  ool FullMessageCombiner::loaded() const\n  {\n      return headerPartPtr()->fetched() && bodyPartPtr()->fetched();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  ool ImapMessageAttachmentItem::isAvailableLocally() const\n  {\n      return fullMessageCombiner->loaded();\n  }\n}"
  },
  {
    "function_name": "mimeType(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "266-269",
    "snippet": "ByteArray ImapMessageAttachmentItem::mimeType() const\n{\n    return \"message/rfc822\";\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  ByteArray ImapMessageAttachmentItem::mimeType() const\n  {\n      return \"message/rfc822\";\n  }\n}"
  },
  {
    "function_name": "setPreferredFileName(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "260-264",
    "snippet": "ool ImapMessageAttachmentItem::setPreferredFileName(const QString &name)\n{\n    preferredName = name;\n    return true;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  ool ImapMessageAttachmentItem::setPreferredFileName(const QString &name)\n  {\n      preferredName = name;\n      return true;\n  }\n}"
  },
  {
    "function_name": "contentDispositionFilename(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "251-258",
    "snippet": "String ImapMessageAttachmentItem::contentDispositionFilename() const\n{\n    if (!preferredName.isEmpty())\n        return preferredName;\n    if (!index.isValid())\n        return QLatin1String(\"attachment.eml\");\n    return index.data(RoleMessageSubject).toString() + QLatin1String(\".eml\");\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ".eml\")"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageSubject)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "attachment.eml\")"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  String ImapMessageAttachmentItem::contentDispositionFilename() const\n  {\n      if (!preferredName.isEmpty())\n          return preferredName;\n      if (!index.isValid())\n          return QLatin1String(\"attachment.eml\");\n      return index.data(RoleMessageSubject).toString() + QLatin1String(\".eml\");\n  }\n}"
  },
  {
    "function_name": "tooltip(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "244-249",
    "snippet": "String ImapMessageAttachmentItem::tooltip() const\n{\n    if (!index.isValid())\n        return QString();\n    return MessageComposer::tr(\"IMAP message %1\").arg(QString::fromUtf8(imapUrl()));\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essageComposer::tr",
          "args": [
            "String::fromUtf8(imapUrl()))"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "mapUrl())"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapUrl(",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "imapUrl(",
          "container": "mapPartAttachmentItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "423-431",
          "snippet": "ByteArray ImapPartAttachmentItem::imapUrl() const\n{\n    Q_ASSERT(index.isValid());\n    return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\").arg(\n                QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                index.data(RoleMailboxUidValidity).toString(),\n                index.data(RoleMessageUid).toString(),\n                index.data(RolePartId).toString()).toUtf8();\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ByteArray ImapPartAttachmentItem::imapUrl() const\n  {\n      Q_ASSERT(index.isValid());\n      return QString::fromUtf8(\"/%1;UIDVALIDITY=%2/;UID=%3/;SECTION=%4\").arg(\n                  QUrl::toPercentEncoding(index.data(RoleMailboxName).toString().toUtf8()),\n                  index.data(RoleMailboxUidValidity).toString(),\n                  index.data(RoleMessageUid).toString(),\n                  index.data(RolePartId).toString()).toUtf8();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "IMAP message %1\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String(",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "asPrettyString(",
          "container": "ailAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/MailAddress.cpp",
          "lines": "261-266",
          "snippet": "String MailAddress::asPrettyString() const\n{\n    return name.isEmpty() ?\n                asSMTPMailbox() :\n                name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n}",
          "includes": [
            "include \"../Parser/Rfc5322HeaderParser.h\"",
            "include \"../Encoders.h\"\n#",
            "include \"../Model/MailboxTree.h\"\n#",
            "include \"MailAddress.h\"\n#",
            "include <QTextCodec>\n#",
            "include <QUrlQuery>\n#",
            "include <QUrl>\n#",
            "include <QTextDocument>\n#",
            "include <typeinfo>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Parser/Rfc5322HeaderParser.h\"\ninclude \"../Encoders.h\"\n#\ninclude \"../Model/MailboxTree.h\"\n#\ninclude \"MailAddress.h\"\n#\ninclude <QTextCodec>\n#\ninclude <QUrlQuery>\n#\ninclude <QUrl>\n#\ninclude <QTextDocument>\n#\ninclude <typeinfo>\n\nailAddress {\n  String MailAddress::asPrettyString() const\n  {\n      return name.isEmpty() ?\n                  asSMTPMailbox() :\n                  name + QLatin1Char(' ') + QLatin1Char('<') + asSMTPMailbox() + QLatin1Char('>');\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  String ImapMessageAttachmentItem::tooltip() const\n  {\n      if (!index.isValid())\n          return QString();\n      return MessageComposer::tr(\"IMAP message %1\").arg(QString::fromUtf8(imapUrl()));\n  }\n}"
  },
  {
    "function_name": "caption(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "232-242",
    "snippet": "String ImapMessageAttachmentItem::caption() const\n{\n    if (!index.isValid())\n        return MessageComposer::tr(\"Message not available\");\n    QString subject = index.data(RoleMessageSubject).toString();\n    if (!preferredName.isEmpty() && subject + QLatin1String(\".eml\") != preferredName) {\n        return MessageComposer::tr(\"%1\\n(%2)\").arg(preferredName, subject);\n    } else {\n        return subject;\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essageComposer::tr",
          "args": [
            "referredName,",
            "ubject)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "%1\\n(%2)\")"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ".eml\")"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "oleMessageSubject)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "Message not available\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndex.isValid",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  String ImapMessageAttachmentItem::caption() const\n  {\n      if (!index.isValid())\n          return MessageComposer::tr(\"Message not available\");\n      QString subject = index.data(RoleMessageSubject).toString();\n      if (!preferredName.isEmpty() && subject + QLatin1String(\".eml\") != preferredName) {\n          return MessageComposer::tr(\"%1\\n(%2)\").arg(preferredName, subject);\n      } else {\n          return subject;\n      }\n  }\n}"
  },
  {
    "function_name": "~ImapMessageAttachmentItem(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "227-230",
    "snippet": "mapMessageAttachmentItem::~ImapMessageAttachmentItem()\n{\n    delete fullMessageCombiner;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  mapMessageAttachmentItem::~ImapMessageAttachmentItem()\n  {\n      delete fullMessageCombiner;\n  }\n}"
  },
  {
    "function_name": "ImapMessageAttachmentItem(",
    "container": "mapMessageAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "207-225",
    "snippet": "mapMessageAttachmentItem::ImapMessageAttachmentItem(Model *model, const QString &mailbox, const uint uidValidity, const uint uid):\n    fullMessageCombiner(0)\n{\n    Q_ASSERT(model);\n    TreeItemMailbox *mboxPtr = model->findMailboxByName(mailbox);\n    if (!mboxPtr)\n        throw Imap::UnknownMessageIndex(\"No such mailbox\");\n\n    if (mboxPtr->syncState.uidValidity() != uidValidity)\n        throw Imap::UnknownMessageIndex(\"UIDVALIDITY mismatch\");\n\n    QList<TreeItemMessage*> messages = model->findMessagesByUids(mboxPtr, QList<uint>() << uid);\n    if (messages.isEmpty())\n        throw Imap::UnknownMessageIndex(\"No such UID\");\n\n    Q_ASSERT(messages.size() == 1);\n    index = messages.front()->toIndex(model);\n    fullMessageCombiner = new FullMessageCombiner(index);\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essages.front",
          "args": [
            "odel)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.front",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "essages.size() == 1)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.size",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "No such UID\")"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essages.isEmpty",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->findMessagesByUids",
          "args": [
            "boxPtr,",
            "List<uint>() << uid)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<uint>",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "newTagRequested",
          "container": "TagListWidget",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/TagListWidget.cpp",
          "lines": "74-87",
          "snippet": "void TagListWidget::newTagRequested()\n{\n    QString tag = QInputDialog::getText(this, tr(\"New Label\"), tr(\"Label name:\"));\n    if (tag.isEmpty()) {\n        return;\n    }\n    if (m_ignoredFlags.contains(tag.toLower())) {\n        QMessageBox::warning(this, tr(\"Invalid tag value\"),\n                             tr(\"Tag name %1 is a reserved name which cannot be manipulated this way.\").arg(tag));\n        return;\n    }\n\n    emit tagAdded(tag);\n}",
          "includes": [
            "#include \"TagWidget.h\"",
            "#include \"FlowLayout.h\"",
            "#include \"TagListWidget.h\"",
            "#include <QPushButton>",
            "#include <QMessageBox>",
            "#include <QLabel>",
            "#include <QInputDialog>",
            "#include <QHBoxLayout>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"TagWidget.h\"\n#include \"FlowLayout.h\"\n#include \"TagListWidget.h\"\n#include <QPushButton>\n#include <QMessageBox>\n#include <QLabel>\n#include <QInputDialog>\n#include <QHBoxLayout>\n\nTagListWidget {\n  void TagListWidget::newTagRequested()\n  {\n      QString tag = QInputDialog::getText(this, tr(\"New Label\"), tr(\"Label name:\"));\n      if (tag.isEmpty()) {\n          return;\n      }\n      if (m_ignoredFlags.contains(tag.toLower())) {\n          QMessageBox::warning(this, tr(\"Invalid tag value\"),\n                               tr(\"Tag name %1 is a reserved name which cannot be manipulated this way.\").arg(tag));\n          return;\n      }\n  \n      emit tagAdded(tag);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "UIDVALIDITY mismatch\")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boxPtr->syncState.uidValidity",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map::UnknownMessageIndex(",
          "args": [
            "No such mailbox\")"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->findMailboxByName",
          "args": [
            "ailbox)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapMessageAttachmentItem {\n  mapMessageAttachmentItem::ImapMessageAttachmentItem(Model *model, const QString &mailbox, const uint uidValidity, const uint uid):\n      fullMessageCombiner(0)\n  {\n      Q_ASSERT(model);\n      TreeItemMailbox *mboxPtr = model->findMailboxByName(mailbox);\n      if (!mboxPtr)\n          throw Imap::UnknownMessageIndex(\"No such mailbox\");\n  \n      if (mboxPtr->syncState.uidValidity() != uidValidity)\n          throw Imap::UnknownMessageIndex(\"UIDVALIDITY mismatch\");\n  \n      QList<TreeItemMessage*> messages = model->findMessagesByUids(mboxPtr, QList<uint>() << uid);\n      if (messages.isEmpty())\n          throw Imap::UnknownMessageIndex(\"No such UID\");\n  \n      Q_ASSERT(messages.size() == 1);\n      index = messages.front()->toIndex(model);\n      fullMessageCombiner = new FullMessageCombiner(index);\n  }\n}"
  },
  {
    "function_name": "asDroppableMimeData(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "201-204",
    "snippet": "oid FileAttachmentItem::asDroppableMimeData(QDataStream &stream) const\n{\n    stream << ATTACHMENT_FILE << fileName;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  oid FileAttachmentItem::asDroppableMimeData(QDataStream &stream) const\n  {\n      stream << ATTACHMENT_FILE << fileName;\n  }\n}"
  },
  {
    "function_name": "preload(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "195-199",
    "snippet": "oid FileAttachmentItem::preload() const\n{\n    // Don't need to do anything\n    // We could possibly leave this file open to prevent eventual deletion, but it's probably not worth the effort.\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  oid FileAttachmentItem::preload() const\n  {\n      // Don't need to do anything\n      // We could possibly leave this file open to prevent eventual deletion, but it's probably not worth the effort.\n  }\n}"
  },
  {
    "function_name": "imapUrl(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "189-193",
    "snippet": "ByteArray FileAttachmentItem::imapUrl() const\n{\n    // It's a local item, it cannot really be on an IMAP server\n    return QByteArray();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteArray(",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "toByteArray(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "43-79",
          "snippet": "ByteArray Sequence::toByteArray() const\n{\n    switch (kind) {\n    case DISTINCT:\n    {\n        Q_ASSERT(! list.isEmpty());\n\n        QStringList res;\n        int i = 0;\n        while (i < list.size()) {\n            int old = i;\n            while (i < list.size() - 1 &&\n                   list[i] == list[ i + 1 ] - 1)\n                ++i;\n            if (old != i) {\n                // we've found a sequence\n                res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n            } else {\n                res << QString::number(list[i]);\n            }\n            ++i;\n        }\n        return res.join(QLatin1String(\",\")).toLocal8Bit();\n    }\n    case RANGE:\n        Q_ASSERT(lo <= hi);\n        if (lo == hi)\n            return QByteArray::number(lo);\n        else\n            return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n    case UNLIMITED:\n        return QByteArray::number(lo) + \":*\";\n    }\n    // fix gcc warning\n    Q_ASSERT(false);\n    return QByteArray();\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  ByteArray Sequence::toByteArray() const\n  {\n      switch (kind) {\n      case DISTINCT:\n      {\n          Q_ASSERT(! list.isEmpty());\n  \n          QStringList res;\n          int i = 0;\n          while (i < list.size()) {\n              int old = i;\n              while (i < list.size() - 1 &&\n                     list[i] == list[ i + 1 ] - 1)\n                  ++i;\n              if (old != i) {\n                  // we've found a sequence\n                  res << QString::number(list[old]) + QLatin1Char(':') + QString::number(list[i]);\n              } else {\n                  res << QString::number(list[i]);\n              }\n              ++i;\n          }\n          return res.join(QLatin1String(\",\")).toLocal8Bit();\n      }\n      case RANGE:\n          Q_ASSERT(lo <= hi);\n          if (lo == hi)\n              return QByteArray::number(lo);\n          else\n              return QByteArray::number(lo) + ':' + QByteArray::number(hi);\n      case UNLIMITED:\n          return QByteArray::number(lo) + \":*\";\n      }\n      // fix gcc warning\n      Q_ASSERT(false);\n      return QByteArray();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ByteArray FileAttachmentItem::imapUrl() const\n  {\n      // It's a local item, it cannot really be on an IMAP server\n      return QByteArray();\n  }\n}"
  },
  {
    "function_name": "suggestedCTE(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "184-187",
    "snippet": "ttachmentItem::ContentTransferEncoding FileAttachmentItem::suggestedCTE() const\n{\n    return CTE_BASE64;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ttachmentItem::ContentTransferEncoding FileAttachmentItem::suggestedCTE() const\n  {\n      return CTE_BASE64;\n  }\n}"
  },
  {
    "function_name": "setPreferredFileName(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "178-182",
    "snippet": "ool FileAttachmentItem::setPreferredFileName(const QString &name)\n{\n    preferredName = name;\n    return true;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ool FileAttachmentItem::setPreferredFileName(const QString &name)\n  {\n      preferredName = name;\n      return true;\n  }\n}"
  },
  {
    "function_name": "contentDispositionFilename(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "168-176",
    "snippet": "String FileAttachmentItem::contentDispositionFilename() const\n{\n    if (!preferredName.isEmpty())\n        return preferredName;\n    QString shortFileName = QFileInfo(fileName).fileName();\n    if (shortFileName.isEmpty())\n        shortFileName = QLatin1String(\"attachment\");\n    return shortFileName;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "attachment\")"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hortFileName.isEmpty",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileInfo",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileInfo(",
          "args": [
            "ileName)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  String FileAttachmentItem::contentDispositionFilename() const\n  {\n      if (!preferredName.isEmpty())\n          return preferredName;\n      QString shortFileName = QFileInfo(fileName).fileName();\n      if (shortFileName.isEmpty())\n          shortFileName = QLatin1String(\"attachment\");\n      return shortFileName;\n  }\n}"
  },
  {
    "function_name": "mimeType(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "158-166",
    "snippet": "ByteArray FileAttachmentItem::mimeType() const\n{\n    if (!m_cachedMime.isEmpty())\n        return m_cachedMime;\n\n    QMimeDatabase mimeDb;\n    m_cachedMime = mimeDb.mimeTypeForFile(fileName).name().toUtf8();\n    return m_cachedMime;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "imeDb.mimeTypeForFile",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeDb.mimeTypeForFile",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeDb.mimeTypeForFile",
          "args": [
            "ileName)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cachedMime.isEmpty",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ByteArray FileAttachmentItem::mimeType() const\n  {\n      if (!m_cachedMime.isEmpty())\n          return m_cachedMime;\n  \n      QMimeDatabase mimeDb;\n      m_cachedMime = mimeDb.mimeTypeForFile(fileName).name().toUtf8();\n      return m_cachedMime;\n  }\n}"
  },
  {
    "function_name": "rawData(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "151-156",
    "snippet": "SharedPointer<QIODevice> FileAttachmentItem::rawData() const\n{\n    QSharedPointer<QIODevice> io(new QFile(fileName));\n    io->open(QIODevice::ReadOnly);\n    return io;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o->open",
          "args": [
            "IODevice::ReadOnly)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  SharedPointer<QIODevice> FileAttachmentItem::rawData() const\n  {\n      QSharedPointer<QIODevice> io(new QFile(fileName));\n      io->open(QIODevice::ReadOnly);\n      return io;\n  }\n}"
  },
  {
    "function_name": "isAvailableLocally(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "145-149",
    "snippet": "ool FileAttachmentItem::isAvailableLocally() const\n{\n    QFileInfo info(fileName);\n    return info.isFile() && info.isReadable();\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfo.isReadable",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfo.isFile",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ool FileAttachmentItem::isAvailableLocally() const\n  {\n      QFileInfo info(fileName);\n      return info.isFile() && info.isReadable();\n  }\n}"
  },
  {
    "function_name": "tooltip(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "131-143",
    "snippet": "String FileAttachmentItem::tooltip() const\n{\n    QFileInfo f(fileName);\n\n    if (!f.exists())\n        return MessageComposer::tr(\"File does not exist\");\n\n    if (!f.isReadable())\n        return MessageComposer::tr(\"File is not readable\");\n\n    return MessageComposer::tr(\"%1: %2, %3\")\n            .arg(fileName, QString::fromUtf8(mimeType()), PrettySize::prettySize(f.size(), PrettySize::WITH_BYTES_SUFFIX));\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essageComposer::tr",
          "args": [
            "ileName,",
            "String::fromUtf8(mimeType()),",
            "rettySize::prettySize(f.size(), PrettySize::WITH_BYTES_SUFFIX))"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rettySize::prettySize(",
          "args": [
            ".size(),",
            "rettySize::WITH_BYTES_SUFFIX)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "prettySize(",
          "container": "rettySize",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Utils.cpp",
          "lines": "50-76",
          "snippet": "String PrettySize::prettySize(uint bytes, const ShowBytesSuffix compactUnitFormat)\n{\n    if (bytes == 0) {\n        return tr(\"0\");\n    }\n    int order = std::log(static_cast<double>(bytes)) / std::log(1024.0);\n    double number = bytes / std::pow(1024.0, order);\n\n    QString suffix;\n    if (order <= 0) {\n        if (compactUnitFormat == COMPACT_FORM)\n            return QString::number(bytes);\n        else\n            return tr(\"%1 bytes\").arg(QString::number(bytes));\n    } else if (order == 1) {\n        suffix = tr(\"kB\");\n    } else if (order == 2) {\n        suffix = tr(\"MB\");\n    } else if (order == 3) {\n        suffix = tr(\"GB\");\n    } else {\n        // make sure not to show wrong size for those that have > 1024 TB e-mail messages\n        order = 4;\n        suffix = tr(\"TB\"); // shame on you for such mails\n    }\n    return tr(\"%1 %2\").arg(QString::number(number, 'f', number < 100 ? 1 : 0), suffix);\n}",
          "includes": [
            "include <QSystemDeviceInfo>\n#",
            "include \"Imap/Model/Model.h\"",
            "include \"Common/SettingsNames.h\"\n#",
            "include \"Common/Paths.h\"\n#",
            "include <QTextDocument>",
            "include <QSysInfo>\n#",
            "include <QSslKey>\n#",
            "include <QSslError>\n#",
            "include <QSettings>\n#",
            "include <QProcess>\n#",
            "include <QLocale>\n#",
            "include <QGuiApplication>\n#",
            "include <QDir>\n#",
            "include <QDateTime>\n#",
            "include <cmath>\n#",
            "include \"Utils.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QSystemDeviceInfo>\n#\ninclude \"Imap/Model/Model.h\"\ninclude \"Common/SettingsNames.h\"\n#\ninclude \"Common/Paths.h\"\n#\ninclude <QTextDocument>\ninclude <QSysInfo>\n#\ninclude <QSslKey>\n#\ninclude <QSslError>\n#\ninclude <QSettings>\n#\ninclude <QProcess>\n#\ninclude <QLocale>\n#\ninclude <QGuiApplication>\n#\ninclude <QDir>\n#\ninclude <QDateTime>\n#\ninclude <cmath>\n#\ninclude \"Utils.h\"\n#\n\nrettySize {\n  String PrettySize::prettySize(uint bytes, const ShowBytesSuffix compactUnitFormat)\n  {\n      if (bytes == 0) {\n          return tr(\"0\");\n      }\n      int order = std::log(static_cast<double>(bytes)) / std::log(1024.0);\n      double number = bytes / std::pow(1024.0, order);\n  \n      QString suffix;\n      if (order <= 0) {\n          if (compactUnitFormat == COMPACT_FORM)\n              return QString::number(bytes);\n          else\n              return tr(\"%1 bytes\").arg(QString::number(bytes));\n      } else if (order == 1) {\n          suffix = tr(\"kB\");\n      } else if (order == 2) {\n          suffix = tr(\"MB\");\n      } else if (order == 3) {\n          suffix = tr(\"GB\");\n      } else {\n          // make sure not to show wrong size for those that have > 1024 TB e-mail messages\n          order = 4;\n          suffix = tr(\"TB\"); // shame on you for such mails\n      }\n      return tr(\"%1 %2\").arg(QString::number(number, 'f', number < 100 ? 1 : 0), suffix);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ".size",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sizeHint",
          "container": "FlowLayout",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/FlowLayout.cpp",
          "lines": "131-134",
          "snippet": "QSize FlowLayout::sizeHint() const\n{\n    return minimumSize();\n}",
          "includes": [
            "#include \"FlowLayout.h\"",
            "#include <QWidget>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"FlowLayout.h\"\n#include <QWidget>\n\nFlowLayout {\n  QSize FlowLayout::sizeHint() const\n  {\n      return minimumSize();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "imeType())"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeType(",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "mimeType(",
          "container": "mapPartAttachmentItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "378-381",
          "snippet": "ByteArray ImapPartAttachmentItem::mimeType() const\n{\n    return index.data(RolePartMimeType).toString().toUtf8();\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  ByteArray ImapPartAttachmentItem::mimeType() const\n  {\n      return index.data(RolePartMimeType).toString().toUtf8();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "%1: %2, %3\")"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "File is not readable\")"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".isReadable",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "File does not exist\")"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ".exists",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "exists(",
          "container": "yncState",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxMetadata.cpp",
          "lines": "53-56",
          "snippet": "int SyncState::exists() const\n{\n    return m_exists;\n}",
          "includes": [
            "include \"MailboxMetadata.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"MailboxMetadata.h\"\n\nyncState {\n  int SyncState::exists() const\n  {\n      return m_exists;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  String FileAttachmentItem::tooltip() const\n  {\n      QFileInfo f(fileName);\n  \n      if (!f.exists())\n          return MessageComposer::tr(\"File does not exist\");\n  \n      if (!f.isReadable())\n          return MessageComposer::tr(\"File is not readable\");\n  \n      return MessageComposer::tr(\"%1: %2, %3\")\n              .arg(fileName, QString::fromUtf8(mimeType()), PrettySize::prettySize(f.size(), PrettySize::WITH_BYTES_SUFFIX));\n  }\n}"
  },
  {
    "function_name": "caption(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "121-129",
    "snippet": "String FileAttachmentItem::caption() const\n{\n    QString realFileName = QFileInfo(fileName).fileName();\n    if (!preferredName.isEmpty() && realFileName != preferredName) {\n        return MessageComposer::tr(\"%1\\n(from %2)\").arg(preferredName, realFileName);\n    } else {\n        return realFileName;\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "essageComposer::tr",
          "args": [
            "referredName,",
            "ealFileName)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "essageComposer::tr(",
          "args": [
            "%1\\n(from %2)\")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "referredName.isEmpty",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileInfo",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FileInfo(",
          "args": [
            "ileName)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  String FileAttachmentItem::caption() const\n  {\n      QString realFileName = QFileInfo(fileName).fileName();\n      if (!preferredName.isEmpty() && realFileName != preferredName) {\n          return MessageComposer::tr(\"%1\\n(from %2)\").arg(preferredName, realFileName);\n      } else {\n          return realFileName;\n      }\n  }\n}"
  },
  {
    "function_name": "~FileAttachmentItem(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "117-119",
    "snippet": "ileAttachmentItem::~FileAttachmentItem()\n{\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ileAttachmentItem::~FileAttachmentItem()\n  {\n  }\n}"
  },
  {
    "function_name": "FileAttachmentItem(",
    "container": "ileAttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "112-115",
    "snippet": "ileAttachmentItem::FileAttachmentItem(const QString &fileName):\n    fileName(fileName)\n{\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nileAttachmentItem {\n  ileAttachmentItem::FileAttachmentItem(const QString &fileName):\n      fileName(fileName)\n  {\n  }\n}"
  },
  {
    "function_name": "setContentDispositionMode(",
    "container": "ttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "106-110",
    "snippet": "ool AttachmentItem::setContentDispositionMode(const ContentDisposition contentDisposition)\n{\n    m_contentDisposition = contentDisposition;\n    return true;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem {\n  ool AttachmentItem::setContentDispositionMode(const ContentDisposition contentDisposition)\n  {\n      m_contentDisposition = contentDisposition;\n      return true;\n  }\n}"
  },
  {
    "function_name": "contentDispositionMode(",
    "container": "ttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "101-104",
    "snippet": "ontentDisposition AttachmentItem::contentDispositionMode() const\n{\n    return m_contentDisposition;\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem {\n  ontentDisposition AttachmentItem::contentDispositionMode() const\n  {\n      return m_contentDisposition;\n  }\n}"
  },
  {
    "function_name": "contentDispositionHeader(",
    "container": "ttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "88-99",
    "snippet": "ByteArray AttachmentItem::contentDispositionHeader() const\n{\n    // Looks like Thunderbird ignores attachments with funky MIME type sent with \"Content-Disposition: attachment\"\n    // when they are not marked with the \"filename\" option.\n    // Either I'm having a really, really bad day and I'm missing something, or they made a rather stupid bug.\n\n    QString shortFileName = contentDispositionFilename();\n    if (shortFileName.isEmpty())\n        shortFileName = QLatin1String(\"attachment\");\n    return \"Content-Disposition: \" + contentDispositionToByteArray(m_contentDisposition) + \";\\r\\n\\t\" +\n            Imap::encodeRfc2231Parameter(\"filename\", shortFileName) + \"\\r\\n\";\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map::encodeRfc2231Parameter(",
          "args": [
            "filename\",",
            "hortFileName)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ontentDispositionToByteArray(",
          "args": [
            "_contentDisposition)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ontentDispositionToByteArray(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "47-58",
          "snippet": "ByteArray contentDispositionToByteArray(const ContentDisposition cdn)\n{\n    switch (cdn) {\n    case CDN_INLINE:\n        return \"inline\";\n    case CDN_ATTACHMENT:\n        return \"attachment\";\n    }\n    Q_ASSERT(false);\n    // failsafe from RFC 2183\n    return \"attachment\";\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nByteArray contentDispositionToByteArray(const ContentDisposition cdn)\n{\n    switch (cdn) {\n    case CDN_INLINE:\n        return \"inline\";\n    case CDN_ATTACHMENT:\n        return \"attachment\";\n    }\n    Q_ASSERT(false);\n    // failsafe from RFC 2183\n    return \"attachment\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "attachment\")"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hortFileName.isEmpty",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ontentDispositionFilename(",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "contentDispositionFilename(",
          "container": "mapPartAttachmentItem",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
          "lines": "383-389",
          "snippet": "String ImapPartAttachmentItem::contentDispositionFilename() const\n{\n    if (!preferredName.isEmpty())\n        return preferredName;\n    QString res = index.data(RolePartFileName).toString();\n    return res.isEmpty() ? QLatin1String(\"attachment\") : res;\n}",
          "includes": [
            "include \"Imap/Network/MsgPartNetAccessManager.h\"",
            "include \"Imap/Model/Utils.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FullMessageCombiner.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Composer/MessageComposer.h\"\n#",
            "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
            "include <QMimeDatabase>\n#",
            "include <QUrl>\n#",
            "include <QProcess>\n#",
            "include <QMimeData>\n#",
            "include <QFileInfo>\n#",
            "include <QBuffer>\n#",
            "include \"ComposerAttachments.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nmapPartAttachmentItem {\n  String ImapPartAttachmentItem::contentDispositionFilename() const\n  {\n      if (!preferredName.isEmpty())\n          return preferredName;\n      QString res = index.data(RolePartFileName).toString();\n      return res.isEmpty() ? QLatin1String(\"attachment\") : res;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem {\n  ByteArray AttachmentItem::contentDispositionHeader() const\n  {\n      // Looks like Thunderbird ignores attachments with funky MIME type sent with \"Content-Disposition: attachment\"\n      // when they are not marked with the \"filename\" option.\n      // Either I'm having a really, really bad day and I'm missing something, or they made a rather stupid bug.\n  \n      QString shortFileName = contentDispositionFilename();\n      if (shortFileName.isEmpty())\n          shortFileName = QLatin1String(\"attachment\");\n      return \"Content-Disposition: \" + contentDispositionToByteArray(m_contentDisposition) + \";\\r\\n\\t\" +\n              Imap::encodeRfc2231Parameter(\"filename\", shortFileName) + \"\\r\\n\";\n  }\n}"
  },
  {
    "function_name": "~AttachmentItem(",
    "container": "ttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "84-86",
    "snippet": "ttachmentItem::~AttachmentItem()\n{\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem {\n  ttachmentItem::~AttachmentItem()\n  {\n  }\n}"
  },
  {
    "function_name": "AttachmentItem(",
    "container": "ttachmentItem",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "80-82",
    "snippet": "ttachmentItem::AttachmentItem(): m_contentDisposition(CDN_ATTACHMENT)\n{\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem {\n  ttachmentItem::AttachmentItem(): m_contentDisposition(CDN_ATTACHMENT)\n  {\n  }\n}"
  },
  {
    "function_name": "TEForContainers(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "61-78",
    "snippet": "ttachmentItem::ContentTransferEncoding CTEForContainers(const QModelIndex &index)\n{\n    QByteArray cte = index.data(RolePartEncoding).toByteArray();\n    if (cte == \"7bit\") {\n        return AttachmentItem::CTE_7BIT;\n    } else if (cte == \"8bit\") {\n        return AttachmentItem::CTE_8BIT;\n    } else if (cte == \"binary\") {\n        return AttachmentItem::CTE_BINARY;\n    } else {\n        // Well, we're pretty screwed here :(, the original message is either gone now (which is the better outcome),\n        // or it does not specify a valid an allowed content encoding.\n        // The composite types, and message/rfc822 is one of them, are not allowed to be encoded in anything but\n        // 7bit, 8bit and binary (http://tools.ietf.org/html/rfc2045#page-17).\n        // Let's assume \"7bit\", which is the default in RFC 2045.\n        return AttachmentItem::CTE_7BIT;\n    }\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ndex.data",
          "args": [
            "olePartEncoding)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nttachmentItem::ContentTransferEncoding CTEForContainers(const QModelIndex &index)\n{\n    QByteArray cte = index.data(RolePartEncoding).toByteArray();\n    if (cte == \"7bit\") {\n        return AttachmentItem::CTE_7BIT;\n    } else if (cte == \"8bit\") {\n        return AttachmentItem::CTE_8BIT;\n    } else if (cte == \"binary\") {\n        return AttachmentItem::CTE_BINARY;\n    } else {\n        // Well, we're pretty screwed here :(, the original message is either gone now (which is the better outcome),\n        // or it does not specify a valid an allowed content encoding.\n        // The composite types, and message/rfc822 is one of them, are not allowed to be encoded in anything but\n        // 7bit, 8bit and binary (http://tools.ietf.org/html/rfc2045#page-17).\n        // Let's assume \"7bit\", which is the default in RFC 2045.\n        return AttachmentItem::CTE_7BIT;\n    }\n}"
  },
  {
    "function_name": "ontentDispositionToByteArray(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Composer/ComposerAttachments.cpp",
    "lines": "47-58",
    "snippet": "ByteArray contentDispositionToByteArray(const ContentDisposition cdn)\n{\n    switch (cdn) {\n    case CDN_INLINE:\n        return \"inline\";\n    case CDN_ATTACHMENT:\n        return \"attachment\";\n    }\n    Q_ASSERT(false);\n    // failsafe from RFC 2183\n    return \"attachment\";\n}",
    "includes": [
      "include \"Imap/Network/MsgPartNetAccessManager.h\"",
      "include \"Imap/Model/Utils.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Imap/Model/FullMessageCombiner.h\"\n#",
      "include \"Imap/Encoders.h\"\n#",
      "include \"Composer/MessageComposer.h\"\n#",
      "include \"mimetypes-qt4/include/QMimeDatabase\"\n#",
      "include <QMimeDatabase>\n#",
      "include <QUrl>\n#",
      "include <QProcess>\n#",
      "include <QMimeData>\n#",
      "include <QFileInfo>\n#",
      "include <QBuffer>\n#",
      "include \"ComposerAttachments.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "alse)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"Imap/Network/MsgPartNetAccessManager.h\"\ninclude \"Imap/Model/Utils.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FullMessageCombiner.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Composer/MessageComposer.h\"\n#\ninclude \"mimetypes-qt4/include/QMimeDatabase\"\n#\ninclude <QMimeDatabase>\n#\ninclude <QUrl>\n#\ninclude <QProcess>\n#\ninclude <QMimeData>\n#\ninclude <QFileInfo>\n#\ninclude <QBuffer>\n#\ninclude \"ComposerAttachments.h\"\n#\n\nByteArray contentDispositionToByteArray(const ContentDisposition cdn)\n{\n    switch (cdn) {\n    case CDN_INLINE:\n        return \"inline\";\n    case CDN_ATTACHMENT:\n        return \"attachment\";\n    }\n    Q_ASSERT(false);\n    // failsafe from RFC 2183\n    return \"attachment\";\n}"
  }
]