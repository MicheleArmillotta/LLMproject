[
  {
    "function_name": "taskData(",
    "container": "etchMsgPartTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
    "lines": "112-115",
    "snippet": "Variant FetchMsgPartTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Downloading messages\")) : QVariant();\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [
            "r(\"Downloading messages\"))"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Downloading messages\")"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "etchMsgPartTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
          "lines": "67-99",
          "snippet": "ool FetchMsgPartTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (!mailboxIndex.isValid()) {\n        _failed(\"Mailbox disappeared\");\n        return false;\n    }\n\n    if (resp->tag == tag) {\n        if (resp->kind == Responses::OK) {\n            log(\"Fetched parts\", Common::LOG_MESSAGES);\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            QList<TreeItemMessage *> messages = model->findMessagesByUids(mailbox, uids);\n            Q_FOREACH(TreeItemMessage *message, messages) {\n                Q_FOREACH(const QString &partId, parts) {\n                    log(\"Fetched part\" + partId, Common::LOG_MESSAGES);\n                    model->finalizeFetchPart(mailbox, message->row() + 1, partId);\n                }\n            }\n            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n            _completed();\n        } else {\n            // FIXME: error handling\n            _failed(\"Part fetch failed\");\n        }\n        return true;\n    } else {\n        return false;\n    }\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  ool FetchMsgPartTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (!mailboxIndex.isValid()) {\n          _failed(\"Mailbox disappeared\");\n          return false;\n      }\n  \n      if (resp->tag == tag) {\n          if (resp->kind == Responses::OK) {\n              log(\"Fetched parts\", Common::LOG_MESSAGES);\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              QList<TreeItemMessage *> messages = model->findMessagesByUids(mailbox, uids);\n              Q_FOREACH(TreeItemMessage *message, messages) {\n                  Q_FOREACH(const QString &partId, parts) {\n                      log(\"Fetched part\" + partId, Common::LOG_MESSAGES);\n                      model->finalizeFetchPart(mailbox, message->row() + 1, partId);\n                  }\n              }\n              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n              _completed();\n          } else {\n              // FIXME: error handling\n              _failed(\"Part fetch failed\");\n          }\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  Variant FetchMsgPartTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Downloading messages\")) : QVariant();\n  }\n}"
  },
  {
    "function_name": "debugIdentification(",
    "container": "etchMsgPartTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
    "lines": "101-110",
    "snippet": "String FetchMsgPartTask::debugIdentification() const\n{\n    if (!mailboxIndex.isValid())\n        return QLatin1String(\"[invalid mailbox]\");\n\n    Q_ASSERT(!uids.isEmpty());\n    return QString::fromUtf8(\"%1: parts %2 for UIDs %3\")\n           .arg(mailboxIndex.data(RoleMailboxName).toString(), parts.join(QLatin1String(\", \")),\n                Sequence::fromList(uids).toByteArray());\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "ailboxIndex.data(RoleMailboxName).toString(),",
            "arts.join(QLatin1String(\", \")),",
            "equence::fromList(uids).toByteArray())"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::fromList",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::fromList(",
          "args": [
            "ids)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "fromList(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "114-123",
          "snippet": "equence Sequence::fromList(QList<uint> numbers)\n{\n    Q_ASSERT(!numbers.isEmpty());\n    qSort(numbers);\n    Sequence seq(numbers.first());\n    for (int i = 1; i < numbers.size(); ++i) {\n        seq.add(numbers[i]);\n    }\n    return seq;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  equence Sequence::fromList(QList<uint> numbers)\n  {\n      Q_ASSERT(!numbers.isEmpty());\n      qSort(numbers);\n      Sequence seq(numbers.first());\n      for (int i = 1; i < numbers.size(); ++i) {\n          seq.add(numbers[i]);\n      }\n      return seq;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arts.join",
          "args": [
            "Latin1String(\", \"))"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            ", \")"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "%1: parts %2 for UIDs %3\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "uids.isEmpty())"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.isEmpty",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "[invalid mailbox]\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  String FetchMsgPartTask::debugIdentification() const\n  {\n      if (!mailboxIndex.isValid())\n          return QLatin1String(\"[invalid mailbox]\");\n  \n      Q_ASSERT(!uids.isEmpty());\n      return QString::fromUtf8(\"%1: parts %2 for UIDs %3\")\n             .arg(mailboxIndex.data(RoleMailboxName).toString(), parts.join(QLatin1String(\", \")),\n                  Sequence::fromList(uids).toByteArray());\n  }\n}"
  },
  {
    "function_name": "handleStateHelper(",
    "container": "etchMsgPartTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
    "lines": "67-99",
    "snippet": "ool FetchMsgPartTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (!mailboxIndex.isValid()) {\n        _failed(\"Mailbox disappeared\");\n        return false;\n    }\n\n    if (resp->tag == tag) {\n        if (resp->kind == Responses::OK) {\n            log(\"Fetched parts\", Common::LOG_MESSAGES);\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            QList<TreeItemMessage *> messages = model->findMessagesByUids(mailbox, uids);\n            Q_FOREACH(TreeItemMessage *message, messages) {\n                Q_FOREACH(const QString &partId, parts) {\n                    log(\"Fetched part\" + partId, Common::LOG_MESSAGES);\n                    model->finalizeFetchPart(mailbox, message->row() + 1, partId);\n                }\n            }\n            model->changeConnectionState(parser, CONN_STATE_SELECTED);\n            _completed();\n        } else {\n            // FIXME: error handling\n            _failed(\"Part fetch failed\");\n        }\n        return true;\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Part fetch failed\")"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->changeConnectionState",
          "args": [
            "arser,",
            "ONN_STATE_SELECTED)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->finalizeFetchPart",
          "args": [
            "ailbox,",
            "essage->row() + 1,",
            "artId)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "finalizeFetchPart(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "504-527",
          "snippet": "oid Model::finalizeFetchPart(TreeItemMailbox *const mailbox, const uint sequenceNo, const QString &partId)\n{\n    // At first, verify that the message itself is marked as loaded.\n    // If it isn't, it's probably because of Model::releaseMessageData().\n    TreeItem *item = mailbox->m_children[0]; // TreeItemMsgList\n    item = item->child(sequenceNo - 1, this);   // TreeItemMessage\n    Q_ASSERT(item);   // FIXME: or rather throw an exception?\n    if (item->accessFetchStatus() == TreeItem::NONE) {\n        // ...and it indeed got released, so let's just return and don't try to check anything\n        return;\n    }\n\n    TreeItemPart *part = mailbox->partIdToPtr(this, static_cast<TreeItemMessage *>(item), partId);\n    if (! part) {\n        qDebug() << \"Can't verify part fetching status: part is not here!\";\n        return;\n    }\n    if (part->loading()) {\n        // basically, there's nothing to do if the FETCH targetted a message part and not the message as a whole\n        qDebug() << \"Imap::Model::_finalizeFetch(): didn't receive anything about message\" <<\n                 part->message()->row() << \"part\" << part->partId();\n        part->setFetchStatus(TreeItem::DONE);\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::finalizeFetchPart(TreeItemMailbox *const mailbox, const uint sequenceNo, const QString &partId)\n  {\n      // At first, verify that the message itself is marked as loaded.\n      // If it isn't, it's probably because of Model::releaseMessageData().\n      TreeItem *item = mailbox->m_children[0]; // TreeItemMsgList\n      item = item->child(sequenceNo - 1, this);   // TreeItemMessage\n      Q_ASSERT(item);   // FIXME: or rather throw an exception?\n      if (item->accessFetchStatus() == TreeItem::NONE) {\n          // ...and it indeed got released, so let's just return and don't try to check anything\n          return;\n      }\n  \n      TreeItemPart *part = mailbox->partIdToPtr(this, static_cast<TreeItemMessage *>(item), partId);\n      if (! part) {\n          qDebug() << \"Can't verify part fetching status: part is not here!\";\n          return;\n      }\n      if (part->loading()) {\n          // basically, there's nothing to do if the FETCH targetted a message part and not the message as a whole\n          qDebug() << \"Imap::Model::_finalizeFetch(): didn't receive anything about message\" <<\n                   part->message()->row() << \"part\" << part->partId();\n          part->setFetchStatus(TreeItem::DONE);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "essage->row",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "row(",
          "container": "reeItemMessage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "1049-1053",
          "snippet": "nt TreeItemMessage::row() const\n{\n    Q_ASSERT(m_offset != -1);\n    return m_offset;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMessage {\n  nt TreeItemMessage::row() const\n  {\n      Q_ASSERT(m_offset != -1);\n      return m_offset;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "Fetched part\" + partId,",
            "ommon::LOG_MESSAGES)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "301-310",
          "snippet": "oid ImapTask::log(const QString &message, const Common::LogKind kind)\n{\n    Q_ASSERT(model);\n    QString dbg = debugIdentification();\n    if (!dbg.isEmpty()) {\n        dbg.prepend(QLatin1Char(' '));\n    }\n    model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n    model->m_taskModel->slotTaskMighHaveChanged(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::log(const QString &message, const Common::LogKind kind)\n  {\n      Q_ASSERT(model);\n      QString dbg = debugIdentification();\n      if (!dbg.isEmpty()) {\n          dbg.prepend(QLatin1Char(' '));\n      }\n      model->logTrace(parser ? parser->parserId() : 0, kind, metaObject()->className() + dbg, message);\n      model->m_taskModel->slotTaskMighHaveChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->findMessagesByUids",
          "args": [
            "ailbox,",
            "ids)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  ool FetchMsgPartTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (!mailboxIndex.isValid()) {\n          _failed(\"Mailbox disappeared\");\n          return false;\n      }\n  \n      if (resp->tag == tag) {\n          if (resp->kind == Responses::OK) {\n              log(\"Fetched parts\", Common::LOG_MESSAGES);\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              QList<TreeItemMessage *> messages = model->findMessagesByUids(mailbox, uids);\n              Q_FOREACH(TreeItemMessage *message, messages) {\n                  Q_FOREACH(const QString &partId, parts) {\n                      log(\"Fetched part\" + partId, Common::LOG_MESSAGES);\n                      model->finalizeFetchPart(mailbox, message->row() + 1, partId);\n                  }\n              }\n              model->changeConnectionState(parser, CONN_STATE_SELECTED);\n              _completed();\n          } else {\n              // FIXME: error handling\n              _failed(\"Part fetch failed\");\n          }\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "handleFetch(",
    "container": "etchMsgPartTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
    "lines": "54-65",
    "snippet": "ool FetchMsgPartTask::handleFetch(const Imap::Responses::Fetch *const resp)\n{\n    if (!mailboxIndex.isValid()) {\n        _failed(\"Mailbox disappeared\");\n        return false;\n    }\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    model->genericHandleFetch(mailbox, resp);\n    return true;\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->genericHandleFetch",
          "args": [
            "ailbox,",
            "esp)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Mailbox disappeared\")"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  ool FetchMsgPartTask::handleFetch(const Imap::Responses::Fetch *const resp)\n  {\n      if (!mailboxIndex.isValid()) {\n          _failed(\"Mailbox disappeared\");\n          return false;\n      }\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      model->genericHandleFetch(mailbox, resp);\n      return true;\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "etchMsgPartTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
    "lines": "43-52",
    "snippet": "oid FetchMsgPartTask::perform()\n{\n    parser = conn->parser;\n    markAsActiveTask();\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    Sequence seq = Sequence::fromList(uids);\n    tag = parser->uidFetch(seq, parts);\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->uidFetch",
          "args": [
            "eq,",
            "arts)"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "uidFetch(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "460-465",
          "snippet": "ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n{\n    return queueCommand(Commands::Command(\"UID FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n  {\n      return queueCommand(Commands::Command(\"UID FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "equence::fromList(",
          "args": [
            "ids)"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "fromList(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "114-123",
          "snippet": "equence Sequence::fromList(QList<uint> numbers)\n{\n    Q_ASSERT(!numbers.isEmpty());\n    qSort(numbers);\n    Sequence seq(numbers.first());\n    for (int i = 1; i < numbers.size(); ++i) {\n        seq.add(numbers[i]);\n    }\n    return seq;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  equence Sequence::fromList(QList<uint> numbers)\n  {\n      Q_ASSERT(!numbers.isEmpty());\n      qSort(numbers);\n      Sequence seq(numbers.first());\n      for (int i = 1; i < numbers.size(); ++i) {\n          seq.add(numbers[i]);\n      }\n      return seq;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  oid FetchMsgPartTask::perform()\n  {\n      parser = conn->parser;\n      markAsActiveTask();\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      Sequence seq = Sequence::fromList(uids);\n      tag = parser->uidFetch(seq, parts);\n  }\n}"
  },
  {
    "function_name": "FetchMsgPartTask(",
    "container": "etchMsgPartTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/FetchMsgPartTask.cpp",
    "lines": "35-41",
    "snippet": "etchMsgPartTask::FetchMsgPartTask(Model *model, const QModelIndex &mailbox, const QList<uint> &uids, const QStringList &parts):\n    ImapTask(model), uids(uids), parts(parts), mailboxIndex(mailbox)\n{\n    Q_ASSERT(!uids.isEmpty());\n    conn = model->findTaskResponsibleFor(mailboxIndex);\n    conn->addDependentTask(this);\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->findTaskResponsibleFor",
          "args": [
            "ailboxIndex)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "uids.isEmpty())"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.isEmpty",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\n\netchMsgPartTask {\n  etchMsgPartTask::FetchMsgPartTask(Model *model, const QModelIndex &mailbox, const QList<uint> &uids, const QStringList &parts):\n      ImapTask(model), uids(uids), parts(parts), mailboxIndex(mailbox)\n  {\n      Q_ASSERT(!uids.isEmpty());\n      conn = model->findTaskResponsibleFor(mailboxIndex);\n      conn->addDependentTask(this);\n  }\n}"
  }
]