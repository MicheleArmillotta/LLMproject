[
  {
    "function_name": "signalSyncFailure(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "990-1005",
    "snippet": "oid KeepMailboxOpenTask::signalSyncFailure(const QString &message)\n{\n    if (!mailboxIndex.isValid()) {\n        // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n        // Seems that there's nothing to report here.\n        return;\n    }\n\n    if (synchronizeConn) {\n        // Well, we aren't synced yet. We're going to rely on the ObtainSynchronizedMailboxTask's own\n        // emitting of mailboxSyncFailed() to prevent duplicate signals.\n        return;\n    }\n\n    EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "odel,",
            "ailboxSyncFailed,",
            "_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()),",
            "_ARG(QString, message))"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "essage)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "ailboxIndex.data(RoleMailboxName).toString())"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::signalSyncFailure(const QString &message)\n  {\n      if (!mailboxIndex.isValid()) {\n          // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n          // Seems that there's nothing to report here.\n          return;\n      }\n  \n      if (synchronizeConn) {\n          // Well, we aren't synced yet. We're going to rely on the ObtainSynchronizedMailboxTask's own\n          // emitting of mailboxSyncFailed() to prevent duplicate signals.\n          return;\n      }\n  \n      EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n  }\n}"
  },
  {
    "function_name": "closeMailboxDestructively(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "984-987",
    "snippet": "oid KeepMailboxOpenTask::closeMailboxDestructively()\n{\n    tagClose = parser->close();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->close",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "close(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "301-304",
          "snippet": "ommandHandle Parser::close()\n{\n    return queueCommand(Commands::ATOM, \"CLOSE\");\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::close()\n  {\n      return queueCommand(Commands::ATOM, \"CLOSE\");\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::closeMailboxDestructively()\n  {\n      tagClose = parser->close();\n  }\n}"
  },
  {
    "function_name": "saveSyncStateNowOrLater(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "974-982",
    "snippet": "oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    if (list->fetched()) {\n        mailbox->saveSyncStateAndUids(model);\n    } else {\n        list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist->setFetchStatus",
          "args": [
            "map::Mailbox::TreeItem::LOADING)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist->fetched",
          "args": [],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItemMsgList*>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      if (list->fetched()) {\n          mailbox->saveSyncStateAndUids(model);\n      } else {\n          list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n      }\n  }\n}"
  },
  {
    "function_name": "feelFreeToAbortCaller(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "969-972",
    "snippet": "oid KeepMailboxOpenTask::feelFreeToAbortCaller(ImapTask *task)\n{\n    abortableTasks.append(task);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bortableTasks.append",
          "args": [
            "ask)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::feelFreeToAbortCaller(ImapTask *task)\n  {\n      abortableTasks.append(task);\n  }\n}"
  },
  {
    "function_name": "taskData(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "958-963",
    "snippet": "Variant KeepMailboxOpenTask::taskData(const int role) const\n{\n    // FIXME\n    Q_UNUSED(role);\n    return QVariant();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_UNUSED(",
          "args": [
            "ole)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  Variant KeepMailboxOpenTask::taskData(const int role) const\n  {\n      // FIXME\n      Q_UNUSED(role);\n      return QVariant();\n  }\n}"
  },
  {
    "function_name": "canRunIdleRightNow(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "931-956",
    "snippet": "ool KeepMailboxOpenTask::canRunIdleRightNow() const\n{\n    bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n            dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n\n    // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n    // and that one more thing is a SortTask which is in the \"just updating\" mode.\n    // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n    // Nifty, isn't it?\n    if (model->accessParser(parser).activeTasks.size() > 1) {\n        if (model->accessParser(parser).activeTasks.size() == 2 &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n            // This is OK, so no need to clear the \"OK\" flag\n        } else {\n            // Too bad, cannot IDLE\n            res = false;\n        }\n    }\n\n    if (!res)\n        return false;\n\n    Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "odel->accessParser(parser).activeTasks.front() == this)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<SortTask*>",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<SortTask*>",
          "args": [
            "odel->accessParser(parser).activeTasks[1])"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<SortTask*>",
          "args": [
            "odel->accessParser(parser).activeTasks[1])"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.isEmpty",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.isEmpty",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::canRunIdleRightNow() const\n  {\n      bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n              dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n  \n      // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n      // and that one more thing is a SortTask which is in the \"just updating\" mode.\n      // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n      // Nifty, isn't it?\n      if (model->accessParser(parser).activeTasks.size() > 1) {\n          if (model->accessParser(parser).activeTasks.size() == 2 &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n              // This is OK, so no need to clear the \"OK\" flag\n          } else {\n              // Too bad, cannot IDLE\n              res = false;\n          }\n      }\n  \n      if (!res)\n          return false;\n  \n      Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n      return true;\n  }\n}"
  },
  {
    "function_name": "isReadyToTerminate(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "925-928",
    "snippet": "ool KeepMailboxOpenTask::isReadyToTerminate() const\n{\n    return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asPendingInternalActions(",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "hasPendingInternalActions(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "914-919",
          "snippet": "ool KeepMailboxOpenTask::hasPendingInternalActions() const\n{\n    bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n    return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n             requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::hasPendingInternalActions() const\n  {\n      bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n      return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n               requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::isReadyToTerminate() const\n  {\n      return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n  }\n}"
  },
  {
    "function_name": "hasPendingInternalActions(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "914-919",
    "snippet": "ool KeepMailboxOpenTask::hasPendingInternalActions() const\n{\n    bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n    return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n             requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.isEmpty",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedParts.isEmpty",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unningTasksForThisMailbox.isEmpty",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.isEmpty",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.isEmpty",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dleLauncher->waitingForIdleTaggedTermination",
          "args": [],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "waitingForIdleTaggedTermination(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "118-121",
          "snippet": "ool IdleLauncher::waitingForIdleTaggedTermination() const\n{\n    return m_idleCommandRunning;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  ool IdleLauncher::waitingForIdleTaggedTermination() const\n  {\n      return m_idleCommandRunning;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::hasPendingInternalActions() const\n  {\n      bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n      return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n               requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n  }\n}"
  },
  {
    "function_name": "dieIfInvalidMailbox(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "894-912",
    "snippet": "ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    if (m_deleteCurrentMailboxTask) {\n        // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n        return true;\n    }\n\n    // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n    if (!unSelectTask && isRunning) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nSelectTask->perform",
          "args": [],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "nSelectTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/UnSelectTask.cpp",
          "lines": "43-61",
          "snippet": "oid UnSelectTask::perform()\n{\n    markAsActiveTask(TASK_PREPEND);\n\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return;\n    }\n    // We really should ignore abort() -- we're a very important task\n\n    if (model->accessParser(parser).maintainingTask) {\n        model->accessParser(parser).maintainingTask->breakOrCancelPossibleIdle();\n    }\n    if (model->accessParser(parser).capabilities.contains(\"UNSELECT\")) {\n        unSelectTag = parser->unSelect();\n    } else {\n        doFakeSelect();\n    }\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include <QUuid>\n#",
            "include \"UnSelectTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude <QUuid>\n#\ninclude \"UnSelectTask.h\"\n#\n\nnSelectTask {\n  oid UnSelectTask::perform()\n  {\n      markAsActiveTask(TASK_PREPEND);\n  \n      if (_dead) {\n          _failed(\"Asked to die\");\n          return;\n      }\n      // We really should ignore abort() -- we're a very important task\n  \n      if (model->accessParser(parser).maintainingTask) {\n          model->accessParser(parser).maintainingTask->breakOrCancelPossibleIdle();\n      }\n      if (model->accessParser(parser).capabilities.contains(\"UNSELECT\")) {\n          unSelectTag = parser->unSelect();\n      } else {\n          doFakeSelect();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createUnSelectTask",
          "args": [
            "odel,",
            "his)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      if (m_deleteCurrentMailboxTask) {\n          // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n          return true;\n      }\n  \n      // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n      if (!unSelectTask && isRunning) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "slotUnselected(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "886-892",
    "snippet": "oid KeepMailboxOpenTask::slotUnselected()\n{\n    detachFromMailbox();\n    isRunning = true;\n    shouldExit = true;\n    _failed(\"UNSELECTed\");\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "UNSELECTed\")"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "etachFromMailbox(",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "detachFromMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "599-613",
          "snippet": "oid KeepMailboxOpenTask::detachFromMailbox()\n{\n    if (mailboxIndex.isValid()) {\n        // Mark current mailbox as \"orphaned by the housekeeping task\"\n        TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailbox);\n\n        // We're already obsolete -> don't pretend to accept new tasks\n        if (mailbox->maintainingTask == this)\n            mailbox->maintainingTask = 0;\n    }\n    if (model->accessParser(parser).maintainingTask == this) {\n        model->accessParser(parser).maintainingTask = 0;\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::detachFromMailbox()\n  {\n      if (mailboxIndex.isValid()) {\n          // Mark current mailbox as \"orphaned by the housekeeping task\"\n          TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailbox);\n  \n          // We're already obsolete -> don't pretend to accept new tasks\n          if (mailbox->maintainingTask == this)\n              mailbox->maintainingTask = 0;\n      }\n      if (model->accessParser(parser).maintainingTask == this) {\n          model->accessParser(parser).maintainingTask = 0;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotUnselected()\n  {\n      detachFromMailbox();\n      isRunning = true;\n      shouldExit = true;\n      _failed(\"UNSELECTed\");\n  }\n}"
  },
  {
    "function_name": "handleResponseCodeInsideState(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "804-884",
    "snippet": "ool KeepMailboxOpenTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n{\n    switch (resp->respCode) {\n    case Responses::UIDNEXT:\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUidNext(num->data);\n            saveSyncStateNowOrLater(mailbox);\n            // We shouldn't eat tagged responses from this context\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::PERMANENTFLAGS:\n        // Another useless one, but we want to consume it now to prevent a warning about\n        // an unhandled message\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setPermanentFlags(num->data);\n            // We shouldn't eat tagged responses from this context\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::HIGHESTMODSEQ:\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n        Q_ASSERT(num);\n        mailbox->syncState.setHighestModSeq(num->data);\n        saveSyncStateNowOrLater(mailbox);\n        return resp->tag.isEmpty();\n    }\n    case Responses::UIDVALIDITY:\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        Q_ASSERT(num);\n        if (mailbox->syncState.uidValidity() == num->data) {\n            // this is a harmless and useless message\n            return resp->tag.isEmpty();\n        } else {\n            // On the other hand, this a serious condition -- the server is telling us that the UIDVALIDITY has changed while\n            // a mailbox is open. There isn't much we could do here; having code for handling this gracefuly is just too much\n            // work for little to no benefit.\n            // The sane thing is to disconnect from this mailbox.\n            EMIT_LATER(model, imapError, Q_ARG(QString, tr(\"The UIDVALIDITY has changed while mailbox is open. Please reconnect.\")));\n            model->setNetworkPolicy(NETWORK_OFFLINE);\n            return resp->tag.isEmpty();\n        }\n    }\n    default:\n        // Do nothing here\n        break;\n    }\n    return false;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->setNetworkPolicy",
          "args": [
            "ETWORK_OFFLINE)"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "setNetworkPolicy(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "1069-1124",
          "snippet": "oid Model::setNetworkPolicy(const NetworkPolicy policy)\n{\n    bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n    switch (policy) {\n    case NETWORK_OFFLINE:\n        for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n            if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                // there's no point in sending LOGOUT over these\n                continue;\n            }\n            Q_ASSERT(it->parser);\n            if (it->maintainingTask) {\n                // First of all, give the maintaining task a chance to finish its housekeeping\n                it->maintainingTask->stopForLogout();\n            }\n            // Kill all tasks that are also using this connection\n            Q_FOREACH(ImapTask *task, it->activeTasks) {\n                task->die(tr(\"Going offline\"));\n            }\n            it->logoutCmd = it->parser->logout();\n            it->connState = CONN_STATE_LOGOUT;\n        }\n        m_netPolicy = NETWORK_OFFLINE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyOffline();\n\n        // FIXME: kill the connection\n        break;\n    case NETWORK_EXPENSIVE:\n        m_netPolicy = NETWORK_EXPENSIVE;\n        m_periodicMailboxNumbersRefresh->stop();\n        emit networkPolicyChanged();\n        emit networkPolicyExpensive();\n        break;\n    case NETWORK_ONLINE:\n        m_netPolicy = NETWORK_ONLINE;\n        m_periodicMailboxNumbersRefresh->start();\n        emit networkPolicyChanged();\n        emit networkPolicyOnline();\n        break;\n    }\n\n    if (networkReconnected) {\n        // We're connecting after being offline\n        if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n            // We should ask for an updated list of mailboxes\n            // The main reason is that this happens after entering wrong password and going back online\n            reloadMailboxList();\n        }\n    } else if (m_netPolicy == NETWORK_ONLINE) {\n        // The connection is online after some time in a different mode. Let's use this opportunity to request\n        // updated message counts from all visible mailboxes.\n        invalidateAllMessageCounts();\n    }\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::setNetworkPolicy(const NetworkPolicy policy)\n  {\n      bool networkReconnected = m_netPolicy == NETWORK_OFFLINE && policy != NETWORK_OFFLINE;\n      switch (policy) {\n      case NETWORK_OFFLINE:\n          for (QMap<Parser *,ParserState>::iterator it = m_parsers.begin(); it != m_parsers.end(); ++it) {\n              if (!it->parser || it->connState == CONN_STATE_LOGOUT) {\n                  // there's no point in sending LOGOUT over these\n                  continue;\n              }\n              Q_ASSERT(it->parser);\n              if (it->maintainingTask) {\n                  // First of all, give the maintaining task a chance to finish its housekeeping\n                  it->maintainingTask->stopForLogout();\n              }\n              // Kill all tasks that are also using this connection\n              Q_FOREACH(ImapTask *task, it->activeTasks) {\n                  task->die(tr(\"Going offline\"));\n              }\n              it->logoutCmd = it->parser->logout();\n              it->connState = CONN_STATE_LOGOUT;\n          }\n          m_netPolicy = NETWORK_OFFLINE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyOffline();\n  \n          // FIXME: kill the connection\n          break;\n      case NETWORK_EXPENSIVE:\n          m_netPolicy = NETWORK_EXPENSIVE;\n          m_periodicMailboxNumbersRefresh->stop();\n          emit networkPolicyChanged();\n          emit networkPolicyExpensive();\n          break;\n      case NETWORK_ONLINE:\n          m_netPolicy = NETWORK_ONLINE;\n          m_periodicMailboxNumbersRefresh->start();\n          emit networkPolicyChanged();\n          emit networkPolicyOnline();\n          break;\n      }\n  \n      if (networkReconnected) {\n          // We're connecting after being offline\n          if (m_mailboxes->accessFetchStatus() != TreeItem::NONE) {\n              // We should ask for an updated list of mailboxes\n              // The main reason is that this happens after entering wrong password and going back online\n              reloadMailboxList();\n          }\n      } else if (m_netPolicy == NETWORK_ONLINE) {\n          // The connection is online after some time in a different mode. Let's use this opportunity to request\n          // updated message counts from all visible mailboxes.\n          invalidateAllMessageCounts();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIT_LATER(",
          "args": [
            "odel,",
            "mapError,",
            "_ARG(QString, tr(\"The UIDVALIDITY has changed while mailbox is open. Please reconnect.\")))"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ARG(",
          "args": [
            "String,",
            "r(\"The UIDVALIDITY has changed while mailbox is open. Please reconnect.\"))"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "The UIDVALIDITY has changed while mailbox is open. Please reconnect.\")"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateNowOrLater(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "974-982",
          "snippet": "oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    if (list->fetched()) {\n        mailbox->saveSyncStateAndUids(model);\n    } else {\n        list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      if (list->fetched()) {\n          mailbox->saveSyncStateAndUids(model);\n      } else {\n          list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidValidity",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "um)"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<uint>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->respCodeData.data",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "894-912",
          "snippet": "ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    if (m_deleteCurrentMailboxTask) {\n        // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n        return true;\n    }\n\n    // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n    if (!unSelectTask && isRunning) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      if (m_deleteCurrentMailboxTask) {\n          // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n          return true;\n      }\n  \n      // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n      if (!unSelectTask && isRunning) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setHighestModSeq",
          "args": [
            "um->data)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "um)"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<quint64>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "State response has invalid PERMANENTFLAGS respCodeData\",",
            "resp)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setPermanentFlags",
          "args": [
            "um->data)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<QStringList>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antHappen(",
          "args": [
            "State response has invalid UIDNEXT respCodeData\",",
            "resp)"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setUidNext",
          "args": [
            "um->data)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<uint>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n  {\n      switch (resp->respCode) {\n      case Responses::UIDNEXT:\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUidNext(num->data);\n              saveSyncStateNowOrLater(mailbox);\n              // We shouldn't eat tagged responses from this context\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::PERMANENTFLAGS:\n          // Another useless one, but we want to consume it now to prevent a warning about\n          // an unhandled message\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setPermanentFlags(num->data);\n              // We shouldn't eat tagged responses from this context\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::HIGHESTMODSEQ:\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n          Q_ASSERT(num);\n          mailbox->syncState.setHighestModSeq(num->data);\n          saveSyncStateNowOrLater(mailbox);\n          return resp->tag.isEmpty();\n      }\n      case Responses::UIDVALIDITY:\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          Q_ASSERT(num);\n          if (mailbox->syncState.uidValidity() == num->data) {\n              // this is a harmless and useless message\n              return resp->tag.isEmpty();\n          } else {\n              // On the other hand, this a serious condition -- the server is telling us that the UIDVALIDITY has changed while\n              // a mailbox is open. There isn't much we could do here; having code for handling this gracefuly is just too much\n              // work for little to no benefit.\n              // The sane thing is to disconnect from this mailbox.\n              EMIT_LATER(model, imapError, Q_ARG(QString, tr(\"The UIDVALIDITY has changed while mailbox is open. Please reconnect.\")));\n              model->setNetworkPolicy(NETWORK_OFFLINE);\n              return resp->tag.isEmpty();\n          }\n      }\n      default:\n          // Do nothing here\n          break;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "breakOrCancelPossibleIdle(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "797-802",
    "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dleLauncher->finishIdle",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "finishIdle(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "79-89",
          "snippet": "oid IdleLauncher::finishIdle()\n{\n    Q_ASSERT(task->parser);\n    if (m_idling) {\n        renewal->stop();\n        task->parser->idleDone();\n        m_idling = false;\n    } else if (delayedEnter->isActive()) {\n        delayedEnter->stop();\n    }\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::finishIdle()\n  {\n      Q_ASSERT(task->parser);\n      if (m_idling) {\n          renewal->stop();\n          task->parser->idleDone();\n          m_idling = false;\n      } else if (delayedEnter->isActive()) {\n          delayedEnter->stop();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
  },
  {
    "function_name": "slotFetchRequestedEnvelopes(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "776-795",
    "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n{\n    // FIXME: abort/die\n\n    if (requestedEnvelopes.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QList<uint> fetchNow;\n    if (shouldExit) {\n        fetchNow = requestedEnvelopes;\n        requestedEnvelopes.clear();\n    } else {\n        const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n        fetchNow = requestedEnvelopes.mid(0, amount);\n        requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n    }\n    fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createFetchMsgMetadataTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            "etchNow)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.erase",
          "args": [
            "equestedEnvelopes.begin(),",
            "equestedEnvelopes.begin() + amount)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.begin",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.begin",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.mid",
          "args": [
            ",",
            "mount)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min(",
          "args": [
            "equestedEnvelopes.size(),",
            "imitMessagesAtOnce)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.size",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.clear",
          "args": [],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reakOrCancelPossibleIdle(",
          "args": [],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "breakOrCancelPossibleIdle(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "797-802",
          "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.isEmpty",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n  {\n      // FIXME: abort/die\n  \n      if (requestedEnvelopes.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QList<uint> fetchNow;\n      if (shouldExit) {\n          fetchNow = requestedEnvelopes;\n          requestedEnvelopes.clear();\n      } else {\n          const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n          fetchNow = requestedEnvelopes.mid(0, amount);\n          requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n      }\n      fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n  }\n}"
  },
  {
    "function_name": "slotFetchRequestedParts(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "745-774",
    "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedParts()\n{\n    // FIXME: abort/die\n\n    if (requestedParts.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n    QSet<QString> parts = *it;\n\n    // When asked to exit, do as much as possible and die\n    while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n        QList<uint> uids;\n        uint totalSize = 0;\n        while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n            if (parts != *it)\n                break;\n            parts = *it;\n            uids << it.key();\n            totalSize += requestedPartSizes.take(it.key());\n            it = requestedParts.erase(it);\n        }\n        if (uids.isEmpty())\n            return;\n\n        fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createFetchMsgPartTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            "ids,",
            "arts.toList())"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arts.toList",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.isEmpty",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedParts.erase",
          "args": [
            "t)"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedPartSizes.take",
          "args": [
            "t.key())"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.key",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedParts.end",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ids.size",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchPartTasks.size",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedParts.begin",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reakOrCancelPossibleIdle(",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "breakOrCancelPossibleIdle(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "797-802",
          "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "equestedParts.isEmpty",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedParts()\n  {\n      // FIXME: abort/die\n  \n      if (requestedParts.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n      QSet<QString> parts = *it;\n  \n      // When asked to exit, do as much as possible and die\n      while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n          QList<uint> uids;\n          uint totalSize = 0;\n          while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n              if (parts != *it)\n                  break;\n              parts = *it;\n              uids << it.key();\n              totalSize += requestedPartSizes.take(it.key());\n              it = requestedParts.erase(it);\n          }\n          if (uids.isEmpty())\n              return;\n  \n          fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n      }\n  }\n}"
  },
  {
    "function_name": "requestEnvelopeDownload(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "737-743",
    "snippet": "oid KeepMailboxOpenTask::requestEnvelopeDownload(const uint uid)\n{\n    requestedEnvelopes.append(uid);\n    if (!fetchEnvelopeTimer->isActive()) {\n        fetchEnvelopeTimer->start();\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etchEnvelopeTimer->start",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchEnvelopeTimer->isActive",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.append",
          "args": [
            "id)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::requestEnvelopeDownload(const uint uid)\n  {\n      requestedEnvelopes.append(uid);\n      if (!fetchEnvelopeTimer->isActive()) {\n          fetchEnvelopeTimer->start();\n      }\n  }\n}"
  },
  {
    "function_name": "requestPartDownload(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "728-735",
    "snippet": "oid KeepMailboxOpenTask::requestPartDownload(const uint uid, const QString &partId, const uint estimatedSize)\n{\n    requestedParts[uid].insert(partId);\n    requestedPartSizes[uid] += estimatedSize;\n    if (!fetchPartTimer->isActive()) {\n        fetchPartTimer->start();\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etchPartTimer->start",
          "args": [],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchPartTimer->isActive",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedParts[uid].insert",
          "args": [
            "artId)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::requestPartDownload(const uint uid, const QString &partId, const uint estimatedSize)\n  {\n      requestedParts[uid].insert(partId);\n      requestedPartSizes[uid] += estimatedSize;\n      if (!fetchPartTimer->isActive()) {\n          fetchPartTimer->start();\n      }\n  }\n}"
  },
  {
    "function_name": "activateTasks(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "693-726",
    "snippet": "oid KeepMailboxOpenTask::activateTasks()\n{\n    // FIXME: abort/die\n\n    if (!isRunning)\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    if (m_deleteCurrentMailboxTask) {\n        closeMailboxDestructively();\n        return;\n    }\n\n    slotFetchRequestedEnvelopes();\n    slotFetchRequestedParts();\n\n    while (!dependingTasksForThisMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n        breakOrCancelPossibleIdle();\n        ImapTask *task = dependingTasksForThisMailbox.takeFirst();\n        runningTasksForThisMailbox.append(task);\n        dependentTasks.removeOne(task);\n        task->perform();\n    }\n    while (!dependingTasksNoMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n        breakOrCancelPossibleIdle();\n        ImapTask *task = dependingTasksNoMailbox.takeFirst();\n        dependentTasks.removeOne(task);\n        task->perform();\n    }\n\n    if (idleLauncher && canRunIdleRightNow())\n        idleLauncher->enterIdleLater();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dleLauncher->enterIdleLater",
          "args": [],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "enterIdleLater(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "97-103",
          "snippet": "oid IdleLauncher::enterIdleLater()\n{\n    if (m_idling)\n        return;\n\n    delayedEnter->start();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::enterIdleLater()\n  {\n      if (m_idling)\n          return;\n  \n      delayedEnter->start();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "anRunIdleRightNow(",
          "args": [],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "canRunIdleRightNow(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "931-956",
          "snippet": "ool KeepMailboxOpenTask::canRunIdleRightNow() const\n{\n    bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n            dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n\n    // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n    // and that one more thing is a SortTask which is in the \"just updating\" mode.\n    // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n    // Nifty, isn't it?\n    if (model->accessParser(parser).activeTasks.size() > 1) {\n        if (model->accessParser(parser).activeTasks.size() == 2 &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n            // This is OK, so no need to clear the \"OK\" flag\n        } else {\n            // Too bad, cannot IDLE\n            res = false;\n        }\n    }\n\n    if (!res)\n        return false;\n\n    Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::canRunIdleRightNow() const\n  {\n      bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n              dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n  \n      // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n      // and that one more thing is a SortTask which is in the \"just updating\" mode.\n      // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n      // Nifty, isn't it?\n      if (model->accessParser(parser).activeTasks.size() > 1) {\n          if (model->accessParser(parser).activeTasks.size() == 2 &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n              // This is OK, so no need to clear the \"OK\" flag\n          } else {\n              // Too bad, cannot IDLE\n              res = false;\n          }\n      }\n  \n      if (!res)\n          return false;\n  \n      Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask->perform",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "perform(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "339-374",
          "snippet": "oid KeepMailboxOpenTask::perform()\n{\n    // FIXME: abort/die\n\n    Q_ASSERT(synchronizeConn);\n    Q_ASSERT(synchronizeConn->isFinished());\n    parser = synchronizeConn->parser;\n    synchronizeConn = 0; // will get deleted by Model\n    markAsActiveTask();\n\n    isRunning = true;\n    fetchPartTimer->start();\n    fetchEnvelopeTimer->start();\n\n    if (!waitingObtainTasks.isEmpty()) {\n        shouldExit = true;\n    }\n\n    activateTasks();\n\n    if (model->accessParser(parser).capabilitiesFresh && model->accessParser(parser).capabilities.contains(\"IDLE\")) {\n        shouldRunIdle = true;\n    } else {\n        shouldRunNoop = true;\n    }\n\n    if (shouldRunNoop) {\n        noopTimer->start();\n    } else if (shouldRunIdle) {\n        idleLauncher = new IdleLauncher(this);\n        if (canRunIdleRightNow()) {\n            // There's no task yet, so we have to start IDLE now\n            idleLauncher->enterIdleLater();\n        }\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::perform()\n  {\n      // FIXME: abort/die\n  \n      Q_ASSERT(synchronizeConn);\n      Q_ASSERT(synchronizeConn->isFinished());\n      parser = synchronizeConn->parser;\n      synchronizeConn = 0; // will get deleted by Model\n      markAsActiveTask();\n  \n      isRunning = true;\n      fetchPartTimer->start();\n      fetchEnvelopeTimer->start();\n  \n      if (!waitingObtainTasks.isEmpty()) {\n          shouldExit = true;\n      }\n  \n      activateTasks();\n  \n      if (model->accessParser(parser).capabilitiesFresh && model->accessParser(parser).capabilities.contains(\"IDLE\")) {\n          shouldRunIdle = true;\n      } else {\n          shouldRunNoop = true;\n      }\n  \n      if (shouldRunNoop) {\n          noopTimer->start();\n      } else if (shouldRunIdle) {\n          idleLauncher = new IdleLauncher(this);\n          if (canRunIdleRightNow()) {\n              // There's no task yet, so we have to start IDLE now\n              idleLauncher->enterIdleLater();\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ependentTasks.removeOne",
          "args": [
            "ask)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.takeFirst",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reakOrCancelPossibleIdle(",
          "args": [],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "breakOrCancelPossibleIdle(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "797-802",
          "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.isEmpty",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependentTasks.removeOne",
          "args": [
            "ask)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unningTasksForThisMailbox.append",
          "args": [
            "ask)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.takeFirst",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.isEmpty",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotFetchRequestedParts(",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchRequestedParts(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "745-774",
          "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedParts()\n{\n    // FIXME: abort/die\n\n    if (requestedParts.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n    QSet<QString> parts = *it;\n\n    // When asked to exit, do as much as possible and die\n    while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n        QList<uint> uids;\n        uint totalSize = 0;\n        while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n            if (parts != *it)\n                break;\n            parts = *it;\n            uids << it.key();\n            totalSize += requestedPartSizes.take(it.key());\n            it = requestedParts.erase(it);\n        }\n        if (uids.isEmpty())\n            return;\n\n        fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedParts()\n  {\n      // FIXME: abort/die\n  \n      if (requestedParts.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n      QSet<QString> parts = *it;\n  \n      // When asked to exit, do as much as possible and die\n      while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n          QList<uint> uids;\n          uint totalSize = 0;\n          while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n              if (parts != *it)\n                  break;\n              parts = *it;\n              uids << it.key();\n              totalSize += requestedPartSizes.take(it.key());\n              it = requestedParts.erase(it);\n          }\n          if (uids.isEmpty())\n              return;\n  \n          fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lotFetchRequestedEnvelopes(",
          "args": [],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchRequestedEnvelopes(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "776-795",
          "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n{\n    // FIXME: abort/die\n\n    if (requestedEnvelopes.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QList<uint> fetchNow;\n    if (shouldExit) {\n        fetchNow = requestedEnvelopes;\n        requestedEnvelopes.clear();\n    } else {\n        const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n        fetchNow = requestedEnvelopes.mid(0, amount);\n        requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n    }\n    fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n  {\n      // FIXME: abort/die\n  \n      if (requestedEnvelopes.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QList<uint> fetchNow;\n      if (shouldExit) {\n          fetchNow = requestedEnvelopes;\n          requestedEnvelopes.clear();\n      } else {\n          const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n          fetchNow = requestedEnvelopes.mid(0, amount);\n          requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n      }\n      fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "loseMailboxDestructively(",
          "args": [],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "closeMailboxDestructively(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "984-987",
          "snippet": "oid KeepMailboxOpenTask::closeMailboxDestructively()\n{\n    tagClose = parser->close();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::closeMailboxDestructively()\n  {\n      tagClose = parser->close();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::activateTasks()\n  {\n      // FIXME: abort/die\n  \n      if (!isRunning)\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      if (m_deleteCurrentMailboxTask) {\n          closeMailboxDestructively();\n          return;\n      }\n  \n      slotFetchRequestedEnvelopes();\n      slotFetchRequestedParts();\n  \n      while (!dependingTasksForThisMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n          breakOrCancelPossibleIdle();\n          ImapTask *task = dependingTasksForThisMailbox.takeFirst();\n          runningTasksForThisMailbox.append(task);\n          dependentTasks.removeOne(task);\n          task->perform();\n      }\n      while (!dependingTasksNoMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n          breakOrCancelPossibleIdle();\n          ImapTask *task = dependingTasksNoMailbox.takeFirst();\n          dependentTasks.removeOne(task);\n          task->perform();\n      }\n  \n      if (idleLauncher && canRunIdleRightNow())\n          idleLauncher->enterIdleLater();\n  }\n}"
  },
  {
    "function_name": "handleFlags(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "679-691",
    "snippet": "ool KeepMailboxOpenTask::handleFlags(const Imap::Responses::Flags *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    // Well, there isn't much point in keeping track of these flags, but given that\n    // IMAP servers are happy to send these responses even after the initial sync, we\n    // better handle them explicitly here.\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    mailbox->syncState.setFlags(resp->flags);\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ailbox->syncState.setFlags",
          "args": [
            "esp->flags)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "894-912",
          "snippet": "ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    if (m_deleteCurrentMailboxTask) {\n        // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n        return true;\n    }\n\n    // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n    if (!unSelectTask && isRunning) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      if (m_deleteCurrentMailboxTask) {\n          // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n          return true;\n      }\n  \n      // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n      if (!unSelectTask && isRunning) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleFlags(const Imap::Responses::Flags *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      // Well, there isn't much point in keeping track of these flags, but given that\n      // IMAP servers are happy to send these responses even after the initial sync, we\n      // better handle them explicitly here.\n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      mailbox->syncState.setFlags(resp->flags);\n      return true;\n  }\n}"
  },
  {
    "function_name": "stopForLogout(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "663-677",
    "snippet": "oid KeepMailboxOpenTask::stopForLogout()\n{\n    abort();\n    breakOrCancelPossibleIdle();\n    killAllPendingTasks(tr(\"Logging off...\"));\n\n    // We're supposed to go offline. Given that we're a long-running task, I do not consider this a \"failure\".\n    // In particular, if the initial SELECT has not finished yet, the ObtainSynchronizedMailboxTask would get\n    // killed as well, and hence the mailboxSyncFailed() signal will get emitted.\n    // The worst thing which can possibly happen is that we're in the middle of checking the new arrivals.\n    // That's bad, because we've got unknown UIDs in our in-memory map, which is going to hurt during the next sync\n    // -- but that's something which should be handled elsewhere, IMHO.\n    // Therefore, make sure a subsequent call to die() doesn't propagate a failure.\n    shouldExit = true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "illAllPendingTasks(",
          "args": [
            "r(\"Logging off...\"))"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "killAllPendingTasks(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "636-647",
          "snippet": "oid KeepMailboxOpenTask::killAllPendingTasks(const QString &message)\n{\n    Q_FOREACH(ImapTask *task, dependingTasksForThisMailbox) {\n        task->die(message);\n    }\n    Q_FOREACH(ImapTask *task, dependingTasksNoMailbox) {\n        task->die(message);\n    }\n    Q_FOREACH(ImapTask *task, waitingObtainTasks) {\n        task->die(message);\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::killAllPendingTasks(const QString &message)\n  {\n      Q_FOREACH(ImapTask *task, dependingTasksForThisMailbox) {\n          task->die(message);\n      }\n      Q_FOREACH(ImapTask *task, dependingTasksNoMailbox) {\n          task->die(message);\n      }\n      Q_FOREACH(ImapTask *task, waitingObtainTasks) {\n          task->die(message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Logging off...\")"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateNowOrLater(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "974-982",
          "snippet": "oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    if (list->fetched()) {\n        mailbox->saveSyncStateAndUids(model);\n    } else {\n        list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      if (list->fetched()) {\n          mailbox->saveSyncStateAndUids(model);\n      } else {\n          list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reakOrCancelPossibleIdle(",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "breakOrCancelPossibleIdle(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "797-802",
          "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bort(",
          "args": [],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "abort(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "584-596",
          "snippet": "oid KeepMailboxOpenTask::abort()\n{\n    if (noopTimer)\n        noopTimer->stop();\n    if (idleLauncher)\n        idleLauncher->die();\n\n    detachFromMailbox();\n\n    _aborted = true;\n    // We do not want to propagate the signal to the child tasks, though -- the KeepMailboxOpenTask::abort() is used in the course\n    // of the regular \"hey, free this connection and pass it to another KeepMailboxOpenTask\" situations.\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::abort()\n  {\n      if (noopTimer)\n          noopTimer->stop();\n      if (idleLauncher)\n          idleLauncher->die();\n  \n      detachFromMailbox();\n  \n      _aborted = true;\n      // We do not want to propagate the signal to the child tasks, though -- the KeepMailboxOpenTask::abort() is used in the course\n      // of the regular \"hey, free this connection and pass it to another KeepMailboxOpenTask\" situations.\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::stopForLogout()\n  {\n      abort();\n      breakOrCancelPossibleIdle();\n      killAllPendingTasks(tr(\"Logging off...\"));\n  \n      // We're supposed to go offline. Given that we're a long-running task, I do not consider this a \"failure\".\n      // In particular, if the initial SELECT has not finished yet, the ObtainSynchronizedMailboxTask would get\n      // killed as well, and hence the mailboxSyncFailed() signal will get emitted.\n      // The worst thing which can possibly happen is that we're in the middle of checking the new arrivals.\n      // That's bad, because we've got unknown UIDs in our in-memory map, which is going to hurt during the next sync\n      // -- but that's something which should be handled elsewhere, IMHO.\n      // Therefore, make sure a subsequent call to die() doesn't propagate a failure.\n      shouldExit = true;\n  }\n}"
  },
  {
    "function_name": "debugIdentification(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "649-660",
    "snippet": "String KeepMailboxOpenTask::debugIdentification() const\n{\n    if (! mailboxIndex.isValid())\n        return QLatin1String(\"[invalid mailboxIndex]\");\n\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n    return QString::fromUtf8(\"attached to %1%2%3\").arg(mailbox->mailbox(),\n            (synchronizeConn && ! synchronizeConn->isFinished()) ? \" [syncConn unfinished]\" : \"\",\n            shouldExit ? \" [shouldExit]\" : \"\"\n                                                       );\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String::fromUtf8",
          "args": [
            "ailbox->mailbox(),",
            "synchronizeConn && ! synchronizeConn->isFinished()) ? \" [syncConn unfinished]\" : \"\",",
            "houldExit ? \" [shouldExit]\" : \"\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->mailbox",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "String::fromUtf8(",
          "args": [
            "attached to %1%2%3\")"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "[invalid mailboxIndex]\")"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  String KeepMailboxOpenTask::debugIdentification() const\n  {\n      if (! mailboxIndex.isValid())\n          return QLatin1String(\"[invalid mailboxIndex]\");\n  \n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n      return QString::fromUtf8(\"attached to %1%2%3\").arg(mailbox->mailbox(),\n              (synchronizeConn && ! synchronizeConn->isFinished()) ? \" [syncConn unfinished]\" : \"\",\n              shouldExit ? \" [shouldExit]\" : \"\"\n                                                         );\n  }\n}"
  },
  {
    "function_name": "killAllPendingTasks(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "636-647",
    "snippet": "oid KeepMailboxOpenTask::killAllPendingTasks(const QString &message)\n{\n    Q_FOREACH(ImapTask *task, dependingTasksForThisMailbox) {\n        task->die(message);\n    }\n    Q_FOREACH(ImapTask *task, dependingTasksNoMailbox) {\n        task->die(message);\n    }\n    Q_FOREACH(ImapTask *task, waitingObtainTasks) {\n        task->die(message);\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ask->die",
          "args": [
            "essage)"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "619-630",
          "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::die(const QString &message)\n  {\n      if (shouldExit) {\n          // OK, we're done, and getting killed. This is fine; just don't emit failed()\n          // because we aren't actually failing.\n          // This is a speciality of the KeepMailboxOpenTask because it's the only task\n          // this has a very long life.\n          _finished = true;\n      }\n      ImapTask::die(message);\n      detachFromMailbox();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::killAllPendingTasks(const QString &message)\n  {\n      Q_FOREACH(ImapTask *task, dependingTasksForThisMailbox) {\n          task->die(message);\n      }\n      Q_FOREACH(ImapTask *task, dependingTasksNoMailbox) {\n          task->die(message);\n      }\n      Q_FOREACH(ImapTask *task, waitingObtainTasks) {\n          task->die(message);\n      }\n  }\n}"
  },
  {
    "function_name": "die(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "619-630",
    "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etachFromMailbox(",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "detachFromMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "599-613",
          "snippet": "oid KeepMailboxOpenTask::detachFromMailbox()\n{\n    if (mailboxIndex.isValid()) {\n        // Mark current mailbox as \"orphaned by the housekeeping task\"\n        TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailbox);\n\n        // We're already obsolete -> don't pretend to accept new tasks\n        if (mailbox->maintainingTask == this)\n            mailbox->maintainingTask = 0;\n    }\n    if (model->accessParser(parser).maintainingTask == this) {\n        model->accessParser(parser).maintainingTask = 0;\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::detachFromMailbox()\n  {\n      if (mailboxIndex.isValid()) {\n          // Mark current mailbox as \"orphaned by the housekeeping task\"\n          TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailbox);\n  \n          // We're already obsolete -> don't pretend to accept new tasks\n          if (mailbox->maintainingTask == this)\n              mailbox->maintainingTask = 0;\n      }\n      if (model->accessParser(parser).maintainingTask == this) {\n          model->accessParser(parser).maintainingTask = 0;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapTask::die(",
          "args": [
            "essage)"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "619-630",
          "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::die(const QString &message)\n  {\n      if (shouldExit) {\n          // OK, we're done, and getting killed. This is fine; just don't emit failed()\n          // because we aren't actually failing.\n          // This is a speciality of the KeepMailboxOpenTask because it's the only task\n          // this has a very long life.\n          _finished = true;\n      }\n      ImapTask::die(message);\n      detachFromMailbox();\n  }\n}"
  },
  {
    "function_name": "detachFromMailbox(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "599-613",
    "snippet": "oid KeepMailboxOpenTask::detachFromMailbox()\n{\n    if (mailboxIndex.isValid()) {\n        // Mark current mailbox as \"orphaned by the housekeeping task\"\n        TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailbox);\n\n        // We're already obsolete -> don't pretend to accept new tasks\n        if (mailbox->maintainingTask == this)\n            mailbox->maintainingTask = 0;\n    }\n    if (model->accessParser(parser).maintainingTask == this) {\n        model->accessParser(parser).maintainingTask = 0;\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::detachFromMailbox()\n  {\n      if (mailboxIndex.isValid()) {\n          // Mark current mailbox as \"orphaned by the housekeeping task\"\n          TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailbox);\n  \n          // We're already obsolete -> don't pretend to accept new tasks\n          if (mailbox->maintainingTask == this)\n              mailbox->maintainingTask = 0;\n      }\n      if (model->accessParser(parser).maintainingTask == this) {\n          model->accessParser(parser).maintainingTask = 0;\n      }\n  }\n}"
  },
  {
    "function_name": "abort(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "584-596",
    "snippet": "oid KeepMailboxOpenTask::abort()\n{\n    if (noopTimer)\n        noopTimer->stop();\n    if (idleLauncher)\n        idleLauncher->die();\n\n    detachFromMailbox();\n\n    _aborted = true;\n    // We do not want to propagate the signal to the child tasks, though -- the KeepMailboxOpenTask::abort() is used in the course\n    // of the regular \"hey, free this connection and pass it to another KeepMailboxOpenTask\" situations.\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "etachFromMailbox(",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "detachFromMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "599-613",
          "snippet": "oid KeepMailboxOpenTask::detachFromMailbox()\n{\n    if (mailboxIndex.isValid()) {\n        // Mark current mailbox as \"orphaned by the housekeeping task\"\n        TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailbox);\n\n        // We're already obsolete -> don't pretend to accept new tasks\n        if (mailbox->maintainingTask == this)\n            mailbox->maintainingTask = 0;\n    }\n    if (model->accessParser(parser).maintainingTask == this) {\n        model->accessParser(parser).maintainingTask = 0;\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::detachFromMailbox()\n  {\n      if (mailboxIndex.isValid()) {\n          // Mark current mailbox as \"orphaned by the housekeeping task\"\n          TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailbox);\n  \n          // We're already obsolete -> don't pretend to accept new tasks\n          if (mailbox->maintainingTask == this)\n              mailbox->maintainingTask = 0;\n      }\n      if (model->accessParser(parser).maintainingTask == this) {\n          model->accessParser(parser).maintainingTask = 0;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dleLauncher->die",
          "args": [],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "105-111",
          "snippet": "oid IdleLauncher::die()\n{\n    delayedEnter->stop();\n    delayedEnter->disconnect();\n    renewal->stop();\n    renewal->disconnect();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::die()\n  {\n      delayedEnter->stop();\n      delayedEnter->disconnect();\n      renewal->stop();\n      renewal->disconnect();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oopTimer->stop",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::abort()\n  {\n      if (noopTimer)\n          noopTimer->stop();\n      if (idleLauncher)\n          idleLauncher->die();\n  \n      detachFromMailbox();\n  \n      _aborted = true;\n      // We do not want to propagate the signal to the child tasks, though -- the KeepMailboxOpenTask::abort() is used in the course\n      // of the regular \"hey, free this connection and pass it to another KeepMailboxOpenTask\" situations.\n  }\n}"
  },
  {
    "function_name": "handleStateHelper(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "506-573",
    "snippet": "ool KeepMailboxOpenTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    // FIXME: abort/die\n\n    if (handleResponseCodeInsideState(resp))\n        return true;\n\n    // FIXME: checks for shouldExit and proper boundaries?\n\n    if (resp->tag.isEmpty())\n        return false;\n\n    if (resp->tag == tagIdle) {\n\n        Q_ASSERT(idleLauncher);\n        if (resp->kind == Responses::OK) {\n            // The IDLE got terminated for whatever reason, so we should schedule its restart\n            idleLauncher->idleCommandCompleted();\n            if (canRunIdleRightNow()) {\n                idleLauncher->enterIdleLater();\n            }\n        } else {\n            // The IDLE command has failed. Let's assume it's a permanent error and don't request it in future.\n            log(\"The IDLE command has failed\");\n            shouldRunIdle = false;\n            idleLauncher->idleCommandFailed();\n            idleLauncher->deleteLater();\n            idleLauncher = 0;\n        }\n        tagIdle.clear();\n        // IDLE is special because it's not really a native Task. Therefore, we have to duplicate the check for its completion\n        // and possible termination request here.\n        // FIXME: maybe rewrite IDLE to be a native task and get all the benefits for free? Any drawbacks?\n        if (shouldExit && ! hasPendingInternalActions() && (! synchronizeConn || synchronizeConn->isFinished())) {\n            terminate();\n        }\n        return true;\n    } else if (newArrivalsFetch.contains(resp->tag)) {\n        newArrivalsFetch.removeOne(resp->tag);\n\n        if (newArrivalsFetch.isEmpty() && mailboxIndex.isValid()) {\n            // No pending commands for fetches of the mailbox state -> we have a consistent and accurate, up-to-date view\n            // -> we should save this\n            TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n            Q_ASSERT(mailbox);\n            mailbox->saveSyncStateAndUids(model);\n        }\n\n        if (resp->kind != Responses::OK) {\n            _failed(QLatin1String(\"FETCH of new arrivals failed: \") + resp->message);\n        }\n        // Don't forget to resume IDLE, if desired; that's easiest by simply behaving as if a \"task\" has just finished\n        slotTaskDeleted(0);\n        return true;\n    } else if (resp->tag == tagClose) {\n        tagClose.clear();\n        if (m_deleteCurrentMailboxTask) {\n            m_deleteCurrentMailboxTask->perform();\n        }\n        if (resp->kind != Responses::OK) {\n            _failed(QLatin1String(\"CLOSE failed: \") + resp->message);\n        }\n        terminate();\n        return true;\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "erminate(",
          "args": [],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "isReadyToTerminate(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "925-928",
          "snippet": "ool KeepMailboxOpenTask::isReadyToTerminate() const\n{\n    return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::isReadyToTerminate() const\n  {\n      return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Latin1String(\"CLOSE failed: \") + resp->message)"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CLOSE failed: \")"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_deleteCurrentMailboxTask->perform",
          "args": [],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "perform",
          "container": "UpdateFlagsOfAllMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/UpdateFlagsOfAllMessagesTask.cpp",
          "lines": "45-55",
          "snippet": "void UpdateFlagsOfAllMessagesTask::perform()\n{\n    Q_ASSERT(conn);\n    parser = conn->parser;\n\n    markAsActiveTask();\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    Sequence seq = Sequence::startingAt(1);\n    tag = parser->store(seq, toImapString(flagOperation), flags);\n}",
          "includes": [
            "#include \"KeepMailboxOpenTask.h\"",
            "#include \"Imap/Model/Model.h\"",
            "#include \"Imap/Model/MailboxTree.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include \"UpdateFlagsOfAllMessagesTask.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"KeepMailboxOpenTask.h\"\n#include \"Imap/Model/Model.h\"\n#include \"Imap/Model/MailboxTree.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include \"UpdateFlagsOfAllMessagesTask.h\"\n\nUpdateFlagsOfAllMessagesTask {\n  void UpdateFlagsOfAllMessagesTask::perform()\n  {\n      Q_ASSERT(conn);\n      parser = conn->parser;\n  \n      markAsActiveTask();\n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      Sequence seq = Sequence::startingAt(1);\n      tag = parser->store(seq, toImapString(flagOperation), flags);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "agClose.clear",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lotTaskDeleted(",
          "args": [
            ")"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "slotTaskDeleted(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "243-280",
          "snippet": "oid KeepMailboxOpenTask::slotTaskDeleted(QObject *object)\n{\n    if (_finished)\n        return;\n\n    if (!model->m_parsers.contains(parser)) {\n        // The parser is gone; we have to get out of here ASAP\n        _failed(\"Parser is gone\");\n        die(\"Parser is gone\");\n        return;\n    }\n    // FIXME: abort/die\n\n    // Now, object is no longer an ImapTask*, as this gets emitted from inside QObject's destructor. However,\n    // we can't use the passed pointer directly, and therefore we have to perform the cast here. It is safe\n    // to do that here, as we're only interested in raw pointer value.\n    if (object) {\n        dependentTasks.removeOne(static_cast<ImapTask *>(object));\n        dependingTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n        dependingTasksNoMailbox.removeOne(static_cast<ImapTask *>(object));\n        runningTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n        fetchPartTasks.removeOne(static_cast<FetchMsgPartTask *>(object));\n        fetchMetadataTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n        abortableTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n    }\n\n    if (isReadyToTerminate()) {\n        terminate();\n    } else if (shouldRunNoop) {\n        // A command just completed, and NOOPing is active, so let's schedule/postpone it again\n        noopTimer->start();\n    } else if (canRunIdleRightNow()) {\n        // A command just completed and IDLE is supported, so let's queue/schedule/postpone it\n        idleLauncher->enterIdleLater();\n    }\n    // It's possible that we can start more tasks at this time...\n    activateTasks();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotTaskDeleted(QObject *object)\n  {\n      if (_finished)\n          return;\n  \n      if (!model->m_parsers.contains(parser)) {\n          // The parser is gone; we have to get out of here ASAP\n          _failed(\"Parser is gone\");\n          die(\"Parser is gone\");\n          return;\n      }\n      // FIXME: abort/die\n  \n      // Now, object is no longer an ImapTask*, as this gets emitted from inside QObject's destructor. However,\n      // we can't use the passed pointer directly, and therefore we have to perform the cast here. It is safe\n      // to do that here, as we're only interested in raw pointer value.\n      if (object) {\n          dependentTasks.removeOne(static_cast<ImapTask *>(object));\n          dependingTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n          dependingTasksNoMailbox.removeOne(static_cast<ImapTask *>(object));\n          runningTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n          fetchPartTasks.removeOne(static_cast<FetchMsgPartTask *>(object));\n          fetchMetadataTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n          abortableTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n      }\n  \n      if (isReadyToTerminate()) {\n          terminate();\n      } else if (shouldRunNoop) {\n          // A command just completed, and NOOPing is active, so let's schedule/postpone it again\n          noopTimer->start();\n      } else if (canRunIdleRightNow()) {\n          // A command just completed and IDLE is supported, so let's queue/schedule/postpone it\n          idleLauncher->enterIdleLater();\n      }\n      // It's possible that we can start more tasks at this time...\n      activateTasks();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FETCH of new arrivals failed: \")"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->saveSyncStateAndUids",
          "args": [
            "odel)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateAndUids(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "564-576",
          "snippet": "oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n    if (list->m_unreadMessageCount != -1) {\n        syncState.setUnSeenCount(list->m_unreadMessageCount);\n    }\n    if (list->m_recentMessageCount != -1) {\n        syncState.setRecent(list->m_recentMessageCount);\n    }\n    model->cache()->setMailboxSyncState(mailbox(), syncState);\n    model->saveUidMap(list);\n    list->setFetchStatus(DONE);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::saveSyncStateAndUids(Model * model)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(m_children[0]);\n      if (list->m_unreadMessageCount != -1) {\n          syncState.setUnSeenCount(list->m_unreadMessageCount);\n      }\n      if (list->m_recentMessageCount != -1) {\n          syncState.setRecent(list->m_recentMessageCount);\n      }\n      model->cache()->setMailboxSyncState(mailbox(), syncState);\n      model->saveUidMap(list);\n      list->setFetchStatus(DONE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.isEmpty",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.removeOne",
          "args": [
            "esp->tag)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.contains",
          "args": [
            "esp->tag)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asPendingInternalActions(",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "hasPendingInternalActions(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "914-919",
          "snippet": "ool KeepMailboxOpenTask::hasPendingInternalActions() const\n{\n    bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n    return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n             requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::hasPendingInternalActions() const\n  {\n      bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n      return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n               requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dleLauncher->deleteLater",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dleLauncher->idleCommandFailed",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "idleCommandFailed(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "136-145",
          "snippet": "oid IdleLauncher::idleCommandFailed()\n{\n    // FIXME: these asseerts could be triggered by a rogue server...\n    Q_ASSERT(m_idling);\n    Q_ASSERT(m_idleCommandRunning);\n    renewal->stop();\n    m_idleCommandRunning = false;\n    task->parser->idleContinuationWontCome();\n    die();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::idleCommandFailed()\n  {\n      // FIXME: these asseerts could be triggered by a rogue server...\n      Q_ASSERT(m_idling);\n      Q_ASSERT(m_idleCommandRunning);\n      renewal->stop();\n      m_idleCommandRunning = false;\n      task->parser->idleContinuationWontCome();\n      die();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "og(",
          "args": [
            "The IDLE command has failed\")"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "log(",
          "container": "essageDownloader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/XtConnect/MessageDownloader.cpp",
          "lines": "57-60",
          "snippet": "oid MessageDownloader::log(const QString &message)\n{\n    m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n}",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Imap/Model/FindInterestingPart.h\"\n#",
            "include \"MessageDownloader.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Imap/Model/FindInterestingPart.h\"\n#\ninclude \"MessageDownloader.h\"\n#\n\nessageDownloader {\n  oid MessageDownloader::log(const QString &message)\n  {\n      m_model->logTrace(0, Common::LOG_OTHER, QLatin1String(\"MessageDownloader\"), message);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dleLauncher->enterIdleLater",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "enterIdleLater(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "97-103",
          "snippet": "oid IdleLauncher::enterIdleLater()\n{\n    if (m_idling)\n        return;\n\n    delayedEnter->start();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::enterIdleLater()\n  {\n      if (m_idling)\n          return;\n  \n      delayedEnter->start();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "anRunIdleRightNow(",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "canRunIdleRightNow(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "931-956",
          "snippet": "ool KeepMailboxOpenTask::canRunIdleRightNow() const\n{\n    bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n            dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n\n    // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n    // and that one more thing is a SortTask which is in the \"just updating\" mode.\n    // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n    // Nifty, isn't it?\n    if (model->accessParser(parser).activeTasks.size() > 1) {\n        if (model->accessParser(parser).activeTasks.size() == 2 &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n            // This is OK, so no need to clear the \"OK\" flag\n        } else {\n            // Too bad, cannot IDLE\n            res = false;\n        }\n    }\n\n    if (!res)\n        return false;\n\n    Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::canRunIdleRightNow() const\n  {\n      bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n              dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n  \n      // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n      // and that one more thing is a SortTask which is in the \"just updating\" mode.\n      // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n      // Nifty, isn't it?\n      if (model->accessParser(parser).activeTasks.size() > 1) {\n          if (model->accessParser(parser).activeTasks.size() == 2 &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n              // This is OK, so no need to clear the \"OK\" flag\n          } else {\n              // Too bad, cannot IDLE\n              res = false;\n          }\n      }\n  \n      if (!res)\n          return false;\n  \n      Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dleLauncher->idleCommandCompleted",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "idleCommandCompleted(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "123-134",
          "snippet": "oid IdleLauncher::idleCommandCompleted()\n{\n    // FIXME: these asseerts could be triggered by a rogue server...\n    if (m_idling) {\n        task->log(\"Warning: IDLE completed before we could ask for its termination...\", Common::LOG_MAILBOX_SYNC);\n        m_idling = false;\n        renewal->stop();\n        task->parser->idleMagicallyTerminatedByServer();\n    }\n    Q_ASSERT(m_idleCommandRunning);\n    m_idleCommandRunning = false;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::idleCommandCompleted()\n  {\n      // FIXME: these asseerts could be triggered by a rogue server...\n      if (m_idling) {\n          task->log(\"Warning: IDLE completed before we could ask for its termination...\", Common::LOG_MAILBOX_SYNC);\n          m_idling = false;\n          renewal->stop();\n          task->parser->idleMagicallyTerminatedByServer();\n      }\n      Q_ASSERT(m_idleCommandRunning);\n      m_idleCommandRunning = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "dleLauncher)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "andleResponseCodeInsideState(",
          "args": [
            "esp)"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "handleResponseCodeInsideState(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "804-884",
          "snippet": "ool KeepMailboxOpenTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n{\n    switch (resp->respCode) {\n    case Responses::UIDNEXT:\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setUidNext(num->data);\n            saveSyncStateNowOrLater(mailbox);\n            // We shouldn't eat tagged responses from this context\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::PERMANENTFLAGS:\n        // Another useless one, but we want to consume it now to prevent a warning about\n        // an unhandled message\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n        if (num) {\n            mailbox->syncState.setPermanentFlags(num->data);\n            // We shouldn't eat tagged responses from this context\n            return resp->tag.isEmpty();\n        } else {\n            throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n        }\n        break;\n    }\n    case Responses::HIGHESTMODSEQ:\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n        Q_ASSERT(num);\n        mailbox->syncState.setHighestModSeq(num->data);\n        saveSyncStateNowOrLater(mailbox);\n        return resp->tag.isEmpty();\n    }\n    case Responses::UIDVALIDITY:\n    {\n        if (dieIfInvalidMailbox())\n            return resp->tag.isEmpty();\n\n        TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n        Q_ASSERT(mailbox);\n        const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n        Q_ASSERT(num);\n        if (mailbox->syncState.uidValidity() == num->data) {\n            // this is a harmless and useless message\n            return resp->tag.isEmpty();\n        } else {\n            // On the other hand, this a serious condition -- the server is telling us that the UIDVALIDITY has changed while\n            // a mailbox is open. There isn't much we could do here; having code for handling this gracefuly is just too much\n            // work for little to no benefit.\n            // The sane thing is to disconnect from this mailbox.\n            EMIT_LATER(model, imapError, Q_ARG(QString, tr(\"The UIDVALIDITY has changed while mailbox is open. Please reconnect.\")));\n            model->setNetworkPolicy(NETWORK_OFFLINE);\n            return resp->tag.isEmpty();\n        }\n    }\n    default:\n        // Do nothing here\n        break;\n    }\n    return false;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleResponseCodeInsideState(const Imap::Responses::State *const resp)\n  {\n      switch (resp->respCode) {\n      case Responses::UIDNEXT:\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setUidNext(num->data);\n              saveSyncStateNowOrLater(mailbox);\n              // We shouldn't eat tagged responses from this context\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid UIDNEXT respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::PERMANENTFLAGS:\n          // Another useless one, but we want to consume it now to prevent a warning about\n          // an unhandled message\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<QStringList> *const num = dynamic_cast<const Responses::RespData<QStringList>* const>(resp->respCodeData.data());\n          if (num) {\n              mailbox->syncState.setPermanentFlags(num->data);\n              // We shouldn't eat tagged responses from this context\n              return resp->tag.isEmpty();\n          } else {\n              throw CantHappen(\"State response has invalid PERMANENTFLAGS respCodeData\", *resp);\n          }\n          break;\n      }\n      case Responses::HIGHESTMODSEQ:\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<quint64> *const num = dynamic_cast<const Responses::RespData<quint64>* const>(resp->respCodeData.data());\n          Q_ASSERT(num);\n          mailbox->syncState.setHighestModSeq(num->data);\n          saveSyncStateNowOrLater(mailbox);\n          return resp->tag.isEmpty();\n      }\n      case Responses::UIDVALIDITY:\n      {\n          if (dieIfInvalidMailbox())\n              return resp->tag.isEmpty();\n  \n          TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n          Q_ASSERT(mailbox);\n          const Responses::RespData<uint> *const num = dynamic_cast<const Responses::RespData<uint>* const>(resp->respCodeData.data());\n          Q_ASSERT(num);\n          if (mailbox->syncState.uidValidity() == num->data) {\n              // this is a harmless and useless message\n              return resp->tag.isEmpty();\n          } else {\n              // On the other hand, this a serious condition -- the server is telling us that the UIDVALIDITY has changed while\n              // a mailbox is open. There isn't much we could do here; having code for handling this gracefuly is just too much\n              // work for little to no benefit.\n              // The sane thing is to disconnect from this mailbox.\n              EMIT_LATER(model, imapError, Q_ARG(QString, tr(\"The UIDVALIDITY has changed while mailbox is open. Please reconnect.\")));\n              model->setNetworkPolicy(NETWORK_OFFLINE);\n              return resp->tag.isEmpty();\n          }\n      }\n      default:\n          // Do nothing here\n          break;\n      }\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      // FIXME: abort/die\n  \n      if (handleResponseCodeInsideState(resp))\n          return true;\n  \n      // FIXME: checks for shouldExit and proper boundaries?\n  \n      if (resp->tag.isEmpty())\n          return false;\n  \n      if (resp->tag == tagIdle) {\n  \n          Q_ASSERT(idleLauncher);\n          if (resp->kind == Responses::OK) {\n              // The IDLE got terminated for whatever reason, so we should schedule its restart\n              idleLauncher->idleCommandCompleted();\n              if (canRunIdleRightNow()) {\n                  idleLauncher->enterIdleLater();\n              }\n          } else {\n              // The IDLE command has failed. Let's assume it's a permanent error and don't request it in future.\n              log(\"The IDLE command has failed\");\n              shouldRunIdle = false;\n              idleLauncher->idleCommandFailed();\n              idleLauncher->deleteLater();\n              idleLauncher = 0;\n          }\n          tagIdle.clear();\n          // IDLE is special because it's not really a native Task. Therefore, we have to duplicate the check for its completion\n          // and possible termination request here.\n          // FIXME: maybe rewrite IDLE to be a native task and get all the benefits for free? Any drawbacks?\n          if (shouldExit && ! hasPendingInternalActions() && (! synchronizeConn || synchronizeConn->isFinished())) {\n              terminate();\n          }\n          return true;\n      } else if (newArrivalsFetch.contains(resp->tag)) {\n          newArrivalsFetch.removeOne(resp->tag);\n  \n          if (newArrivalsFetch.isEmpty() && mailboxIndex.isValid()) {\n              // No pending commands for fetches of the mailbox state -> we have a consistent and accurate, up-to-date view\n              // -> we should save this\n              TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n              Q_ASSERT(mailbox);\n              mailbox->saveSyncStateAndUids(model);\n          }\n  \n          if (resp->kind != Responses::OK) {\n              _failed(QLatin1String(\"FETCH of new arrivals failed: \") + resp->message);\n          }\n          // Don't forget to resume IDLE, if desired; that's easiest by simply behaving as if a \"task\" has just finished\n          slotTaskDeleted(0);\n          return true;\n      } else if (resp->tag == tagClose) {\n          tagClose.clear();\n          if (m_deleteCurrentMailboxTask) {\n              m_deleteCurrentMailboxTask->perform();\n          }\n          if (resp->kind != Responses::OK) {\n              _failed(QLatin1String(\"CLOSE failed: \") + resp->message);\n          }\n          terminate();\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "slotPerformNoop(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "500-504",
    "snippet": "oid KeepMailboxOpenTask::slotPerformNoop()\n{\n    // FIXME: abort/die\n    model->m_taskFactory->createNoopTask(model, this);\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createNoopTask",
          "args": [
            "odel,",
            "his)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotPerformNoop()\n  {\n      // FIXME: abort/die\n      model->m_taskFactory->createNoopTask(model, this);\n  }\n}"
  },
  {
    "function_name": "handleFetch(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "480-498",
    "snippet": "ool KeepMailboxOpenTask::handleFetch(const Imap::Responses::Fetch *const resp)\n{\n    if (dieIfInvalidMailbox())\n        return true;\n\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n\n    // FIXME: add proper boundaries\n    if (! isRunning)\n        return false;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    model->genericHandleFetch(mailbox, resp);\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->genericHandleFetch",
          "args": [
            "ailbox,",
            "esp)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Asked to die\")"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "894-912",
          "snippet": "ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    if (m_deleteCurrentMailboxTask) {\n        // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n        return true;\n    }\n\n    // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n    if (!unSelectTask && isRunning) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      if (m_deleteCurrentMailboxTask) {\n          // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n          return true;\n      }\n  \n      // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n      if (!unSelectTask && isRunning) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleFetch(const Imap::Responses::Fetch *const resp)\n  {\n      if (dieIfInvalidMailbox())\n          return true;\n  \n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n  \n      // FIXME: add proper boundaries\n      if (! isRunning)\n          return false;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      model->genericHandleFetch(mailbox, resp);\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleVanished(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "455-478",
    "snippet": "ool KeepMailboxOpenTask::handleVanished(const Responses::Vanished *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n\n    if (dieIfInvalidMailbox())\n        return true;\n\n    // FIXME: add proper boundaries\n    if (! isRunning)\n        return false;\n\n    if (resp->earlier != Responses::Vanished::NOT_EARLIER)\n        return false;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n\n    mailbox->handleVanished(model, *resp);\n    saveSyncStateNowOrLater(mailbox);\n    return true;\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aveSyncStateNowOrLater(",
          "args": [
            "ailbox)"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateNowOrLater(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "974-982",
          "snippet": "oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    if (list->fetched()) {\n        mailbox->saveSyncStateAndUids(model);\n    } else {\n        list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      if (list->fetched()) {\n          mailbox->saveSyncStateAndUids(model);\n      } else {\n          list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->handleVanished",
          "args": [
            "odel,",
            "resp)"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "handleVanished(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "609-736",
          "snippet": "oid TreeItemMailbox::handleVanished(Model *const model, const Responses::Vanished &resp)\n{\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n    Q_ASSERT(list);\n    QModelIndex listIndex = list->toIndex(model);\n\n    QList<uint> uids = resp.uids;\n    qSort(uids);\n    // Remove duplicates -- even that garbage can be present in a perfectly valid VANISHED :(\n    uids.erase(std::unique(uids.begin(), uids.end()), uids.end());\n\n    auto it = list->m_children.end();\n    while (!uids.isEmpty()) {\n        // We have to process each UID separately because the UIDs in the mailbox are not necessarily present\n        // in a continuous range; zeros might be present\n        uint uid = uids.takeLast();\n\n        if (uid == 0) {\n            qDebug() << \"VANISHED informs about removal of UID zero...\";\n            model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                            \"VANISHED contains UID zero for increased fun\");\n            break;\n        }\n\n        if (list->m_children.isEmpty()) {\n            // Well, it'd be cool to throw an exception here but VANISHED is free to contain references to UIDs which are not here\n            // at all...\n            qDebug() << \"VANISHED attempted to remove too many messages\";\n            model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                            \"VANISHED attempted to remove too many messages\");\n            break;\n        }\n\n        // Find a highest message with UID zero such as no message with non-zero UID higher than the current UID exists\n        // at a position after the target message\n        it = model->findMessageOrNextOneByUid(list, uid);\n\n        if (it == list->m_children.end()) {\n            // this is a legitimate situation, the UID of the last message in the mailbox which is getting expunged right now\n            // could very well be not know at this point\n            --it;\n        }\n        // there's a special case above guarding against an empty list\n        Q_ASSERT(it >= list->m_children.begin());\n\n        TreeItemMessage *msgCandidate = static_cast<TreeItemMessage*>(*it);\n        if (msgCandidate->uid() == uid) {\n            // will be deleted\n        } else if (resp.earlier == Responses::Vanished::EARLIER) {\n            // We don't have any such UID in our UID mapping, so we can safely ignore this one\n            continue;\n        } else if (msgCandidate->uid() == 0) {\n            // will be deleted\n        } else {\n            if (it != list->m_children.begin()) {\n                --it;\n                msgCandidate = static_cast<TreeItemMessage*>(*it);\n                if (msgCandidate->uid() == 0) {\n                    // will be deleted\n                } else {\n                    // VANISHED is free to refer to a non-existing UID...\n                    QString str;\n                    QTextStream ss(&str);\n                    ss << \"VANISHED refers to UID \" << uid << \" which wasn't found in the mailbox (found adjacent UIDs \" <<\n                          msgCandidate->uid() << \" and \" << static_cast<TreeItemMessage*>(*(it + 1))->uid() << \" with \" <<\n                          static_cast<TreeItemMessage*>(*(list->m_children.end() - 1))->uid() << \" at the end)\";\n                    ss.flush();\n                    qDebug() << str.toUtf8().constData();\n                    model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                    continue;\n                }\n            } else {\n                // Again, VANISHED can refer to non-existing UIDs\n                QString str;\n                QTextStream ss(&str);\n                ss << \"VANISHED refers to UID \" << uid << \" which is too low (lowest UID is \" <<\n                      static_cast<TreeItemMessage*>(list->m_children.front())->uid() << \")\";\n                ss.flush();\n                qDebug() << str.toUtf8().constData();\n                model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                continue;\n            }\n        }\n\n        int row = msgCandidate->row();\n        Q_ASSERT(row == it - list->m_children.begin());\n        model->beginRemoveRows(listIndex, row, row);\n        it = list->m_children.erase(it);\n        for (auto furtherMessage = it; furtherMessage != list->m_children.end(); ++furtherMessage) {\n            --static_cast<TreeItemMessage *>(*furtherMessage)->m_offset;\n        }\n        model->endRemoveRows();\n\n        if (syncState.uidNext() <= uid) {\n            // We're informed about a message being deleted; this means that that UID must have been in the mailbox for some\n            // (possibly tiny) time and we can therefore use it to get an idea about the UIDNEXT\n            syncState.setUidNext(uid + 1);\n        }\n        model->cache()->clearMessage(mailbox(), uid);\n        delete msgCandidate;\n    }\n\n    if (resp.earlier == Responses::Vanished::EARLIER && static_cast<uint>(list->m_children.size()) < syncState.exists()) {\n        // Okay, there were some new arrivals which we failed to take into account because we had processed EXISTS\n        // before VANISHED (EARLIER). That means that we have to add some of that messages back right now.\n        int newArrivals = syncState.exists() - list->m_children.size();\n        Q_ASSERT(newArrivals > 0);\n        QModelIndex parent = list->toIndex(model);\n        int offset = list->m_children.size();\n        model->beginInsertRows(parent, offset, syncState.exists() - 1);\n        for (int i = 0; i < newArrivals; ++i) {\n            TreeItemMessage *msg = new TreeItemMessage(list);\n            msg->m_offset = i + offset;\n            list->m_children << msg;\n            // yes, we really have to add this message with UID 0 :(\n        }\n        model->endInsertRows();\n    }\n\n    list->m_totalMessageCount = list->m_children.size();\n    syncState.setExists(list->m_totalMessageCount);\n    list->recalcVariousMessageCounts(const_cast<Model *>(model));\n\n    if (list->accessFetchStatus() == DONE) {\n        // Previously, we were synced, so we got to save this update\n        saveSyncStateAndUids(model);\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleVanished(Model *const model, const Responses::Vanished &resp)\n  {\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n      Q_ASSERT(list);\n      QModelIndex listIndex = list->toIndex(model);\n  \n      QList<uint> uids = resp.uids;\n      qSort(uids);\n      // Remove duplicates -- even that garbage can be present in a perfectly valid VANISHED :(\n      uids.erase(std::unique(uids.begin(), uids.end()), uids.end());\n  \n      auto it = list->m_children.end();\n      while (!uids.isEmpty()) {\n          // We have to process each UID separately because the UIDs in the mailbox are not necessarily present\n          // in a continuous range; zeros might be present\n          uint uid = uids.takeLast();\n  \n          if (uid == 0) {\n              qDebug() << \"VANISHED informs about removal of UID zero...\";\n              model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                              \"VANISHED contains UID zero for increased fun\");\n              break;\n          }\n  \n          if (list->m_children.isEmpty()) {\n              // Well, it'd be cool to throw an exception here but VANISHED is free to contain references to UIDs which are not here\n              // at all...\n              qDebug() << \"VANISHED attempted to remove too many messages\";\n              model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"),\n                              \"VANISHED attempted to remove too many messages\");\n              break;\n          }\n  \n          // Find a highest message with UID zero such as no message with non-zero UID higher than the current UID exists\n          // at a position after the target message\n          it = model->findMessageOrNextOneByUid(list, uid);\n  \n          if (it == list->m_children.end()) {\n              // this is a legitimate situation, the UID of the last message in the mailbox which is getting expunged right now\n              // could very well be not know at this point\n              --it;\n          }\n          // there's a special case above guarding against an empty list\n          Q_ASSERT(it >= list->m_children.begin());\n  \n          TreeItemMessage *msgCandidate = static_cast<TreeItemMessage*>(*it);\n          if (msgCandidate->uid() == uid) {\n              // will be deleted\n          } else if (resp.earlier == Responses::Vanished::EARLIER) {\n              // We don't have any such UID in our UID mapping, so we can safely ignore this one\n              continue;\n          } else if (msgCandidate->uid() == 0) {\n              // will be deleted\n          } else {\n              if (it != list->m_children.begin()) {\n                  --it;\n                  msgCandidate = static_cast<TreeItemMessage*>(*it);\n                  if (msgCandidate->uid() == 0) {\n                      // will be deleted\n                  } else {\n                      // VANISHED is free to refer to a non-existing UID...\n                      QString str;\n                      QTextStream ss(&str);\n                      ss << \"VANISHED refers to UID \" << uid << \" which wasn't found in the mailbox (found adjacent UIDs \" <<\n                            msgCandidate->uid() << \" and \" << static_cast<TreeItemMessage*>(*(it + 1))->uid() << \" with \" <<\n                            static_cast<TreeItemMessage*>(*(list->m_children.end() - 1))->uid() << \" at the end)\";\n                      ss.flush();\n                      qDebug() << str.toUtf8().constData();\n                      model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                      continue;\n                  }\n              } else {\n                  // Again, VANISHED can refer to non-existing UIDs\n                  QString str;\n                  QTextStream ss(&str);\n                  ss << \"VANISHED refers to UID \" << uid << \" which is too low (lowest UID is \" <<\n                        static_cast<TreeItemMessage*>(list->m_children.front())->uid() << \")\";\n                  ss.flush();\n                  qDebug() << str.toUtf8().constData();\n                  model->logTrace(listIndex.parent(), Common::LOG_MAILBOX_SYNC, QLatin1String(\"TreeItemMailbox::handleVanished\"), str);\n                  continue;\n              }\n          }\n  \n          int row = msgCandidate->row();\n          Q_ASSERT(row == it - list->m_children.begin());\n          model->beginRemoveRows(listIndex, row, row);\n          it = list->m_children.erase(it);\n          for (auto furtherMessage = it; furtherMessage != list->m_children.end(); ++furtherMessage) {\n              --static_cast<TreeItemMessage *>(*furtherMessage)->m_offset;\n          }\n          model->endRemoveRows();\n  \n          if (syncState.uidNext() <= uid) {\n              // We're informed about a message being deleted; this means that that UID must have been in the mailbox for some\n              // (possibly tiny) time and we can therefore use it to get an idea about the UIDNEXT\n              syncState.setUidNext(uid + 1);\n          }\n          model->cache()->clearMessage(mailbox(), uid);\n          delete msgCandidate;\n      }\n  \n      if (resp.earlier == Responses::Vanished::EARLIER && static_cast<uint>(list->m_children.size()) < syncState.exists()) {\n          // Okay, there were some new arrivals which we failed to take into account because we had processed EXISTS\n          // before VANISHED (EARLIER). That means that we have to add some of that messages back right now.\n          int newArrivals = syncState.exists() - list->m_children.size();\n          Q_ASSERT(newArrivals > 0);\n          QModelIndex parent = list->toIndex(model);\n          int offset = list->m_children.size();\n          model->beginInsertRows(parent, offset, syncState.exists() - 1);\n          for (int i = 0; i < newArrivals; ++i) {\n              TreeItemMessage *msg = new TreeItemMessage(list);\n              msg->m_offset = i + offset;\n              list->m_children << msg;\n              // yes, we really have to add this message with UID 0 :(\n          }\n          model->endInsertRows();\n      }\n  \n      list->m_totalMessageCount = list->m_children.size();\n      syncState.setExists(list->m_totalMessageCount);\n      list->recalcVariousMessageCounts(const_cast<Model *>(model));\n  \n      if (list->accessFetchStatus() == DONE) {\n          // Previously, we were synced, so we got to save this update\n          saveSyncStateAndUids(model);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "894-912",
          "snippet": "ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    if (m_deleteCurrentMailboxTask) {\n        // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n        return true;\n    }\n\n    // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n    if (!unSelectTask && isRunning) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      if (m_deleteCurrentMailboxTask) {\n          // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n          return true;\n      }\n  \n      // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n      if (!unSelectTask && isRunning) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Asked to die\")"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleVanished(const Responses::Vanished *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n  \n      if (dieIfInvalidMailbox())\n          return true;\n  \n      // FIXME: add proper boundaries\n      if (! isRunning)\n          return false;\n  \n      if (resp->earlier != Responses::Vanished::NOT_EARLIER)\n          return false;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n  \n      mailbox->handleVanished(model, *resp);\n      saveSyncStateNowOrLater(mailbox);\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleNumberResponse(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "390-453",
    "snippet": "ool KeepMailboxOpenTask::handleNumberResponse(const Imap::Responses::NumberResponse *const resp)\n{\n    if (_dead) {\n        _failed(\"Asked to die\");\n        return true;\n    }\n\n    if (dieIfInvalidMailbox())\n        return true;\n\n    // FIXME: add proper boundaries\n    if (! isRunning)\n        return false;\n\n    TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n    Q_ASSERT(mailbox);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    // FIXME: tests!\n    if (resp->kind == Imap::Responses::EXPUNGE) {\n        mailbox->handleExpunge(model, *resp);\n        mailbox->syncState.setExists(mailbox->syncState.exists() - 1);\n        saveSyncStateNowOrLater(mailbox);\n        return true;\n    } else if (resp->kind == Imap::Responses::EXISTS) {\n\n        if (resp->number == static_cast<uint>(list->m_children.size())) {\n            // no changes\n            return true;\n        }\n\n        mailbox->handleExists(model, *resp);\n\n        breakOrCancelPossibleIdle();\n\n        Q_ASSERT(list->m_children.size());\n        uint highestKnownUid = 0;\n        for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n            highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n            //qDebug() << \"UID disco: trying seq\" << i << highestKnownUid;\n        }\n        breakOrCancelPossibleIdle();\n        newArrivalsFetch.append(parser->uidFetch(Sequence::startingAt(\n                                                // Did the UID walk return a usable number?\n                                                highestKnownUid ?\n                                                // Yes, we've got at least one message with a UID known -> ask for higher\n                                                // but don't forget to compensate for an pre-existing UIDNEXT value\n                                                qMax(mailbox->syncState.uidNext(), highestKnownUid + 1)\n                                                :\n                                                // No messages, or no messages with valid UID -> use the UIDNEXT from the syncing state\n                                                // but prevent a possible invalid 0:*\n                                                qMax(mailbox->syncState.uidNext(), 1u)\n                                            ), QStringList() << QLatin1String(\"FLAGS\")));\n        return true;\n    } else if (resp->kind == Imap::Responses::RECENT) {\n        mailbox->syncState.setRecent(resp->number);\n        list->m_recentMessageCount = resp->number;\n        model->emitMessageCountChanged(mailbox);\n        saveSyncStateNowOrLater(mailbox);\n        return true;\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aveSyncStateNowOrLater(",
          "args": [
            "ailbox)"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "saveSyncStateNowOrLater(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "974-982",
          "snippet": "oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    if (list->fetched()) {\n        mailbox->saveSyncStateAndUids(model);\n    } else {\n        list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::saveSyncStateNowOrLater(Imap::Mailbox::TreeItemMailbox *mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      if (list->fetched()) {\n          mailbox->saveSyncStateAndUids(model);\n      } else {\n          list->setFetchStatus(Imap::Mailbox::TreeItem::LOADING);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->emitMessageCountChanged",
          "args": [
            "ailbox)"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "emitMessageCountChanged(",
          "container": "odel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/Model.cpp",
          "lines": "495-501",
          "snippet": "oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n{\n    TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n    QModelIndex msgListIndex = list->toIndex(this);\n    emit dataChanged(msgListIndex, msgListIndex);\n    emit messageCountPossiblyChanged(mailbox->toIndex(this));\n}",
          "includes": [
            "include \"Streams/SocketFactory.h\"",
            "include \"Imap/Tasks/UpdateFlagsTask.h\"\n#",
            "include \"Imap/Tasks/OpenConnectionTask.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Tasks/GetAnyConnectionTask.h\"\n#",
            "include \"Imap/Tasks/AppendTask.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include \"TaskPresentationModel.h\"\n#",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"QAIM_reset.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"Model.h\"\n#",
            "include <QtAlgorithms>\n#",
            "include <QDebug>\n#",
            "include <QCoreApplication>\n#",
            "include <QAuthenticator>\n#",
            "include <QAbstractProxyModel>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Streams/SocketFactory.h\"\ninclude \"Imap/Tasks/UpdateFlagsTask.h\"\n#\ninclude \"Imap/Tasks/OpenConnectionTask.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Tasks/GetAnyConnectionTask.h\"\n#\ninclude \"Imap/Tasks/AppendTask.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude \"TaskPresentationModel.h\"\n#\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"QAIM_reset.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"Model.h\"\n#\ninclude <QtAlgorithms>\n#\ninclude <QDebug>\n#\ninclude <QCoreApplication>\n#\ninclude <QAuthenticator>\n#\ninclude <QAbstractProxyModel>\n#\n\nodel {\n  oid Model::emitMessageCountChanged(TreeItemMailbox *const mailbox)\n  {\n      TreeItemMsgList *list = static_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      QModelIndex msgListIndex = list->toIndex(this);\n      emit dataChanged(msgListIndex, msgListIndex);\n      emit messageCountPossiblyChanged(mailbox->toIndex(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setRecent",
          "args": [
            "esp->number)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ewArrivalsFetch.append",
          "args": [
            "arser->uidFetch(Sequence::startingAt(\n                                                // Did the UID walk return a usable number?\n                                                highestKnownUid ?\n                                                // Yes, we've got at least one message with a UID known -> ask for higher\n                                                // but don't forget to compensate for an pre-existing UIDNEXT value\n                                                qMax(mailbox->syncState.uidNext(), highestKnownUid + 1)\n                                                :\n                                                // No messages, or no messages with valid UID -> use the UIDNEXT from the syncing state\n                                                // but prevent a possible invalid 0:*\n                                                qMax(mailbox->syncState.uidNext(), 1u)\n                                            ), QStringList() << QLatin1String(\"FLAGS\")))"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->uidFetch",
          "args": [
            "equence::startingAt(\n                                                // Did the UID walk return a usable number?\n                                                highestKnownUid ?\n                                                // Yes, we've got at least one message with a UID known -> ask for higher\n                                                // but don't forget to compensate for an pre-existing UIDNEXT value\n                                                qMax(mailbox->syncState.uidNext(), highestKnownUid + 1)\n                                                :\n                                                // No messages, or no messages with valid UID -> use the UIDNEXT from the syncing state\n                                                // but prevent a possible invalid 0:*\n                                                qMax(mailbox->syncState.uidNext(), 1u)\n                                            ),",
            "StringList() << QLatin1String(\"FLAGS\"))"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "uidFetch(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "460-465",
          "snippet": "ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n{\n    return queueCommand(Commands::Command(\"UID FETCH\") <<\n                        Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                        Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidFetch(const Sequence &seq, const QStringList &items)\n  {\n      return queueCommand(Commands::Command(\"UID FETCH\") <<\n                          Commands::PartOfCommand(Commands::ATOM, seq.toByteArray()) <<\n                          Commands::PartOfCommand(Commands::ATOM, '(' + items.join(QLatin1String(\" \")).toUtf8() + ')'));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "FLAGS\")"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equence::startingAt(",
          "args": [
            "/ Did the UID walk return a usable number?\nighestKnownUid ?\n                                                // Yes, we've got at least one message with a UID known -> ask for higher\n                                                // but don't forget to compensate for an pre-existing UIDNEXT value\n                                                qMax(mailbox->syncState.uidNext(), highestKnownUid + 1)\n                                                :\n                                                // No messages, or no messages with valid UID -> use the UIDNEXT from the syncing state\n                                                // but prevent a possible invalid 0:*\n                                                qMax(mailbox->syncState.uidNext(), 1u)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "startingAt(",
          "container": "equence",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Sequence.cpp",
          "lines": "35-41",
          "snippet": "equence Sequence::startingAt(const uint lo)\n{\n    Sequence res(lo);\n    res.lo = lo;\n    res.kind = UNLIMITED;\n    return res;\n}",
          "includes": [
            "include <QTextStream>",
            "include <QStringList>\n#",
            "include \"Sequence.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QTextStream>\ninclude <QStringList>\n#\ninclude \"Sequence.h\"\n#\n\nequence {\n  equence Sequence::startingAt(const uint lo)\n  {\n      Sequence res(lo);\n      res.lo = lo;\n      res.kind = UNLIMITED;\n      return res;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            "ailbox->syncState.uidNext(),",
            "u)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidNext",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max(",
          "args": [
            "ailbox->syncState.uidNext(),",
            "ighestKnownUid + 1)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.uidNext",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reakOrCancelPossibleIdle(",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "breakOrCancelPossibleIdle(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "797-802",
          "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<const TreeItemMessage *>",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<const TreeItemMessage *>",
          "args": [
            "ist->m_children[i])"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->handleExists",
          "args": [
            "odel,",
            "resp)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "handleExists(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "742-773",
          "snippet": "oid TreeItemMailbox::handleExists(Model *const model, const Responses::NumberResponse &resp)\n{\n    Q_ASSERT(resp.kind == Responses::EXISTS);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[0]);\n    Q_ASSERT(list);\n    // This is a bit tricky -- unfortunately, we can't assume anything about the UID of new arrivals. On the other hand,\n    // these messages can be referenced by (even unrequested) FETCH responses and deleted by EXPUNGE, so we really want\n    // to add them to the tree.\n    int newArrivals = resp.number - list->m_children.size();\n    if (newArrivals < 0) {\n        throw UnexpectedResponseReceived(\"EXISTS response attempted to decrease number of messages\", resp);\n    }\n    syncState.setExists(resp.number);\n    if (newArrivals == 0) {\n        // remains unchanged...\n        return;\n    }\n\n    QModelIndex parent = list->toIndex(model);\n    int offset = list->m_children.size();\n    model->beginInsertRows(parent, offset, resp.number - 1);\n    for (int i = 0; i < newArrivals; ++i) {\n        TreeItemMessage *msg = new TreeItemMessage(list);\n        msg->m_offset = i + offset;\n        list->m_children << msg;\n        // yes, we really have to add this message with UID 0 :(\n    }\n    model->endInsertRows();\n    list->m_totalMessageCount = resp.number;\n    list->setFetchStatus(LOADING);\n    model->emitMessageCountChanged(this);\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleExists(Model *const model, const Responses::NumberResponse &resp)\n  {\n      Q_ASSERT(resp.kind == Responses::EXISTS);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[0]);\n      Q_ASSERT(list);\n      // This is a bit tricky -- unfortunately, we can't assume anything about the UID of new arrivals. On the other hand,\n      // these messages can be referenced by (even unrequested) FETCH responses and deleted by EXPUNGE, so we really want\n      // to add them to the tree.\n      int newArrivals = resp.number - list->m_children.size();\n      if (newArrivals < 0) {\n          throw UnexpectedResponseReceived(\"EXISTS response attempted to decrease number of messages\", resp);\n      }\n      syncState.setExists(resp.number);\n      if (newArrivals == 0) {\n          // remains unchanged...\n          return;\n      }\n  \n      QModelIndex parent = list->toIndex(model);\n      int offset = list->m_children.size();\n      model->beginInsertRows(parent, offset, resp.number - 1);\n      for (int i = 0; i < newArrivals; ++i) {\n          TreeItemMessage *msg = new TreeItemMessage(list);\n          msg->m_offset = i + offset;\n          list->m_children << msg;\n          // yes, we really have to add this message with UID 0 :(\n      }\n      model->endInsertRows();\n      list->m_totalMessageCount = resp.number;\n      list->setFetchStatus(LOADING);\n      model->emitMessageCountChanged(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tatic_cast<uint>",
          "args": [
            "ist->m_children.size())"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->m_children.size",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.setExists",
          "args": [
            "ailbox->syncState.exists() - 1)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->syncState.exists",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->handleExpunge",
          "args": [
            "odel,",
            "resp)"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "handleExpunge(",
          "container": "reeItemMailbox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "579-607",
          "snippet": "oid TreeItemMailbox::handleExpunge(Model *const model, const Responses::NumberResponse &resp)\n{\n    Q_ASSERT(resp.kind == Responses::EXPUNGE);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n    Q_ASSERT(list);\n    if (resp.number > static_cast<uint>(list->m_children.size()) || resp.number == 0) {\n        throw UnknownMessageIndex(\"EXPUNGE references message number which is out-of-bounds\");\n    }\n    uint offset = resp.number - 1;\n\n    model->beginRemoveRows(list->toIndex(model), offset, offset);\n    auto it = list->m_children.begin() + offset;\n    TreeItemMessage *message = static_cast<TreeItemMessage *>(*it);\n    list->m_children.erase(it);\n    model->cache()->clearMessage(static_cast<TreeItemMailbox *>(list->parent())->mailbox(), message->uid());\n    for (int i = offset; i < list->m_children.size(); ++i) {\n        --static_cast<TreeItemMessage *>(list->m_children[i])->m_offset;\n    }\n    model->endRemoveRows();\n    delete message;\n\n    --list->m_totalMessageCount;\n    list->recalcVariousMessageCounts(const_cast<Model *>(model));\n\n    if (list->accessFetchStatus() == DONE) {\n        // Previously, we were synced, so we got to save this update\n        saveSyncStateAndUids(model);\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMailbox {\n  oid TreeItemMailbox::handleExpunge(Model *const model, const Responses::NumberResponse &resp)\n  {\n      Q_ASSERT(resp.kind == Responses::EXPUNGE);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(m_children[ 0 ]);\n      Q_ASSERT(list);\n      if (resp.number > static_cast<uint>(list->m_children.size()) || resp.number == 0) {\n          throw UnknownMessageIndex(\"EXPUNGE references message number which is out-of-bounds\");\n      }\n      uint offset = resp.number - 1;\n  \n      model->beginRemoveRows(list->toIndex(model), offset, offset);\n      auto it = list->m_children.begin() + offset;\n      TreeItemMessage *message = static_cast<TreeItemMessage *>(*it);\n      list->m_children.erase(it);\n      model->cache()->clearMessage(static_cast<TreeItemMailbox *>(list->parent())->mailbox(), message->uid());\n      for (int i = offset; i < list->m_children.size(); ++i) {\n          --static_cast<TreeItemMessage *>(list->m_children[i])->m_offset;\n      }\n      model->endRemoveRows();\n      delete message;\n  \n      --list->m_totalMessageCount;\n      list->recalcVariousMessageCounts(const_cast<Model *>(model));\n  \n      if (list->accessFetchStatus() == DONE) {\n          // Previously, we were synced, so we got to save this update\n          saveSyncStateAndUids(model);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList *>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel::mailboxForSomeItem(",
          "args": [
            "ailboxIndex)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ieIfInvalidMailbox(",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "dieIfInvalidMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "894-912",
          "snippet": "ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n{\n    if (mailboxIndex.isValid())\n        return false;\n\n    if (m_deleteCurrentMailboxTask) {\n        // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n        return true;\n    }\n\n    // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n    if (!unSelectTask && isRunning) {\n        unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n        connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n        unSelectTask->perform();\n    }\n\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::dieIfInvalidMailbox()\n  {\n      if (mailboxIndex.isValid())\n          return false;\n  \n      if (m_deleteCurrentMailboxTask) {\n          // The current mailbox was supposed to be deleted; don't try to UNSELECT from this context\n          return true;\n      }\n  \n      // See ObtainSynchronizedMailboxTask::dieIfInvalidMailbox() for details\n      if (!unSelectTask && isRunning) {\n          unSelectTask = model->m_taskFactory->createUnSelectTask(model, this);\n          connect(unSelectTask, SIGNAL(completed(Imap::Mailbox::ImapTask *)), this, SLOT(slotUnselected()));\n          unSelectTask->perform();\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Asked to die\")"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::handleNumberResponse(const Imap::Responses::NumberResponse *const resp)\n  {\n      if (_dead) {\n          _failed(\"Asked to die\");\n          return true;\n      }\n  \n      if (dieIfInvalidMailbox())\n          return true;\n  \n      // FIXME: add proper boundaries\n      if (! isRunning)\n          return false;\n  \n      TreeItemMailbox *mailbox = Model::mailboxForSomeItem(mailboxIndex);\n      Q_ASSERT(mailbox);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList *>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      // FIXME: tests!\n      if (resp->kind == Imap::Responses::EXPUNGE) {\n          mailbox->handleExpunge(model, *resp);\n          mailbox->syncState.setExists(mailbox->syncState.exists() - 1);\n          saveSyncStateNowOrLater(mailbox);\n          return true;\n      } else if (resp->kind == Imap::Responses::EXISTS) {\n  \n          if (resp->number == static_cast<uint>(list->m_children.size())) {\n              // no changes\n              return true;\n          }\n  \n          mailbox->handleExists(model, *resp);\n  \n          breakOrCancelPossibleIdle();\n  \n          Q_ASSERT(list->m_children.size());\n          uint highestKnownUid = 0;\n          for (int i = list->m_children.size() - 1; ! highestKnownUid && i >= 0; --i) {\n              highestKnownUid = static_cast<const TreeItemMessage *>(list->m_children[i])->uid();\n              //qDebug() << \"UID disco: trying seq\" << i << highestKnownUid;\n          }\n          breakOrCancelPossibleIdle();\n          newArrivalsFetch.append(parser->uidFetch(Sequence::startingAt(\n                                                  // Did the UID walk return a usable number?\n                                                  highestKnownUid ?\n                                                  // Yes, we've got at least one message with a UID known -> ask for higher\n                                                  // but don't forget to compensate for an pre-existing UIDNEXT value\n                                                  qMax(mailbox->syncState.uidNext(), highestKnownUid + 1)\n                                                  :\n                                                  // No messages, or no messages with valid UID -> use the UIDNEXT from the syncing state\n                                                  // but prevent a possible invalid 0:*\n                                                  qMax(mailbox->syncState.uidNext(), 1u)\n                                              ), QStringList() << QLatin1String(\"FLAGS\")));\n          return true;\n      } else if (resp->kind == Imap::Responses::RECENT) {\n          mailbox->syncState.setRecent(resp->number);\n          list->m_recentMessageCount = resp->number;\n          model->emitMessageCountChanged(mailbox);\n          saveSyncStateNowOrLater(mailbox);\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "resynchronizeMailbox(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "376-388",
    "snippet": "oid KeepMailboxOpenTask::resynchronizeMailbox()\n{\n    // FIXME: abort/die\n\n    if (isRunning) {\n        // Instead of wild magic with re-creating synchronizeConn, it's way easier to\n        // just have us replaced by another KeepMailboxOpenTask\n        model->m_taskFactory->createKeepMailboxOpenTask(model, mailboxIndex, parser);\n    } else {\n        // We aren't running yet, which means that the sync hadn't happened yet, and therefore\n        // we don't have to do it \"once again\" -- it will happen automatically later on.\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createKeepMailboxOpenTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            "arser)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::resynchronizeMailbox()\n  {\n      // FIXME: abort/die\n  \n      if (isRunning) {\n          // Instead of wild magic with re-creating synchronizeConn, it's way easier to\n          // just have us replaced by another KeepMailboxOpenTask\n          model->m_taskFactory->createKeepMailboxOpenTask(model, mailboxIndex, parser);\n      } else {\n          // We aren't running yet, which means that the sync hadn't happened yet, and therefore\n          // we don't have to do it \"once again\" -- it will happen automatically later on.\n      }\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "339-374",
    "snippet": "oid KeepMailboxOpenTask::perform()\n{\n    // FIXME: abort/die\n\n    Q_ASSERT(synchronizeConn);\n    Q_ASSERT(synchronizeConn->isFinished());\n    parser = synchronizeConn->parser;\n    synchronizeConn = 0; // will get deleted by Model\n    markAsActiveTask();\n\n    isRunning = true;\n    fetchPartTimer->start();\n    fetchEnvelopeTimer->start();\n\n    if (!waitingObtainTasks.isEmpty()) {\n        shouldExit = true;\n    }\n\n    activateTasks();\n\n    if (model->accessParser(parser).capabilitiesFresh && model->accessParser(parser).capabilities.contains(\"IDLE\")) {\n        shouldRunIdle = true;\n    } else {\n        shouldRunNoop = true;\n    }\n\n    if (shouldRunNoop) {\n        noopTimer->start();\n    } else if (shouldRunIdle) {\n        idleLauncher = new IdleLauncher(this);\n        if (canRunIdleRightNow()) {\n            // There's no task yet, so we have to start IDLE now\n            idleLauncher->enterIdleLater();\n        }\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dleLauncher->enterIdleLater",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "enterIdleLater(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "97-103",
          "snippet": "oid IdleLauncher::enterIdleLater()\n{\n    if (m_idling)\n        return;\n\n    delayedEnter->start();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::enterIdleLater()\n  {\n      if (m_idling)\n          return;\n  \n      delayedEnter->start();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "anRunIdleRightNow(",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "canRunIdleRightNow(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "931-956",
          "snippet": "ool KeepMailboxOpenTask::canRunIdleRightNow() const\n{\n    bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n            dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n\n    // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n    // and that one more thing is a SortTask which is in the \"just updating\" mode.\n    // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n    // Nifty, isn't it?\n    if (model->accessParser(parser).activeTasks.size() > 1) {\n        if (model->accessParser(parser).activeTasks.size() == 2 &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n            // This is OK, so no need to clear the \"OK\" flag\n        } else {\n            // Too bad, cannot IDLE\n            res = false;\n        }\n    }\n\n    if (!res)\n        return false;\n\n    Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::canRunIdleRightNow() const\n  {\n      bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n              dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n  \n      // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n      // and that one more thing is a SortTask which is in the \"just updating\" mode.\n      // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n      // Nifty, isn't it?\n      if (model->accessParser(parser).activeTasks.size() > 1) {\n          if (model->accessParser(parser).activeTasks.size() == 2 &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n              // This is OK, so no need to clear the \"OK\" flag\n          } else {\n              // Too bad, cannot IDLE\n              res = false;\n          }\n      }\n  \n      if (!res)\n          return false;\n  \n      Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oopTimer->start",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "IDLE\")"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctivateTasks(",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "activateTasks(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "693-726",
          "snippet": "oid KeepMailboxOpenTask::activateTasks()\n{\n    // FIXME: abort/die\n\n    if (!isRunning)\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    if (m_deleteCurrentMailboxTask) {\n        closeMailboxDestructively();\n        return;\n    }\n\n    slotFetchRequestedEnvelopes();\n    slotFetchRequestedParts();\n\n    while (!dependingTasksForThisMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n        breakOrCancelPossibleIdle();\n        ImapTask *task = dependingTasksForThisMailbox.takeFirst();\n        runningTasksForThisMailbox.append(task);\n        dependentTasks.removeOne(task);\n        task->perform();\n    }\n    while (!dependingTasksNoMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n        breakOrCancelPossibleIdle();\n        ImapTask *task = dependingTasksNoMailbox.takeFirst();\n        dependentTasks.removeOne(task);\n        task->perform();\n    }\n\n    if (idleLauncher && canRunIdleRightNow())\n        idleLauncher->enterIdleLater();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::activateTasks()\n  {\n      // FIXME: abort/die\n  \n      if (!isRunning)\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      if (m_deleteCurrentMailboxTask) {\n          closeMailboxDestructively();\n          return;\n      }\n  \n      slotFetchRequestedEnvelopes();\n      slotFetchRequestedParts();\n  \n      while (!dependingTasksForThisMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n          breakOrCancelPossibleIdle();\n          ImapTask *task = dependingTasksForThisMailbox.takeFirst();\n          runningTasksForThisMailbox.append(task);\n          dependentTasks.removeOne(task);\n          task->perform();\n      }\n      while (!dependingTasksNoMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n          breakOrCancelPossibleIdle();\n          ImapTask *task = dependingTasksNoMailbox.takeFirst();\n          dependentTasks.removeOne(task);\n          task->perform();\n      }\n  \n      if (idleLauncher && canRunIdleRightNow())\n          idleLauncher->enterIdleLater();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "aitingObtainTasks.isEmpty",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchEnvelopeTimer->start",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchPartTimer->start",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ynchronizeConn->isFinished())"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ynchronizeConn)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::perform()\n  {\n      // FIXME: abort/die\n  \n      Q_ASSERT(synchronizeConn);\n      Q_ASSERT(synchronizeConn->isFinished());\n      parser = synchronizeConn->parser;\n      synchronizeConn = 0; // will get deleted by Model\n      markAsActiveTask();\n  \n      isRunning = true;\n      fetchPartTimer->start();\n      fetchEnvelopeTimer->start();\n  \n      if (!waitingObtainTasks.isEmpty()) {\n          shouldExit = true;\n      }\n  \n      activateTasks();\n  \n      if (model->accessParser(parser).capabilitiesFresh && model->accessParser(parser).capabilities.contains(\"IDLE\")) {\n          shouldRunIdle = true;\n      } else {\n          shouldRunNoop = true;\n      }\n  \n      if (shouldRunNoop) {\n          noopTimer->start();\n      } else if (shouldRunIdle) {\n          idleLauncher = new IdleLauncher(this);\n          if (canRunIdleRightNow()) {\n              // There's no task yet, so we have to start IDLE now\n              idleLauncher->enterIdleLater();\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "terminate(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "282-337",
    "snippet": "oid KeepMailboxOpenTask::terminate()\n{\n    if (_aborted) {\n        // We've already been there, so we *cannot* proceed towards activating our replacement tasks\n        return;\n    }\n    abort();\n    detachFromMailbox();\n\n    // FIXME: abort/die\n\n    Q_ASSERT(dependingTasksForThisMailbox.isEmpty());\n    Q_ASSERT(dependingTasksNoMailbox.isEmpty());\n    Q_ASSERT(requestedParts.isEmpty());\n    Q_ASSERT(requestedEnvelopes.isEmpty());\n    Q_ASSERT(runningTasksForThisMailbox.isEmpty());\n    Q_ASSERT(abortableTasks.isEmpty());\n\n    // Break periodic activities\n    if (idleLauncher) {\n        // got to break the IDLE cycle and especially make sure it won't restart\n        idleLauncher->die();\n    }\n    shouldRunIdle = false;\n    shouldRunNoop = false;\n    isRunning = false;\n\n    // Merge the lists of waiting tasks\n    if (!waitingObtainTasks.isEmpty()) {\n        ObtainSynchronizedMailboxTask *first = waitingObtainTasks.takeFirst();\n        dependentTasks.removeOne(first);\n        Q_ASSERT(first);\n        Q_ASSERT(first->keepTaskChild);\n        Q_ASSERT(first->keepTaskChild->synchronizeConn == first);\n\n        CHECK_TASK_TREE\n        // Update the parent information for the moved tasks\n        Q_FOREACH(ObtainSynchronizedMailboxTask *movedObtainTask, waitingObtainTasks) {\n            Q_ASSERT(movedObtainTask->parentTask);\n            movedObtainTask->parentTask->dependentTasks.removeOne(movedObtainTask);\n            movedObtainTask->parentTask = first->keepTaskChild;\n            first->keepTaskChild->dependentTasks.append(movedObtainTask);\n        }\n        CHECK_TASK_TREE\n\n        // And launch the replacement\n        first->keepTaskChild->waitingObtainTasks = waitingObtainTasks + first->keepTaskChild->waitingObtainTasks;\n        model->accessParser(parser).maintainingTask = first->keepTaskChild;\n        first->keepTaskChild->slotPerformConnection();\n    } else {\n        Q_ASSERT(dependentTasks.isEmpty());\n    }\n    _finished = true;\n    emit completed(this);\n    CHECK_TASK_TREE\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ependentTasks.isEmpty())"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependentTasks.isEmpty",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irst->keepTaskChild->slotPerformConnection",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irst->keepTaskChild->dependentTasks.append",
          "args": [
            "ovedObtainTask)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovedObtainTask->parentTask->dependentTasks.removeOne",
          "args": [
            "ovedObtainTask)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ovedObtainTask->parentTask)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irst->keepTaskChild->synchronizeConn == first)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irst->keepTaskChild)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "irst)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependentTasks.removeOne",
          "args": [
            "irst)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aitingObtainTasks.takeFirst",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aitingObtainTasks.isEmpty",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dleLauncher->die",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "105-111",
          "snippet": "oid IdleLauncher::die()\n{\n    delayedEnter->stop();\n    delayedEnter->disconnect();\n    renewal->stop();\n    renewal->disconnect();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::die()\n  {\n      delayedEnter->stop();\n      delayedEnter->disconnect();\n      renewal->stop();\n      renewal->disconnect();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "bortableTasks.isEmpty())"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bortableTasks.isEmpty",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "unningTasksForThisMailbox.isEmpty())"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unningTasksForThisMailbox.isEmpty",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "equestedEnvelopes.isEmpty())"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedEnvelopes.isEmpty",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "equestedParts.isEmpty())"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equestedParts.isEmpty",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ependingTasksNoMailbox.isEmpty())"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.isEmpty",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ependingTasksForThisMailbox.isEmpty())"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.isEmpty",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etachFromMailbox(",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "detachFromMailbox(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "599-613",
          "snippet": "oid KeepMailboxOpenTask::detachFromMailbox()\n{\n    if (mailboxIndex.isValid()) {\n        // Mark current mailbox as \"orphaned by the housekeeping task\"\n        TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n        Q_ASSERT(mailbox);\n\n        // We're already obsolete -> don't pretend to accept new tasks\n        if (mailbox->maintainingTask == this)\n            mailbox->maintainingTask = 0;\n    }\n    if (model->accessParser(parser).maintainingTask == this) {\n        model->accessParser(parser).maintainingTask = 0;\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::detachFromMailbox()\n  {\n      if (mailboxIndex.isValid()) {\n          // Mark current mailbox as \"orphaned by the housekeeping task\"\n          TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n          Q_ASSERT(mailbox);\n  \n          // We're already obsolete -> don't pretend to accept new tasks\n          if (mailbox->maintainingTask == this)\n              mailbox->maintainingTask = 0;\n      }\n      if (model->accessParser(parser).maintainingTask == this) {\n          model->accessParser(parser).maintainingTask = 0;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bort(",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "abort(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "584-596",
          "snippet": "oid KeepMailboxOpenTask::abort()\n{\n    if (noopTimer)\n        noopTimer->stop();\n    if (idleLauncher)\n        idleLauncher->die();\n\n    detachFromMailbox();\n\n    _aborted = true;\n    // We do not want to propagate the signal to the child tasks, though -- the KeepMailboxOpenTask::abort() is used in the course\n    // of the regular \"hey, free this connection and pass it to another KeepMailboxOpenTask\" situations.\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::abort()\n  {\n      if (noopTimer)\n          noopTimer->stop();\n      if (idleLauncher)\n          idleLauncher->die();\n  \n      detachFromMailbox();\n  \n      _aborted = true;\n      // We do not want to propagate the signal to the child tasks, though -- the KeepMailboxOpenTask::abort() is used in the course\n      // of the regular \"hey, free this connection and pass it to another KeepMailboxOpenTask\" situations.\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::terminate()\n  {\n      if (_aborted) {\n          // We've already been there, so we *cannot* proceed towards activating our replacement tasks\n          return;\n      }\n      abort();\n      detachFromMailbox();\n  \n      // FIXME: abort/die\n  \n      Q_ASSERT(dependingTasksForThisMailbox.isEmpty());\n      Q_ASSERT(dependingTasksNoMailbox.isEmpty());\n      Q_ASSERT(requestedParts.isEmpty());\n      Q_ASSERT(requestedEnvelopes.isEmpty());\n      Q_ASSERT(runningTasksForThisMailbox.isEmpty());\n      Q_ASSERT(abortableTasks.isEmpty());\n  \n      // Break periodic activities\n      if (idleLauncher) {\n          // got to break the IDLE cycle and especially make sure it won't restart\n          idleLauncher->die();\n      }\n      shouldRunIdle = false;\n      shouldRunNoop = false;\n      isRunning = false;\n  \n      // Merge the lists of waiting tasks\n      if (!waitingObtainTasks.isEmpty()) {\n          ObtainSynchronizedMailboxTask *first = waitingObtainTasks.takeFirst();\n          dependentTasks.removeOne(first);\n          Q_ASSERT(first);\n          Q_ASSERT(first->keepTaskChild);\n          Q_ASSERT(first->keepTaskChild->synchronizeConn == first);\n  \n          CHECK_TASK_TREE\n          // Update the parent information for the moved tasks\n          Q_FOREACH(ObtainSynchronizedMailboxTask *movedObtainTask, waitingObtainTasks) {\n              Q_ASSERT(movedObtainTask->parentTask);\n              movedObtainTask->parentTask->dependentTasks.removeOne(movedObtainTask);\n              movedObtainTask->parentTask = first->keepTaskChild;\n              first->keepTaskChild->dependentTasks.append(movedObtainTask);\n          }\n          CHECK_TASK_TREE\n  \n          // And launch the replacement\n          first->keepTaskChild->waitingObtainTasks = waitingObtainTasks + first->keepTaskChild->waitingObtainTasks;\n          model->accessParser(parser).maintainingTask = first->keepTaskChild;\n          first->keepTaskChild->slotPerformConnection();\n      } else {\n          Q_ASSERT(dependentTasks.isEmpty());\n      }\n      _finished = true;\n      emit completed(this);\n      CHECK_TASK_TREE\n  }\n}"
  },
  {
    "function_name": "slotTaskDeleted(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "243-280",
    "snippet": "oid KeepMailboxOpenTask::slotTaskDeleted(QObject *object)\n{\n    if (_finished)\n        return;\n\n    if (!model->m_parsers.contains(parser)) {\n        // The parser is gone; we have to get out of here ASAP\n        _failed(\"Parser is gone\");\n        die(\"Parser is gone\");\n        return;\n    }\n    // FIXME: abort/die\n\n    // Now, object is no longer an ImapTask*, as this gets emitted from inside QObject's destructor. However,\n    // we can't use the passed pointer directly, and therefore we have to perform the cast here. It is safe\n    // to do that here, as we're only interested in raw pointer value.\n    if (object) {\n        dependentTasks.removeOne(static_cast<ImapTask *>(object));\n        dependingTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n        dependingTasksNoMailbox.removeOne(static_cast<ImapTask *>(object));\n        runningTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n        fetchPartTasks.removeOne(static_cast<FetchMsgPartTask *>(object));\n        fetchMetadataTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n        abortableTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n    }\n\n    if (isReadyToTerminate()) {\n        terminate();\n    } else if (shouldRunNoop) {\n        // A command just completed, and NOOPing is active, so let's schedule/postpone it again\n        noopTimer->start();\n    } else if (canRunIdleRightNow()) {\n        // A command just completed and IDLE is supported, so let's queue/schedule/postpone it\n        idleLauncher->enterIdleLater();\n    }\n    // It's possible that we can start more tasks at this time...\n    activateTasks();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ctivateTasks(",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "activateTasks(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "693-726",
          "snippet": "oid KeepMailboxOpenTask::activateTasks()\n{\n    // FIXME: abort/die\n\n    if (!isRunning)\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    if (m_deleteCurrentMailboxTask) {\n        closeMailboxDestructively();\n        return;\n    }\n\n    slotFetchRequestedEnvelopes();\n    slotFetchRequestedParts();\n\n    while (!dependingTasksForThisMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n        breakOrCancelPossibleIdle();\n        ImapTask *task = dependingTasksForThisMailbox.takeFirst();\n        runningTasksForThisMailbox.append(task);\n        dependentTasks.removeOne(task);\n        task->perform();\n    }\n    while (!dependingTasksNoMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n        breakOrCancelPossibleIdle();\n        ImapTask *task = dependingTasksNoMailbox.takeFirst();\n        dependentTasks.removeOne(task);\n        task->perform();\n    }\n\n    if (idleLauncher && canRunIdleRightNow())\n        idleLauncher->enterIdleLater();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::activateTasks()\n  {\n      // FIXME: abort/die\n  \n      if (!isRunning)\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      if (m_deleteCurrentMailboxTask) {\n          closeMailboxDestructively();\n          return;\n      }\n  \n      slotFetchRequestedEnvelopes();\n      slotFetchRequestedParts();\n  \n      while (!dependingTasksForThisMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n          breakOrCancelPossibleIdle();\n          ImapTask *task = dependingTasksForThisMailbox.takeFirst();\n          runningTasksForThisMailbox.append(task);\n          dependentTasks.removeOne(task);\n          task->perform();\n      }\n      while (!dependingTasksNoMailbox.isEmpty() && model->accessParser(parser).activeTasks.size() < limitActiveTasks) {\n          breakOrCancelPossibleIdle();\n          ImapTask *task = dependingTasksNoMailbox.takeFirst();\n          dependentTasks.removeOne(task);\n          task->perform();\n      }\n  \n      if (idleLauncher && canRunIdleRightNow())\n          idleLauncher->enterIdleLater();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dleLauncher->enterIdleLater",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "enterIdleLater(",
          "container": "dleLauncher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/IdleLauncher.cpp",
          "lines": "97-103",
          "snippet": "oid IdleLauncher::enterIdleLater()\n{\n    if (m_idling)\n        return;\n\n    delayedEnter->start();\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include <QTimer>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude <QTimer>\n#\n\ndleLauncher {\n  oid IdleLauncher::enterIdleLater()\n  {\n      if (m_idling)\n          return;\n  \n      delayedEnter->start();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "anRunIdleRightNow(",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "canRunIdleRightNow(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "931-956",
          "snippet": "ool KeepMailboxOpenTask::canRunIdleRightNow() const\n{\n    bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n            dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n\n    // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n    // and that one more thing is a SortTask which is in the \"just updating\" mode.\n    // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n    // Nifty, isn't it?\n    if (model->accessParser(parser).activeTasks.size() > 1) {\n        if (model->accessParser(parser).activeTasks.size() == 2 &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n            // This is OK, so no need to clear the \"OK\" flag\n        } else {\n            // Too bad, cannot IDLE\n            res = false;\n        }\n    }\n\n    if (!res)\n        return false;\n\n    Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n    return true;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::canRunIdleRightNow() const\n  {\n      bool res = shouldRunIdle && dependingTasksForThisMailbox.isEmpty() &&\n              dependingTasksNoMailbox.isEmpty() && newArrivalsFetch.isEmpty();\n  \n      // If there's just one active tasks, it's the \"this\" one. If there are more of them, let's see if it's just one more\n      // and that one more thing is a SortTask which is in the \"just updating\" mode.\n      // If that is the case, we can still allow further IDLE, that task will abort idling when it needs to.\n      // Nifty, isn't it?\n      if (model->accessParser(parser).activeTasks.size() > 1) {\n          if (model->accessParser(parser).activeTasks.size() == 2 &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1]) &&\n                  dynamic_cast<SortTask*>(model->accessParser(parser).activeTasks[1])->isJustUpdatingNow()) {\n              // This is OK, so no need to clear the \"OK\" flag\n          } else {\n              // Too bad, cannot IDLE\n              res = false;\n          }\n      }\n  \n      if (!res)\n          return false;\n  \n      Q_ASSERT(model->accessParser(parser).activeTasks.front() == this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "oopTimer->start",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erminate(",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "isReadyToTerminate(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "925-928",
          "snippet": "ool KeepMailboxOpenTask::isReadyToTerminate() const\n{\n    return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::isReadyToTerminate() const\n  {\n      return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bortableTasks.removeOne",
          "args": [
            "tatic_cast<FetchMsgMetadataTask *>(object))"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<FetchMsgMetadataTask *>",
          "args": [
            "bject)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchMetadataTasks.removeOne",
          "args": [
            "tatic_cast<FetchMsgMetadataTask *>(object))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<FetchMsgMetadataTask *>",
          "args": [
            "bject)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchPartTasks.removeOne",
          "args": [
            "tatic_cast<FetchMsgPartTask *>(object))"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<FetchMsgPartTask *>",
          "args": [
            "bject)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unningTasksForThisMailbox.removeOne",
          "args": [
            "tatic_cast<ImapTask *>(object))"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "bject)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.removeOne",
          "args": [
            "tatic_cast<ImapTask *>(object))"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "bject)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.removeOne",
          "args": [
            "tatic_cast<ImapTask *>(object))"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "bject)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependentTasks.removeOne",
          "args": [
            "tatic_cast<ImapTask *>(object))"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<ImapTask *>",
          "args": [
            "bject)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ie(",
          "args": [
            "Parser is gone\")"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "die(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "619-630",
          "snippet": "oid KeepMailboxOpenTask::die(const QString &message)\n{\n    if (shouldExit) {\n        // OK, we're done, and getting killed. This is fine; just don't emit failed()\n        // because we aren't actually failing.\n        // This is a speciality of the KeepMailboxOpenTask because it's the only task\n        // this has a very long life.\n        _finished = true;\n    }\n    ImapTask::die(message);\n    detachFromMailbox();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::die(const QString &message)\n  {\n      if (shouldExit) {\n          // OK, we're done, and getting killed. This is fine; just don't emit failed()\n          // because we aren't actually failing.\n          // This is a speciality of the KeepMailboxOpenTask because it's the only task\n          // this has a very long life.\n          _finished = true;\n      }\n      ImapTask::die(message);\n      detachFromMailbox();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Parser is gone\")"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->m_parsers.contains",
          "args": [
            "arser)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotTaskDeleted(QObject *object)\n  {\n      if (_finished)\n          return;\n  \n      if (!model->m_parsers.contains(parser)) {\n          // The parser is gone; we have to get out of here ASAP\n          _failed(\"Parser is gone\");\n          die(\"Parser is gone\");\n          return;\n      }\n      // FIXME: abort/die\n  \n      // Now, object is no longer an ImapTask*, as this gets emitted from inside QObject's destructor. However,\n      // we can't use the passed pointer directly, and therefore we have to perform the cast here. It is safe\n      // to do that here, as we're only interested in raw pointer value.\n      if (object) {\n          dependentTasks.removeOne(static_cast<ImapTask *>(object));\n          dependingTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n          dependingTasksNoMailbox.removeOne(static_cast<ImapTask *>(object));\n          runningTasksForThisMailbox.removeOne(static_cast<ImapTask *>(object));\n          fetchPartTasks.removeOne(static_cast<FetchMsgPartTask *>(object));\n          fetchMetadataTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n          abortableTasks.removeOne(static_cast<FetchMsgMetadataTask *>(object));\n      }\n  \n      if (isReadyToTerminate()) {\n          terminate();\n      } else if (shouldRunNoop) {\n          // A command just completed, and NOOPing is active, so let's schedule/postpone it again\n          noopTimer->start();\n      } else if (canRunIdleRightNow()) {\n          // A command just completed and IDLE is supported, so let's queue/schedule/postpone it\n          idleLauncher->enterIdleLater();\n      }\n      // It's possible that we can start more tasks at this time...\n      activateTasks();\n  }\n}"
  },
  {
    "function_name": "addDependentTask(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "177-241",
    "snippet": "oid KeepMailboxOpenTask::addDependentTask(ImapTask *task)\n{\n    CHECK_TASK_TREE\n    Q_ASSERT(task);\n\n    // FIXME: what about abort()/die() here?\n\n    breakOrCancelPossibleIdle();\n\n    DeleteMailboxTask *deleteTask = qobject_cast<DeleteMailboxTask*>(task);\n    if (!deleteTask || deleteTask->mailbox != mailboxIndex.data(RoleMailboxName).toString()) {\n        deleteTask = 0;\n    }\n\n    if (ObtainSynchronizedMailboxTask *obtainTask = qobject_cast<ObtainSynchronizedMailboxTask *>(task)) {\n        // Another KeepMailboxOpenTask would like to replace us, so we shall die, eventually.\n        // This branch is reimplemented from ImapTask\n\n        dependentTasks.append(task);\n        waitingObtainTasks.append(obtainTask);\n        shouldExit = true;\n        task->updateParentTask(this);\n\n        // Before we can die, though, we have to accommodate fetch requests for all envelopes and parts queued so far.\n        slotFetchRequestedEnvelopes();\n        slotFetchRequestedParts();\n\n        if (! hasPendingInternalActions() && (! synchronizeConn || synchronizeConn->isFinished())) {\n            QTimer::singleShot(0, this, SLOT(terminate()));\n        }\n\n        Q_FOREACH(ImapTask *abortable, abortableTasks) {\n            abortable->abort();\n        }\n    } else if (deleteTask) {\n        // Got a request to delete the current mailbox. Fair enough, here we go!\n\n        if (hasPendingInternalActions() || (synchronizeConn && !synchronizeConn->isFinished())) {\n            // Hmm, this is bad -- the caller has instructed us to delete the current mailbox, but we still have\n            // some pending actions (or have not even started yet). Better reject the request for deleting than lose some data.\n            // Alternatively, we might pretend that we're a performance-oriented library and \"optimize out\" the\n            // data transfer by deleting early :)\n            deleteTask->mailboxHasPendingActions();\n            return;\n        }\n\n        m_deleteCurrentMailboxTask = deleteTask;\n        shouldExit = true;\n        connect(task, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n        ImapTask::addDependentTask(task);\n        QTimer::singleShot(0, this, SLOT(slotActivateTasks()));\n\n    } else {\n        // This branch calls the inherited ImapTask::addDependentTask()\n        connect(task, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n        ImapTask::addDependentTask(task);\n        if (task->needsMailbox()) {\n            // it's a task which is tied to a particular mailbox\n            dependingTasksForThisMailbox.append(task);\n        } else {\n            dependingTasksNoMailbox.append(task);\n        }\n        QTimer::singleShot(0, this, SLOT(slotActivateTasks()));\n    }\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(slotActivateTasks()))"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotActivateTasks())"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotActivateTasks(",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "lotActivateTasks(",
          "container": "eepMailboxOpenTask ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.h",
          "lines": "184-184",
          "snippet": "oid slotActivateTasks() { activateTasks(); }",
          "includes": [
            "include \"ImapTask.h\"",
            "include <QSet>\n#",
            "include <QModelIndex>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"ImapTask.h\"\ninclude <QSet>\n#\ninclude <QModelIndex>\n#\n\neepMailboxOpenTask  {\n  oid slotActivateTasks() { activateTasks(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ependingTasksNoMailbox.append",
          "args": [
            "ask)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependingTasksForThisMailbox.append",
          "args": [
            "ask)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask->needsMailbox",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "needsMailbox",
          "container": "UpdateFlagsOfAllMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/UpdateFlagsOfAllMessagesTask.h",
          "lines": "53-53",
          "snippet": "virtual bool needsMailbox() const {return true;}",
          "includes": [
            "#include \"ImapTask.h\"",
            "#include \"Imap/Model/FlagsOperation.h\"",
            "#include <QPersistentModelIndex>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ImapTask.h\"\n#include \"Imap/Model/FlagsOperation.h\"\n#include <QPersistentModelIndex>\n\nUpdateFlagsOfAllMessagesTask {\n  virtual bool needsMailbox() const {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapTask::addDependentTask(",
          "args": [
            "ask)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "addDependentTask(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "177-241",
          "snippet": "oid KeepMailboxOpenTask::addDependentTask(ImapTask *task)\n{\n    CHECK_TASK_TREE\n    Q_ASSERT(task);\n\n    // FIXME: what about abort()/die() here?\n\n    breakOrCancelPossibleIdle();\n\n    DeleteMailboxTask *deleteTask = qobject_cast<DeleteMailboxTask*>(task);\n    if (!deleteTask || deleteTask->mailbox != mailboxIndex.data(RoleMailboxName).toString()) {\n        deleteTask = 0;\n    }\n\n    if (ObtainSynchronizedMailboxTask *obtainTask = qobject_cast<ObtainSynchronizedMailboxTask *>(task)) {\n        // Another KeepMailboxOpenTask would like to replace us, so we shall die, eventually.\n        // This branch is reimplemented from ImapTask\n\n        dependentTasks.append(task);\n        waitingObtainTasks.append(obtainTask);\n        shouldExit = true;\n        task->updateParentTask(this);\n\n        // Before we can die, though, we have to accommodate fetch requests for all envelopes and parts queued so far.\n        slotFetchRequestedEnvelopes();\n        slotFetchRequestedParts();\n\n        if (! hasPendingInternalActions() && (! synchronizeConn || synchronizeConn->isFinished())) {\n            QTimer::singleShot(0, this, SLOT(terminate()));\n        }\n\n        Q_FOREACH(ImapTask *abortable, abortableTasks) {\n            abortable->abort();\n        }\n    } else if (deleteTask) {\n        // Got a request to delete the current mailbox. Fair enough, here we go!\n\n        if (hasPendingInternalActions() || (synchronizeConn && !synchronizeConn->isFinished())) {\n            // Hmm, this is bad -- the caller has instructed us to delete the current mailbox, but we still have\n            // some pending actions (or have not even started yet). Better reject the request for deleting than lose some data.\n            // Alternatively, we might pretend that we're a performance-oriented library and \"optimize out\" the\n            // data transfer by deleting early :)\n            deleteTask->mailboxHasPendingActions();\n            return;\n        }\n\n        m_deleteCurrentMailboxTask = deleteTask;\n        shouldExit = true;\n        connect(task, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n        ImapTask::addDependentTask(task);\n        QTimer::singleShot(0, this, SLOT(slotActivateTasks()));\n\n    } else {\n        // This branch calls the inherited ImapTask::addDependentTask()\n        connect(task, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n        ImapTask::addDependentTask(task);\n        if (task->needsMailbox()) {\n            // it's a task which is tied to a particular mailbox\n            dependingTasksForThisMailbox.append(task);\n        } else {\n            dependingTasksNoMailbox.append(task);\n        }\n        QTimer::singleShot(0, this, SLOT(slotActivateTasks()));\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(slotActivateTasks()))"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotActivateTasks())"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eleteTask->mailboxHasPendingActions",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asPendingInternalActions(",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "hasPendingInternalActions(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "914-919",
          "snippet": "ool KeepMailboxOpenTask::hasPendingInternalActions() const\n{\n    bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n    return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n             requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::hasPendingInternalActions() const\n  {\n      bool hasToWaitForIdleTermination = idleLauncher ? idleLauncher->waitingForIdleTaggedTermination() : false;\n      return !(dependingTasksForThisMailbox.isEmpty() && dependingTasksNoMailbox.isEmpty() && runningTasksForThisMailbox.isEmpty() &&\n               requestedParts.isEmpty() && requestedEnvelopes.isEmpty() && newArrivalsFetch.isEmpty()) || hasToWaitForIdleTermination;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bortable->abort",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(terminate()))"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "erminate())"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erminate(",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "isReadyToTerminate(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "925-928",
          "snippet": "ool KeepMailboxOpenTask::isReadyToTerminate() const\n{\n    return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  ool KeepMailboxOpenTask::isReadyToTerminate() const\n  {\n      return shouldExit && !hasPendingInternalActions() && (!synchronizeConn || synchronizeConn->isFinished());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotFetchRequestedParts(",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchRequestedParts(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "745-774",
          "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedParts()\n{\n    // FIXME: abort/die\n\n    if (requestedParts.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n    QSet<QString> parts = *it;\n\n    // When asked to exit, do as much as possible and die\n    while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n        QList<uint> uids;\n        uint totalSize = 0;\n        while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n            if (parts != *it)\n                break;\n            parts = *it;\n            uids << it.key();\n            totalSize += requestedPartSizes.take(it.key());\n            it = requestedParts.erase(it);\n        }\n        if (uids.isEmpty())\n            return;\n\n        fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedParts()\n  {\n      // FIXME: abort/die\n  \n      if (requestedParts.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n      QSet<QString> parts = *it;\n  \n      // When asked to exit, do as much as possible and die\n      while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n          QList<uint> uids;\n          uint totalSize = 0;\n          while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n              if (parts != *it)\n                  break;\n              parts = *it;\n              uids << it.key();\n              totalSize += requestedPartSizes.take(it.key());\n              it = requestedParts.erase(it);\n          }\n          if (uids.isEmpty())\n              return;\n  \n          fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lotFetchRequestedEnvelopes(",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchRequestedEnvelopes(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "776-795",
          "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n{\n    // FIXME: abort/die\n\n    if (requestedEnvelopes.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QList<uint> fetchNow;\n    if (shouldExit) {\n        fetchNow = requestedEnvelopes;\n        requestedEnvelopes.clear();\n    } else {\n        const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n        fetchNow = requestedEnvelopes.mid(0, amount);\n        requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n    }\n    fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n  {\n      // FIXME: abort/die\n  \n      if (requestedEnvelopes.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QList<uint> fetchNow;\n      if (shouldExit) {\n          fetchNow = requestedEnvelopes;\n          requestedEnvelopes.clear();\n      } else {\n          const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n          fetchNow = requestedEnvelopes.mid(0, amount);\n          requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n      }\n      fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ask->updateParentTask",
          "args": [
            "his)"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "updateParentTask(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "61-73",
          "snippet": "oid ImapTask::updateParentTask(ImapTask *newParent)\n{\n    Q_ASSERT(!parentTask);\n    Q_ASSERT(newParent);\n    parentTask = newParent;\n    CHECK_TASK_TREE\n    model->m_taskModel->slotTaskGotReparented(this);\n    if (parser) {\n        Q_ASSERT(!model->accessParser(parser).activeTasks.contains(this));\n        //log(tr(\"Reparented to %1\").arg(newParent->debugIdentification()));\n    }\n    CHECK_TASK_TREE\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::updateParentTask(ImapTask *newParent)\n  {\n      Q_ASSERT(!parentTask);\n      Q_ASSERT(newParent);\n      parentTask = newParent;\n      CHECK_TASK_TREE\n      model->m_taskModel->slotTaskGotReparented(this);\n      if (parser) {\n          Q_ASSERT(!model->accessParser(parser).activeTasks.contains(this));\n          //log(tr(\"Reparented to %1\").arg(newParent->debugIdentification()));\n      }\n      CHECK_TASK_TREE\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "aitingObtainTasks.append",
          "args": [
            "btainTask)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ependentTasks.append",
          "args": [
            "ask)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<ObtainSynchronizedMailboxTask *>",
          "args": [
            "ask)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.data",
          "args": [
            "oleMailboxName)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_cast<DeleteMailboxTask*>",
          "args": [
            "ask)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reakOrCancelPossibleIdle(",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "breakOrCancelPossibleIdle(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "797-802",
          "snippet": "oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n{\n    if (idleLauncher) {\n        idleLauncher->finishIdle();\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::breakOrCancelPossibleIdle()\n  {\n      if (idleLauncher) {\n          idleLauncher->finishIdle();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::addDependentTask(ImapTask *task)\n  {\n      CHECK_TASK_TREE\n      Q_ASSERT(task);\n  \n      // FIXME: what about abort()/die() here?\n  \n      breakOrCancelPossibleIdle();\n  \n      DeleteMailboxTask *deleteTask = qobject_cast<DeleteMailboxTask*>(task);\n      if (!deleteTask || deleteTask->mailbox != mailboxIndex.data(RoleMailboxName).toString()) {\n          deleteTask = 0;\n      }\n  \n      if (ObtainSynchronizedMailboxTask *obtainTask = qobject_cast<ObtainSynchronizedMailboxTask *>(task)) {\n          // Another KeepMailboxOpenTask would like to replace us, so we shall die, eventually.\n          // This branch is reimplemented from ImapTask\n  \n          dependentTasks.append(task);\n          waitingObtainTasks.append(obtainTask);\n          shouldExit = true;\n          task->updateParentTask(this);\n  \n          // Before we can die, though, we have to accommodate fetch requests for all envelopes and parts queued so far.\n          slotFetchRequestedEnvelopes();\n          slotFetchRequestedParts();\n  \n          if (! hasPendingInternalActions() && (! synchronizeConn || synchronizeConn->isFinished())) {\n              QTimer::singleShot(0, this, SLOT(terminate()));\n          }\n  \n          Q_FOREACH(ImapTask *abortable, abortableTasks) {\n              abortable->abort();\n          }\n      } else if (deleteTask) {\n          // Got a request to delete the current mailbox. Fair enough, here we go!\n  \n          if (hasPendingInternalActions() || (synchronizeConn && !synchronizeConn->isFinished())) {\n              // Hmm, this is bad -- the caller has instructed us to delete the current mailbox, but we still have\n              // some pending actions (or have not even started yet). Better reject the request for deleting than lose some data.\n              // Alternatively, we might pretend that we're a performance-oriented library and \"optimize out\" the\n              // data transfer by deleting early :)\n              deleteTask->mailboxHasPendingActions();\n              return;\n          }\n  \n          m_deleteCurrentMailboxTask = deleteTask;\n          shouldExit = true;\n          connect(task, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n          ImapTask::addDependentTask(task);\n          QTimer::singleShot(0, this, SLOT(slotActivateTasks()));\n  \n      } else {\n          // This branch calls the inherited ImapTask::addDependentTask()\n          connect(task, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n          ImapTask::addDependentTask(task);\n          if (task->needsMailbox()) {\n              // it's a task which is tied to a particular mailbox\n              dependingTasksForThisMailbox.append(task);\n          } else {\n              dependingTasksNoMailbox.append(task);\n          }\n          QTimer::singleShot(0, this, SLOT(slotActivateTasks()));\n      }\n  }\n}"
  },
  {
    "function_name": "slotPerformConnection(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "162-175",
    "snippet": "oid KeepMailboxOpenTask::slotPerformConnection()\n{\n    CHECK_TASK_TREE\n    Q_ASSERT(synchronizeConn);\n    Q_ASSERT(!synchronizeConn->isFinished());\n    if (_dead) {\n        _failed(\"Asked to die\");\n        synchronizeConn->die(QLatin1String(\"KeepMailboxOpenTask died before the sync started\"));\n        return;\n    }\n\n    connect(synchronizeConn, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n    synchronizeConn->perform();\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ynchronizeConn->perform",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "perform",
          "container": "UpdateFlagsOfAllMessagesTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/UpdateFlagsOfAllMessagesTask.cpp",
          "lines": "45-55",
          "snippet": "void UpdateFlagsOfAllMessagesTask::perform()\n{\n    Q_ASSERT(conn);\n    parser = conn->parser;\n\n    markAsActiveTask();\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    Sequence seq = Sequence::startingAt(1);\n    tag = parser->store(seq, toImapString(flagOperation), flags);\n}",
          "includes": [
            "#include \"KeepMailboxOpenTask.h\"",
            "#include \"Imap/Model/Model.h\"",
            "#include \"Imap/Model/MailboxTree.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include \"UpdateFlagsOfAllMessagesTask.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"KeepMailboxOpenTask.h\"\n#include \"Imap/Model/Model.h\"\n#include \"Imap/Model/MailboxTree.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include \"UpdateFlagsOfAllMessagesTask.h\"\n\nUpdateFlagsOfAllMessagesTask {\n  void UpdateFlagsOfAllMessagesTask::perform()\n  {\n      Q_ASSERT(conn);\n      parser = conn->parser;\n  \n      markAsActiveTask();\n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      Sequence seq = Sequence::startingAt(1);\n      tag = parser->store(seq, toImapString(flagOperation), flags);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->die",
          "args": [
            "Latin1String(\"KeepMailboxOpenTask died before the sync started\"))"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "KeepMailboxOpenTask died before the sync started\")"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Asked to die\")"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "synchronizeConn->isFinished())"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynchronizeConn->isFinished",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotPerformConnection()\n  {\n      CHECK_TASK_TREE\n      Q_ASSERT(synchronizeConn);\n      Q_ASSERT(!synchronizeConn->isFinished());\n      if (_dead) {\n          _failed(\"Asked to die\");\n          synchronizeConn->die(QLatin1String(\"KeepMailboxOpenTask died before the sync started\"));\n          return;\n      }\n  \n      connect(synchronizeConn, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n      synchronizeConn->perform();\n  }\n}"
  },
  {
    "function_name": "KeepMailboxOpenTask(",
    "container": "eepMailboxOpenTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
    "lines": "50-160",
    "snippet": "eepMailboxOpenTask::KeepMailboxOpenTask(Model *model, const QModelIndex &mailboxIndex, Parser *oldParser) :\n    ImapTask(model), mailboxIndex(mailboxIndex), synchronizeConn(0), shouldExit(false), isRunning(false),\n    shouldRunNoop(false), shouldRunIdle(false), idleLauncher(0), unSelectTask(0)\n{\n    Q_ASSERT(mailboxIndex.isValid());\n    Q_ASSERT(mailboxIndex.model() == model);\n    TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n    Q_ASSERT(mailbox);\n\n    // Now make sure that we at least try to load data from the cache\n    Q_ASSERT(mailbox->m_children.size() > 0);\n    TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n    Q_ASSERT(list);\n    list->fetch(model);\n\n    // We're the latest KeepMailboxOpenTask, so it makes a lot of sense to add us as the active\n    // maintainingTask to the target mailbox\n    mailbox->maintainingTask = this;\n\n    if (oldParser) {\n        // We're asked to re-use an existing connection. Let's see if there's something associated with it\n\n        // We will use its parser, that's for sure already\n        parser = oldParser;\n\n        // Find if there's a KeepMailboxOpenTask already associated; if it is, we have to register with it\n        if (model->accessParser(parser).maintainingTask) {\n            // The parser looks busy -- some task is associated with it and has a mailbox open, so\n            // let's just wait till we get a chance to play\n            synchronizeConn = model->m_taskFactory->\n                              createObtainSynchronizedMailboxTask(model, mailboxIndex, model->accessParser(oldParser).maintainingTask, this);\n        } else if (model->accessParser(parser).connState < CONN_STATE_AUTHENTICATED) {\n            // The parser is still in the process of being initialized, let's wait until it's completed\n            Q_ASSERT(!model->accessParser(oldParser).activeTasks.isEmpty());\n            ImapTask *task = model->accessParser(oldParser).activeTasks.front();\n            synchronizeConn = model->m_taskFactory->createObtainSynchronizedMailboxTask(model, mailboxIndex, task, this);\n        } else {\n            // The parser is free, or at least there's no KeepMailboxOpenTask associated with it.\n            // There's no mailbox besides us in the game, yet, so we can simply schedule us for immediate execution.\n            synchronizeConn = model->m_taskFactory->createObtainSynchronizedMailboxTask(model, mailboxIndex, 0, this);\n            // We'll also register with the model, so that all other KeepMailboxOpenTask which could get constructed in future\n            // know about us and don't step on our toes.  This means that further KeepMailboxOpenTask which could possibly want\n            // to use this connection will have to go through this task at first.\n            model->accessParser(parser).maintainingTask = this;\n            QTimer::singleShot(0, this, SLOT(slotPerformConnection()));\n        }\n\n        // We shall catch destruction of any preexisting tasks so that we can properly launch IDLE etc in response to their termination\n        Q_FOREACH(ImapTask *task, model->accessParser(parser).activeTasks) {\n            connect(task, SIGNAL(destroyed(QObject*)), this, SLOT(slotTaskDeleted(QObject*)));\n        }\n    } else {\n        ImapTask *conn = 0;\n        if (model->networkPolicy() == NETWORK_OFFLINE) {\n            // Well, except that we cannot really open a new connection now\n            conn = new OfflineConnectionTask(model);\n        } else {\n            conn = model->m_taskFactory->createOpenConnectionTask(model);\n        }\n        parser = conn->parser;\n        Q_ASSERT(parser);\n        model->accessParser(parser).maintainingTask = this;\n        synchronizeConn = model->m_taskFactory->createObtainSynchronizedMailboxTask(model, mailboxIndex, conn, this);\n    }\n\n    Q_ASSERT(synchronizeConn);\n\n    // Setup the timer for NOOPing. It won't get started at this time, though.\n    noopTimer = new QTimer(this);\n    connect(noopTimer, SIGNAL(timeout()), this, SLOT(slotPerformNoop()));\n    bool ok;\n    int timeout = model->property(\"trojita-imap-noop-period\").toUInt(&ok);\n    if (! ok)\n        timeout = 2 * 60 * 1000; // once every two minutes\n    noopTimer->setInterval(timeout);\n    noopTimer->setSingleShot(true);\n\n    fetchPartTimer = new QTimer(this);\n    connect(fetchPartTimer, SIGNAL(timeout()), this, SLOT(slotFetchRequestedParts()));\n    timeout = model->property(\"trojita-imap-delayed-fetch-part\").toUInt(&ok);\n    if (! ok)\n        timeout = 50;\n    fetchPartTimer->setInterval(timeout);\n    fetchPartTimer->setSingleShot(true);\n\n    fetchEnvelopeTimer = new QTimer(this);\n    connect(fetchEnvelopeTimer, SIGNAL(timeout()), this, SLOT(slotFetchRequestedEnvelopes()));\n    fetchEnvelopeTimer->setInterval(0); // message metadata is pretty important, hence an immediate fetch\n    fetchEnvelopeTimer->setSingleShot(true);\n\n    limitBytesAtOnce = model->property(\"trojita-imap-limit-fetch-bytes-per-group\").toUInt(&ok);\n    if (! ok)\n        limitBytesAtOnce = 1024 * 1024;\n\n    limitMessagesAtOnce = model->property(\"trojita-imap-limit-fetch-messages-per-group\").toInt(&ok);\n    if (! ok)\n        limitMessagesAtOnce = 300;\n\n    limitParallelFetchTasks = model->property(\"trojita-imap-limit-parallel-fetch-tasks\").toInt(&ok);\n    if (! ok)\n        limitParallelFetchTasks = 10;\n\n    limitActiveTasks = model->property(\"trojita-imap-limit-active-tasks\").toInt(&ok);\n    if (! ok)\n        limitActiveTasks = 100;\n\n    CHECK_TASK_TREE\n    emit model->mailboxSyncingProgress(mailboxIndex, STATE_WAIT_FOR_CONN);\n\n    connect(this, SIGNAL(failed(QString)), this, SLOT(signalSyncFailure(QString)));\n}",
    "includes": [
      "include \"UnSelectTask.h\"",
      "include \"NoopTask.h\"\n#",
      "include \"SortTask.h\"\n#",
      "include \"OfflineConnectionTask.h\"\n#",
      "include \"ObtainSynchronizedMailboxTask.h\"\n#",
      "include \"OpenConnectionTask.h\"\n#",
      "include \"IdleLauncher.h\"\n#",
      "include \"FetchMsgPartTask.h\"\n#",
      "include \"FetchMsgMetadataTask.h\"\n#",
      "include \"DeleteMailboxTask.h\"\n#",
      "include \"Imap/Model/TaskFactory.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include \"Common/InvokeMethod.h\"\n#",
      "include \"KeepMailboxOpenTask.h\"\n#",
      "include <sstream>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "his,",
            "IGNAL(failed(QString)),",
            "his,",
            "LOT(signalSyncFailure(QString)))"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "ignalSyncFailure(QString))"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignalSyncFailure(",
          "args": [
            "String)"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "signalSyncFailure(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "990-1005",
          "snippet": "oid KeepMailboxOpenTask::signalSyncFailure(const QString &message)\n{\n    if (!mailboxIndex.isValid()) {\n        // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n        // Seems that there's nothing to report here.\n        return;\n    }\n\n    if (synchronizeConn) {\n        // Well, we aren't synced yet. We're going to rely on the ObtainSynchronizedMailboxTask's own\n        // emitting of mailboxSyncFailed() to prevent duplicate signals.\n        return;\n    }\n\n    EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::signalSyncFailure(const QString &message)\n  {\n      if (!mailboxIndex.isValid()) {\n          // Well, that mailbox is no longer there; perhaps this is because the list of mailboxes got replaced.\n          // Seems that there's nothing to report here.\n          return;\n      }\n  \n      if (synchronizeConn) {\n          // Well, we aren't synced yet. We're going to rely on the ObtainSynchronizedMailboxTask's own\n          // emitting of mailboxSyncFailed() to prevent duplicate signals.\n          return;\n      }\n  \n      EMIT_LATER(model, mailboxSyncFailed, Q_ARG(QString, mailboxIndex.data(RoleMailboxName).toString()), Q_ARG(QString, message));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "ailed(QString))"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailed(",
          "args": [
            "String)"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "hreadTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ThreadTask.cpp",
          "lines": "112-117",
          "snippet": "oid ThreadTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"ThreadTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"ThreadTask.h\"\n#\n\nhreadTask {\n  oid ThreadTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit model->threadingFailed(mailboxIndex, algorithm, searchCriteria);\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "ok)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "trojita-imap-limit-active-tasks\")"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "ok)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "trojita-imap-limit-parallel-fetch-tasks\")"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "ok)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "trojita-imap-limit-fetch-messages-per-group\")"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "ok)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "trojita-imap-limit-fetch-bytes-per-group\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchEnvelopeTimer->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchEnvelopeTimer->setInterval",
          "args": [
            ")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "etchEnvelopeTimer,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotFetchRequestedEnvelopes()))"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotFetchRequestedEnvelopes())"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotFetchRequestedEnvelopes(",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchRequestedEnvelopes(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "776-795",
          "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n{\n    // FIXME: abort/die\n\n    if (requestedEnvelopes.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QList<uint> fetchNow;\n    if (shouldExit) {\n        fetchNow = requestedEnvelopes;\n        requestedEnvelopes.clear();\n    } else {\n        const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n        fetchNow = requestedEnvelopes.mid(0, amount);\n        requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n    }\n    fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedEnvelopes()\n  {\n      // FIXME: abort/die\n  \n      if (requestedEnvelopes.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QList<uint> fetchNow;\n      if (shouldExit) {\n          fetchNow = requestedEnvelopes;\n          requestedEnvelopes.clear();\n      } else {\n          const int amount = qMin(requestedEnvelopes.size(), limitMessagesAtOnce); // FIXME: add an extra limit?\n          fetchNow = requestedEnvelopes.mid(0, amount);\n          requestedEnvelopes.erase(requestedEnvelopes.begin(), requestedEnvelopes.begin() + amount);\n      }\n      fetchMetadataTasks << model->m_taskFactory->createFetchMsgMetadataTask(model, mailboxIndex, fetchNow);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchPartTimer->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etchPartTimer->setInterval",
          "args": [
            "imeout)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "ok)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "trojita-imap-delayed-fetch-part\")"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "etchPartTimer,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotFetchRequestedParts()))"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotFetchRequestedParts())"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotFetchRequestedParts(",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "slotFetchRequestedParts(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "745-774",
          "snippet": "oid KeepMailboxOpenTask::slotFetchRequestedParts()\n{\n    // FIXME: abort/die\n\n    if (requestedParts.isEmpty())\n        return;\n\n    breakOrCancelPossibleIdle();\n\n    QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n    QSet<QString> parts = *it;\n\n    // When asked to exit, do as much as possible and die\n    while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n        QList<uint> uids;\n        uint totalSize = 0;\n        while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n            if (parts != *it)\n                break;\n            parts = *it;\n            uids << it.key();\n            totalSize += requestedPartSizes.take(it.key());\n            it = requestedParts.erase(it);\n        }\n        if (uids.isEmpty())\n            return;\n\n        fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n    }\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotFetchRequestedParts()\n  {\n      // FIXME: abort/die\n  \n      if (requestedParts.isEmpty())\n          return;\n  \n      breakOrCancelPossibleIdle();\n  \n      QMap<uint, QSet<QString> >::iterator it = requestedParts.begin();\n      QSet<QString> parts = *it;\n  \n      // When asked to exit, do as much as possible and die\n      while (shouldExit || fetchPartTasks.size() < limitParallelFetchTasks) {\n          QList<uint> uids;\n          uint totalSize = 0;\n          while (uids.size() < limitMessagesAtOnce && it != requestedParts.end() && totalSize < limitBytesAtOnce) {\n              if (parts != *it)\n                  break;\n              parts = *it;\n              uids << it.key();\n              totalSize += requestedPartSizes.take(it.key());\n              it = requestedParts.erase(it);\n          }\n          if (uids.isEmpty())\n              return;\n  \n          fetchPartTasks << model->m_taskFactory->createFetchMsgPartTask(model, mailboxIndex, uids, parts.toList());\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oopTimer->setSingleShot",
          "args": [
            "rue)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oopTimer->setInterval",
          "args": [
            "imeout)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "ok)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->property",
          "args": [
            "trojita-imap-noop-period\")"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onnect(",
          "args": [
            "oopTimer,",
            "IGNAL(timeout()),",
            "his,",
            "LOT(slotPerformNoop()))"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotPerformNoop())"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotPerformNoop(",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "slotPerformNoop(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "500-504",
          "snippet": "oid KeepMailboxOpenTask::slotPerformNoop()\n{\n    // FIXME: abort/die\n    model->m_taskFactory->createNoopTask(model, this);\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotPerformNoop()\n  {\n      // FIXME: abort/die\n      model->m_taskFactory->createNoopTask(model, this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IGNAL(",
          "args": [
            "imeout())"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imeout(",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ynchronizeConn)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createObtainSynchronizedMailboxTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            "onn,",
            "his)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "arser)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createOpenConnectionTask",
          "args": [
            "odel)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->networkPolicy",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_FOREACH(",
          "args": [
            "mapTask *task,",
            "odel->accessParser(parser).activeTasks)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "_FOREACH(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Gui/PartWidget.cpp",
          "lines": "209-216",
          "snippet": "_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\",
          "includes": [
            "include \"Imap/Model/MailboxTree.h\"",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"PartWidgetFactory.h\"\n#",
            "include \"MessageView.h\"\n#",
            "include \"LoadablePartWidget.h\"\n#",
            "include \"EnvelopeView.h\"\n#",
            "include <QTabBar>",
            "include <QVBoxLayout>\n#",
            "include <QModelIndex>\n#",
            "include <QLabel>\n#",
            "include \"PartWidget.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"Imap/Model/MailboxTree.h\"\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"PartWidgetFactory.h\"\n#\ninclude \"MessageView.h\"\n#\ninclude \"LoadablePartWidget.h\"\n#\ninclude \"EnvelopeView.h\"\n#\ninclude <QTabBar>\ninclude <QVBoxLayout>\n#\ninclude <QModelIndex>\n#\ninclude <QLabel>\n#\ninclude \"PartWidget.h\"\n\n_FOREACH( QObject* const obj, children() ) {\\\n        /*qDebug() << obj->metaObject()->className();*/\\\n        AbstractPartWidget* w = dynamic_cast<AbstractPartWidget*>( obj );\\\n        if ( w ) {\\\n            /*qDebug() << \"reloadContents:\" << w;*/\\\n            w->reloadContents();\\\n        }\\\n    }\\"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Timer::singleShot(",
          "args": [
            ",",
            "his,",
            "LOT(slotPerformConnection()))"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOT(",
          "args": [
            "lotPerformConnection())"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lotPerformConnection(",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "slotPerformConnection(",
          "container": "eepMailboxOpenTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/KeepMailboxOpenTask.cpp",
          "lines": "162-175",
          "snippet": "oid KeepMailboxOpenTask::slotPerformConnection()\n{\n    CHECK_TASK_TREE\n    Q_ASSERT(synchronizeConn);\n    Q_ASSERT(!synchronizeConn->isFinished());\n    if (_dead) {\n        _failed(\"Asked to die\");\n        synchronizeConn->die(QLatin1String(\"KeepMailboxOpenTask died before the sync started\"));\n        return;\n    }\n\n    connect(synchronizeConn, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n    synchronizeConn->perform();\n}",
          "includes": [
            "include \"UnSelectTask.h\"",
            "include \"NoopTask.h\"\n#",
            "include \"SortTask.h\"\n#",
            "include \"OfflineConnectionTask.h\"\n#",
            "include \"ObtainSynchronizedMailboxTask.h\"\n#",
            "include \"OpenConnectionTask.h\"\n#",
            "include \"IdleLauncher.h\"\n#",
            "include \"FetchMsgPartTask.h\"\n#",
            "include \"FetchMsgMetadataTask.h\"\n#",
            "include \"DeleteMailboxTask.h\"\n#",
            "include \"Imap/Model/TaskFactory.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"KeepMailboxOpenTask.h\"\n#",
            "include <sstream>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  oid KeepMailboxOpenTask::slotPerformConnection()\n  {\n      CHECK_TASK_TREE\n      Q_ASSERT(synchronizeConn);\n      Q_ASSERT(!synchronizeConn->isFinished());\n      if (_dead) {\n          _failed(\"Asked to die\");\n          synchronizeConn->die(QLatin1String(\"KeepMailboxOpenTask died before the sync started\"));\n          return;\n      }\n  \n      connect(synchronizeConn, SIGNAL(destroyed(QObject *)), this, SLOT(slotTaskDeleted(QObject *)));\n      synchronizeConn->perform();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createObtainSynchronizedMailboxTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            ",",
            "his)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->createObtainSynchronizedMailboxTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            "ask,",
            "his)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "ldParser)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "model->accessParser(oldParser).activeTasks.isEmpty())"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "ldParser)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskFactory->\n                              createObtainSynchronizedMailboxTask",
          "args": [
            "odel,",
            "ailboxIndex,",
            "odel->accessParser(oldParser).maintainingTask,",
            "his)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "ldParser)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist->fetch",
          "args": [
            "odel)"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "fetchNumbers(",
          "container": "reeItemMsgList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "861-867",
          "snippet": "oid TreeItemMsgList::fetchNumbers(Model *const model)\n{\n    if (m_numberFetchingStatus == NONE) {\n        m_numberFetchingStatus = LOADING;\n        model->askForNumberOfMessages(this);\n    }\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nreeItemMsgList {\n  oid TreeItemMsgList::fetchNumbers(Model *const model)\n  {\n      if (m_numberFetchingStatus == NONE) {\n          m_numberFetchingStatus = LOADING;\n          model->askForNumberOfMessages(this);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ist)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMsgList*>",
          "args": [
            "ailbox->m_children[0])"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox->m_children.size() > 0)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailbox->m_children.size",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailbox)"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<TreeItemMailbox *>",
          "args": [
            "tatic_cast<TreeItem *>(mailboxIndex.internalPointer()))"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tatic_cast<TreeItem *>",
          "args": [
            "ailboxIndex.internalPointer())"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.internalPointer",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.model() == model)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.model",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ailboxIndex.isValid())"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"UnSelectTask.h\"\ninclude \"NoopTask.h\"\n#\ninclude \"SortTask.h\"\n#\ninclude \"OfflineConnectionTask.h\"\n#\ninclude \"ObtainSynchronizedMailboxTask.h\"\n#\ninclude \"OpenConnectionTask.h\"\n#\ninclude \"IdleLauncher.h\"\n#\ninclude \"FetchMsgPartTask.h\"\n#\ninclude \"FetchMsgMetadataTask.h\"\n#\ninclude \"DeleteMailboxTask.h\"\n#\ninclude \"Imap/Model/TaskFactory.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"KeepMailboxOpenTask.h\"\n#\ninclude <sstream>\n#\n\neepMailboxOpenTask {\n  eepMailboxOpenTask::KeepMailboxOpenTask(Model *model, const QModelIndex &mailboxIndex, Parser *oldParser) :\n      ImapTask(model), mailboxIndex(mailboxIndex), synchronizeConn(0), shouldExit(false), isRunning(false),\n      shouldRunNoop(false), shouldRunIdle(false), idleLauncher(0), unSelectTask(0)\n  {\n      Q_ASSERT(mailboxIndex.isValid());\n      Q_ASSERT(mailboxIndex.model() == model);\n      TreeItemMailbox *mailbox = dynamic_cast<TreeItemMailbox *>(static_cast<TreeItem *>(mailboxIndex.internalPointer()));\n      Q_ASSERT(mailbox);\n  \n      // Now make sure that we at least try to load data from the cache\n      Q_ASSERT(mailbox->m_children.size() > 0);\n      TreeItemMsgList *list = dynamic_cast<TreeItemMsgList*>(mailbox->m_children[0]);\n      Q_ASSERT(list);\n      list->fetch(model);\n  \n      // We're the latest KeepMailboxOpenTask, so it makes a lot of sense to add us as the active\n      // maintainingTask to the target mailbox\n      mailbox->maintainingTask = this;\n  \n      if (oldParser) {\n          // We're asked to re-use an existing connection. Let's see if there's something associated with it\n  \n          // We will use its parser, that's for sure already\n          parser = oldParser;\n  \n          // Find if there's a KeepMailboxOpenTask already associated; if it is, we have to register with it\n          if (model->accessParser(parser).maintainingTask) {\n              // The parser looks busy -- some task is associated with it and has a mailbox open, so\n              // let's just wait till we get a chance to play\n              synchronizeConn = model->m_taskFactory->\n                                createObtainSynchronizedMailboxTask(model, mailboxIndex, model->accessParser(oldParser).maintainingTask, this);\n          } else if (model->accessParser(parser).connState < CONN_STATE_AUTHENTICATED) {\n              // The parser is still in the process of being initialized, let's wait until it's completed\n              Q_ASSERT(!model->accessParser(oldParser).activeTasks.isEmpty());\n              ImapTask *task = model->accessParser(oldParser).activeTasks.front();\n              synchronizeConn = model->m_taskFactory->createObtainSynchronizedMailboxTask(model, mailboxIndex, task, this);\n          } else {\n              // The parser is free, or at least there's no KeepMailboxOpenTask associated with it.\n              // There's no mailbox besides us in the game, yet, so we can simply schedule us for immediate execution.\n              synchronizeConn = model->m_taskFactory->createObtainSynchronizedMailboxTask(model, mailboxIndex, 0, this);\n              // We'll also register with the model, so that all other KeepMailboxOpenTask which could get constructed in future\n              // know about us and don't step on our toes.  This means that further KeepMailboxOpenTask which could possibly want\n              // to use this connection will have to go through this task at first.\n              model->accessParser(parser).maintainingTask = this;\n              QTimer::singleShot(0, this, SLOT(slotPerformConnection()));\n          }\n  \n          // We shall catch destruction of any preexisting tasks so that we can properly launch IDLE etc in response to their termination\n          Q_FOREACH(ImapTask *task, model->accessParser(parser).activeTasks) {\n              connect(task, SIGNAL(destroyed(QObject*)), this, SLOT(slotTaskDeleted(QObject*)));\n          }\n      } else {\n          ImapTask *conn = 0;\n          if (model->networkPolicy() == NETWORK_OFFLINE) {\n              // Well, except that we cannot really open a new connection now\n              conn = new OfflineConnectionTask(model);\n          } else {\n              conn = model->m_taskFactory->createOpenConnectionTask(model);\n          }\n          parser = conn->parser;\n          Q_ASSERT(parser);\n          model->accessParser(parser).maintainingTask = this;\n          synchronizeConn = model->m_taskFactory->createObtainSynchronizedMailboxTask(model, mailboxIndex, conn, this);\n      }\n  \n      Q_ASSERT(synchronizeConn);\n  \n      // Setup the timer for NOOPing. It won't get started at this time, though.\n      noopTimer = new QTimer(this);\n      connect(noopTimer, SIGNAL(timeout()), this, SLOT(slotPerformNoop()));\n      bool ok;\n      int timeout = model->property(\"trojita-imap-noop-period\").toUInt(&ok);\n      if (! ok)\n          timeout = 2 * 60 * 1000; // once every two minutes\n      noopTimer->setInterval(timeout);\n      noopTimer->setSingleShot(true);\n  \n      fetchPartTimer = new QTimer(this);\n      connect(fetchPartTimer, SIGNAL(timeout()), this, SLOT(slotFetchRequestedParts()));\n      timeout = model->property(\"trojita-imap-delayed-fetch-part\").toUInt(&ok);\n      if (! ok)\n          timeout = 50;\n      fetchPartTimer->setInterval(timeout);\n      fetchPartTimer->setSingleShot(true);\n  \n      fetchEnvelopeTimer = new QTimer(this);\n      connect(fetchEnvelopeTimer, SIGNAL(timeout()), this, SLOT(slotFetchRequestedEnvelopes()));\n      fetchEnvelopeTimer->setInterval(0); // message metadata is pretty important, hence an immediate fetch\n      fetchEnvelopeTimer->setSingleShot(true);\n  \n      limitBytesAtOnce = model->property(\"trojita-imap-limit-fetch-bytes-per-group\").toUInt(&ok);\n      if (! ok)\n          limitBytesAtOnce = 1024 * 1024;\n  \n      limitMessagesAtOnce = model->property(\"trojita-imap-limit-fetch-messages-per-group\").toInt(&ok);\n      if (! ok)\n          limitMessagesAtOnce = 300;\n  \n      limitParallelFetchTasks = model->property(\"trojita-imap-limit-parallel-fetch-tasks\").toInt(&ok);\n      if (! ok)\n          limitParallelFetchTasks = 10;\n  \n      limitActiveTasks = model->property(\"trojita-imap-limit-active-tasks\").toInt(&ok);\n      if (! ok)\n          limitActiveTasks = 100;\n  \n      CHECK_TASK_TREE\n      emit model->mailboxSyncingProgress(mailboxIndex, STATE_WAIT_FOR_CONN);\n  \n      connect(this, SIGNAL(failed(QString)), this, SLOT(signalSyncFailure(QString)));\n  }\n}"
  }
]