[
  {
    "function_name": "abort(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "262-268",
    "snippet": "oid SortTask::abort()\n{\n    if (cancelUpdateTag.isEmpty() && isJustUpdatingNow()) {\n        cancelSortingUpdates();\n    }\n    ImapTask::abort();\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapTask::abort(",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "abort(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "262-268",
          "snippet": "oid SortTask::abort()\n{\n    if (cancelUpdateTag.isEmpty() && isJustUpdatingNow()) {\n        cancelSortingUpdates();\n    }\n    ImapTask::abort();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ancelSortingUpdates(",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "cancelSortingUpdates(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "252-260",
          "snippet": "oid SortTask::cancelSortingUpdates()\n{\n    Q_ASSERT(m_persistentSearch);\n    Q_ASSERT(!sortTag.isEmpty());\n    KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n    Q_ASSERT(keepTask);\n    keepTask->breakOrCancelPossibleIdle();\n    cancelUpdateTag = parser->cancelUpdate(sortTag);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::cancelSortingUpdates()\n  {\n      Q_ASSERT(m_persistentSearch);\n      Q_ASSERT(!sortTag.isEmpty());\n      KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n      Q_ASSERT(keepTask);\n      keepTask->breakOrCancelPossibleIdle();\n      cancelUpdateTag = parser->cancelUpdate(sortTag);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sJustUpdatingNow(",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "isJustUpdatingNow(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "247-250",
          "snippet": "ool SortTask::isJustUpdatingNow() const\n{\n    return isPersistent() && m_firstCommandCompleted && !_aborted;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::isJustUpdatingNow() const\n  {\n      return isPersistent() && m_firstCommandCompleted && !_aborted;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ancelUpdateTag.isEmpty",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::abort()\n  {\n      if (cancelUpdateTag.isEmpty() && isJustUpdatingNow()) {\n          cancelSortingUpdates();\n      }\n      ImapTask::abort();\n  }\n}"
  },
  {
    "function_name": "cancelSortingUpdates(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "252-260",
    "snippet": "oid SortTask::cancelSortingUpdates()\n{\n    Q_ASSERT(m_persistentSearch);\n    Q_ASSERT(!sortTag.isEmpty());\n    KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n    Q_ASSERT(keepTask);\n    keepTask->breakOrCancelPossibleIdle();\n    cancelUpdateTag = parser->cancelUpdate(sortTag);\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->cancelUpdate",
          "args": [
            "ortTag)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "cancelUpdate(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "390-395",
          "snippet": "ommandHandle Parser::cancelUpdate(const CommandHandle &tag)\n{\n    Commands::Command command(\"CANCELUPDATE\");\n    command << Commands::PartOfCommand(Commands::QUOTED_STRING, tag);\n    return queueCommand(command);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::cancelUpdate(const CommandHandle &tag)\n  {\n      Commands::Command command(\"CANCELUPDATE\");\n      command << Commands::PartOfCommand(Commands::QUOTED_STRING, tag);\n      return queueCommand(command);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eepTask->breakOrCancelPossibleIdle",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "eepTask)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<KeepMailboxOpenTask*>",
          "args": [
            "onn)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "sortTag.isEmpty())"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortTag.isEmpty",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "_persistentSearch)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::cancelSortingUpdates()\n  {\n      Q_ASSERT(m_persistentSearch);\n      Q_ASSERT(!sortTag.isEmpty());\n      KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n      Q_ASSERT(keepTask);\n      keepTask->breakOrCancelPossibleIdle();\n      cancelUpdateTag = parser->cancelUpdate(sortTag);\n  }\n}"
  },
  {
    "function_name": "isJustUpdatingNow(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "247-250",
    "snippet": "ool SortTask::isJustUpdatingNow() const\n{\n    return isPersistent() && m_firstCommandCompleted && !_aborted;\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sPersistent(",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "isPersistent(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "241-244",
          "snippet": "ool SortTask::isPersistent() const\n{\n    return m_persistentSearch;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::isPersistent() const\n  {\n      return m_persistentSearch;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::isJustUpdatingNow() const\n  {\n      return isPersistent() && m_firstCommandCompleted && !_aborted;\n  }\n}"
  },
  {
    "function_name": "isPersistent(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "241-244",
    "snippet": "ool SortTask::isPersistent() const\n{\n    return m_persistentSearch;\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::isPersistent() const\n  {\n      return m_persistentSearch;\n  }\n}"
  },
  {
    "function_name": "_failed(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "234-239",
    "snippet": "oid SortTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit sortingFailed();\n    ImapTask::_failed(errorMessage);\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapTask::_failed(",
          "args": [
            "rrorMessage)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "234-239",
          "snippet": "oid SortTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit sortingFailed();\n    ImapTask::_failed(errorMessage);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit sortingFailed();\n      ImapTask::_failed(errorMessage);\n  }\n}"
  },
  {
    "function_name": "taskData(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "229-232",
    "snippet": "Variant SortTask::taskData(const int role) const\n{\n    return role == RoleTaskCompactName ? QVariant(tr(\"Sorting mailbox\")) : QVariant();\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Variant(",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Variant(",
          "args": [
            "r(\"Sorting mailbox\"))"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ddresListToQVariant(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/MailboxTree.cpp",
          "lines": "40-47",
          "snippet": "VariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}",
          "includes": [
            "include <QtDebug>",
            "include \"SpecialFlagNames.h\"\n#",
            "include \"Model.h\"\n#",
            "include \"MailboxTree.h\"\n#",
            "include \"ItemRoles.h\"\n#",
            "include \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#",
            "include \"Imap/Parser/Rfc5322HeaderParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Common/MetaTypes.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"Common/FindWithUnknown.h\"\n#",
            "include <QTextStream>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <QtDebug>\ninclude \"SpecialFlagNames.h\"\n#\ninclude \"Model.h\"\n#\ninclude \"MailboxTree.h\"\n#\ninclude \"ItemRoles.h\"\n#\ninclude \"Imap/Tasks/KeepMailboxOpenTask.h\"\n#\ninclude \"Imap/Parser/Rfc5322HeaderParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Common/MetaTypes.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"Common/FindWithUnknown.h\"\n#\ninclude <QTextStream>\n#\ninclude <algorithm>\n#\n\nVariantList addresListToQVariant(const QList<Imap::Message::MailAddress> &addressList)\n{\n    QVariantList res;\n    foreach(const Imap::Message::MailAddress& address, addressList) {\n        res.append(QVariant(QStringList() << address.name << address.adl << address.mailbox << address.host));\n    }\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r(",
          "args": [
            "Sorting mailbox\")"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "handleStateHelper(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "102-157",
          "snippet": "ool SortTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (resp->tag.isEmpty()) {\n        if (resp->kind == Responses::NO && resp->respCode == Responses::NOUPDATE) {\n            // * NO [NOUPDATE \"tag\"] means that the server won't be providing further updates for our SEARCH/SORT criteria\n            const Responses::RespData<QString> *const untaggedTag = dynamic_cast<const Responses::RespData<QString>* const>(\n                        resp->respCodeData.data());\n            Q_ASSERT(untaggedTag);\n            if (untaggedTag->data == sortTag) {\n                m_persistentSearch = false;\n                model->m_taskModel->slotTaskMighHaveChanged(this);\n\n                if (m_firstCommandCompleted) {\n                    // The server decided that it will no longer inform us about the updated SORT order, and the original\n                    // response has been already received and processed. That means that we're done here and shall declare\n                    // ourselves as completed.\n                    _completed();\n                }\n                // We actually support even more benevolent mode of operation where the server can tell us at any time that\n                // this context updating is no longer supported. Yay for that; let's hope that it's reasonably bug-free now.\n                return true;\n            }\n        }\n        return false;\n    }\n\n    if (resp->tag == sortTag) {\n        m_firstCommandCompleted = true;\n        if (resp->kind == Responses::OK) {\n            emit sortingAvailable(sortResult);\n            if (!m_persistentSearch || _aborted) {\n                // This is a one-shot operation, we shall not remain as an active task, listening for further updates\n                _completed();\n            } else {\n                // got to prod the TaskPresentationModel\n                model->m_taskModel->slotTaskMighHaveChanged(this);\n\n                // Even though we aren't \"finished\" at this point, the KeepMailboxOpenTask is now free to issue its IDLE thing,\n                // as that won't interfere with our mode of operation. Let's kick it around.\n                KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n                Q_ASSERT(keepTask);\n                keepTask->activateTasks();\n            }\n        } else {\n            _failed(\"Sorting command has failed\");\n        }\n        return true;\n    } else if (resp->tag == cancelUpdateTag) {\n        m_persistentSearch = false;\n        model->m_taskModel->slotTaskMighHaveChanged(this);\n        _completed();\n        return true;\n    } else {\n        return false;\n    }\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty()) {\n          if (resp->kind == Responses::NO && resp->respCode == Responses::NOUPDATE) {\n              // * NO [NOUPDATE \"tag\"] means that the server won't be providing further updates for our SEARCH/SORT criteria\n              const Responses::RespData<QString> *const untaggedTag = dynamic_cast<const Responses::RespData<QString>* const>(\n                          resp->respCodeData.data());\n              Q_ASSERT(untaggedTag);\n              if (untaggedTag->data == sortTag) {\n                  m_persistentSearch = false;\n                  model->m_taskModel->slotTaskMighHaveChanged(this);\n  \n                  if (m_firstCommandCompleted) {\n                      // The server decided that it will no longer inform us about the updated SORT order, and the original\n                      // response has been already received and processed. That means that we're done here and shall declare\n                      // ourselves as completed.\n                      _completed();\n                  }\n                  // We actually support even more benevolent mode of operation where the server can tell us at any time that\n                  // this context updating is no longer supported. Yay for that; let's hope that it's reasonably bug-free now.\n                  return true;\n              }\n          }\n          return false;\n      }\n  \n      if (resp->tag == sortTag) {\n          m_firstCommandCompleted = true;\n          if (resp->kind == Responses::OK) {\n              emit sortingAvailable(sortResult);\n              if (!m_persistentSearch || _aborted) {\n                  // This is a one-shot operation, we shall not remain as an active task, listening for further updates\n                  _completed();\n              } else {\n                  // got to prod the TaskPresentationModel\n                  model->m_taskModel->slotTaskMighHaveChanged(this);\n  \n                  // Even though we aren't \"finished\" at this point, the KeepMailboxOpenTask is now free to issue its IDLE thing,\n                  // as that won't interfere with our mode of operation. Let's kick it around.\n                  KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n                  Q_ASSERT(keepTask);\n                  keepTask->activateTasks();\n              }\n          } else {\n              _failed(\"Sorting command has failed\");\n          }\n          return true;\n      } else if (resp->tag == cancelUpdateTag) {\n          m_persistentSearch = false;\n          model->m_taskModel->slotTaskMighHaveChanged(this);\n          _completed();\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  Variant SortTask::taskData(const int role) const\n  {\n      return role == RoleTaskCompactName ? QVariant(tr(\"Sorting mailbox\")) : QVariant();\n  }\n}"
  },
  {
    "function_name": "handleESearch(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "183-227",
    "snippet": "ool SortTask::handleESearch(const Responses::ESearch *const resp)\n{\n    if (resp->tag != sortTag)\n        return false;\n\n    if (resp->seqOrUids != Imap::Responses::ESearch::UIDS)\n        throw UnexpectedResponseReceived(\"ESEARCH response to a UID SORT command with matching tag uses \"\n                                         \"sequence numbers instead of UIDs\", *resp);\n\n    Responses::ESearch::CompareListDataIdentifier<Responses::ESearch::ListData_t> allComparator(\"ALL\");\n    Responses::ESearch::ListData_t::const_iterator allIterator =\n            std::find_if(resp->listData.constBegin(), resp->listData.constEnd(), allComparator);\n\n    if (allIterator != resp->listData.constEnd()) {\n        m_firstUntaggedReceived = true;\n        sortResult = allIterator->second;\n\n        ++allIterator;\n        if (std::find_if(allIterator, resp->listData.constEnd(), allComparator) != resp->listData.constEnd())\n            throw UnexpectedResponseReceived(\"ESEARCH contains the ALL key too many times\", *resp);\n\n        if (!resp->incrementalContextData.isEmpty())\n            throw UnexpectedResponseReceived(\"ESEARCH contains both ALL result set and some incremental updates\", *resp);\n\n        return true;\n    }\n\n    Q_ASSERT(allIterator == resp->listData.constEnd());\n\n    if (resp->incrementalContextData.isEmpty()) {\n        sortResult.clear();\n        // This means that there have been no matches\n        // FIXME: cover this in the test suite!\n        return true;\n    }\n\n    Q_ASSERT(!resp->incrementalContextData.isEmpty());\n\n    if (!m_persistentSearch)\n        throw UnexpectedResponseReceived(\"ESEARCH contains incremental responses even though we haven't requested that\", *resp);\n\n    emit incrementalSortUpdate(resp->incrementalContextData);\n\n    return true;\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "ESEARCH contains incremental responses even though we haven't requested that\",",
            "resp)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "resp->incrementalContextData.isEmpty())"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->incrementalContextData.isEmpty",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortResult.clear",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "QMimeTypePrivate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimetype.cpp",
          "lines": "70-78",
          "snippet": "void QMimeTypePrivate::clear()\n{\n    name.clear();\n    localeComments.clear();\n    genericIconName.clear();\n    iconName.clear();\n    globPatterns.clear();\n    loaded = false;\n}",
          "includes": [
            "#include <memory>",
            "#include <QLocale>",
            "#include <QDebug>",
            "#include \"qmimeglobpattern_p.h\"",
            "#include \"qmimeprovider_p.h\"",
            "#include \"qmimedatabase_p.h\"",
            "#include \"qmimetype_p.h\"",
            "#include \"qmimetype.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "QT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <QLocale>\n#include <QDebug>\n#include \"qmimeglobpattern_p.h\"\n#include \"qmimeprovider_p.h\"\n#include \"qmimedatabase_p.h\"\n#include \"qmimetype_p.h\"\n#include \"qmimetype.h\"\n\nQT_BEGIN_NAMESPACE\n\nQMimeTypePrivate::QMimeTypePrivate()\n    : loaded(false);\n\nQMimeTypePrivate {\n  void QMimeTypePrivate::clear()\n  {\n      name.clear();\n      localeComments.clear();\n      genericIconName.clear();\n      iconName.clear();\n      globPatterns.clear();\n      loaded = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->incrementalContextData.isEmpty",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "llIterator == resp->listData.constEnd())"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "ESEARCH contains both ALL result set and some incremental updates\",",
            "resp)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->incrementalContextData.isEmpty",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "ESEARCH contains the ALL key too many times\",",
            "resp)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "llIterator,",
            "esp->listData.constEnd(),",
            "llComparator)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::find_if(",
          "args": [
            "esp->listData.constBegin(),",
            "esp->listData.constEnd(),",
            "llComparator)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constEnd",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->listData.constBegin",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nexpectedResponseReceived(",
          "args": [
            "ESEARCH response to a UID SORT command with matching tag uses \"\n                                         \"sequence numbers instead of UIDs\",",
            "resp)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::handleESearch(const Responses::ESearch *const resp)\n  {\n      if (resp->tag != sortTag)\n          return false;\n  \n      if (resp->seqOrUids != Imap::Responses::ESearch::UIDS)\n          throw UnexpectedResponseReceived(\"ESEARCH response to a UID SORT command with matching tag uses \"\n                                           \"sequence numbers instead of UIDs\", *resp);\n  \n      Responses::ESearch::CompareListDataIdentifier<Responses::ESearch::ListData_t> allComparator(\"ALL\");\n      Responses::ESearch::ListData_t::const_iterator allIterator =\n              std::find_if(resp->listData.constBegin(), resp->listData.constEnd(), allComparator);\n  \n      if (allIterator != resp->listData.constEnd()) {\n          m_firstUntaggedReceived = true;\n          sortResult = allIterator->second;\n  \n          ++allIterator;\n          if (std::find_if(allIterator, resp->listData.constEnd(), allComparator) != resp->listData.constEnd())\n              throw UnexpectedResponseReceived(\"ESEARCH contains the ALL key too many times\", *resp);\n  \n          if (!resp->incrementalContextData.isEmpty())\n              throw UnexpectedResponseReceived(\"ESEARCH contains both ALL result set and some incremental updates\", *resp);\n  \n          return true;\n      }\n  \n      Q_ASSERT(allIterator == resp->listData.constEnd());\n  \n      if (resp->incrementalContextData.isEmpty()) {\n          sortResult.clear();\n          // This means that there have been no matches\n          // FIXME: cover this in the test suite!\n          return true;\n      }\n  \n      Q_ASSERT(!resp->incrementalContextData.isEmpty());\n  \n      if (!m_persistentSearch)\n          throw UnexpectedResponseReceived(\"ESEARCH contains incremental responses even though we haven't requested that\", *resp);\n  \n      emit incrementalSortUpdate(resp->incrementalContextData);\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "handleSearch(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "165-181",
    "snippet": "ool SortTask::handleSearch(const Imap::Responses::Search *const resp)\n{\n    if (searchConditions == QStringList() << QLatin1String(\"ALL\")) {\n        // We're really a SORT task, so we shouldn't process this stuff\n        return false;\n    }\n\n    // The actual data for the SEARCH response can be split into several responses.\n    // Possible performance optimization might be to call sort & unique only after receiving the tagged OK,\n    // but that'd also mean that one has to keep track of whether we're doing a SORT or SEARCH from there.\n    // That just doesn't look like worth it.\n\n    sortResult += resp->items;\n    qSort(sortResult);\n    sortResult.erase(std::unique(sortResult.begin(), sortResult.end()), sortResult.end());\n    return true;\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ortResult.erase",
          "args": [
            "td::unique(sortResult.begin(), sortResult.end()),",
            "ortResult.end())"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortResult.end",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td::unique(",
          "args": [
            "ortResult.begin(),",
            "ortResult.end())"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortResult.end",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortResult.begin",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sort(",
          "args": [
            "ortResult)"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "handleSort(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "159-163",
          "snippet": "ool SortTask::handleSort(const Imap::Responses::Sort *const resp)\n{\n    sortResult = resp->numbers;\n    return true;\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::handleSort(const Imap::Responses::Sort *const resp)\n  {\n      sortResult = resp->numbers;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::handleSearch(const Imap::Responses::Search *const resp)\n  {\n      if (searchConditions == QStringList() << QLatin1String(\"ALL\")) {\n          // We're really a SORT task, so we shouldn't process this stuff\n          return false;\n      }\n  \n      // The actual data for the SEARCH response can be split into several responses.\n      // Possible performance optimization might be to call sort & unique only after receiving the tagged OK,\n      // but that'd also mean that one has to keep track of whether we're doing a SORT or SEARCH from there.\n      // That just doesn't look like worth it.\n  \n      sortResult += resp->items;\n      qSort(sortResult);\n      sortResult.erase(std::unique(sortResult.begin(), sortResult.end()), sortResult.end());\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleSort(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "159-163",
    "snippet": "ool SortTask::handleSort(const Imap::Responses::Sort *const resp)\n{\n    sortResult = resp->numbers;\n    return true;\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::handleSort(const Imap::Responses::Sort *const resp)\n  {\n      sortResult = resp->numbers;\n      return true;\n  }\n}"
  },
  {
    "function_name": "handleStateHelper(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "102-157",
    "snippet": "ool SortTask::handleStateHelper(const Imap::Responses::State *const resp)\n{\n    if (resp->tag.isEmpty()) {\n        if (resp->kind == Responses::NO && resp->respCode == Responses::NOUPDATE) {\n            // * NO [NOUPDATE \"tag\"] means that the server won't be providing further updates for our SEARCH/SORT criteria\n            const Responses::RespData<QString> *const untaggedTag = dynamic_cast<const Responses::RespData<QString>* const>(\n                        resp->respCodeData.data());\n            Q_ASSERT(untaggedTag);\n            if (untaggedTag->data == sortTag) {\n                m_persistentSearch = false;\n                model->m_taskModel->slotTaskMighHaveChanged(this);\n\n                if (m_firstCommandCompleted) {\n                    // The server decided that it will no longer inform us about the updated SORT order, and the original\n                    // response has been already received and processed. That means that we're done here and shall declare\n                    // ourselves as completed.\n                    _completed();\n                }\n                // We actually support even more benevolent mode of operation where the server can tell us at any time that\n                // this context updating is no longer supported. Yay for that; let's hope that it's reasonably bug-free now.\n                return true;\n            }\n        }\n        return false;\n    }\n\n    if (resp->tag == sortTag) {\n        m_firstCommandCompleted = true;\n        if (resp->kind == Responses::OK) {\n            emit sortingAvailable(sortResult);\n            if (!m_persistentSearch || _aborted) {\n                // This is a one-shot operation, we shall not remain as an active task, listening for further updates\n                _completed();\n            } else {\n                // got to prod the TaskPresentationModel\n                model->m_taskModel->slotTaskMighHaveChanged(this);\n\n                // Even though we aren't \"finished\" at this point, the KeepMailboxOpenTask is now free to issue its IDLE thing,\n                // as that won't interfere with our mode of operation. Let's kick it around.\n                KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n                Q_ASSERT(keepTask);\n                keepTask->activateTasks();\n            }\n        } else {\n            _failed(\"Sorting command has failed\");\n        }\n        return true;\n    } else if (resp->tag == cancelUpdateTag) {\n        m_persistentSearch = false;\n        model->m_taskModel->slotTaskMighHaveChanged(this);\n        _completed();\n        return true;\n    } else {\n        return false;\n    }\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "completed(",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "_completed(",
          "container": "mapTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/ImapTask.cpp",
          "lines": "224-233",
          "snippet": "oid ImapTask::_completed()\n{\n    _finished = true;\n    log(\"Completed\");\n    Q_FOREACH(ImapTask* task, dependentTasks) {\n        if (!task->isFinished())\n            task->perform();\n    }\n    emit completed(this);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Common/InvokeMethod.h\"\n#",
            "include \"ImapTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Common/InvokeMethod.h\"\n#\ninclude \"ImapTask.h\"\n#\n\nmapTask {\n  oid ImapTask::_completed()\n  {\n      _finished = true;\n      log(\"Completed\");\n      Q_FOREACH(ImapTask* task, dependentTasks) {\n          if (!task->isFinished())\n              task->perform();\n      }\n      emit completed(this);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "odel->m_taskModel->slotTaskMighHaveChanged",
          "args": [
            "his)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Sorting command has failed\")"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "234-239",
          "snippet": "oid SortTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit sortingFailed();\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit sortingFailed();\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "eepTask->activateTasks",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "eepTask)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<KeepMailboxOpenTask*>",
          "args": [
            "onn)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskModel->slotTaskMighHaveChanged",
          "args": [
            "his)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->m_taskModel->slotTaskMighHaveChanged",
          "args": [
            "his)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "ntaggedTag)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<const Responses::RespData<QString>* const>",
          "args": [
            "esp->respCodeData.data())"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esp->respCodeData.data",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "ModelTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Model/ModelTest/modeltest.cpp",
          "lines": "378-447",
          "snippet": "void ModelTest::data()\n{\n    // Invalid index should return an invalid qvariant\n    Q_ASSERT(!model->data(QModelIndex()).isValid());\n\n    if (model->rowCount() == 0)\n        return;\n\n    // A valid index should have a valid QVariant data\n    Q_ASSERT(model->index(0, 0).isValid());\n\n    // shouldn't be able to set data on an invalid index\n    Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n\n    // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n    // General Purpose roles that should return a QString\n    QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n    variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QString>(variant));\n    }\n\n    // General Purpose roles that should return a QSize\n    variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n    if (variant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QSize>(variant));\n    }\n\n    // General Purpose roles that should return a QFont\n    QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n    if (fontVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n    }\n\n    // Check that the alignment is one we know about\n    QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n    if (textAlignmentVariant.isValid()) {\n        int alignment = textAlignmentVariant.toInt();\n       Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n    }\n\n    // General Purpose roles that should return a QColor\n    QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n\n    colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n    if (colorVariant.isValid()) {\n        Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n    }\n#endif\n\n    // Check that the \"check state\" is one we know about.\n    QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n    if (checkStateVariant.isValid()) {\n        int state = checkStateVariant.toInt();\n        Q_ASSERT(state == Qt::Unchecked ||\n                 state == Qt::PartiallyChecked ||\n                 state == Qt::Checked);\n    }\n}",
          "includes": [
            "#include \"modeltest.h\"",
            "#include \"Imap/Model/ItemRoles.h\"",
            "#include <QtGui/QtGui>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modeltest.h\"\n#include \"Imap/Model/ItemRoles.h\"\n#include <QtGui/QtGui>\n\nModelTest {\n  void ModelTest::data()\n  {\n      // Invalid index should return an invalid qvariant\n      Q_ASSERT(!model->data(QModelIndex()).isValid());\n  \n      if (model->rowCount() == 0)\n          return;\n  \n      // A valid index should have a valid QVariant data\n      Q_ASSERT(model->index(0, 0).isValid());\n  \n      // shouldn't be able to set data on an invalid index\n      Q_ASSERT(model->setData(QModelIndex(), QLatin1String(\"foo\"), Qt::DisplayRole) == false);\n  \n      // TODO: would be cool to have proper support for Qt5 here; Qt5 deprecates qVariantCanConvert\n  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)\n      // General Purpose roles that should return a QString\n      QVariant variant = model->data(model->index(0, 0), Qt::ToolTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::StatusTipRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n      variant = model->data(model->index(0, 0), Qt::WhatsThisRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QString>(variant));\n      }\n  \n      // General Purpose roles that should return a QSize\n      variant = model->data(model->index(0, 0), Qt::SizeHintRole);\n      if (variant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QSize>(variant));\n      }\n  \n      // General Purpose roles that should return a QFont\n      QVariant fontVariant = model->data(model->index(0, 0), Qt::FontRole);\n      if (fontVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QFont>(fontVariant));\n      }\n  \n      // Check that the alignment is one we know about\n      QVariant textAlignmentVariant = model->data(model->index(0, 0), Qt::TextAlignmentRole);\n      if (textAlignmentVariant.isValid()) {\n          int alignment = textAlignmentVariant.toInt();\n         Q_ASSERT(alignment == (alignment & (Qt::AlignHorizontal_Mask | Qt::AlignVertical_Mask)));\n      }\n  \n      // General Purpose roles that should return a QColor\n      QVariant colorVariant = model->data(model->index(0, 0), Qt::BackgroundColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  \n      colorVariant = model->data(model->index(0, 0), Qt::TextColorRole);\n      if (colorVariant.isValid()) {\n          Q_ASSERT(qVariantCanConvert<QColor>(colorVariant));\n      }\n  #endif\n  \n      // Check that the \"check state\" is one we know about.\n      QVariant checkStateVariant = model->data(model->index(0, 0), Qt::CheckStateRole);\n      if (checkStateVariant.isValid()) {\n          int state = checkStateVariant.toInt();\n          Q_ASSERT(state == Qt::Unchecked ||\n                   state == Qt::PartiallyChecked ||\n                   state == Qt::Checked);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esp->tag.isEmpty",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ool SortTask::handleStateHelper(const Imap::Responses::State *const resp)\n  {\n      if (resp->tag.isEmpty()) {\n          if (resp->kind == Responses::NO && resp->respCode == Responses::NOUPDATE) {\n              // * NO [NOUPDATE \"tag\"] means that the server won't be providing further updates for our SEARCH/SORT criteria\n              const Responses::RespData<QString> *const untaggedTag = dynamic_cast<const Responses::RespData<QString>* const>(\n                          resp->respCodeData.data());\n              Q_ASSERT(untaggedTag);\n              if (untaggedTag->data == sortTag) {\n                  m_persistentSearch = false;\n                  model->m_taskModel->slotTaskMighHaveChanged(this);\n  \n                  if (m_firstCommandCompleted) {\n                      // The server decided that it will no longer inform us about the updated SORT order, and the original\n                      // response has been already received and processed. That means that we're done here and shall declare\n                      // ourselves as completed.\n                      _completed();\n                  }\n                  // We actually support even more benevolent mode of operation where the server can tell us at any time that\n                  // this context updating is no longer supported. Yay for that; let's hope that it's reasonably bug-free now.\n                  return true;\n              }\n          }\n          return false;\n      }\n  \n      if (resp->tag == sortTag) {\n          m_firstCommandCompleted = true;\n          if (resp->kind == Responses::OK) {\n              emit sortingAvailable(sortResult);\n              if (!m_persistentSearch || _aborted) {\n                  // This is a one-shot operation, we shall not remain as an active task, listening for further updates\n                  _completed();\n              } else {\n                  // got to prod the TaskPresentationModel\n                  model->m_taskModel->slotTaskMighHaveChanged(this);\n  \n                  // Even though we aren't \"finished\" at this point, the KeepMailboxOpenTask is now free to issue its IDLE thing,\n                  // as that won't interfere with our mode of operation. Let's kick it around.\n                  KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n                  Q_ASSERT(keepTask);\n                  keepTask->activateTasks();\n              }\n          } else {\n              _failed(\"Sorting command has failed\");\n          }\n          return true;\n      } else if (resp->tag == cancelUpdateTag) {\n          m_persistentSearch = false;\n          model->m_taskModel->slotTaskMighHaveChanged(this);\n          _completed();\n          return true;\n      } else {\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "perform(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "47-100",
    "snippet": "oid SortTask::perform()\n{\n    parser = conn->parser;\n    markAsActiveTask();\n\n    IMAP_TASK_CHECK_ABORT_DIE;\n\n    if (! mailboxIndex.isValid()) {\n        _failed(\"Mailbox vanished before we could ask for threading info\");\n        return;\n    }\n\n    // We can be killed when appropriate\n    KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n    Q_ASSERT(keepTask);\n    keepTask->feelFreeToAbortCaller(this);\n\n    if (sortCriteria.isEmpty()) {\n        if (model->accessParser(parser).capabilitiesFresh &&\n                model->accessParser(parser).capabilities.contains(QLatin1String(\"ESEARCH\"))) {\n            // We always prefer ESEARCH over SEARCH, if only for its embedded reference to the command tag\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"CONTEXT=SEARCH\"))) {\n                // Hurray, this IMAP server supports incremental ESEARCH updates\n                m_persistentSearch = true;\n                sortTag = parser->uidESearch(\"utf-8\", searchConditions,\n                                             QStringList() << QLatin1String(\"ALL\") << QLatin1String(\"UPDATE\"));\n            } else {\n                // ESORT without CONTEXT is still worth the effort, if only for the tag reference\n                sortTag = parser->uidESearch(\"utf-8\", searchConditions, QStringList() << QLatin1String(\"ALL\"));\n            }\n        } else {\n            // Plain \"old\" SORT\n            sortTag = parser->uidSearch(searchConditions, \"utf-8\");\n        }\n    } else {\n        // SEARCH and SORT combined\n        if (model->accessParser(parser).capabilitiesFresh &&\n                model->accessParser(parser).capabilities.contains(QLatin1String(\"ESORT\"))) {\n            // ESORT's better than regular SORT, if only for its embedded reference to the command tag\n            if (model->accessParser(parser).capabilities.contains(QLatin1String(\"CONTEXT=SORT\"))) {\n                // Hurray, this IMAP server supports incremental SORT updates\n                m_persistentSearch = true;\n                sortTag = parser->uidESort(sortCriteria, \"utf-8\", searchConditions,\n                                       QStringList() << QLatin1String(\"ALL\") << QLatin1String(\"UPDATE\"));\n            } else {\n                // ESORT without CONTEXT is still worth the effort, if only for the tag reference\n                sortTag = parser->uidESort(sortCriteria, \"utf-8\", searchConditions, QStringList() << QLatin1String(\"ALL\"));\n            }\n        } else {\n            // Plain \"old\" SORT\n            sortTag = parser->uidSort(sortCriteria, \"utf-8\", searchConditions);\n        }\n    }\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arser->uidSort",
          "args": [
            "ortCriteria,",
            "utf-8\",",
            "earchConditions)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "uidSort(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "372-375",
          "snippet": "ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n{\n    return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidSort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria)\n  {\n      return sortHelper(\"UID SORT\", sortCriteria, charset, searchCriteria);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arser->uidESort",
          "args": [
            "ortCriteria,",
            "utf-8\",",
            "earchConditions,",
            "StringList() << QLatin1String(\"ALL\"))"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "uidESort(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "377-382",
          "snippet": "ommandHandle Parser::uidESort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria,\n                               const QStringList &returnOptions)\n{\n    return sortHelper(\"UID SORT RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                      sortCriteria, charset, searchCriteria);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidESort(const QStringList &sortCriteria, const QByteArray &charset, const QStringList &searchCriteria,\n                                 const QStringList &returnOptions)\n  {\n      return sortHelper(\"UID SORT RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                        sortCriteria, charset, searchCriteria);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE\")"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"CONTEXT=SORT\"))"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CONTEXT=SORT\")"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"ESORT\"))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ESORT\")"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->uidSearch",
          "args": [
            "earchConditions,",
            "utf-8\")"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arser->uidESearch",
          "args": [
            "utf-8\",",
            "earchConditions,",
            "StringList() << QLatin1String(\"ALL\"))"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "uidESearch(",
          "container": "arser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Parser/Parser.cpp",
          "lines": "384-388",
          "snippet": "ommandHandle Parser::uidESearch(const QByteArray &charset, const QStringList &searchCriteria, const QStringList &returnOptions)\n{\n    return searchHelper(\"UID SEARCH RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                        searchCriteria, charset);\n}",
          "includes": [
            "include \"../Model/Utils.h\"",
            "include \"../../Streams/IODeviceSocket.h\"\n#",
            "include \"LowLevelParser.h\"\n#",
            "include \"Imap/Encoders.h\"\n#",
            "include \"Parser.h\"\n#",
            "include <QTimer>\n#",
            "include <QTime>\n#",
            "include <QSslError>\n#",
            "include <QProcess>\n#",
            "include <QMutexLocker>\n#",
            "include <QStringList>\n#",
            "include <QDebug>\n#",
            "include <algorithm>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"../Model/Utils.h\"\ninclude \"../../Streams/IODeviceSocket.h\"\n#\ninclude \"LowLevelParser.h\"\n#\ninclude \"Imap/Encoders.h\"\n#\ninclude \"Parser.h\"\n#\ninclude <QTimer>\n#\ninclude <QTime>\n#\ninclude <QSslError>\n#\ninclude <QProcess>\n#\ninclude <QMutexLocker>\n#\ninclude <QStringList>\n#\ninclude <QDebug>\n#\ninclude <algorithm>\n#\n\narser {\n  ommandHandle Parser::uidESearch(const QByteArray &charset, const QStringList &searchCriteria, const QStringList &returnOptions)\n  {\n      return searchHelper(\"UID SEARCH RETURN (\" + returnOptions.join(QLatin1String(\" \")).toUtf8() + \")\",\n                          searchCriteria, charset);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "UPDATE\")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringList(",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"CONTEXT=SEARCH\"))"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "CONTEXT=SEARCH\")"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "Latin1String(\"ESEARCH\"))"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ESEARCH\")"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->accessParser",
          "args": [
            "arser)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ortCriteria.isEmpty",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eepTask->feelFreeToAbortCaller",
          "args": [
            "his)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ASSERT(",
          "args": [
            "eepTask)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ynamic_cast<KeepMailboxOpenTask*>",
          "args": [
            "onn)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed(",
          "args": [
            "Mailbox vanished before we could ask for threading info\")"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "_failed(",
          "container": "ortTask",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
          "lines": "234-239",
          "snippet": "oid SortTask::_failed(const QString &errorMessage)\n{\n    // FIXME: show this in the GUI\n    emit sortingFailed();\n    ImapTask::_failed(errorMessage);\n}",
          "includes": [
            "include \"KeepMailboxOpenTask.h\"",
            "include \"Imap/Model/TaskPresentationModel.h\"\n#",
            "include \"Imap/Model/MailboxTree.h\"\n#",
            "include \"Imap/Model/Model.h\"\n#",
            "include \"Imap/Model/ItemRoles.h\"\n#",
            "include <algorithm>\n#",
            "include \"SortTask.h\"\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::_failed(const QString &errorMessage)\n  {\n      // FIXME: show this in the GUI\n      emit sortingFailed();\n      ImapTask::_failed(errorMessage);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ailboxIndex.isValid",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "isValid",
          "container": "QMimeXMLProvider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/mimetypes-qt4/mimetypes/qmimeprovider.cpp",
          "lines": "681-684",
          "snippet": "bool QMimeXMLProvider::isValid()\n{\n    return true;\n}",
          "includes": [
            "#include <QtEndian>",
            "#include <QDateTime>",
            "#include <QDebug>",
            "#include <QByteArrayMatcher>",
            "#include <QFile>",
            "#include <QDir>",
            "#include <QXmlStreamReader>",
            "#include \"qmimemagicrulematcher_p.h\"",
            "#include <qstandardpaths.h>",
            "#include \"qmimetypeparser_p.h\"",
            "#include \"qmimeprovider_p.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtEndian>\n#include <QDateTime>\n#include <QDebug>\n#include <QByteArrayMatcher>\n#include <QFile>\n#include <QDir>\n#include <QXmlStreamReader>\n#include \"qmimemagicrulematcher_p.h\"\n#include <qstandardpaths.h>\n#include \"qmimetypeparser_p.h\"\n#include \"qmimeprovider_p.h\"\n\nQMimeXMLProvider {\n  bool QMimeXMLProvider::isValid()\n  {\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arkAsActiveTask(",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  oid SortTask::perform()\n  {\n      parser = conn->parser;\n      markAsActiveTask();\n  \n      IMAP_TASK_CHECK_ABORT_DIE;\n  \n      if (! mailboxIndex.isValid()) {\n          _failed(\"Mailbox vanished before we could ask for threading info\");\n          return;\n      }\n  \n      // We can be killed when appropriate\n      KeepMailboxOpenTask *keepTask = dynamic_cast<KeepMailboxOpenTask*>(conn);\n      Q_ASSERT(keepTask);\n      keepTask->feelFreeToAbortCaller(this);\n  \n      if (sortCriteria.isEmpty()) {\n          if (model->accessParser(parser).capabilitiesFresh &&\n                  model->accessParser(parser).capabilities.contains(QLatin1String(\"ESEARCH\"))) {\n              // We always prefer ESEARCH over SEARCH, if only for its embedded reference to the command tag\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"CONTEXT=SEARCH\"))) {\n                  // Hurray, this IMAP server supports incremental ESEARCH updates\n                  m_persistentSearch = true;\n                  sortTag = parser->uidESearch(\"utf-8\", searchConditions,\n                                               QStringList() << QLatin1String(\"ALL\") << QLatin1String(\"UPDATE\"));\n              } else {\n                  // ESORT without CONTEXT is still worth the effort, if only for the tag reference\n                  sortTag = parser->uidESearch(\"utf-8\", searchConditions, QStringList() << QLatin1String(\"ALL\"));\n              }\n          } else {\n              // Plain \"old\" SORT\n              sortTag = parser->uidSearch(searchConditions, \"utf-8\");\n          }\n      } else {\n          // SEARCH and SORT combined\n          if (model->accessParser(parser).capabilitiesFresh &&\n                  model->accessParser(parser).capabilities.contains(QLatin1String(\"ESORT\"))) {\n              // ESORT's better than regular SORT, if only for its embedded reference to the command tag\n              if (model->accessParser(parser).capabilities.contains(QLatin1String(\"CONTEXT=SORT\"))) {\n                  // Hurray, this IMAP server supports incremental SORT updates\n                  m_persistentSearch = true;\n                  sortTag = parser->uidESort(sortCriteria, \"utf-8\", searchConditions,\n                                         QStringList() << QLatin1String(\"ALL\") << QLatin1String(\"UPDATE\"));\n              } else {\n                  // ESORT without CONTEXT is still worth the effort, if only for the tag reference\n                  sortTag = parser->uidESort(sortCriteria, \"utf-8\", searchConditions, QStringList() << QLatin1String(\"ALL\"));\n              }\n          } else {\n              // Plain \"old\" SORT\n              sortTag = parser->uidSort(sortCriteria, \"utf-8\", searchConditions);\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "SortTask(",
    "container": "ortTask",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2014-2567/repo/src/Imap/Tasks/SortTask.cpp",
    "lines": "37-45",
    "snippet": "ortTask::SortTask(Model *model, const QModelIndex &mailbox, const QStringList &searchConditions, const QStringList &sortCriteria):\n    ImapTask(model), mailboxIndex(mailbox), searchConditions(searchConditions), sortCriteria(sortCriteria),\n    m_persistentSearch(false), m_firstUntaggedReceived(false), m_firstCommandCompleted(false)\n{\n    conn = model->findTaskResponsibleFor(mailbox);\n    conn->addDependentTask(this);\n    if (searchConditions.isEmpty())\n        this->searchConditions << QLatin1String(\"ALL\");\n}",
    "includes": [
      "include \"KeepMailboxOpenTask.h\"",
      "include \"Imap/Model/TaskPresentationModel.h\"\n#",
      "include \"Imap/Model/MailboxTree.h\"\n#",
      "include \"Imap/Model/Model.h\"\n#",
      "include \"Imap/Model/ItemRoles.h\"\n#",
      "include <algorithm>\n#",
      "include \"SortTask.h\"\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Latin1String(",
          "args": [
            "ALL\")"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earchConditions.isEmpty",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onn->addDependentTask",
          "args": [
            "his)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odel->findTaskResponsibleFor",
          "args": [
            "ailbox)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"KeepMailboxOpenTask.h\"\ninclude \"Imap/Model/TaskPresentationModel.h\"\n#\ninclude \"Imap/Model/MailboxTree.h\"\n#\ninclude \"Imap/Model/Model.h\"\n#\ninclude \"Imap/Model/ItemRoles.h\"\n#\ninclude <algorithm>\n#\ninclude \"SortTask.h\"\n#\n\nortTask {\n  ortTask::SortTask(Model *model, const QModelIndex &mailbox, const QStringList &searchConditions, const QStringList &sortCriteria):\n      ImapTask(model), mailboxIndex(mailbox), searchConditions(searchConditions), sortCriteria(sortCriteria),\n      m_persistentSearch(false), m_firstUntaggedReceived(false), m_firstCommandCompleted(false)\n  {\n      conn = model->findTaskResponsibleFor(mailbox);\n      conn->addDependentTask(this);\n      if (searchConditions.isEmpty())\n          this->searchConditions << QLatin1String(\"ALL\");\n  }\n}"
  }
]